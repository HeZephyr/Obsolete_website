(window.webpackJsonp=window.webpackJsonp||[]).push([[133],{488:function(t,e,r){"use strict";r.r(e);var n=r(0),_=Object(n.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("23种设计模式分类如下：")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"center"}},[e("strong",[t._v("模式类型")])]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[e("strong",[t._v("描述")])]),t._v(" "),e("th",{staticStyle:{"text-align":"center"}},[e("strong",[t._v("包括的模式")])])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("创建型模式")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 "),e("code",[t._v("new")]),t._v(" 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("工厂模式（Factory Pattern）"),e("br"),t._v("抽象工厂模式（Abstract Factory Pattern）"),e("br"),t._v("单例模式（Singleton Pattern）"),e("br"),t._v("建造者模式（Builder Pattern）"),e("br"),t._v("原型模式（Prototype Pattern）")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("结构型模式")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("适配器模式（Adapter Pattern）"),e("br"),t._v("桥接模式（Bridge Pattern）"),e("br"),t._v("过滤器模式（Filter、Criteria Pattern）"),e("br"),t._v("组合模式（Composite Pattern）"),e("br"),t._v("装饰器模式（Decorator Pattern）"),e("br"),t._v("外观模式（Facade Pattern）"),e("br"),t._v("享元模式（Flyweight Pattern）"),e("br"),t._v("代理模式（Proxy Pattern）")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"center"}},[t._v("行为型模式")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("这些设计模式特别关注对象之间的通信，即对象之间的行为。")]),t._v(" "),e("td",{staticStyle:{"text-align":"center"}},[t._v("责任链模式（Chain of Responsibility Pattern）"),e("br"),t._v("命令模式（Command Pattern）"),e("br"),t._v("解释器模式（Interpreter Pattern）"),e("br"),t._v("迭代器模式（Iterator Pattern）"),e("br"),t._v("中介者模式（Mediator Pattern）"),e("br"),t._v("备忘录模式（Memento Pattern）"),e("br"),t._v("观察者模式（Observer Pattern）"),e("br"),t._v("状态模式（State Pattern）"),e("br"),t._v("空对象模式（Null Object Pattern）"),e("br"),t._v("策略模式（Strategy Pattern）"),e("br"),t._v("模板模式（Template Pattern）"),e("br"),t._v("访问者模式（Visitor Pattern）")])])])]),t._v(" "),e("p",[t._v("设计模式的六大原则是软件设计中的基石，它们为构建灵活、易于维护和升级的软件系统提供了指导。以下是对这六大原则的简要说明：")]),t._v(" "),e("ol",[e("li",[e("p",[e("strong",[t._v("开闭原则（Open Close Principle）")]),t._v("：")]),t._v(" "),e("ul",[e("li",[t._v("意义：对扩展开放，对修改关闭。即在需要进行拓展时，不修改原有代码，实现热插拔的效果。")]),t._v(" "),e("li",[t._v("实现方式：使用接口和抽象类，通过抽象化来保持程序的扩展性，易于维护和升级。")])])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("里氏代换原则（Liskov Substitution Principle）")]),t._v("：")]),t._v(" "),e("ul",[e("li",[t._v("意义：任何基类可以出现的地方，子类一定可以出现。基类能够被派生类替换，且不影响软件单位的功能，实现真正的复用。")]),t._v(" "),e("li",[t._v("补充关系：是对开闭原则的补充，通过继承关系实现对抽象化的具体步骤规范。")])])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("依赖倒转原则（Dependence Inversion Principle）")]),t._v("：")]),t._v(" "),e("ul",[e("li",[t._v("基础：是开闭原则的基础。具体内容为针对接口编程，依赖于抽象而不依赖于具体。")])])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("接口隔离原则（Interface Segregation Principle）")]),t._v("：")]),t._v(" "),e("ul",[e("li",[t._v("意义：使用多个隔离的接口比使用单个接口更好，降低类之间的耦合度。")]),t._v(" "),e("li",[t._v("设计思想：从大型软件架构出发，强调降低依赖，降低耦合。")])])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("迪米特法则，又称最少知道原则（Demeter Principle）")]),t._v("：")]),t._v(" "),e("ul",[e("li",[t._v("定义：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。")])])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("合成复用原则（Composite Reuse Principle）")]),t._v("：")]),t._v(" "),e("ul",[e("li",[t._v("意义：尽量使用合成/聚合的方式，而不是使用继承。通过组合而非继承实现代码复用，增强系统的灵活性。")])])])]),t._v(" "),e("p",[t._v("这些原则提供了一种指导思想，帮助开发人员设计出具有弹性、可维护性和可扩展性的软件系统。通过遵循这些原则，可以有效应对软件变化，提高代码质量和可维护性。")]),t._v(" "),e("p",[t._v("以下是部分语言实现设计模式的仓库，以供学习。")]),t._v(" "),e("ol",[e("li",[e("a",{attrs:{href:"https://github.com/mohuishou/go-design-pattern",target:"_blank",rel:"noopener noreferrer"}},[t._v("Go"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://github.com/youlookwhat/DesignPattern",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://github.com/jaredtao/DesignPattern/",target:"_blank",rel:"noopener noreferrer"}},[t._v("C++"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://github.com/tim-chow/DesignPattern",target:"_blank",rel:"noopener noreferrer"}},[t._v("Python"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://github.com/nnupoor-zz/js_designpatterns",target:"_blank",rel:"noopener noreferrer"}},[t._v("JavaScript"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=_.exports}}]);