(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var i,a,s=e[0],l=e[1],c=e[2],u=0,p=[];u<s.length;u++)a=s[u],Object.prototype.hasOwnProperty.call(r,a)&&r[a]&&p.push(r[a][0]),r[a]=0;for(i in l)Object.prototype.hasOwnProperty.call(l,i)&&(n[i]=l[i]);for(d&&d(e);p.length;)p.shift()();return o.push.apply(o,c||[]),t()}function t(){for(var n,e=0;e<o.length;e++){for(var t=o[e],i=!0,s=1;s<t.length;s++){var l=t[s];0!==r[l]&&(i=!1)}i&&(o.splice(e--,1),n=a(a.s=t[0]))}return n}var i={},r={8:0},o=[];function a(e){if(i[e])return i[e].exports;var t=i[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,a),t.l=!0,t.exports}a.e=function(n){var e=[],t=r[n];if(0!==t)if(t)e.push(t[2]);else{var i=new Promise((function(e,i){t=r[n]=[e,i]}));e.push(t[2]=i);var o,s=document.createElement("script");s.charset="utf-8",s.timeout=120,a.nc&&s.setAttribute("nonce",a.nc),s.src=function(n){return a.p+"assets/js/"+({9:"vendors~docsearch"}[n]||n)+"."+{1:"4a1189e9",2:"8e76b5b7",3:"bca043f9",4:"71a85121",5:"780a742d",6:"6c206683",7:"03420b55",9:"caeb3b49",10:"ce2d8b4d",11:"87208a0c",12:"7f5cceef",13:"f2cea533",14:"f8459573",15:"06cd6cc8",16:"33942615",17:"da2e0126",18:"a39b8ae2",19:"1760f287",20:"bc1029fc",21:"4b161474",22:"69d29451",23:"2a87052f",24:"6beeaf9b",25:"e9d4e312",26:"c128f1d5",27:"2bab9253",28:"0b0ea581",29:"71a2a1e9",30:"11fd1987",31:"92abb231",32:"27d7c672",33:"9f002fe8",34:"39abd7b3",35:"a54492ae",36:"1b3ef370",37:"3dda47b6",38:"3dc3656a",39:"78160c0e",40:"382841f8",41:"dad5aa09",42:"9b31e597",43:"bd06b1c5",44:"c5b9fce0",45:"8e169e05",46:"907fb663",47:"b494d092",48:"7c4206ed",49:"fc0a67dc",50:"9779c691",51:"b675874a",52:"59a39ef7",53:"5120cd43",54:"0dbbf9fc",55:"c01fe65c",56:"c89a75a8",57:"e1685918",58:"fdc9435f",59:"0a608087",60:"3acec2d6",61:"c8057e71",62:"a15c3ffa",63:"50ef528e",64:"b53bf088",65:"803a60c5",66:"28f9f642",67:"10df3d56",68:"32bb7b03",69:"9712dac4",70:"b6437760",71:"06d181ad",72:"4154f4f2",73:"63864839",74:"5a1fa47d",75:"6bfdacb8",76:"f9ca76ce",77:"c0dbcf86",78:"8a7b0fb7",79:"7a93649b",80:"875f961a",81:"016c7026",82:"8ac6ee9b",83:"2af4873d",84:"9ed04afc",85:"c45be379",86:"96a9a357",87:"56cb2eb9",88:"401bc0ca",89:"213805a9",90:"9b182cbd",91:"6a9f6d9a",92:"5c42bf0b",93:"c058db1e",94:"ce7693b0",95:"909330ff",96:"9390fc5e",97:"3168909b",98:"252090ac",99:"915c956d",100:"72e81ad1",101:"be1fbb56",102:"156931d8",103:"e7a8f6f7",104:"018e7261",105:"5ad485d3",106:"9767ba12",107:"6e091b4d",108:"097145e2",109:"2e404c20",110:"ca026ed7",111:"6a385ffc",112:"1853d540",113:"8c44ee9f",114:"98972148",115:"de29d63a",116:"a9c3694d",117:"8a50a962",118:"0c681c69",119:"59f4a06b",120:"1977588c",121:"80313bf3",122:"f29ff5e7",123:"8ef21f06",124:"f7b970b2",125:"75d16aaf",126:"1e82e746",127:"40438671",128:"fbfe4598",129:"b2b4a3c1",130:"f99078ae",131:"802d0c89",132:"e79ac496",133:"815ad514",134:"4dad648a",135:"8fcb3926",136:"7eb9c0a7",137:"1ad08aec",138:"6c8770ce",139:"65b8c2d0",140:"cc1ffc8e",141:"93e7ee91",142:"ce1ace58",143:"260eff32",144:"dff9a412",145:"09721f38",146:"407151a3",147:"44cc124d",148:"19af33d2"}[n]+".js"}(n);var l=new Error;o=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=r[n];if(0!==t){if(t){var i=e&&("load"===e.type?"missing":e.type),o=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+i+": "+o+")",l.name="ChunkLoadError",l.type=i,l.request=o,t[1](l)}r[n]=void 0}};var c=setTimeout((function(){o({type:"timeout",target:s})}),12e4);s.onerror=s.onload=o,document.head.appendChild(s)}return Promise.all(e)},a.m=n,a.c=i,a.d=function(n,e,t){a.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},a.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},a.t=function(n,e){if(1&e&&(n=a(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(a.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var i in n)a.d(t,i,function(e){return n[e]}.bind(null,i));return t},a.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return a.d(e,"a",e),e},a.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},a.p="/",a.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var d=l;o.push([110,0]),t()}([function(n,e,t){"use strict";function i(n,e,t,i,r,o,a,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),i&&(c.functional=!0),o&&(c._scopeId="data-v-"+o),a?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),r&&r.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(a)},c._ssrRegister=l):r&&(l=s?function(){r.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:r),l)if(c.functional){c._injectStyles=l;var d=c.render;c.render=function(n,e){return l.call(e),d(n,e)}}else{var u=c.beforeCreate;c.beforeCreate=u?[].concat(u,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return i}))},function(n,e,t){"use strict";var i=function(n){return n&&n.Math===Math&&n};n.exports=i("object"==typeof globalThis&&globalThis)||i("object"==typeof window&&window)||i("object"==typeof self&&self)||i("object"==typeof global&&global)||i("object"==typeof this&&this)||function(){return this}()||Function("return this")()},function(n,e,t){"use strict";var i=t(56),r=i.all;n.exports=i.IS_HTMLDDA?function(n){return"function"==typeof n||n===r}:function(n){return"function"==typeof n}},function(n,e,t){"use strict";var i=t(29),r=Function.prototype,o=r.call,a=i&&r.bind.bind(o,o);n.exports=i?a:function(n){return function(){return o.apply(n,arguments)}}},function(n,e,t){"use strict";n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){"use strict";var i=t(4);n.exports=!i((function(){return 7!==Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){"use strict";var i=t(3),r=t(33),o=i({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return o(r(n),e)}},function(n,e,t){var i=t(70),r="object"==typeof self&&self&&self.Object===Object&&self,o=i||r||Function("return this")();n.exports=o},function(n,e,t){"use strict";var i=t(2),r=t(56),o=r.all;n.exports=r.IS_HTMLDDA?function(n){return"object"==typeof n?null!==n:i(n)||n===o}:function(n){return"object"==typeof n?null!==n:i(n)}},function(n,e,t){var i=t(168),r=t(171);n.exports=function(n,e){var t=r(n,e);return i(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return i})),t.d(e,"b",(function(){return o})),t.d(e,"j",(function(){return a})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return d})),t.d(e,"c",(function(){return u})),t.d(e,"f",(function(){return p})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return g})),t.d(e,"k",(function(){return v})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return y}));t(17);const i=/#.*$/,r=/\.(md|html)$/,o=/\/$/,a=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(i,"").replace(r,"")}function l(n){return a.test(n)}function c(n){return/^mailto:/.test(n)}function d(n){return/^tel:/.test(n)}function u(n){if(l(n))return n;if(!n)return"404";const e=n.match(i),t=e?e[0]:"",r=s(n);return o.test(r)?n:r+".html"+t}function p(n,e){const t=n.hash,r=function(n){const e=n&&n.match(i);if(e)return e[0]}(e);if(r&&t!==r)return!1;return s(n.path)===s(e)}function m(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const i=n.charAt(0);if("/"===i)return n;if("?"===i||"#"===i)return e+n;const r=e.split("/");t&&r[r.length-1]||r.pop();const o=n.replace(/^\//,"").split("/");for(let n=0;n<o.length;n++){const e=o[n];".."===e?r.pop():"."!==e&&r.push(e)}""!==r[0]&&r.unshift("");return r.join("/")}(e,t));const i=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===i)return Object.assign({},n[e],{type:"page",path:u(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function h(n,e,t,i){const{pages:r,themeConfig:o}=t,a=i&&o.locales&&o.locales[i]||o;if("auto"===(n.frontmatter.sidebar||a.sidebar||o.sidebar))return f(n);const s=a.sidebar||o.sidebar;if(s){const{base:t,config:i}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const i in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(i)))return{base:i,config:e[i]};var t;return{}}(e,s);return"auto"===i?f(n):i?i.map(n=>function n(e,t,i,r=1){if("string"==typeof e)return m(t,e,i);if(Array.isArray(e))return Object.assign(m(t,e[0],i),{title:e[1]});{r>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const o=e.children||[];return 0===o.length&&e.path?Object.assign(m(t,e.path,i),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:o.map(e=>n(e,t,i,r+1)),collapsable:!1!==e.collapsable}}}(n,r,t)):[]}return[]}function f(n){const e=g(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function g(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function v(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function x(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function y(n,e){return x(e)-x(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){"use strict";var i=t(5),r=t(65),o=t(107),a=t(28),s=t(55),l=TypeError,c=Object.defineProperty,d=Object.getOwnPropertyDescriptor;e.f=i?o?function(n,e,t){if(a(n),e=s(e),a(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var i=d(n,e);i&&i.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:i.configurable,enumerable:"enumerable"in t?t.enumerable:i.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(a(n),e=s(e),a(t),r)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw new l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var i=t(16),r=t(153),o=t(154),a=i?i.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":a&&a in Object(n)?r(n):o(n)}},function(n,e,t){"use strict";var i=t(5),r=t(13),o=t(36);n.exports=i?function(n,e,t){return r.f(n,e,o(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var i=t(8).Symbol;n.exports=i},function(n,e,t){"use strict";var i=t(18),r=t(33),o=t(34),a=t(133),s=t(135);i({target:"Array",proto:!0,arity:1,forced:t(4)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=r(this),t=o(e),i=arguments.length;s(t+i);for(var l=0;l<i;l++)e[t]=arguments[l],t++;return a(e,t),t}})},function(n,e,t){"use strict";var i=t(1),r=t(52).f,o=t(15),a=t(101),s=t(38),l=t(66),c=t(129);n.exports=function(n,e){var t,d,u,p,m,h=n.target,f=n.global,g=n.stat;if(t=f?i:g?i[h]||s(h,{}):(i[h]||{}).prototype)for(d in e){if(p=e[d],u=n.dontCallGetSet?(m=r(t,d))&&m.value:t[d],!c(f?d:h+(g?".":"#")+d,n.forced)&&void 0!==u){if(typeof p==typeof u)continue;l(p,u)}(n.sham||u&&u.sham)&&o(p,"sham",!0),a(t,d,p,n)}}},function(n,e,t){"use strict";var i=t(3),r=i({}.toString),o=i("".slice);n.exports=function(n){return o(r(n),8,-1)}},function(n,e,t){"use strict";var i=t(1),r=t(62),o=t(7),a=t(64),s=t(60),l=t(59),c=i.Symbol,d=r("wks"),u=l?c.for||c:c&&c.withoutSetter||a;n.exports=function(n){return o(d,n)||(d[n]=s&&o(c,n)?c[n]:u("Symbol."+n)),d[n]}},function(n,e,t){var i=t(158),r=t(159),o=t(160),a=t(161),s=t(162);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var i=n[e];this.set(i[0],i[1])}}l.prototype.clear=i,l.prototype.delete=r,l.prototype.get=o,l.prototype.has=a,l.prototype.set=s,n.exports=l},function(n,e,t){var i=t(72);n.exports=function(n,e){for(var t=n.length;t--;)if(i(n[t][0],e))return t;return-1}},function(n,e,t){var i=t(10)(Object,"create");n.exports=i},function(n,e,t){var i=t(180);n.exports=function(n,e){var t=n.__data__;return i(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var i=t(46);n.exports=function(n){if("string"==typeof n||i(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var i,r;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(r="function"==typeof(i=function(){var n,e,t={version:"0.2.0"},i=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function r(n,e,t){return n<e?e:n>t?t:n}function o(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(i[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=r(n,i.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(i.barSelector),d=i.speed,u=i.easing;return l.offsetWidth,a((function(e){""===i.positionUsing&&(i.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var r;return(r="translate3d"===i.positionUsing?{transform:"translate3d("+o(n)+"%,0,0)"}:"translate"===i.positionUsing?{transform:"translate("+o(n)+"%,0)"}:{"margin-left":o(n)+"%"}).transition="all "+e+"ms "+t,r}(n,d,u)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+d+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),d)}),d)):setTimeout(e,d)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),i.trickleSpeed)};return i.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*r(Math.random()*e,.1,.95)),e=r(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*i.trickleRate)},n=0,e=0,t.promise=function(i){return i&&"resolved"!==i.state()?(0===e&&t.start(),n++,e++,i.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=i.template;var r,a=e.querySelector(i.barSelector),l=n?"-100":o(t.status||0),d=document.querySelector(i.parent);return s(a,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),i.showSpinner||(r=e.querySelector(i.spinnerSelector))&&p(r),d!=document.body&&c(d,"nprogress-custom-parent"),d.appendChild(e),e},t.remove=function(){d(document.documentElement,"nprogress-busy"),d(document.querySelector(i.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var a=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var i,r=n.length,o=e.charAt(0).toUpperCase()+e.slice(1);r--;)if((i=n[r]+o)in t)return i;return e}(t))}function i(n,e,i){e=t(e),n.style[e]=i}return function(n,e){var t,r,o=arguments;if(2==o.length)for(t in e)void 0!==(r=e[t])&&e.hasOwnProperty(t)&&i(n,t,r);else i(n,o[1],o[2])}}();function l(n,e){return("string"==typeof n?n:u(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=u(n),i=t+e;l(t,e)||(n.className=i.substring(1))}function d(n,e){var t,i=u(n);l(n,e)&&(t=i.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function u(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?i.call(e,t,e,n):i)||(n.exports=r)},function(n){n.exports=JSON.parse('{"name":"vuepress-plugin-comment","version":"0.7.3","description":"Comment plugin in vuepress, such as Gitalk, Valine...","main":"index.js","scripts":{"test":"echo \\"Error: no test specified\\" && exit 1"},"repository":{"type":"git","url":"git+ssh://git@github.com/dongyuanxin/vuepress-plugin-comment.git"},"keywords":["vuepress","comment","plugin","vue","gitalk","valine"],"author":"dongyuanxin","license":"MIT","bugs":{"url":"https://github.com/dongyuanxin/vuepress-plugin-comment/issues"},"homepage":"https://github.com/dongyuanxin/vuepress-plugin-comment#readme","dependencies":{"ejs":"^2.6.1","gitalk":"^1.5.0","gitalk-fix":"^1.5.2","i":"^0.3.6","npm":"^6.9.0","valine":"^1.3.9"}}')},function(n,e,t){"use strict";var i=t(9),r=String,o=TypeError;n.exports=function(n){if(i(n))return n;throw new o(r(n)+" is not an object")}},function(n,e,t){"use strict";var i=t(4);n.exports=!i((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){"use strict";var i=t(49),r=t(53);n.exports=function(n){return i(r(n))}},function(n,e,t){"use strict";var i=t(1),r=t(2),o=function(n){return r(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?o(i[n]):i[n]&&i[n][e]}},function(n,e,t){"use strict";var i=t(2),r=t(116),o=TypeError;n.exports=function(n){if(i(n))return n;throw new o(r(n)+" is not a function")}},function(n,e,t){"use strict";var i=t(53),r=Object;n.exports=function(n){return r(i(n))}},function(n,e,t){"use strict";var i=t(127);n.exports=function(n){return i(n.length)}},function(n,e,t){"use strict";var i=t(29),r=Function.prototype.call;n.exports=i?r.bind(r):function(){return r.apply(r,arguments)}},function(n,e,t){"use strict";n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){"use strict";var i=t(1),r=t(38),o=i["__core-js_shared__"]||r("__core-js_shared__",{});n.exports=o},function(n,e,t){"use strict";var i=t(1),r=Object.defineProperty;n.exports=function(n,e){try{r(i,n,{value:e,configurable:!0,writable:!0})}catch(t){i[n]=e}return e}},function(n,e,t){var i=t(152),r=t(12),o=Object.prototype,a=o.hasOwnProperty,s=o.propertyIsEnumerable,l=i(function(){return arguments}())?i:function(n){return r(n)&&a.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var i=t(10)(t(8),"Map");n.exports=i},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var i=t(172),r=t(179),o=t(181),a=t(182),s=t(183);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var i=n[e];this.set(i[0],i[1])}}l.prototype.clear=i,l.prototype.delete=r,l.prototype.get=o,l.prototype.has=a,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var i=t(6),r=t(46),o=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,a=/^\w*$/;n.exports=function(n,e){if(i(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!r(n))||(a.test(n)||!o.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var i=t(14),r=t(12);n.exports=function(n){return"symbol"==typeof n||r(n)&&"[object Symbol]"==i(n)}},function(n,e){n.exports=function(n){return n}},function(n,e){var t=/^\s+|\s+$/g,i=/^[-+]0x[0-9a-f]+$/i,r=/^0b[01]+$/i,o=/^0o[0-7]+$/i,a=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),d=Object.prototype.toString,u=Math.max,p=Math.min,m=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function f(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==d.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=r.test(n);return s||o.test(n)?a(n.slice(2),s?2:8):i.test(n)?NaN:+n}n.exports=function(n,e,t){var i,r,o,a,s,l,c=0,d=!1,g=!1,v=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=i,o=r;return i=r=void 0,c=e,a=n.apply(o,t)}function x(n){return c=n,s=setTimeout(k,e),d?b(n):a}function y(n){var t=n-l;return void 0===l||t>=e||t<0||g&&n-c>=o}function k(){var n=m();if(y(n))return _(n);s=setTimeout(k,function(n){var t=e-(n-l);return g?p(t,o-(n-c)):t}(n))}function _(n){return s=void 0,v&&i?b(n):(i=r=void 0,a)}function w(){var n=m(),t=y(n);if(i=arguments,r=this,l=n,t){if(void 0===s)return x(l);if(g)return s=setTimeout(k,e),b(l)}return void 0===s&&(s=setTimeout(k,e)),a}return e=f(e)||0,h(t)&&(d=!!t.leading,o=(g="maxWait"in t)?u(f(t.maxWait)||0,e):o,v="trailing"in t?!!t.trailing:v),w.cancel=function(){void 0!==s&&clearTimeout(s),c=0,i=l=r=s=void 0},w.flush=function(){return void 0===s?a:_(m())},w}},function(n,e,t){"use strict";var i=t(3),r=t(4),o=t(19),a=Object,s=i("".split);n.exports=r((function(){return!a("z").propertyIsEnumerable(0)}))?function(n){return"String"===o(n)?s(n,""):a(n)}:a},function(n,e,t){"use strict";n.exports={}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e,t){"use strict";var i=t(5),r=t(35),o=t(112),a=t(36),s=t(30),l=t(55),c=t(7),d=t(65),u=Object.getOwnPropertyDescriptor;e.f=i?u:function(n,e){if(n=s(n),e=l(e),d)try{return u(n,e)}catch(n){}if(c(n,e))return a(!r(o.f,n,e),n[e])}},function(n,e,t){"use strict";var i=t(54),r=TypeError;n.exports=function(n){if(i(n))throw new r("Can't call method on "+n);return n}},function(n,e,t){"use strict";n.exports=function(n){return null==n}},function(n,e,t){"use strict";var i=t(113),r=t(57);n.exports=function(n){var e=i(n,"string");return r(e)?e:e+""}},function(n,e,t){"use strict";var i="object"==typeof document&&document.all,r=void 0===i&&void 0!==i;n.exports={all:i,IS_HTMLDDA:r}},function(n,e,t){"use strict";var i=t(31),r=t(2),o=t(58),a=t(59),s=Object;n.exports=a?function(n){return"symbol"==typeof n}:function(n){var e=i("Symbol");return r(e)&&o(e.prototype,s(n))}},function(n,e,t){"use strict";var i=t(3);n.exports=i({}.isPrototypeOf)},function(n,e,t){"use strict";var i=t(60);n.exports=i&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){"use strict";var i=t(61),r=t(4),o=t(1).String;n.exports=!!Object.getOwnPropertySymbols&&!r((function(){var n=Symbol("symbol detection");return!o(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&i&&i<41}))},function(n,e,t){"use strict";var i,r,o=t(1),a=t(114),s=o.process,l=o.Deno,c=s&&s.versions||l&&l.version,d=c&&c.v8;d&&(r=(i=d.split("."))[0]>0&&i[0]<4?1:+(i[0]+i[1])),!r&&a&&(!(i=a.match(/Edge\/(\d+)/))||i[1]>=74)&&(i=a.match(/Chrome\/(\d+)/))&&(r=+i[1]),n.exports=r},function(n,e,t){"use strict";var i=t(63),r=t(37);(n.exports=function(n,e){return r[n]||(r[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.33.3",mode:i?"pure":"global",copyright:"© 2014-2023 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.33.3/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){"use strict";n.exports=!1},function(n,e,t){"use strict";var i=t(3),r=0,o=Math.random(),a=i(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+a(++r+o,36)}},function(n,e,t){"use strict";var i=t(5),r=t(4),o=t(106);n.exports=!i&&!r((function(){return 7!==Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){"use strict";var i=t(7),r=t(122),o=t(52),a=t(13);n.exports=function(n,e,t){for(var s=r(e),l=a.f,c=o.f,d=0;d<s.length;d++){var u=s[d];i(n,u)||t&&i(t,u)||l(n,u,c(e,u))}}},function(n,e,t){"use strict";var i=t(126);n.exports=function(n){var e=+n;return e!=e||0===e?0:i(e)}},function(n,e,t){"use strict";var i=t(139),r=t(28),o=t(140);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=i(Object.prototype,"__proto__","set"))(t,[]),e=t instanceof Array}catch(n){}return function(t,i){return r(t),o(i),e?n(t,i):t.__proto__=i,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,i=e.length,r=n.length;++t<i;)n[r+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var i=t(21),r=t(163),o=t(164),a=t(165),s=t(166),l=t(167);function c(n){var e=this.__data__=new i(n);this.size=e.size}c.prototype.clear=r,c.prototype.delete=o,c.prototype.get=a,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var i=t(14),r=t(41);n.exports=function(n){if(!r(n))return!1;var e=i(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var i=t(184),r=t(12);n.exports=function n(e,t,o,a,s){return e===t||(null==e||null==t||!r(e)&&!r(t)?e!=e&&t!=t:i(e,t,o,a,n,s))}},function(n,e,t){var i=t(77),r=t(187),o=t(78);n.exports=function(n,e,t,a,s,l){var c=1&t,d=n.length,u=e.length;if(d!=u&&!(c&&u>d))return!1;var p=l.get(n),m=l.get(e);if(p&&m)return p==e&&m==n;var h=-1,f=!0,g=2&t?new i:void 0;for(l.set(n,e),l.set(e,n);++h<d;){var v=n[h],b=e[h];if(a)var x=c?a(b,v,h,e,n,l):a(v,b,h,n,e,l);if(void 0!==x){if(x)continue;f=!1;break}if(g){if(!r(e,(function(n,e){if(!o(g,e)&&(v===n||s(v,n,t,a,l)))return g.push(e)}))){f=!1;break}}else if(v!==b&&!s(v,b,t,a,l)){f=!1;break}}return l.delete(n),l.delete(e),f}},function(n,e,t){var i=t(42),r=t(185),o=t(186);function a(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new i;++e<t;)this.add(n[e])}a.prototype.add=a.prototype.push=r,a.prototype.has=o,n.exports=a},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var i=t(197),r=t(203),o=t(83);n.exports=function(n){return o(n)?i(n):r(n)}},function(n,e,t){(function(n){var i=t(8),r=t(199),o=e&&!e.nodeType&&e,a=o&&"object"==typeof n&&n&&!n.nodeType&&n,s=a&&a.exports===o?i.Buffer:void 0,l=(s?s.isBuffer:void 0)||r;n.exports=l}).call(this,t(51)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var i=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==i||"symbol"!=i&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var i=t(200),r=t(201),o=t(202),a=o&&o.isTypedArray,s=a?r(a):i;n.exports=s},function(n,e,t){var i=t(73),r=t(44);n.exports=function(n){return null!=n&&r(n.length)&&!i(n)}},function(n,e,t){var i=t(10)(t(8),"Set");n.exports=i},function(n,e,t){var i=t(41);n.exports=function(n){return n==n&&!i(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var i=t(88),r=t(25);n.exports=function(n,e){for(var t=0,o=(e=i(e,n)).length;null!=n&&t<o;)n=n[r(e[t++])];return t&&t==o?n:void 0}},function(n,e,t){var i=t(6),r=t(45),o=t(214),a=t(217);n.exports=function(n,e){return i(n)?n:r(n,e)?[n]:o(a(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var i=t(150),r=t(155),o=t(226),a=t(234),s=t(243),l=t(103),c=o((function(n){var e=l(n);return s(e)&&(e=void 0),a(i(n,1,s,!0),r(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var i=/["'&<>]/;n.exports=function(n){var e,t=""+n,r=i.exec(t);if(!r)return t;var o="",a=0,s=0;for(a=r.index;a<t.length;a++){switch(t.charCodeAt(a)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==a&&(o+=t.substring(s,a)),s=a+1,o+=e}return s!==a?o+t.substring(s,a):o}},function(n,e,t){"use strict";
/**
 * @file Embedded JavaScript templating engine. {@link http://ejs.co}
 * @author Matthew Eernisse <mde@fleegix.org>
 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 * @project EJS
 * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
 */var i=t(255),r=t(256),o=t(257),a=!1,s=t(258).version,l=["delimiter","scope","context","debug","compileDebug","client","_with","rmWhitespace","strict","filename","async"],c=l.concat("cache"),d=/^\uFEFF/;function u(n,t){var r,o,a=t.views,s=/^[A-Za-z]+:\\|^\//.exec(n);if(s&&s.length)r=e.resolveInclude(n.replace(/^\/*/,""),t.root||"/",!0);else if(t.filename&&(o=e.resolveInclude(n,t.filename),i.existsSync(o)&&(r=o)),r||Array.isArray(a)&&a.some((function(t){return o=e.resolveInclude(n,t,!0),i.existsSync(o)}))&&(r=o),!r)throw new Error('Could not find the include file "'+t.escapeFunction(n)+'"');return r}function p(n,t){var i,r=n.filename,o=arguments.length>1;if(n.cache){if(!r)throw new Error("cache option requires a filename");if(i=e.cache.get(r))return i;o||(t=h(r).toString().replace(d,""))}else if(!o){if(!r)throw new Error("Internal EJS error: no file name or template provided");t=h(r).toString().replace(d,"")}return i=e.compile(t,n),n.cache&&e.cache.set(r,i),i}function m(n,t,i){var r;if(!i){if("function"==typeof e.promiseImpl)return new e.promiseImpl((function(e,i){try{e(r=p(n)(t))}catch(n){i(n)}}));throw new Error("Please provide a callback function")}try{r=p(n)(t)}catch(n){return i(n)}i(null,r)}function h(n){return e.fileLoader(n)}function f(n,e,t,i,r){var o=e.split("\n"),a=Math.max(i-3,0),s=Math.min(o.length,i+3),l=r(t),c=o.slice(a,s).map((function(n,e){var t=e+a+1;return(t==i?" >> ":"    ")+t+"| "+n})).join("\n");throw n.path=l,n.message=(l||"ejs")+":"+i+"\n"+c+"\n\n"+n.message,n}function g(n){return n.replace(/;(\s*$)/,"$1")}function v(n,t){t=t||{};var i={};this.templateText=n,this.mode=null,this.truncate=!1,this.currentLine=1,this.source="",this.dependencies=[],i.client=t.client||!1,i.escapeFunction=t.escape||t.escapeFunction||o.escapeXML,i.compileDebug=!1!==t.compileDebug,i.debug=!!t.debug,i.filename=t.filename,i.openDelimiter=t.openDelimiter||e.openDelimiter||"<",i.closeDelimiter=t.closeDelimiter||e.closeDelimiter||">",i.delimiter=t.delimiter||e.delimiter||"%",i.strict=t.strict||!1,i.context=t.context,i.cache=t.cache||!1,i.rmWhitespace=t.rmWhitespace,i.root=t.root,i.outputFunctionName=t.outputFunctionName,i.localsName=t.localsName||e.localsName||"locals",i.views=t.views,i.async=t.async,i.destructuredLocals=t.destructuredLocals,i.legacyInclude=void 0===t.legacyInclude||!!t.legacyInclude,i.strict?i._with=!1:i._with=void 0===t._with||t._with,this.opts=i,this.regex=this.createRegex()}e.cache=o.cache,e.fileLoader=i.readFileSync,e.localsName="locals",e.promiseImpl=new Function("return this;")().Promise,e.resolveInclude=function(n,e,t){var i=r.dirname,o=r.extname,a=(0,r.resolve)(t?e:i(e),n);return o(n)||(a+=".ejs"),a},e.compile=function(n,e){return e&&e.scope&&(a||(console.warn("`scope` option is deprecated and will be removed in EJS 3"),a=!0),e.context||(e.context=e.scope),delete e.scope),new v(n,e).compile()},e.render=function(n,e,t){var i=e||{},r=t||{};return 2==arguments.length&&o.shallowCopyFromList(r,i,l),p(r,n)(i)},e.renderFile=function(){var n,e,t,i=Array.prototype.slice.call(arguments),r=i.shift(),a={filename:r};return"function"==typeof arguments[arguments.length-1]&&(n=i.pop()),i.length?(e=i.shift(),i.length?o.shallowCopy(a,i.pop()):(e.settings&&(e.settings.views&&(a.views=e.settings.views),e.settings["view cache"]&&(a.cache=!0),(t=e.settings["view options"])&&o.shallowCopy(a,t)),o.shallowCopyFromList(a,e,c)),a.filename=r):e={},m(a,e,n)},e.Template=v,e.clearCache=function(){e.cache.reset()},v.modes={EVAL:"eval",ESCAPED:"escaped",RAW:"raw",COMMENT:"comment",LITERAL:"literal"},v.prototype={createRegex:function(){var n="(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)",e=o.escapeRegExpChars(this.opts.delimiter),t=o.escapeRegExpChars(this.opts.openDelimiter),i=o.escapeRegExpChars(this.opts.closeDelimiter);return n=n.replace(/%/g,e).replace(/</g,t).replace(/>/g,i),new RegExp(n)},compile:function(){var n,e,t,i=this.opts,a="",s="",l=i.escapeFunction;if(!this.source){if(this.generateSource(),a+='  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n',i.outputFunctionName&&(a+="  var "+i.outputFunctionName+" = __append;\n"),i.destructuredLocals&&i.destructuredLocals.length){for(var c="  var __locals = ("+i.localsName+" || {}),\n",d=0;d<i.destructuredLocals.length;d++){var m=i.destructuredLocals[d];d>0&&(c+=",\n  "),c+=m+" = __locals."+m}a+=c+";\n"}!1!==i._with&&(a+="  with ("+i.localsName+" || {}) {\n",s+="  }\n"),s+="  return __output;\n",this.source=a+this.source+s}n=i.compileDebug?"var __line = 1\n  , __lines = "+JSON.stringify(this.templateText)+"\n  , __filename = "+(i.filename?JSON.stringify(i.filename):"undefined")+";\ntry {\n"+this.source+"} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n":this.source,i.client&&(n="escapeFn = escapeFn || "+l.toString()+";\n"+n,i.compileDebug&&(n="rethrow = rethrow || "+f.toString()+";\n"+n)),i.strict&&(n='"use strict";\n'+n),i.debug&&console.log(n),i.compileDebug&&i.filename&&(n=n+"\n//# sourceURL="+i.filename+"\n");try{if(i.async)try{t=new Function("return (async function(){}).constructor;")()}catch(n){throw n instanceof SyntaxError?new Error("This environment does not support async/await"):n}else t=Function;e=new t(i.localsName+", escapeFn, include, rethrow",n)}catch(n){throw n instanceof SyntaxError&&(i.filename&&(n.message+=" in "+i.filename),n.message+=" while compiling ejs\n\n",n.message+="If the above error is not helpful, you may want to try EJS-Lint:\n",n.message+="https://github.com/RyanZim/EJS-Lint",i.async||(n.message+="\n",n.message+="Or, if you meant to create an async function, pass `async: true` as an option.")),n}var h=i.client?e:function(n){return e.apply(i.context,[n||{},l,function(e,t){var r=o.shallowCopy({},n);return t&&(r=o.shallowCopy(r,t)),function(n,e){var t=o.shallowCopy({},e);return t.filename=u(n,t),p(t)}(e,i)(r)},f])};if(h.dependencies=this.dependencies,i.filename&&"function"==typeof Object.defineProperty){var g=i.filename,v=r.basename(g,r.extname(g));try{Object.defineProperty(h,"name",{value:v,writable:!1,enumerable:!1,configurable:!0})}catch(n){}}return h},generateSource:function(){var n=this.opts;n.rmWhitespace&&(this.templateText=this.templateText.replace(/[\r\n]+/g,"\n").replace(/^\s+|\s+$/gm,"")),this.templateText=this.templateText.replace(/[ \t]*<%_/gm,"<%_").replace(/_%>[ \t]*/gm,"_%>");var t=this,i=this.parseTemplateText(),r=this.opts.delimiter,a=this.opts.openDelimiter,s=this.opts.closeDelimiter;i&&i.length&&i.forEach((function(l,c){var p,m,f,g,b,x;if(0===l.indexOf(a+r)&&0!==l.indexOf(a+r+r)&&(m=i[c+2])!=r+s&&m!="-"+r+s&&m!="_"+r+s)throw new Error('Could not find matching close tag for "'+l+'".');if(n.legacyInclude&&(f=l.match(/^\s*include\s+(\S+)/))&&(p=i[c-1])&&(p==a+r||p==a+r+"-"||p==a+r+"_"))return g=o.shallowCopy({},t.opts),b=function(n,e){var t,i,r=o.shallowCopy({},e);i=h(t=u(n,r)).toString().replace(d,""),r.filename=t;var a=new v(i,r);return a.generateSource(),{source:a.source,filename:t,template:i}}(f[1],g),x=t.opts.compileDebug?"    ; (function(){\n      var __line = 1\n      , __lines = "+JSON.stringify(b.template)+"\n      , __filename = "+JSON.stringify(b.filename)+";\n      try {\n"+b.source+"      } catch (e) {\n        rethrow(e, __lines, __filename, __line, escapeFn);\n      }\n    ; }).call(this)\n":"    ; (function(){\n"+b.source+"    ; }).call(this)\n",t.source+=x,void t.dependencies.push(e.resolveInclude(f[1],g.filename));t.scanLine(l)}))},parseTemplateText:function(){for(var n,e=this.templateText,t=this.regex,i=t.exec(e),r=[];i;)0!==(n=i.index)&&(r.push(e.substring(0,n)),e=e.slice(n)),r.push(i[0]),e=e.slice(i[0].length),i=t.exec(e);return e&&r.push(e),r},_addOutput:function(n){if(this.truncate&&(n=n.replace(/^(?:\r\n|\r|\n)/,""),this.truncate=!1),!n)return n;n=(n=(n=(n=n.replace(/\\/g,"\\\\")).replace(/\n/g,"\\n")).replace(/\r/g,"\\r")).replace(/"/g,'\\"'),this.source+='    ; __append("'+n+'")\n'},scanLine:function(n){var e,t=this.opts.delimiter,i=this.opts.openDelimiter,r=this.opts.closeDelimiter;switch(e=n.split("\n").length-1,n){case i+t:case i+t+"_":this.mode=v.modes.EVAL;break;case i+t+"=":this.mode=v.modes.ESCAPED;break;case i+t+"-":this.mode=v.modes.RAW;break;case i+t+"#":this.mode=v.modes.COMMENT;break;case i+t+t:this.mode=v.modes.LITERAL,this.source+='    ; __append("'+n.replace(i+t+t,i+t)+'")\n';break;case t+t+r:this.mode=v.modes.LITERAL,this.source+='    ; __append("'+n.replace(t+t+r,t+r)+'")\n';break;case t+r:case"-"+t+r:case"_"+t+r:this.mode==v.modes.LITERAL&&this._addOutput(n),this.mode=null,this.truncate=0===n.indexOf("-")||0===n.indexOf("_");break;default:if(this.mode){switch(this.mode){case v.modes.EVAL:case v.modes.ESCAPED:case v.modes.RAW:n.lastIndexOf("//")>n.lastIndexOf("\n")&&(n+="\n")}switch(this.mode){case v.modes.EVAL:this.source+="    ; "+n+"\n";break;case v.modes.ESCAPED:this.source+="    ; __append(escapeFn("+g(n)+"))\n";break;case v.modes.RAW:this.source+="    ; __append("+g(n)+")\n";break;case v.modes.COMMENT:break;case v.modes.LITERAL:this._addOutput(n)}}else this._addOutput(n)}this.opts.compileDebug&&e&&(this.currentLine+=e,this.source+="    ; __line = "+this.currentLine+"\n")}},e.escapeXML=o.escapeXML,e.__express=e.renderFile,e.VERSION=s,e.name="ejs","undefined"!=typeof window&&(window.ejs=e)},function(n,e,t){"use strict";t.r(e);var i={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},r=(t(246),t(0)),o=Object(r.a)(i,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=o.exports},function(n,e,t){"use strict";t.r(e);var i={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},r=(t(247),t(0)),o=Object(r.a)(i,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,i){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":i===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(i)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=o.exports},function(n,e,t){"use strict";var i=t(2),r=t(13),o=t(104),a=t(38);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,c=void 0!==s.name?s.name:e;if(i(t)&&o(t,c,s),s.global)l?n[e]=t:a(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:r.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){"use strict";var i=t(144),r=String;n.exports=function(n){if("Symbol"===i(n))throw new TypeError("Cannot convert a Symbol value to a string");return r(n)}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){"use strict";var i=t(3),r=t(4),o=t(2),a=t(7),s=t(5),l=t(118).CONFIGURABLE,c=t(119),d=t(120),u=d.enforce,p=d.get,m=String,h=Object.defineProperty,f=i("".slice),g=i("".replace),v=i([].join),b=s&&!r((function(){return 8!==h((function(){}),"length",{value:8}).length})),x=String(String).split("String"),y=n.exports=function(n,e,t){"Symbol("===f(m(e),0,7)&&(e="["+g(m(e),/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!a(n,"name")||l&&n.name!==e)&&(s?h(n,"name",{value:e,configurable:!0}):n.name=e),b&&t&&a(t,"arity")&&n.length!==t.arity&&h(n,"length",{value:t.arity});try{t&&a(t,"constructor")&&t.constructor?s&&h(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var i=u(n);return a(i,"source")||(i.source=v(x,"string"==typeof e?e:"")),n};Function.prototype.toString=y((function(){return o(this)&&p(this).source||c(this)}),"toString")},function(n,e,t){"use strict";n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){"use strict";var i=t(1),r=t(9),o=i.document,a=r(o)&&r(o.createElement);n.exports=function(n){return a?o.createElement(n):{}}},function(n,e,t){"use strict";var i=t(5),r=t(4);n.exports=i&&r((function(){return 42!==Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){"use strict";var i=t(62),r=t(64),o=i("keys");n.exports=function(n){return o[n]||(o[n]=r(n))}},function(n,e,t){"use strict";var i=t(3),r=t(7),o=t(30),a=t(124).indexOf,s=t(50),l=i([].push);n.exports=function(n,e){var t,i=o(n),c=0,d=[];for(t in i)!r(s,t)&&r(i,t)&&l(d,t);for(;e.length>c;)r(i,t=e[c++])&&(~a(d,t)||l(d,t));return d}},function(n,e,t){n.exports=t(261)},function(n,e,t){"use strict";var i=t(18),r=t(130).left,o=t(131),a=t(61);i({target:"Array",proto:!0,forced:!t(132)&&a>79&&a<83||!o("reduce")},{reduce:function(n){var e=arguments.length;return r(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var i={}.propertyIsEnumerable,r=Object.getOwnPropertyDescriptor,o=r&&!i.call({1:2},1);e.f=o?function(n){var e=r(this,n);return!!e&&e.enumerable}:i},function(n,e,t){"use strict";var i=t(35),r=t(9),o=t(57),a=t(115),s=t(117),l=t(20),c=TypeError,d=l("toPrimitive");n.exports=function(n,e){if(!r(n)||o(n))return n;var t,l=a(n,d);if(l){if(void 0===e&&(e="default"),t=i(l,n,e),!r(t)||o(t))return t;throw new c("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e,t){"use strict";n.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},function(n,e,t){"use strict";var i=t(32),r=t(54);n.exports=function(n,e){var t=n[e];return r(t)?void 0:i(t)}},function(n,e,t){"use strict";var i=String;n.exports=function(n){try{return i(n)}catch(n){return"Object"}}},function(n,e,t){"use strict";var i=t(35),r=t(2),o=t(9),a=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&r(t=n.toString)&&!o(s=i(t,n)))return s;if(r(t=n.valueOf)&&!o(s=i(t,n)))return s;if("string"!==e&&r(t=n.toString)&&!o(s=i(t,n)))return s;throw new a("Can't convert object to primitive value")}},function(n,e,t){"use strict";var i=t(5),r=t(7),o=Function.prototype,a=i&&Object.getOwnPropertyDescriptor,s=r(o,"name"),l=s&&"something"===function(){}.name,c=s&&(!i||i&&a(o,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){"use strict";var i=t(3),r=t(2),o=t(37),a=i(Function.toString);r(o.inspectSource)||(o.inspectSource=function(n){return a(n)}),n.exports=o.inspectSource},function(n,e,t){"use strict";var i,r,o,a=t(121),s=t(1),l=t(9),c=t(15),d=t(7),u=t(37),p=t(108),m=t(50),h=s.TypeError,f=s.WeakMap;if(a||u.state){var g=u.state||(u.state=new f);g.get=g.get,g.has=g.has,g.set=g.set,i=function(n,e){if(g.has(n))throw new h("Object already initialized");return e.facade=n,g.set(n,e),e},r=function(n){return g.get(n)||{}},o=function(n){return g.has(n)}}else{var v=p("state");m[v]=!0,i=function(n,e){if(d(n,v))throw new h("Object already initialized");return e.facade=n,c(n,v,e),e},r=function(n){return d(n,v)?n[v]:{}},o=function(n){return d(n,v)}}n.exports={set:i,get:r,has:o,enforce:function(n){return o(n)?r(n):i(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=r(e)).type!==n)throw new h("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){"use strict";var i=t(1),r=t(2),o=i.WeakMap;n.exports=r(o)&&/native code/.test(String(o))},function(n,e,t){"use strict";var i=t(31),r=t(3),o=t(123),a=t(128),s=t(28),l=r([].concat);n.exports=i("Reflect","ownKeys")||function(n){var e=o.f(s(n)),t=a.f;return t?l(e,t(n)):e}},function(n,e,t){"use strict";var i=t(109),r=t(105).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return i(n,r)}},function(n,e,t){"use strict";var i=t(30),r=t(125),o=t(34),a=function(n){return function(e,t,a){var s,l=i(e),c=o(l),d=r(a,c);if(n&&t!=t){for(;c>d;)if((s=l[d++])!=s)return!0}else for(;c>d;d++)if((n||d in l)&&l[d]===t)return n||d||0;return!n&&-1}};n.exports={includes:a(!0),indexOf:a(!1)}},function(n,e,t){"use strict";var i=t(67),r=Math.max,o=Math.min;n.exports=function(n,e){var t=i(n);return t<0?r(t+e,0):o(t,e)}},function(n,e,t){"use strict";var i=Math.ceil,r=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?r:i)(e)}},function(n,e,t){"use strict";var i=t(67),r=Math.min;n.exports=function(n){return n>0?r(i(n),9007199254740991):0}},function(n,e,t){"use strict";e.f=Object.getOwnPropertySymbols},function(n,e,t){"use strict";var i=t(4),r=t(2),o=/#|\.prototype\./,a=function(n,e){var t=l[s(n)];return t===d||t!==c&&(r(e)?i(e):!!e)},s=a.normalize=function(n){return String(n).replace(o,".").toLowerCase()},l=a.data={},c=a.NATIVE="N",d=a.POLYFILL="P";n.exports=a},function(n,e,t){"use strict";var i=t(32),r=t(33),o=t(49),a=t(34),s=TypeError,l=function(n){return function(e,t,l,c){i(t);var d=r(e),u=o(d),p=a(d),m=n?p-1:0,h=n?-1:1;if(l<2)for(;;){if(m in u){c=u[m],m+=h;break}if(m+=h,n?m<0:p<=m)throw new s("Reduce of empty array with no initial value")}for(;n?m>=0:p>m;m+=h)m in u&&(c=t(c,u[m],m,d));return c}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var i=t(4);n.exports=function(n,e){var t=[][n];return!!t&&i((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){"use strict";var i=t(1),r=t(19);n.exports="process"===r(i.process)},function(n,e,t){"use strict";var i=t(5),r=t(134),o=TypeError,a=Object.getOwnPropertyDescriptor,s=i&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,e){if(r(n)&&!a(n,"length").writable)throw new o("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){"use strict";var i=t(19);n.exports=Array.isArray||function(n){return"Array"===i(n)}},function(n,e,t){"use strict";var i=TypeError;n.exports=function(n){if(n>9007199254740991)throw i("Maximum allowed index exceeded");return n}},function(n,e,t){"use strict";var i=t(18),r=t(1),o=t(137),a=t(138),s=r.WebAssembly,l=7!==new Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=a(n,e,l),i({global:!0,constructor:!0,arity:1,forced:l},t)},d=function(n,e){if(s&&s[n]){var t={};t[n]=a("WebAssembly."+n,e,l),i({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return o(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return o(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return o(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return o(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return o(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return o(n,this,arguments)}})),c("URIError",(function(n){return function(e){return o(n,this,arguments)}})),d("CompileError",(function(n){return function(e){return o(n,this,arguments)}})),d("LinkError",(function(n){return function(e){return o(n,this,arguments)}})),d("RuntimeError",(function(n){return function(e){return o(n,this,arguments)}}))},function(n,e,t){"use strict";var i=t(29),r=Function.prototype,o=r.apply,a=r.call;n.exports="object"==typeof Reflect&&Reflect.apply||(i?a.bind(o):function(){return a.apply(o,arguments)})},function(n,e,t){"use strict";var i=t(31),r=t(7),o=t(15),a=t(58),s=t(68),l=t(66),c=t(141),d=t(142),u=t(143),p=t(146),m=t(147),h=t(5),f=t(63);n.exports=function(n,e,t,g){var v=g?2:1,b=n.split("."),x=b[b.length-1],y=i.apply(null,b);if(y){var k=y.prototype;if(!f&&r(k,"cause")&&delete k.cause,!t)return y;var _=i("Error"),w=e((function(n,e){var t=u(g?e:n,void 0),i=g?new y(n):new y;return void 0!==t&&o(i,"message",t),m(i,w,i.stack,2),this&&a(k,this)&&d(i,this,w),arguments.length>v&&p(i,arguments[v]),i}));if(w.prototype=k,"Error"!==x?s?s(w,_):l(w,_,{name:!0}):h&&"stackTraceLimit"in y&&(c(w,y,"stackTraceLimit"),c(w,y,"prepareStackTrace")),l(w,y),!f)try{k.name!==x&&o(k,"name",x),k.constructor=w}catch(n){}return w}}},function(n,e,t){"use strict";var i=t(3),r=t(32);n.exports=function(n,e,t){try{return i(r(Object.getOwnPropertyDescriptor(n,e)[t]))}catch(n){}}},function(n,e,t){"use strict";var i=t(2),r=String,o=TypeError;n.exports=function(n){if("object"==typeof n||i(n))return n;throw new o("Can't set "+r(n)+" as a prototype")}},function(n,e,t){"use strict";var i=t(13).f;n.exports=function(n,e,t){t in n||i(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){"use strict";var i=t(2),r=t(9),o=t(68);n.exports=function(n,e,t){var a,s;return o&&i(a=e.constructor)&&a!==t&&r(s=a.prototype)&&s!==t.prototype&&o(n,s),n}},function(n,e,t){"use strict";var i=t(102);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:i(n)}},function(n,e,t){"use strict";var i=t(145),r=t(2),o=t(19),a=t(20)("toStringTag"),s=Object,l="Arguments"===o(function(){return arguments}());n.exports=i?o:function(n){var e,t,i;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),a))?t:l?o(e):"Object"===(i=o(e))&&r(e.callee)?"Arguments":i}},function(n,e,t){"use strict";var i={};i[t(20)("toStringTag")]="z",n.exports="[object z]"===String(i)},function(n,e,t){"use strict";var i=t(9),r=t(15);n.exports=function(n,e){i(e)&&"cause"in e&&r(n,"cause",e.cause)}},function(n,e,t){"use strict";var i=t(15),r=t(148),o=t(149),a=Error.captureStackTrace;n.exports=function(n,e,t,s){o&&(a?a(n,e):i(n,"stack",r(t,s)))}},function(n,e,t){"use strict";var i=t(3),r=Error,o=i("".replace),a=String(new r("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(a);n.exports=function(n,e){if(l&&"string"==typeof n&&!r.prepareStackTrace)for(;e--;)n=o(n,s,"");return n}},function(n,e,t){"use strict";var i=t(4),r=t(36);n.exports=!i((function(){var n=new Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",r(1,7)),7!==n.stack)}))},function(n,e,t){var i=t(69),r=t(151);n.exports=function n(e,t,o,a,s){var l=-1,c=e.length;for(o||(o=r),s||(s=[]);++l<c;){var d=e[l];t>0&&o(d)?t>1?n(d,t-1,o,a,s):i(s,d):a||(s[s.length]=d)}return s}},function(n,e,t){var i=t(16),r=t(39),o=t(6),a=i?i.isConcatSpreadable:void 0;n.exports=function(n){return o(n)||r(n)||!!(a&&n&&n[a])}},function(n,e,t){var i=t(14),r=t(12);n.exports=function(n){return r(n)&&"[object Arguments]"==i(n)}},function(n,e,t){var i=t(16),r=Object.prototype,o=r.hasOwnProperty,a=r.toString,s=i?i.toStringTag:void 0;n.exports=function(n){var e=o.call(n,s),t=n[s];try{n[s]=void 0;var i=!0}catch(n){}var r=a.call(n);return i&&(e?n[s]=t:delete n[s]),r}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var i=t(156),r=t(212),o=t(47),a=t(6),s=t(223);n.exports=function(n){return"function"==typeof n?n:null==n?o:"object"==typeof n?a(n)?r(n[0],n[1]):i(n):s(n)}},function(n,e,t){var i=t(157),r=t(211),o=t(86);n.exports=function(n){var e=r(n);return 1==e.length&&e[0][2]?o(e[0][0],e[0][1]):function(t){return t===n||i(t,n,e)}}},function(n,e,t){var i=t(71),r=t(75);n.exports=function(n,e,t,o){var a=t.length,s=a,l=!o;if(null==n)return!s;for(n=Object(n);a--;){var c=t[a];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++a<s;){var d=(c=t[a])[0],u=n[d],p=c[1];if(l&&c[2]){if(void 0===u&&!(d in n))return!1}else{var m=new i;if(o)var h=o(u,p,d,n,e,m);if(!(void 0===h?r(p,u,3,o,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var i=t(22),r=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=i(e,n);return!(t<0)&&(t==e.length-1?e.pop():r.call(e,t,1),--this.size,!0)}},function(n,e,t){var i=t(22);n.exports=function(n){var e=this.__data__,t=i(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var i=t(22);n.exports=function(n){return i(this.__data__,n)>-1}},function(n,e,t){var i=t(22);n.exports=function(n,e){var t=this.__data__,r=i(t,n);return r<0?(++this.size,t.push([n,e])):t[r][1]=e,this}},function(n,e,t){var i=t(21);n.exports=function(){this.__data__=new i,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var i=t(21),r=t(40),o=t(42);n.exports=function(n,e){var t=this.__data__;if(t instanceof i){var a=t.__data__;if(!r||a.length<199)return a.push([n,e]),this.size=++t.size,this;t=this.__data__=new o(a)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var i=t(73),r=t(169),o=t(41),a=t(74),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,d=l.toString,u=c.hasOwnProperty,p=RegExp("^"+d.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!o(n)||r(n))&&(i(n)?p:s).test(a(n))}},function(n,e,t){var i,r=t(170),o=(i=/[^.]+$/.exec(r&&r.keys&&r.keys.IE_PROTO||""))?"Symbol(src)_1."+i:"";n.exports=function(n){return!!o&&o in n}},function(n,e,t){var i=t(8)["__core-js_shared__"];n.exports=i},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var i=t(173),r=t(21),o=t(40);n.exports=function(){this.size=0,this.__data__={hash:new i,map:new(o||r),string:new i}}},function(n,e,t){var i=t(174),r=t(175),o=t(176),a=t(177),s=t(178);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var i=n[e];this.set(i[0],i[1])}}l.prototype.clear=i,l.prototype.delete=r,l.prototype.get=o,l.prototype.has=a,l.prototype.set=s,n.exports=l},function(n,e,t){var i=t(23);n.exports=function(){this.__data__=i?i(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var i=t(23),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(i){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return r.call(e,n)?e[n]:void 0}},function(n,e,t){var i=t(23),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return i?void 0!==e[n]:r.call(e,n)}},function(n,e,t){var i=t(23);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=i&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var i=t(24);n.exports=function(n){var e=i(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var i=t(24);n.exports=function(n){return i(this,n).get(n)}},function(n,e,t){var i=t(24);n.exports=function(n){return i(this,n).has(n)}},function(n,e,t){var i=t(24);n.exports=function(n,e){var t=i(this,n),r=t.size;return t.set(n,e),this.size+=t.size==r?0:1,this}},function(n,e,t){var i=t(71),r=t(76),o=t(188),a=t(191),s=t(207),l=t(6),c=t(80),d=t(82),u="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,f){var g=l(n),v=l(e),b=g?"[object Array]":s(n),x=v?"[object Array]":s(e),y=(b="[object Arguments]"==b?u:b)==u,k=(x="[object Arguments]"==x?u:x)==u,_=b==x;if(_&&c(n)){if(!c(e))return!1;g=!0,y=!1}if(_&&!y)return f||(f=new i),g||d(n)?r(n,e,t,m,h,f):o(n,e,b,t,m,h,f);if(!(1&t)){var w=y&&p.call(n,"__wrapped__"),E=k&&p.call(e,"__wrapped__");if(w||E){var T=w?n.value():n,P=E?e.value():e;return f||(f=new i),h(T,P,t,m,f)}}return!!_&&(f||(f=new i),a(n,e,t,m,h,f))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,i=null==n?0:n.length;++t<i;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var i=t(16),r=t(189),o=t(72),a=t(76),s=t(190),l=t(43),c=i?i.prototype:void 0,d=c?c.valueOf:void 0;n.exports=function(n,e,t,i,c,u,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!u(new r(n),new r(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return o(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=s;case"[object Set]":var h=1&i;if(m||(m=l),n.size!=e.size&&!h)return!1;var f=p.get(n);if(f)return f==e;i|=2,p.set(n,e);var g=a(m(n),m(e),i,c,u,p);return p.delete(n),g;case"[object Symbol]":if(d)return d.call(n)==d.call(e)}return!1}},function(n,e,t){var i=t(8).Uint8Array;n.exports=i},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,i){t[++e]=[i,n]})),t}},function(n,e,t){var i=t(192),r=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,o,a,s){var l=1&t,c=i(n),d=c.length;if(d!=i(e).length&&!l)return!1;for(var u=d;u--;){var p=c[u];if(!(l?p in e:r.call(e,p)))return!1}var m=s.get(n),h=s.get(e);if(m&&h)return m==e&&h==n;var f=!0;s.set(n,e),s.set(e,n);for(var g=l;++u<d;){var v=n[p=c[u]],b=e[p];if(o)var x=l?o(b,v,p,e,n,s):o(v,b,p,n,e,s);if(!(void 0===x?v===b||a(v,b,t,o,s):x)){f=!1;break}g||(g="constructor"==p)}if(f&&!g){var y=n.constructor,k=e.constructor;y==k||!("constructor"in n)||!("constructor"in e)||"function"==typeof y&&y instanceof y&&"function"==typeof k&&k instanceof k||(f=!1)}return s.delete(n),s.delete(e),f}},function(n,e,t){var i=t(193),r=t(194),o=t(79);n.exports=function(n){return i(n,o,r)}},function(n,e,t){var i=t(69),r=t(6);n.exports=function(n,e,t){var o=e(n);return r(n)?o:i(o,t(n))}},function(n,e,t){var i=t(195),r=t(196),o=Object.prototype.propertyIsEnumerable,a=Object.getOwnPropertySymbols,s=a?function(n){return null==n?[]:(n=Object(n),i(a(n),(function(e){return o.call(n,e)})))}:r;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,i=null==n?0:n.length,r=0,o=[];++t<i;){var a=n[t];e(a,t,n)&&(o[r++]=a)}return o}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var i=t(198),r=t(39),o=t(6),a=t(80),s=t(81),l=t(82),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=o(n),d=!t&&r(n),u=!t&&!d&&a(n),p=!t&&!d&&!u&&l(n),m=t||d||u||p,h=m?i(n.length,String):[],f=h.length;for(var g in n)!e&&!c.call(n,g)||m&&("length"==g||u&&("offset"==g||"parent"==g)||p&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||s(g,f))||h.push(g);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,i=Array(n);++t<n;)i[t]=e(t);return i}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var i=t(14),r=t(44),o=t(12),a={};a["[object Float32Array]"]=a["[object Float64Array]"]=a["[object Int8Array]"]=a["[object Int16Array]"]=a["[object Int32Array]"]=a["[object Uint8Array]"]=a["[object Uint8ClampedArray]"]=a["[object Uint16Array]"]=a["[object Uint32Array]"]=!0,a["[object Arguments]"]=a["[object Array]"]=a["[object ArrayBuffer]"]=a["[object Boolean]"]=a["[object DataView]"]=a["[object Date]"]=a["[object Error]"]=a["[object Function]"]=a["[object Map]"]=a["[object Number]"]=a["[object Object]"]=a["[object RegExp]"]=a["[object Set]"]=a["[object String]"]=a["[object WeakMap]"]=!1,n.exports=function(n){return o(n)&&r(n.length)&&!!a[i(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var i=t(70),r=e&&!e.nodeType&&e,o=r&&"object"==typeof n&&n&&!n.nodeType&&n,a=o&&o.exports===r&&i.process,s=function(){try{var n=o&&o.require&&o.require("util").types;return n||a&&a.binding&&a.binding("util")}catch(n){}}();n.exports=s}).call(this,t(51)(n))},function(n,e,t){var i=t(204),r=t(205),o=Object.prototype.hasOwnProperty;n.exports=function(n){if(!i(n))return r(n);var e=[];for(var t in Object(n))o.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var i=t(206)(Object.keys,Object);n.exports=i},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var i=t(208),r=t(40),o=t(209),a=t(84),s=t(210),l=t(14),c=t(74),d=c(i),u=c(r),p=c(o),m=c(a),h=c(s),f=l;(i&&"[object DataView]"!=f(new i(new ArrayBuffer(1)))||r&&"[object Map]"!=f(new r)||o&&"[object Promise]"!=f(o.resolve())||a&&"[object Set]"!=f(new a)||s&&"[object WeakMap]"!=f(new s))&&(f=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,i=t?c(t):"";if(i)switch(i){case d:return"[object DataView]";case u:return"[object Map]";case p:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=f},function(n,e,t){var i=t(10)(t(8),"DataView");n.exports=i},function(n,e,t){var i=t(10)(t(8),"Promise");n.exports=i},function(n,e,t){var i=t(10)(t(8),"WeakMap");n.exports=i},function(n,e,t){var i=t(85),r=t(79);n.exports=function(n){for(var e=r(n),t=e.length;t--;){var o=e[t],a=n[o];e[t]=[o,a,i(a)]}return e}},function(n,e,t){var i=t(75),r=t(213),o=t(220),a=t(45),s=t(85),l=t(86),c=t(25);n.exports=function(n,e){return a(n)&&s(e)?l(c(n),e):function(t){var a=r(t,n);return void 0===a&&a===e?o(t,n):i(e,a,3)}}},function(n,e,t){var i=t(87);n.exports=function(n,e,t){var r=null==n?void 0:i(n,e);return void 0===r?t:r}},function(n,e,t){var i=t(215),r=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,o=/\\(\\)?/g,a=i((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(r,(function(n,t,i,r){e.push(i?r.replace(o,"$1"):t||n)})),e}));n.exports=a},function(n,e,t){var i=t(216);n.exports=function(n){var e=i(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var i=t(42);function r(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var i=arguments,r=e?e.apply(this,i):i[0],o=t.cache;if(o.has(r))return o.get(r);var a=n.apply(this,i);return t.cache=o.set(r,a)||o,a};return t.cache=new(r.Cache||i),t}r.Cache=i,n.exports=r},function(n,e,t){var i=t(218);n.exports=function(n){return null==n?"":i(n)}},function(n,e,t){var i=t(16),r=t(219),o=t(6),a=t(46),s=i?i.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(o(e))return r(e,n)+"";if(a(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,i=null==n?0:n.length,r=Array(i);++t<i;)r[t]=e(n[t],t,n);return r}},function(n,e,t){var i=t(221),r=t(222);n.exports=function(n,e){return null!=n&&r(n,e,i)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var i=t(88),r=t(39),o=t(6),a=t(81),s=t(44),l=t(25);n.exports=function(n,e,t){for(var c=-1,d=(e=i(e,n)).length,u=!1;++c<d;){var p=l(e[c]);if(!(u=null!=n&&t(n,p)))break;n=n[p]}return u||++c!=d?u:!!(d=null==n?0:n.length)&&s(d)&&a(p,d)&&(o(n)||r(n))}},function(n,e,t){var i=t(224),r=t(225),o=t(45),a=t(25);n.exports=function(n){return o(n)?i(a(n)):r(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var i=t(87);n.exports=function(n){return function(e){return i(e,n)}}},function(n,e,t){var i=t(47),r=t(227),o=t(229);n.exports=function(n,e){return o(r(n,e,i),n+"")}},function(n,e,t){var i=t(228),r=Math.max;n.exports=function(n,e,t){return e=r(void 0===e?n.length-1:e,0),function(){for(var o=arguments,a=-1,s=r(o.length-e,0),l=Array(s);++a<s;)l[a]=o[e+a];a=-1;for(var c=Array(e+1);++a<e;)c[a]=o[a];return c[e]=t(l),i(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var i=t(230),r=t(233)(i);n.exports=r},function(n,e,t){var i=t(231),r=t(232),o=t(47),a=r?function(n,e){return r(n,"toString",{configurable:!0,enumerable:!1,value:i(e),writable:!0})}:o;n.exports=a},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var i=t(10),r=function(){try{var n=i(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=r},function(n,e){var t=Date.now;n.exports=function(n){var e=0,i=0;return function(){var r=t(),o=16-(r-i);if(i=r,o>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var i=t(77),r=t(235),o=t(240),a=t(78),s=t(241),l=t(43);n.exports=function(n,e,t){var c=-1,d=r,u=n.length,p=!0,m=[],h=m;if(t)p=!1,d=o;else if(u>=200){var f=e?null:s(n);if(f)return l(f);p=!1,d=a,h=new i}else h=e?[]:m;n:for(;++c<u;){var g=n[c],v=e?e(g):g;if(g=t||0!==g?g:0,p&&v==v){for(var b=h.length;b--;)if(h[b]===v)continue n;e&&h.push(v),m.push(g)}else d(h,v,t)||(h!==m&&h.push(v),m.push(g))}return m}},function(n,e,t){var i=t(236);n.exports=function(n,e){return!!(null==n?0:n.length)&&i(n,e,0)>-1}},function(n,e,t){var i=t(237),r=t(238),o=t(239);n.exports=function(n,e,t){return e==e?o(n,e,t):i(n,r,t)}},function(n,e){n.exports=function(n,e,t,i){for(var r=n.length,o=t+(i?1:-1);i?o--:++o<r;)if(e(n[o],o,n))return o;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var i=t-1,r=n.length;++i<r;)if(n[i]===e)return i;return-1}},function(n,e){n.exports=function(n,e,t){for(var i=-1,r=null==n?0:n.length;++i<r;)if(t(e,n[i]))return!0;return!1}},function(n,e,t){var i=t(84),r=t(242),o=t(43),a=i&&1/o(new i([,-0]))[1]==1/0?function(n){return new i(n)}:r;n.exports=a},function(n,e){n.exports=function(){}},function(n,e,t){var i=t(83),r=t(12);n.exports=function(n){return r(n)&&i(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(89)},function(n,e,t){"use strict";t(90)},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(91)},function(n,e,t){"use strict";t(92)},function(n,e,t){"use strict";t(93)},function(n,e,t){"use strict";var i=t(18),r=t(1),o=t(254);i({global:!0},{Reflect:{}}),o(r.Reflect,"Reflect",!0)},function(n,e,t){"use strict";var i=t(13).f,r=t(7),o=t(20)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!r(n,o)&&i(n,o,{configurable:!0,value:e})}},function(n,e){},function(n,e){function t(n,e){for(var t=0,i=n.length-1;i>=0;i--){var r=n[i];"."===r?n.splice(i,1):".."===r?(n.splice(i,1),t++):t&&(n.splice(i,1),t--)}if(e)for(;t--;t)n.unshift("..");return n}function i(n,e){if(n.filter)return n.filter(e);for(var t=[],i=0;i<n.length;i++)e(n[i],i,n)&&t.push(n[i]);return t}e.resolve=function(){for(var n="",e=!1,r=arguments.length-1;r>=-1&&!e;r--){var o=r>=0?arguments[r]:process.cwd();if("string"!=typeof o)throw new TypeError("Arguments to path.resolve must be strings");o&&(n=o+"/"+n,e="/"===o.charAt(0))}return(e?"/":"")+(n=t(i(n.split("/"),(function(n){return!!n})),!e).join("/"))||"."},e.normalize=function(n){var o=e.isAbsolute(n),a="/"===r(n,-1);return(n=t(i(n.split("/"),(function(n){return!!n})),!o).join("/"))||o||(n="."),n&&a&&(n+="/"),(o?"/":"")+n},e.isAbsolute=function(n){return"/"===n.charAt(0)},e.join=function(){var n=Array.prototype.slice.call(arguments,0);return e.normalize(i(n,(function(n,e){if("string"!=typeof n)throw new TypeError("Arguments to path.join must be strings");return n})).join("/"))},e.relative=function(n,t){function i(n){for(var e=0;e<n.length&&""===n[e];e++);for(var t=n.length-1;t>=0&&""===n[t];t--);return e>t?[]:n.slice(e,t-e+1)}n=e.resolve(n).substr(1),t=e.resolve(t).substr(1);for(var r=i(n.split("/")),o=i(t.split("/")),a=Math.min(r.length,o.length),s=a,l=0;l<a;l++)if(r[l]!==o[l]){s=l;break}var c=[];for(l=s;l<r.length;l++)c.push("..");return(c=c.concat(o.slice(s))).join("/")},e.sep="/",e.delimiter=":",e.dirname=function(n){if("string"!=typeof n&&(n+=""),0===n.length)return".";for(var e=n.charCodeAt(0),t=47===e,i=-1,r=!0,o=n.length-1;o>=1;--o)if(47===(e=n.charCodeAt(o))){if(!r){i=o;break}}else r=!1;return-1===i?t?"/":".":t&&1===i?"/":n.slice(0,i)},e.basename=function(n,e){var t=function(n){"string"!=typeof n&&(n+="");var e,t=0,i=-1,r=!0;for(e=n.length-1;e>=0;--e)if(47===n.charCodeAt(e)){if(!r){t=e+1;break}}else-1===i&&(r=!1,i=e+1);return-1===i?"":n.slice(t,i)}(n);return e&&t.substr(-1*e.length)===e&&(t=t.substr(0,t.length-e.length)),t},e.extname=function(n){"string"!=typeof n&&(n+="");for(var e=-1,t=0,i=-1,r=!0,o=0,a=n.length-1;a>=0;--a){var s=n.charCodeAt(a);if(47!==s)-1===i&&(r=!1,i=a+1),46===s?-1===e?e=a:1!==o&&(o=1):-1!==e&&(o=-1);else if(!r){t=a+1;break}}return-1===e||-1===i||0===o||1===o&&e===i-1&&e===t+1?"":n.slice(e,i)};var r="b"==="ab".substr(-1)?function(n,e,t){return n.substr(e,t)}:function(n,e,t){return e<0&&(e=n.length+e),n.substr(e,t)}},function(n,e,t){"use strict";var i=/[|\\{}()[\]^$+*?.]/g;e.escapeRegExpChars=function(n){return n?String(n).replace(i,"\\$&"):""};var r={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&#34;","'":"&#39;"},o=/[&<>'"]/g;function a(n){return r[n]||n}e.escapeXML=function(n){return null==n?"":String(n).replace(o,a)},e.escapeXML.toString=function(){return Function.prototype.toString.call(this)+';\nvar _ENCODE_HTML_RULES = {\n      "&": "&amp;"\n    , "<": "&lt;"\n    , ">": "&gt;"\n    , \'"\': "&#34;"\n    , "\'": "&#39;"\n    }\n  , _MATCH_HTML = /[&<>\'"]/g;\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n};\n'},e.shallowCopy=function(n,e){for(var t in e=e||{})n[t]=e[t];return n},e.shallowCopyFromList=function(n,e,t){for(var i=0;i<t.length;i++){var r=t[i];void 0!==e[r]&&(n[r]=e[r])}return n},e.cache={_data:{},set:function(n,e){this._data[n]=e},get:function(n){return this._data[n]},remove:function(n){delete this._data[n]},reset:function(){this._data={}}}},function(n){n.exports=JSON.parse('{"name":"ejs","description":"Embedded JavaScript templates","keywords":["template","engine","ejs"],"version":"2.7.4","author":"Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)","license":"Apache-2.0","main":"./lib/ejs.js","repository":{"type":"git","url":"git://github.com/mde/ejs.git"},"bugs":"https://github.com/mde/ejs/issues","homepage":"https://github.com/mde/ejs","dependencies":{},"devDependencies":{"browserify":"^13.1.1","eslint":"^4.14.0","git-directory-deploy":"^1.5.1","jake":"^10.3.1","jsdoc":"^3.4.0","lru-cache":"^4.0.1","mocha":"^5.0.5","uglify-js":"^3.3.16"},"engines":{"node":">=0.10.0"},"scripts":{"test":"mocha","postinstall":"node ./postinstall.js"}}')},function(n,e,t){"use strict";t(94)},function(n,e,t){"use strict";t(95)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.15
 * (c) 2014-2023 Evan You
 * Released under the MIT License.
 */
var i=Object.freeze({}),r=Array.isArray;function o(n){return null==n}function a(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function d(n){return null!==n&&"object"==typeof n}var u=Object.prototype.toString;function p(n){return"[object Object]"===u.call(n)}function m(n){return"[object RegExp]"===u.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function f(n){return a(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function g(n){return null==n?"":Array.isArray(n)||p(n)&&n.toString===u?JSON.stringify(n,null,2):String(n)}function v(n){var e=parseFloat(n);return isNaN(e)?n:e}function b(n,e){for(var t=Object.create(null),i=n.split(","),r=0;r<i.length;r++)t[i[r]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}b("slot,component",!0);var x=b("key,ref,slot,slot-scope,is");function y(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var i=n.indexOf(e);if(i>-1)return n.splice(i,1)}}var k=Object.prototype.hasOwnProperty;function _(n,e){return k.call(n,e)}function w(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var E=/-(\w)/g,T=w((function(n){return n.replace(E,(function(n,e){return e?e.toUpperCase():""}))})),P=w((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),j=/\B([A-Z])/g,A=w((function(n){return n.replace(j,"-$1").toLowerCase()}));var C=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var i=arguments.length;return i?i>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function S(n,e){e=e||0;for(var t=n.length-e,i=new Array(t);t--;)i[t]=n[t+e];return i}function B(n,e){for(var t in e)n[t]=e[t];return n}function I(n){for(var e={},t=0;t<n.length;t++)n[t]&&B(e,n[t]);return e}function L(n,e,t){}var D=function(n,e,t){return!1},z=function(n){return n};function O(n,e){if(n===e)return!0;var t=d(n),i=d(e);if(!t||!i)return!t&&!i&&String(n)===String(e);try{var r=Array.isArray(n),o=Array.isArray(e);if(r&&o)return n.length===e.length&&n.every((function(n,t){return O(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(r||o)return!1;var a=Object.keys(n),s=Object.keys(e);return a.length===s.length&&a.every((function(t){return O(n[t],e[t])}))}catch(n){return!1}}function U(n,e){for(var t=0;t<n.length;t++)if(O(n[t],e))return t;return-1}function N(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function R(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var q=["component","directive","filter"],F=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],M={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:D,isReservedAttr:D,isUnknownElement:D,getTagNamespace:L,parsePlatformTagName:z,mustUseProp:D,async:!0,_lifecycleHooks:F},G=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function $(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function V(n,e,t,i){Object.defineProperty(n,e,{value:t,enumerable:!!i,writable:!0,configurable:!0})}var H=new RegExp("[^".concat(G.source,".$_\\d]"));var K="__proto__"in{},J="undefined"!=typeof window,W=J&&window.navigator.userAgent.toLowerCase(),Q=W&&/msie|trident/.test(W),Y=W&&W.indexOf("msie 9.0")>0,X=W&&W.indexOf("edge/")>0;W&&W.indexOf("android");var Z=W&&/iphone|ipad|ipod|ios/.test(W);W&&/chrome\/\d+/.test(W),W&&/phantomjs/.test(W);var nn,en=W&&W.match(/firefox\/(\d+)/),tn={}.watch,rn=!1;if(J)try{var on={};Object.defineProperty(on,"passive",{get:function(){rn=!0}}),window.addEventListener("test-passive",null,on)}catch(n){}var an=function(){return void 0===nn&&(nn=!J&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},sn=J&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,dn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);cn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var un=null;function pn(n){void 0===n&&(n=null),n||un&&un._scope.off(),un=n,n&&n._scope.on()}var mn=function(){function n(n,e,t,i,r,o,a,s){this.tag=n,this.data=e,this.children=t,this.text=i,this.elm=r,this.ns=void 0,this.context=o,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=a,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),hn=function(n){void 0===n&&(n="");var e=new mn;return e.text=n,e.isComment=!0,e};function fn(n){return new mn(void 0,void 0,void 0,String(n))}function gn(n){var e=new mn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var vn=0,bn=[],xn=function(){function n(){this._pending=!1,this.id=vn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,bn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,i=e.length;t<i;t++){0,e[t].update()}},n}();xn.target=null;var yn=[];function kn(n){yn.push(n),xn.target=n}function _n(){yn.pop(),xn.target=yn[yn.length-1]}var wn=Array.prototype,En=Object.create(wn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=wn[n];V(En,n,(function(){for(var t=[],i=0;i<arguments.length;i++)t[i]=arguments[i];var r,o=e.apply(this,t),a=this.__ob__;switch(n){case"push":case"unshift":r=t;break;case"splice":r=t.slice(2)}return r&&a.observeArray(r),a.dep.notify(),o}))}));var Tn=Object.getOwnPropertyNames(En),Pn={},jn=!0;function An(n){jn=n}var Cn={notify:L,depend:L,addSub:L,removeSub:L},Sn=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?Cn:new xn,this.vmCount=0,V(n,"__ob__",this),r(n)){if(!t)if(K)n.__proto__=En;else for(var i=0,o=Tn.length;i<o;i++){V(n,s=Tn[i],En[s])}e||this.observeArray(n)}else{var a=Object.keys(n);for(i=0;i<a.length;i++){var s;In(n,s=a[i],Pn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Bn(n[e],!1,this.mock)},n}();function Bn(n,e,t){return n&&_(n,"__ob__")&&n.__ob__ instanceof Sn?n.__ob__:!jn||!t&&an()||!r(n)&&!p(n)||!Object.isExtensible(n)||n.__v_skip||Rn(n)||n instanceof mn?void 0:new Sn(n,e,t)}function In(n,e,t,i,o,a){var s=new xn,l=Object.getOwnPropertyDescriptor(n,e);if(!l||!1!==l.configurable){var c=l&&l.get,d=l&&l.set;c&&!d||t!==Pn&&2!==arguments.length||(t=n[e]);var u=!o&&Bn(t,!1,a);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=c?c.call(n):t;return xn.target&&(s.depend(),u&&(u.dep.depend(),r(e)&&zn(e))),Rn(e)&&!o?e.value:e},set:function(e){var i=c?c.call(n):t;if(R(i,e)){if(d)d.call(n,e);else{if(c)return;if(!o&&Rn(i)&&!Rn(e))return void(i.value=e);t=e}u=!o&&Bn(e,!1,a),s.notify()}}}),s}}function Ln(n,e,t){if(!Nn(n)){var i=n.__ob__;return r(n)&&h(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),i&&!i.shallow&&i.mock&&Bn(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||i&&i.vmCount?t:i?(In(i.value,e,t,void 0,i.shallow,i.mock),i.dep.notify(),t):(n[e]=t,t)}}function Dn(n,e){if(r(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Nn(n)||_(n,e)&&(delete n[e],t&&t.dep.notify())}}function zn(n){for(var e=void 0,t=0,i=n.length;t<i;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),r(e)&&zn(e)}function On(n){return Un(n,!0),V(n,"__v_isShallow",!0),n}function Un(n,e){if(!Nn(n)){Bn(n,e,an());0}}function Nn(n){return!(!n||!n.__v_isReadonly)}function Rn(n){return!(!n||!0!==n.__v_isRef)}function qn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Rn(n))return n.value;var i=n&&n.__ob__;return i&&i.dep.depend(),n},set:function(n){var i=e[t];Rn(i)&&!Rn(n)?i.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Fn;var Mn=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Fn,!n&&Fn&&(this.index=(Fn.scopes||(Fn.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Fn;try{return Fn=this,n()}finally{Fn=e}}else 0},n.prototype.on=function(){Fn=this},n.prototype.off=function(){Fn=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var i=this.parent.scopes.pop();i&&i!==this&&(this.parent.scopes[this.index]=i,i.index=this.index)}this.parent=void 0,this.active=!1}},n}();function Gn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var $n=w((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),i="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=i?n.slice(1):n,once:t,capture:i,passive:e}}));function Vn(n,e){function t(){var n=t.fns;if(!r(n))return je(n,null,arguments,e,"v-on handler");for(var i=n.slice(),o=0;o<i.length;o++)je(i[o],null,arguments,e,"v-on handler")}return t.fns=n,t}function Hn(n,e,t,i,r,a){var l,c,d,u;for(l in n)c=n[l],d=e[l],u=$n(l),o(c)||(o(d)?(o(c.fns)&&(c=n[l]=Vn(c,a)),s(u.once)&&(c=n[l]=r(u.name,c,u.capture)),t(u.name,c,u.capture,u.passive,u.params)):c!==d&&(d.fns=c,n[l]=d));for(l in e)o(n[l])&&i((u=$n(l)).name,e[l],u.capture)}function Kn(n,e,t){var i;n instanceof mn&&(n=n.data.hook||(n.data.hook={}));var r=n[e];function l(){t.apply(this,arguments),y(i.fns,l)}o(r)?i=Vn([l]):a(r.fns)&&s(r.merged)?(i=r).fns.push(l):i=Vn([r,l]),i.merged=!0,n[e]=i}function Jn(n,e,t,i,r){if(a(e)){if(_(e,t))return n[t]=e[t],r||delete e[t],!0;if(_(e,i))return n[t]=e[i],r||delete e[i],!0}return!1}function Wn(n){return l(n)?[fn(n)]:r(n)?function n(e,t){var i,c,d,u,p=[];for(i=0;i<e.length;i++)o(c=e[i])||"boolean"==typeof c||(d=p.length-1,u=p[d],r(c)?c.length>0&&(Qn((c=n(c,"".concat(t||"","_").concat(i)))[0])&&Qn(u)&&(p[d]=fn(u.text+c[0].text),c.shift()),p.push.apply(p,c)):l(c)?Qn(u)?p[d]=fn(u.text+c):""!==c&&p.push(fn(c)):Qn(c)&&Qn(u)?p[d]=fn(u.text+c.text):(s(e._isVList)&&a(c.tag)&&o(c.key)&&a(t)&&(c.key="__vlist".concat(t,"_").concat(i,"__")),p.push(c)));return p}(n):void 0}function Qn(n){return a(n)&&a(n.text)&&!1===n.isComment}function Yn(n,e){var t,i,o,s,l=null;if(r(n)||"string"==typeof n)for(l=new Array(n.length),t=0,i=n.length;t<i;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(d(n))if(dn&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),u=c.next();!u.done;)l.push(e(u.value,l.length)),u=c.next()}else for(o=Object.keys(n),l=new Array(o.length),t=0,i=o.length;t<i;t++)s=o[t],l[t]=e(n[s],s,t);return a(l)||(l=[]),l._isVList=!0,l}function Xn(n,e,t,i){var r,o=this.$scopedSlots[n];o?(t=t||{},i&&(t=B(B({},i),t)),r=o(t)||(c(e)?e():e)):r=this.$slots[n]||(c(e)?e():e);var a=t&&t.slot;return a?this.$createElement("template",{slot:a},r):r}function Zn(n){return St(this.$options,"filters",n,!0)||z}function ne(n,e){return r(n)?-1===n.indexOf(e):n!==e}function ee(n,e,t,i,r){var o=M.keyCodes[e]||t;return r&&i&&!M.keyCodes[e]?ne(r,i):o?ne(o,n):i?A(i)!==e:void 0===n}function te(n,e,t,i,o){if(t)if(d(t)){r(t)&&(t=I(t));var a=void 0,s=function(r){if("class"===r||"style"===r||x(r))a=n;else{var s=n.attrs&&n.attrs.type;a=i||M.mustUseProp(e,s,r)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=T(r),c=A(r);l in a||c in a||(a[r]=t[r],o&&((n.on||(n.on={}))["update:".concat(r)]=function(n){t[r]=n}))};for(var l in t)s(l)}else;return n}function ie(n,e){var t=this._staticTrees||(this._staticTrees=[]),i=t[n];return i&&!e||oe(i=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),i}function re(n,e,t){return oe(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function oe(n,e,t){if(r(n))for(var i=0;i<n.length;i++)n[i]&&"string"!=typeof n[i]&&ae(n[i],"".concat(e,"_").concat(i),t);else ae(n,e,t)}function ae(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function se(n,e){if(e)if(p(e)){var t=n.on=n.on?B({},n.on):{};for(var i in e){var r=t[i],o=e[i];t[i]=r?[].concat(r,o):o}}else;return n}function le(n,e,t,i){e=e||{$stable:!t};for(var o=0;o<n.length;o++){var a=n[o];r(a)?le(a,e,t):a&&(a.proxy&&(a.fn.proxy=!0),e[a.key]=a.fn)}return i&&(e.$key=i),e}function ce(n,e){for(var t=0;t<e.length;t+=2){var i=e[t];"string"==typeof i&&i&&(n[e[t]]=e[t+1])}return n}function de(n,e){return"string"==typeof n?e+n:n}function ue(n){n._o=re,n._n=v,n._s=g,n._l=Yn,n._t=Xn,n._q=O,n._i=U,n._m=ie,n._f=Zn,n._k=ee,n._b=te,n._v=fn,n._e=hn,n._u=le,n._g=se,n._d=ce,n._p=de}function pe(n,e){if(!n||!n.length)return{};for(var t={},i=0,r=n.length;i<r;i++){var o=n[i],a=o.data;if(a&&a.attrs&&a.attrs.slot&&delete a.attrs.slot,o.context!==e&&o.fnContext!==e||!a||null==a.slot)(t.default||(t.default=[])).push(o);else{var s=a.slot,l=t[s]||(t[s]=[]);"template"===o.tag?l.push.apply(l,o.children||[]):l.push(o)}}for(var c in t)t[c].every(me)&&delete t[c];return t}function me(n){return n.isComment&&!n.asyncFactory||" "===n.text}function he(n){return n.isComment&&n.asyncFactory}function fe(n,e,t,r){var o,a=Object.keys(t).length>0,s=e?!!e.$stable:!a,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&r&&r!==i&&l===r.$key&&!a&&!r.$hasNormal)return r;for(var c in o={},e)e[c]&&"$"!==c[0]&&(o[c]=ge(n,t,c,e[c]))}else o={};for(var d in t)d in o||(o[d]=ve(t,d));return e&&Object.isExtensible(e)&&(e._normalized=o),V(o,"$stable",s),V(o,"$key",l),V(o,"$hasNormal",a),o}function ge(n,e,t,i){var o=function(){var e=un;pn(n);var t=arguments.length?i.apply(null,arguments):i({}),o=(t=t&&"object"==typeof t&&!r(t)?[t]:Wn(t))&&t[0];return pn(e),t&&(!o||1===t.length&&o.isComment&&!he(o))?void 0:t};return i.proxy&&Object.defineProperty(e,t,{get:o,enumerable:!0,configurable:!0}),o}function ve(n,e){return function(){return n[e]}}function be(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};V(e,"_v_attr_proxy",!0),xe(e,n.$attrs,i,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||xe(n._listenersProxy={},n.$listeners,i,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||ke(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:C(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return qn(n,e,t)}))}}}function xe(n,e,t,i,r){var o=!1;for(var a in e)a in n?e[a]!==t[a]&&(o=!0):(o=!0,ye(n,a,i,r));for(var a in n)a in e||(o=!0,delete n[a]);return o}function ye(n,e,t,i){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[i][e]}})}function ke(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var _e=null;function we(n,e){return(n.__esModule||dn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),d(n)?e.extend(n):n}function Ee(n){if(r(n))for(var e=0;e<n.length;e++){var t=n[e];if(a(t)&&(a(t.componentOptions)||he(t)))return t}}function Te(n,e,t,i,u,p){return(r(t)||l(t))&&(u=i,i=t,t=void 0),s(p)&&(u=2),function(n,e,t,i,l){if(a(t)&&a(t.__ob__))return hn();a(t)&&a(t.is)&&(e=t.is);if(!e)return hn();0;r(i)&&c(i[0])&&((t=t||{}).scopedSlots={default:i[0]},i.length=0);2===l?i=Wn(i):1===l&&(i=function(n){for(var e=0;e<n.length;e++)if(r(n[e]))return Array.prototype.concat.apply([],n);return n}(i));var u,p;if("string"==typeof e){var m=void 0;p=n.$vnode&&n.$vnode.ns||M.getTagNamespace(e),u=M.isReservedTag(e)?new mn(M.parsePlatformTagName(e),t,i,void 0,void 0,n):t&&t.pre||!a(m=St(n.$options,"components",e))?new mn(e,t,i,void 0,void 0,n):yt(m,t,n,i,e)}else u=yt(e,t,n,i);return r(u)?u:a(u)?(a(p)&&function n(e,t,i){e.ns=t,"foreignObject"===e.tag&&(t=void 0,i=!0);if(a(e.children))for(var r=0,l=e.children.length;r<l;r++){var c=e.children[r];a(c.tag)&&(o(c.ns)||s(i)&&"svg"!==c.tag)&&n(c,t,i)}}(u,p),a(t)&&function(n){d(n.style)&&Me(n.style);d(n.class)&&Me(n.class)}(t),u):hn()}(n,e,t,i,u)}function Pe(n,e,t){kn();try{if(e)for(var i=e;i=i.$parent;){var r=i.$options.errorCaptured;if(r)for(var o=0;o<r.length;o++)try{if(!1===r[o].call(i,n,e,t))return}catch(n){Ae(n,i,"errorCaptured hook")}}Ae(n,e,t)}finally{_n()}}function je(n,e,t,i,r){var o;try{(o=t?n.apply(e,t):n.call(e))&&!o._isVue&&f(o)&&!o._handled&&(o.catch((function(n){return Pe(n,i,r+" (Promise/async)")})),o._handled=!0)}catch(n){Pe(n,i,r)}return o}function Ae(n,e,t){if(M.errorHandler)try{return M.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Ce(e,null,"config.errorHandler")}Ce(n,e,t)}function Ce(n,e,t){if(!J||"undefined"==typeof console)throw n;console.error(n)}var Se,Be=!1,Ie=[],Le=!1;function De(){Le=!1;var n=Ie.slice(0);Ie.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var ze=Promise.resolve();Se=function(){ze.then(De),Z&&setTimeout(L)},Be=!0}else if(Q||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Se="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(De)}:function(){setTimeout(De,0)};else{var Oe=1,Ue=new MutationObserver(De),Ne=document.createTextNode(String(Oe));Ue.observe(Ne,{characterData:!0}),Se=function(){Oe=(Oe+1)%2,Ne.data=String(Oe)},Be=!0}function Re(n,e){var t;if(Ie.push((function(){if(n)try{n.call(e)}catch(n){Pe(n,e,"nextTick")}else t&&t(e)})),Le||(Le=!0,Se()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function qe(n){return function(e,t){if(void 0===t&&(t=un),t)return function(n,e,t){var i=n.$options;i[e]=Pt(i[e],t)}(t,n,e)}}qe("beforeMount"),qe("mounted"),qe("beforeUpdate"),qe("updated"),qe("beforeDestroy"),qe("destroyed"),qe("activated"),qe("deactivated"),qe("serverPrefetch"),qe("renderTracked"),qe("renderTriggered"),qe("errorCaptured");var Fe=new cn;function Me(n){return function n(e,t){var i,o,a=r(e);if(!a&&!d(e)||e.__v_skip||Object.isFrozen(e)||e instanceof mn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(a)for(i=e.length;i--;)n(e[i],t);else if(Rn(e))n(e.value,t);else for(o=Object.keys(e),i=o.length;i--;)n(e[o[i]],t)}(n,Fe),Fe.clear(),n}var Ge,$e=0,Ve=function(){function n(n,e,t,i,r){var o,a;o=this,void 0===(a=Fn&&!Fn._vm?Fn:n?n._scope:void 0)&&(a=Fn),a&&a.active&&a.effects.push(o),(this.vm=n)&&r&&(n._watcher=this),i?(this.deep=!!i.deep,this.user=!!i.user,this.lazy=!!i.lazy,this.sync=!!i.sync,this.before=i.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++$e,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!H.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=L)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;kn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Pe(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Me(n),_n(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():pt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||d(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');je(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&y(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function He(n,e){Ge.$on(n,e)}function Ke(n,e){Ge.$off(n,e)}function Je(n,e){var t=Ge;return function i(){var r=e.apply(null,arguments);null!==r&&t.$off(n,i)}}function We(n,e,t){Ge=n,Hn(e,t||{},He,Ke,Je,n),Ge=void 0}var Qe=null;function Ye(n){var e=Qe;return Qe=n,function(){Qe=e}}function Xe(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Ze(n,e){if(e){if(n._directInactive=!1,Xe(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Ze(n.$children[t]);nt(n,"activated")}}function nt(n,e,t,i){void 0===i&&(i=!0),kn();var r=un,o=Fn;i&&pn(n);var a=n.$options[e],s="".concat(e," hook");if(a)for(var l=0,c=a.length;l<c;l++)je(a[l],n,t||null,n,s);n._hasHookEvent&&n.$emit("hook:"+e),i&&(pn(r),o&&o.on()),_n()}var et=[],tt=[],it={},rt=!1,ot=!1,at=0;var st=0,lt=Date.now;if(J&&!Q){var ct=window.performance;ct&&"function"==typeof ct.now&&lt()>document.createEvent("Event").timeStamp&&(lt=function(){return ct.now()})}var dt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function ut(){var n,e;for(st=lt(),ot=!0,et.sort(dt),at=0;at<et.length;at++)(n=et[at]).before&&n.before(),e=n.id,it[e]=null,n.run();var t=tt.slice(),i=et.slice();at=et.length=tt.length=0,it={},rt=ot=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Ze(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],i=t.vm;i&&i._watcher===t&&i._isMounted&&!i._isDestroyed&&nt(i,"updated")}}(i),function(){for(var n=0;n<bn.length;n++){var e=bn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}bn.length=0}(),sn&&M.devtools&&sn.emit("flush")}function pt(n){var e=n.id;if(null==it[e]&&(n!==xn.target||!n.noRecurse)){if(it[e]=!0,ot){for(var t=et.length-1;t>at&&et[t].id>n.id;)t--;et.splice(t+1,0,n)}else et.push(n);rt||(rt=!0,Re(ut))}}function mt(n,e){if(n){for(var t=Object.create(null),i=dn?Reflect.ownKeys(n):Object.keys(n),r=0;r<i.length;r++){var o=i[r];if("__ob__"!==o){var a=n[o].from;if(a in e._provided)t[o]=e._provided[a];else if("default"in n[o]){var s=n[o].default;t[o]=c(s)?s.call(e):s}else 0}}return t}}function ht(n,e,t,o,a){var l,c=this,d=a.options;_(o,"_uid")?(l=Object.create(o))._original=o:(l=o,o=o._original);var u=s(d._compiled),p=!u;this.data=n,this.props=e,this.children=t,this.parent=o,this.listeners=n.on||i,this.injections=mt(d.inject,o),this.slots=function(){return c.$slots||fe(o,n.scopedSlots,c.$slots=pe(t,o)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return fe(o,n.scopedSlots,this.slots())}}),u&&(this.$options=d,this.$slots=this.slots(),this.$scopedSlots=fe(o,n.scopedSlots,this.$slots)),d._scopeId?this._c=function(n,e,t,i){var a=Te(l,n,e,t,i,p);return a&&!r(a)&&(a.fnScopeId=d._scopeId,a.fnContext=o),a}:this._c=function(n,e,t,i){return Te(l,n,e,t,i,p)}}function ft(n,e,t,i,r){var o=gn(n);return o.fnContext=t,o.fnOptions=i,e.slot&&((o.data||(o.data={})).slot=e.slot),o}function gt(n,e){for(var t in e)n[T(t)]=e[t]}function vt(n){return n.name||n.__name||n._componentTag}ue(ht.prototype);var bt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;bt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},i=n.data.inlineTemplate;a(i)&&(t.render=i.render,t.staticRenderFns=i.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Qe)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,o){var a=r.data.scopedSlots,s=n.$scopedSlots,l=!!(a&&!a.$stable||s!==i&&!s.$stable||a&&n.$scopedSlots.$key!==a.$key||!a&&n.$scopedSlots.$key),c=!!(o||n.$options._renderChildren||l),d=n.$vnode;n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r),n.$options._renderChildren=o;var u=r.data.attrs||i;n._attrsProxy&&xe(n._attrsProxy,u,d.data&&d.data.attrs||i,n,"$attrs")&&(c=!0),n.$attrs=u,t=t||i;var p=n.$options._parentListeners;if(n._listenersProxy&&xe(n._listenersProxy,t,p||i,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,We(n,t,p),e&&n.$options.props){An(!1);for(var m=n._props,h=n.$options._propKeys||[],f=0;f<h.length;f++){var g=h[f],v=n.$options.props;m[g]=Bt(g,v,e,n)}An(!0),n.$options.propsData=e}c&&(n.$slots=pe(o,r.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,i=n.componentInstance;i._isMounted||(i._isMounted=!0,nt(i,"mounted")),n.data.keepAlive&&(t._isMounted?((e=i)._inactive=!1,tt.push(e)):Ze(i,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Xe(e))||e._inactive)){e._inactive=!0;for(var i=0;i<e.$children.length;i++)n(e.$children[i]);nt(e,"deactivated")}}(e,!0):e.$destroy())}},xt=Object.keys(bt);function yt(n,e,t,l,c){if(!o(n)){var u=t.$options._base;if(d(n)&&(n=u.extend(n)),"function"==typeof n){var p;if(o(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&a(n.errorComp))return n.errorComp;if(a(n.resolved))return n.resolved;var t=_e;if(t&&a(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&a(n.loadingComp))return n.loadingComp;if(t&&!a(n.owners)){var i=n.owners=[t],r=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return y(i,t)}));var u=function(n){for(var e=0,t=i.length;e<t;e++)i[e].$forceUpdate();n&&(i.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},p=N((function(t){n.resolved=we(t,e),r?i.length=0:u(!0)})),m=N((function(e){a(n.errorComp)&&(n.error=!0,u(!0))})),h=n(p,m);return d(h)&&(f(h)?o(n.resolved)&&h.then(p,m):f(h.component)&&(h.component.then(p,m),a(h.error)&&(n.errorComp=we(h.error,e)),a(h.loading)&&(n.loadingComp=we(h.loading,e),0===h.delay?n.loading=!0:l=setTimeout((function(){l=null,o(n.resolved)&&o(n.error)&&(n.loading=!0,u(!1))}),h.delay||200)),a(h.timeout)&&(c=setTimeout((function(){c=null,o(n.resolved)&&m(null)}),h.timeout)))),r=!1,n.loading?n.loadingComp:n.resolved}}(p=n,u)))return function(n,e,t,i,r){var o=hn();return o.asyncFactory=n,o.asyncMeta={data:e,context:t,children:i,tag:r},o}(p,e,t,l,c);e=e||{},Vt(n),a(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",i=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var o=e.on||(e.on={}),s=o[i],l=e.model.callback;a(s)?(r(s)?-1===s.indexOf(l):s!==l)&&(o[i]=[l].concat(s)):o[i]=l}(n.options,e);var m=function(n,e,t){var i=e.options.props;if(!o(i)){var r={},s=n.attrs,l=n.props;if(a(s)||a(l))for(var c in i){var d=A(c);Jn(r,l,c,d,!0)||Jn(r,s,c,d,!1)}return r}}(e,n);if(s(n.options.functional))return function(n,e,t,o,s){var l=n.options,c={},d=l.props;if(a(d))for(var u in d)c[u]=Bt(u,d,e||i);else a(t.attrs)&&gt(c,t.attrs),a(t.props)&&gt(c,t.props);var p=new ht(t,c,s,o,n),m=l.render.call(null,p._c,p);if(m instanceof mn)return ft(m,t,p.parent,l,p);if(r(m)){for(var h=Wn(m)||[],f=new Array(h.length),g=0;g<h.length;g++)f[g]=ft(h[g],t,p.parent,l,p);return f}}(n,m,e,t,l);var h=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var g=e.slot;e={},g&&(e.slot=g)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<xt.length;t++){var i=xt[t],r=e[i],o=bt[i];r===o||r&&r._merged||(e[i]=r?kt(o,r):o)}}(e);var v=vt(n.options)||c;return new mn("vue-component-".concat(n.cid).concat(v?"-".concat(v):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:m,listeners:h,tag:c,children:l},p)}}}function kt(n,e){var t=function(t,i){n(t,i),e(t,i)};return t._merged=!0,t}var _t=L,wt=M.optionMergeStrategies;function Et(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var i,r,o,a=dn?Reflect.ownKeys(e):Object.keys(e),s=0;s<a.length;s++)"__ob__"!==(i=a[s])&&(r=n[i],o=e[i],t&&_(n,i)?r!==o&&p(r)&&p(o)&&Et(r,o):Ln(n,i,o));return n}function Tt(n,e,t){return t?function(){var i=c(e)?e.call(t,t):e,r=c(n)?n.call(t,t):n;return i?Et(i,r):r}:e?n?function(){return Et(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function Pt(n,e){var t=e?n?n.concat(e):r(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function jt(n,e,t,i){var r=Object.create(n||null);return e?B(r,e):r}wt.data=function(n,e,t){return t?Tt(n,e,t):e&&"function"!=typeof e?n:Tt(n,e)},F.forEach((function(n){wt[n]=Pt})),q.forEach((function(n){wt[n+"s"]=jt})),wt.watch=function(n,e,t,i){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var o={};for(var a in B(o,n),e){var s=o[a],l=e[a];s&&!r(s)&&(s=[s]),o[a]=s?s.concat(l):r(l)?l:[l]}return o},wt.props=wt.methods=wt.inject=wt.computed=function(n,e,t,i){if(!n)return e;var r=Object.create(null);return B(r,n),e&&B(r,e),r},wt.provide=function(n,e){return n?function(){var t=Object.create(null);return Et(t,c(n)?n.call(this):n),e&&Et(t,c(e)?e.call(this):e,!1),t}:e};var At=function(n,e){return void 0===e?n:e};function Ct(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var i,o,a={};if(r(t))for(i=t.length;i--;)"string"==typeof(o=t[i])&&(a[T(o)]={type:null});else if(p(t))for(var s in t)o=t[s],a[T(s)]=p(o)?o:{type:o};else 0;n.props=a}}(e),function(n,e){var t=n.inject;if(t){var i=n.inject={};if(r(t))for(var o=0;o<t.length;o++)i[t[o]]={from:t[o]};else if(p(t))for(var a in t){var s=t[a];i[a]=p(s)?B({from:a},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var i=e[t];c(i)&&(e[t]={bind:i,update:i})}}(e),!e._base&&(e.extends&&(n=Ct(n,e.extends,t)),e.mixins))for(var i=0,o=e.mixins.length;i<o;i++)n=Ct(n,e.mixins[i],t);var a,s={};for(a in n)l(a);for(a in e)_(n,a)||l(a);function l(i){var r=wt[i]||At;s[i]=r(n[i],e[i],t,i)}return s}function St(n,e,t,i){if("string"==typeof t){var r=n[e];if(_(r,t))return r[t];var o=T(t);if(_(r,o))return r[o];var a=P(o);return _(r,a)?r[a]:r[t]||r[o]||r[a]}}function Bt(n,e,t,i){var r=e[n],o=!_(t,n),a=t[n],s=zt(Boolean,r.type);if(s>-1)if(o&&!_(r,"default"))a=!1;else if(""===a||a===A(n)){var l=zt(String,r.type);(l<0||s<l)&&(a=!0)}if(void 0===a){a=function(n,e,t){if(!_(e,"default"))return;var i=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(i)&&"Function"!==Lt(e.type)?i.call(n):i}(i,r,n);var d=jn;An(!0),Bn(a),An(d)}return a}var It=/^\s*function (\w+)/;function Lt(n){var e=n&&n.toString().match(It);return e?e[1]:""}function Dt(n,e){return Lt(n)===Lt(e)}function zt(n,e){if(!r(e))return Dt(e,n)?0:-1;for(var t=0,i=e.length;t<i;t++)if(Dt(e[t],n))return t;return-1}var Ot={enumerable:!0,configurable:!0,get:L,set:L};function Ut(n,e,t){Ot.get=function(){return this[e][t]},Ot.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Ot)}function Nt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},i=n._props=On({}),r=n.$options._propKeys=[];n.$parent&&An(!1);var o=function(o){r.push(o);var a=Bt(o,e,t,n);In(i,o,a),o in n||Ut(n,"_props",o)};for(var a in e)o(a);An(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var i=n._setupContext=be(n);pn(n),kn();var r=je(t,null,[n._props||On({}),i],n,"setup");if(_n(),pn(),c(r))e.render=r;else if(d(r))if(n._setupState=r,r.__sfc){var o=n._setupProxy={};for(var a in r)"__sfc"!==a&&qn(o,r,a)}else for(var a in r)$(a)||qn(n,r,a);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?L:C(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;p(e=n._data=c(e)?function(n,e){kn();try{return n.call(e,e)}catch(n){return Pe(n,e,"data()"),{}}finally{_n()}}(e,n):e||{})||(e={});var t=Object.keys(e),i=n.$options.props,r=(n.$options.methods,t.length);for(;r--;){var o=t[r];0,i&&_(i,o)||$(o)||Ut(n,"_data",o)}var a=Bn(e);a&&a.vmCount++}(n);else{var t=Bn(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),i=an();for(var r in e){var o=e[r],a=c(o)?o:o.get;0,i||(t[r]=new Ve(n,a||L,L,Rt)),r in n||qt(n,r,o)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var i=e[t];if(r(i))for(var o=0;o<i.length;o++)Gt(n,t,i[o]);else Gt(n,t,i)}}(n,e.watch)}var Rt={lazy:!0};function qt(n,e,t){var i=!an();c(t)?(Ot.get=i?Ft(e):Mt(t),Ot.set=L):(Ot.get=t.get?i&&!1!==t.cache?Ft(e):Mt(t.get):L,Ot.set=t.set||L),Object.defineProperty(n,e,Ot)}function Ft(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),xn.target&&e.depend(),e.value}}function Mt(n){return function(){return n.call(this,this)}}function Gt(n,e,t,i){return p(t)&&(i=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,i)}var $t=0;function Vt(n){var e=n.options;if(n.super){var t=Vt(n.super);if(t!==n.superOptions){n.superOptions=t;var i=function(n){var e,t=n.options,i=n.sealedOptions;for(var r in t)t[r]!==i[r]&&(e||(e={}),e[r]=t[r]);return e}(n);i&&B(n.extendOptions,i),(e=n.options=Ct(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Ht(n){this._init(n)}function Kt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,i=t.cid,r=n._Ctor||(n._Ctor={});if(r[i])return r[i];var o=vt(n)||vt(t.options);var a=function(n){this._init(n)};return(a.prototype=Object.create(t.prototype)).constructor=a,a.cid=e++,a.options=Ct(t.options,n),a.super=t,a.options.props&&function(n){var e=n.options.props;for(var t in e)Ut(n.prototype,"_props",t)}(a),a.options.computed&&function(n){var e=n.options.computed;for(var t in e)qt(n.prototype,t,e[t])}(a),a.extend=t.extend,a.mixin=t.mixin,a.use=t.use,q.forEach((function(n){a[n]=t[n]})),o&&(a.options.components[o]=a),a.superOptions=t.options,a.extendOptions=n,a.sealedOptions=B({},a.options),r[i]=a,a}}function Jt(n){return n&&(vt(n.Ctor.options)||n.tag)}function Wt(n,e){return r(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!m(n)&&n.test(e)}function Qt(n,e){var t=n.cache,i=n.keys,r=n._vnode;for(var o in t){var a=t[o];if(a){var s=a.name;s&&!e(s)&&Yt(t,o,i,r)}}}function Yt(n,e,t,i){var r=n[e];!r||i&&r.tag===i.tag||r.componentInstance.$destroy(),n[e]=null,y(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=$t++,e._isVue=!0,e.__v_skip=!0,e._scope=new Mn(!0),e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),i=e._parentVnode;t.parent=e.parent,t._parentVnode=i;var r=i.componentOptions;t.propsData=r.propsData,t._parentListeners=r.listeners,t._renderChildren=r.children,t._componentTag=r.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Ct(Vt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&We(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=pe(e._renderChildren,r),n.$scopedSlots=t?fe(n.$parent,t.data.scopedSlots,n.$slots):i,n._c=function(e,t,i,r){return Te(n,e,t,i,r,!1)},n.$createElement=function(e,t,i,r){return Te(n,e,t,i,r,!0)};var o=t&&t.data;In(n,"$attrs",o&&o.attrs||i,null,!0),In(n,"$listeners",e._parentListeners||i,null,!0)}(e),nt(e,"beforeCreate",void 0,!1),function(n){var e=mt(n.$options.inject,n);e&&(An(!1),Object.keys(e).forEach((function(t){In(n,t,e[t])})),An(!0))}(e),Nt(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!d(t))return;for(var i=Gn(n),r=dn?Reflect.ownKeys(t):Object.keys(t),o=0;o<r.length;o++){var a=r[o];Object.defineProperty(i,a,Object.getOwnPropertyDescriptor(t,a))}}}(e),nt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Ht),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Ln,n.prototype.$delete=Dn,n.prototype.$watch=function(n,e,t){if(p(e))return Gt(this,n,e,t);(t=t||{}).user=!0;var i=new Ve(this,n,e,t);if(t.immediate){var r='callback for immediate watcher "'.concat(i.expression,'"');kn(),je(e,this,[i.value],this,r),_n()}return function(){i.teardown()}}}(Ht),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var i=this;if(r(n))for(var o=0,a=n.length;o<a;o++)i.$on(n[o],t);else(i._events[n]||(i._events[n]=[])).push(t),e.test(n)&&(i._hasHookEvent=!0);return i},n.prototype.$once=function(n,e){var t=this;function i(){t.$off(n,i),e.apply(t,arguments)}return i.fn=e,t.$on(n,i),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(r(n)){for(var i=0,o=n.length;i<o;i++)t.$off(n[i],e);return t}var a,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((a=s[l])===e||a.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?S(t):t;for(var i=S(arguments,1),r='event handler for "'.concat(n,'"'),o=0,a=t.length;o<a;o++)je(t[o],e,i,e,r)}return e}}(Ht),function(n){n.prototype._update=function(n,e){var t=this,i=t.$el,r=t._vnode,o=Ye(t);t._vnode=n,t.$el=r?t.__patch__(r,n):t.__patch__(t.$el,n,e,!1),o(),i&&(i.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var a=t;a&&a.$vnode&&a.$parent&&a.$vnode===a.$parent._vnode;)a.$parent.$el=a.$el,a=a.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){nt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||y(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),nt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Ht),function(n){ue(n.prototype),n.prototype.$nextTick=function(n){return Re(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,i=t.render,o=t._parentVnode;o&&e._isMounted&&(e.$scopedSlots=fe(e.$parent,o.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&ke(e._slotsProxy,e.$scopedSlots)),e.$vnode=o;try{pn(e),_e=e,n=i.call(e._renderProxy,e.$createElement)}catch(t){Pe(t,e,"render"),n=e._vnode}finally{_e=null,pn()}return r(n)&&1===n.length&&(n=n[0]),n instanceof mn||(n=hn()),n.parent=o,n}}(Ht);var Xt=[String,RegExp,Array],Zt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Xt,exclude:Xt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,i=this.keyToCache;if(t){var r=t.tag,o=t.componentInstance,a=t.componentOptions;n[i]={name:Jt(a),tag:r,componentInstance:o},e.push(i),this.max&&e.length>parseInt(this.max)&&Yt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Yt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Qt(n,(function(n){return Wt(e,n)}))})),this.$watch("exclude",(function(e){Qt(n,(function(n){return!Wt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Ee(n),t=e&&e.componentOptions;if(t){var i=Jt(t),r=this.include,o=this.exclude;if(r&&(!i||!Wt(r,i))||o&&i&&Wt(o,i))return e;var a=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;a[l]?(e.componentInstance=a[l].componentInstance,y(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return M}};Object.defineProperty(n,"config",e),n.util={warn:_t,extend:B,mergeOptions:Ct,defineReactive:In},n.set=Ln,n.delete=Dn,n.nextTick=Re,n.observable=function(n){return Bn(n),n},n.options=Object.create(null),q.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,B(n.options.components,Zt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=S(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Ct(this.options,n),this}}(n),Kt(n),function(n){q.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&p(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Ht),Object.defineProperty(Ht.prototype,"$isServer",{get:an}),Object.defineProperty(Ht.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Ht,"FunctionalRenderContext",{value:ht}),Ht.version="2.7.15";var ni=b("style,class"),ei=b("input,textarea,option,select,progress"),ti=b("contenteditable,draggable,spellcheck"),ii=b("events,caret,typing,plaintext-only"),ri=b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),oi="http://www.w3.org/1999/xlink",ai=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},si=function(n){return ai(n)?n.slice(6,n.length):""},li=function(n){return null==n||!1===n};function ci(n){for(var e=n.data,t=n,i=n;a(i.componentInstance);)(i=i.componentInstance._vnode)&&i.data&&(e=di(i.data,e));for(;a(t=t.parent);)t&&t.data&&(e=di(e,t.data));return function(n,e){if(a(n)||a(e))return ui(n,pi(e));return""}(e.staticClass,e.class)}function di(n,e){return{staticClass:ui(n.staticClass,e.staticClass),class:a(n.class)?[n.class,e.class]:e.class}}function ui(n,e){return n?e?n+" "+e:n:e||""}function pi(n){return Array.isArray(n)?function(n){for(var e,t="",i=0,r=n.length;i<r;i++)a(e=pi(n[i]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):d(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var mi={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},hi=b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),fi=b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),gi=function(n){return hi(n)||fi(n)};var vi=Object.create(null);var bi=b("text,number,password,search,email,tel,url");var xi=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(mi[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),yi={create:function(n,e){ki(e)},update:function(n,e){n.data.ref!==e.data.ref&&(ki(n,!0),ki(e))},destroy:function(n){ki(n,!0)}};function ki(n,e){var t=n.data.ref;if(a(t)){var i=n.context,o=n.componentInstance||n.elm,s=e?null:o,l=e?void 0:o;if(c(t))je(t,i,[s],i,"template ref function");else{var d=n.data.refInFor,u="string"==typeof t||"number"==typeof t,p=Rn(t),m=i.$refs;if(u||p)if(d){var h=u?m[t]:t.value;e?r(h)&&y(h,o):r(h)?h.includes(o)||h.push(o):u?(m[t]=[o],_i(i,t,m[t])):t.value=[o]}else if(u){if(e&&m[t]!==o)return;m[t]=l,_i(i,t,s)}else if(p){if(e&&t.value!==o)return;t.value=s}else 0}}}function _i(n,e,t){var i=n._setupState;i&&_(i,e)&&(Rn(i[e])?i[e].value=t:i[e]=t)}var wi=new mn("",{},[]),Ei=["create","activate","update","remove","destroy"];function Ti(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&a(n.data)===a(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,i=a(t=n.data)&&a(t=t.attrs)&&t.type,r=a(t=e.data)&&a(t=t.attrs)&&t.type;return i===r||bi(i)&&bi(r)}(n,e)||s(n.isAsyncPlaceholder)&&o(e.asyncFactory.error))}function Pi(n,e,t){var i,r,o={};for(i=e;i<=t;++i)a(r=n[i].key)&&(o[r]=i);return o}var ji={create:Ai,update:Ai,destroy:function(n){Ai(n,wi)}};function Ai(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,i,r,o=n===wi,a=e===wi,s=Si(n.data.directives,n.context),l=Si(e.data.directives,e.context),c=[],d=[];for(t in l)i=s[t],r=l[t],i?(r.oldValue=i.value,r.oldArg=i.arg,Ii(r,"update",e,n),r.def&&r.def.componentUpdated&&d.push(r)):(Ii(r,"bind",e,n),r.def&&r.def.inserted&&c.push(r));if(c.length){var u=function(){for(var t=0;t<c.length;t++)Ii(c[t],"inserted",e,n)};o?Kn(e,"insert",u):u()}d.length&&Kn(e,"postpatch",(function(){for(var t=0;t<d.length;t++)Ii(d[t],"componentUpdated",e,n)}));if(!o)for(t in s)l[t]||Ii(s[t],"unbind",n,n,a)}(n,e)}var Ci=Object.create(null);function Si(n,e){var t,i,r=Object.create(null);if(!n)return r;for(t=0;t<n.length;t++){if((i=n[t]).modifiers||(i.modifiers=Ci),r[Bi(i)]=i,e._setupState&&e._setupState.__sfc){var o=i.def||St(e,"_setupState","v-"+i.name);i.def="function"==typeof o?{bind:o,update:o}:o}i.def=i.def||St(e.$options,"directives",i.name)}return r}function Bi(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Ii(n,e,t,i,r){var o=n.def&&n.def[e];if(o)try{o(t.elm,n,t,i,r)}catch(i){Pe(i,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Li=[yi,ji];function Di(n,e){var t=e.componentOptions;if(!(a(t)&&!1===t.Ctor.options.inheritAttrs||o(n.data.attrs)&&o(e.data.attrs))){var i,r,l=e.elm,c=n.data.attrs||{},d=e.data.attrs||{};for(i in(a(d.__ob__)||s(d._v_attr_proxy))&&(d=e.data.attrs=B({},d)),d)r=d[i],c[i]!==r&&zi(l,i,r,e.data.pre);for(i in(Q||X)&&d.value!==c.value&&zi(l,"value",d.value),c)o(d[i])&&(ai(i)?l.removeAttributeNS(oi,si(i)):ti(i)||l.removeAttribute(i))}}function zi(n,e,t,i){i||n.tagName.indexOf("-")>-1?Oi(n,e,t):ri(e)?li(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):ti(e)?n.setAttribute(e,function(n,e){return li(e)||"false"===e?"false":"contenteditable"===n&&ii(e)?e:"true"}(e,t)):ai(e)?li(t)?n.removeAttributeNS(oi,si(e)):n.setAttributeNS(oi,e,t):Oi(n,e,t)}function Oi(n,e,t){if(li(t))n.removeAttribute(e);else{if(Q&&!Y&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var i=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",i)};n.addEventListener("input",i),n.__ieph=!0}n.setAttribute(e,t)}}var Ui={create:Di,update:Di};function Ni(n,e){var t=e.elm,i=e.data,r=n.data;if(!(o(i.staticClass)&&o(i.class)&&(o(r)||o(r.staticClass)&&o(r.class)))){var s=ci(e),l=t._transitionClasses;a(l)&&(s=ui(s,pi(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var Ri,qi={create:Ni,update:Ni};function Fi(n,e,t){var i=Ri;return function r(){var o=e.apply(null,arguments);null!==o&&$i(n,r,t,i)}}var Mi=Be&&!(en&&Number(en[1])<=53);function Gi(n,e,t,i){if(Mi){var r=st,o=e;e=o._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=r||n.timeStamp<=0||n.target.ownerDocument!==document)return o.apply(this,arguments)}}Ri.addEventListener(n,e,rn?{capture:t,passive:i}:t)}function $i(n,e,t,i){(i||Ri).removeEventListener(n,e._wrapper||e,t)}function Vi(n,e){if(!o(n.data.on)||!o(e.data.on)){var t=e.data.on||{},i=n.data.on||{};Ri=e.elm||n.elm,function(n){if(a(n.__r)){var e=Q?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}a(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Hn(t,i,Gi,$i,Fi,e.context),Ri=void 0}}var Hi,Ki={create:Vi,update:Vi,destroy:function(n){return Vi(n,wi)}};function Ji(n,e){if(!o(n.data.domProps)||!o(e.data.domProps)){var t,i,r=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(a(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.domProps=B({},c)),l)t in c||(r[t]="");for(t in c){if(i=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),i===l[t])continue;1===r.childNodes.length&&r.removeChild(r.childNodes[0])}if("value"===t&&"PROGRESS"!==r.tagName){r._value=i;var d=o(i)?"":String(i);Wi(r,d)&&(r.value=d)}else if("innerHTML"===t&&fi(r.tagName)&&o(r.innerHTML)){(Hi=Hi||document.createElement("div")).innerHTML="<svg>".concat(i,"</svg>");for(var u=Hi.firstChild;r.firstChild;)r.removeChild(r.firstChild);for(;u.firstChild;)r.appendChild(u.firstChild)}else if(i!==l[t])try{r[t]=i}catch(n){}}}}function Wi(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,i=n._vModifiers;if(a(i)){if(i.number)return v(t)!==v(e);if(i.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Qi={create:Ji,update:Ji},Yi=w((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var i=n.split(t);i.length>1&&(e[i[0].trim()]=i[1].trim())}})),e}));function Xi(n){var e=Zi(n.style);return n.staticStyle?B(n.staticStyle,e):e}function Zi(n){return Array.isArray(n)?I(n):"string"==typeof n?Yi(n):n}var nr,er=/^--/,tr=/\s*!important$/,ir=function(n,e,t){if(er.test(e))n.style.setProperty(e,t);else if(tr.test(t))n.style.setProperty(A(e),t.replace(tr,""),"important");else{var i=or(e);if(Array.isArray(t))for(var r=0,o=t.length;r<o;r++)n.style[i]=t[r];else n.style[i]=t}},rr=["Webkit","Moz","ms"],or=w((function(n){if(nr=nr||document.createElement("div").style,"filter"!==(n=T(n))&&n in nr)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<rr.length;t++){var i=rr[t]+e;if(i in nr)return i}}));function ar(n,e){var t=e.data,i=n.data;if(!(o(t.staticStyle)&&o(t.style)&&o(i.staticStyle)&&o(i.style))){var r,s,l=e.elm,c=i.staticStyle,d=i.normalizedStyle||i.style||{},u=c||d,p=Zi(e.data.style)||{};e.data.normalizedStyle=a(p.__ob__)?B({},p):p;var m=function(n,e){var t,i={};if(e)for(var r=n;r.componentInstance;)(r=r.componentInstance._vnode)&&r.data&&(t=Xi(r.data))&&B(i,t);(t=Xi(n.data))&&B(i,t);for(var o=n;o=o.parent;)o.data&&(t=Xi(o.data))&&B(i,t);return i}(e,!0);for(s in u)o(m[s])&&ir(l,s,"");for(s in m)(r=m[s])!==u[s]&&ir(l,s,null==r?"":r)}}var sr={create:ar,update:ar},lr=/\s+/;function cr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(lr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function dr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(lr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),i=" "+e+" ";t.indexOf(i)>=0;)t=t.replace(i," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function ur(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&B(e,pr(n.name||"v")),B(e,n),e}return"string"==typeof n?pr(n):void 0}}var pr=w((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),mr=J&&!Y,hr="transition",fr="transitionend",gr="animation",vr="animationend";mr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(hr="WebkitTransition",fr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(gr="WebkitAnimation",vr="webkitAnimationEnd"));var br=J?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function xr(n){br((function(){br(n)}))}function yr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),cr(n,e))}function kr(n,e){n._transitionClasses&&y(n._transitionClasses,e),dr(n,e)}function _r(n,e,t){var i=Er(n,e),r=i.type,o=i.timeout,a=i.propCount;if(!r)return t();var s="transition"===r?fr:vr,l=0,c=function(){n.removeEventListener(s,d),t()},d=function(e){e.target===n&&++l>=a&&c()};setTimeout((function(){l<a&&c()}),o+1),n.addEventListener(s,d)}var wr=/\b(transform|all)(,|$)/;function Er(n,e){var t,i=window.getComputedStyle(n),r=(i[hr+"Delay"]||"").split(", "),o=(i[hr+"Duration"]||"").split(", "),a=Tr(r,o),s=(i[gr+"Delay"]||"").split(", "),l=(i[gr+"Duration"]||"").split(", "),c=Tr(s,l),d=0,u=0;return"transition"===e?a>0&&(t="transition",d=a,u=o.length):"animation"===e?c>0&&(t="animation",d=c,u=l.length):u=(t=(d=Math.max(a,c))>0?a>c?"transition":"animation":null)?"transition"===t?o.length:l.length:0,{type:t,timeout:d,propCount:u,hasTransform:"transition"===t&&wr.test(i[hr+"Property"])}}function Tr(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Pr(e)+Pr(n[t])})))}function Pr(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function jr(n,e){var t=n.elm;a(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var i=ur(n.data.transition);if(!o(i)&&!a(t._enterCb)&&1===t.nodeType){for(var r=i.css,s=i.type,l=i.enterClass,u=i.enterToClass,p=i.enterActiveClass,m=i.appearClass,h=i.appearToClass,f=i.appearActiveClass,g=i.beforeEnter,b=i.enter,x=i.afterEnter,y=i.enterCancelled,k=i.beforeAppear,_=i.appear,w=i.afterAppear,E=i.appearCancelled,T=i.duration,P=Qe,j=Qe.$vnode;j&&j.parent;)P=j.context,j=j.parent;var A=!P._isMounted||!n.isRootInsert;if(!A||_||""===_){var C=A&&m?m:l,S=A&&f?f:p,B=A&&h?h:u,I=A&&k||g,L=A&&c(_)?_:b,D=A&&w||x,z=A&&E||y,O=v(d(T)?T.enter:T);0;var U=!1!==r&&!Y,R=Sr(L),q=t._enterCb=N((function(){U&&(kr(t,B),kr(t,S)),q.cancelled?(U&&kr(t,C),z&&z(t)):D&&D(t),t._enterCb=null}));n.data.show||Kn(n,"insert",(function(){var e=t.parentNode,i=e&&e._pending&&e._pending[n.key];i&&i.tag===n.tag&&i.elm._leaveCb&&i.elm._leaveCb(),L&&L(t,q)})),I&&I(t),U&&(yr(t,C),yr(t,S),xr((function(){kr(t,C),q.cancelled||(yr(t,B),R||(Cr(O)?setTimeout(q,O):_r(t,s,q)))}))),n.data.show&&(e&&e(),L&&L(t,q)),U||R||q()}}}function Ar(n,e){var t=n.elm;a(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var i=ur(n.data.transition);if(o(i)||1!==t.nodeType)return e();if(!a(t._leaveCb)){var r=i.css,s=i.type,l=i.leaveClass,c=i.leaveToClass,u=i.leaveActiveClass,p=i.beforeLeave,m=i.leave,h=i.afterLeave,f=i.leaveCancelled,g=i.delayLeave,b=i.duration,x=!1!==r&&!Y,y=Sr(m),k=v(d(b)?b.leave:b);0;var _=t._leaveCb=N((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),x&&(kr(t,c),kr(t,u)),_.cancelled?(x&&kr(t,l),f&&f(t)):(e(),h&&h(t)),t._leaveCb=null}));g?g(w):w()}function w(){_.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),x&&(yr(t,l),yr(t,u),xr((function(){kr(t,l),_.cancelled||(yr(t,c),y||(Cr(k)?setTimeout(_,k):_r(t,s,_)))}))),m&&m(t,_),x||y||_())}}function Cr(n){return"number"==typeof n&&!isNaN(n)}function Sr(n){if(o(n))return!1;var e=n.fns;return a(e)?Sr(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Br(n,e){!0!==e.data.show&&jr(e)}var Ir=function(n){var e,t,i={},c=n.modules,d=n.nodeOps;for(e=0;e<Ei.length;++e)for(i[Ei[e]]=[],t=0;t<c.length;++t)a(c[t][Ei[e]])&&i[Ei[e]].push(c[t][Ei[e]]);function u(n){var e=d.parentNode(n);a(e)&&d.removeChild(e,n)}function p(n,e,t,r,o,l,c){if(a(n.elm)&&a(l)&&(n=l[c]=gn(n)),n.isRootInsert=!o,!function(n,e,t,r){var o=n.data;if(a(o)){var l=a(n.componentInstance)&&o.keepAlive;if(a(o=o.hook)&&a(o=o.init)&&o(n,!1),a(n.componentInstance))return m(n,e),h(t,n.elm,r),s(l)&&function(n,e,t,r){var o,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,a(o=s.data)&&a(o=o.transition)){for(o=0;o<i.activate.length;++o)i.activate[o](wi,s);e.push(s);break}h(t,n.elm,r)}(n,e,t,r),!0}}(n,e,t,r)){var u=n.data,p=n.children,g=n.tag;a(g)?(n.elm=n.ns?d.createElementNS(n.ns,g):d.createElement(g,n),x(n),f(n,p,e),a(u)&&v(n,e),h(t,n.elm,r)):s(n.isComment)?(n.elm=d.createComment(n.text),h(t,n.elm,r)):(n.elm=d.createTextNode(n.text),h(t,n.elm,r))}}function m(n,e){a(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(v(n,e),x(n)):(ki(n),e.push(n))}function h(n,e,t){a(n)&&(a(t)?d.parentNode(t)===n&&d.insertBefore(n,e,t):d.appendChild(n,e))}function f(n,e,t){if(r(e)){0;for(var i=0;i<e.length;++i)p(e[i],t,n.elm,null,!0,e,i)}else l(n.text)&&d.appendChild(n.elm,d.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return a(n.tag)}function v(n,t){for(var r=0;r<i.create.length;++r)i.create[r](wi,n);a(e=n.data.hook)&&(a(e.create)&&e.create(wi,n),a(e.insert)&&t.push(n))}function x(n){var e;if(a(e=n.fnScopeId))d.setStyleScope(n.elm,e);else for(var t=n;t;)a(e=t.context)&&a(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e),t=t.parent;a(e=Qe)&&e!==n.context&&e!==n.fnContext&&a(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e)}function y(n,e,t,i,r,o){for(;i<=r;++i)p(t[i],o,n,e,!1,t,i)}function k(n){var e,t,r=n.data;if(a(r))for(a(e=r.hook)&&a(e=e.destroy)&&e(n),e=0;e<i.destroy.length;++e)i.destroy[e](n);if(a(e=n.children))for(t=0;t<n.children.length;++t)k(n.children[t])}function _(n,e,t){for(;e<=t;++e){var i=n[e];a(i)&&(a(i.tag)?(w(i),k(i)):u(i.elm))}}function w(n,e){if(a(e)||a(n.data)){var t,r=i.remove.length+1;for(a(e)?e.listeners+=r:e=function(n,e){function t(){0==--t.listeners&&u(n)}return t.listeners=e,t}(n.elm,r),a(t=n.componentInstance)&&a(t=t._vnode)&&a(t.data)&&w(t,e),t=0;t<i.remove.length;++t)i.remove[t](n,e);a(t=n.data.hook)&&a(t=t.remove)?t(n,e):e()}else u(n.elm)}function E(n,e,t,i){for(var r=t;r<i;r++){var o=e[r];if(a(o)&&Ti(n,o))return r}}function T(n,e,t,r,l,c){if(n!==e){a(e.elm)&&a(r)&&(e=r[l]=gn(e));var u=e.elm=n.elm;if(s(n.isAsyncPlaceholder))a(e.asyncFactory.resolved)?A(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;a(h)&&a(m=h.hook)&&a(m=m.prepatch)&&m(n,e);var f=n.children,v=e.children;if(a(h)&&g(e)){for(m=0;m<i.update.length;++m)i.update[m](n,e);a(m=h.hook)&&a(m=m.update)&&m(n,e)}o(e.text)?a(f)&&a(v)?f!==v&&function(n,e,t,i,r){var s,l,c,u=0,m=0,h=e.length-1,f=e[0],g=e[h],v=t.length-1,b=t[0],x=t[v],k=!r;for(0;u<=h&&m<=v;)o(f)?f=e[++u]:o(g)?g=e[--h]:Ti(f,b)?(T(f,b,i,t,m),f=e[++u],b=t[++m]):Ti(g,x)?(T(g,x,i,t,v),g=e[--h],x=t[--v]):Ti(f,x)?(T(f,x,i,t,v),k&&d.insertBefore(n,f.elm,d.nextSibling(g.elm)),f=e[++u],x=t[--v]):Ti(g,b)?(T(g,b,i,t,m),k&&d.insertBefore(n,g.elm,f.elm),g=e[--h],b=t[++m]):(o(s)&&(s=Pi(e,u,h)),o(l=a(b.key)?s[b.key]:E(b,e,u,h))?p(b,i,n,f.elm,!1,t,m):Ti(c=e[l],b)?(T(c,b,i,t,m),e[l]=void 0,k&&d.insertBefore(n,c.elm,f.elm)):p(b,i,n,f.elm,!1,t,m),b=t[++m]);u>h?y(n,o(t[v+1])?null:t[v+1].elm,t,m,v,i):m>v&&_(e,u,h)}(u,f,v,t,c):a(v)?(a(n.text)&&d.setTextContent(u,""),y(u,null,v,0,v.length-1,t)):a(f)?_(f,0,f.length-1):a(n.text)&&d.setTextContent(u,""):n.text!==e.text&&d.setTextContent(u,e.text),a(h)&&a(m=h.hook)&&a(m=m.postpatch)&&m(n,e)}}}function P(n,e,t){if(s(t)&&a(n.parent))n.parent.data.pendingInsert=e;else for(var i=0;i<e.length;++i)e[i].data.hook.insert(e[i])}var j=b("attrs,class,staticClass,staticStyle,key");function A(n,e,t,i){var r,o=e.tag,l=e.data,c=e.children;if(i=i||l&&l.pre,e.elm=n,s(e.isComment)&&a(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(a(l)&&(a(r=l.hook)&&a(r=r.init)&&r(e,!0),a(r=e.componentInstance)))return m(e,t),!0;if(a(o)){if(a(c))if(n.hasChildNodes())if(a(r=l)&&a(r=r.domProps)&&a(r=r.innerHTML)){if(r!==n.innerHTML)return!1}else{for(var d=!0,u=n.firstChild,p=0;p<c.length;p++){if(!u||!A(u,c[p],t,i)){d=!1;break}u=u.nextSibling}if(!d||u)return!1}else f(e,c,t);if(a(l)){var h=!1;for(var g in l)if(!j(g)){h=!0,v(e,t);break}!h&&l.class&&Me(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,r){if(!o(e)){var l,c=!1,u=[];if(o(n))c=!0,p(e,u);else{var m=a(n.nodeType);if(!m&&Ti(n,e))T(n,e,u,null,null,r);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&A(n,e,u))return P(e,u,!0),n;l=n,n=new mn(d.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,f=d.parentNode(h);if(p(e,u,h._leaveCb?null:f,d.nextSibling(h)),a(e.parent))for(var v=e.parent,b=g(e);v;){for(var x=0;x<i.destroy.length;++x)i.destroy[x](v);if(v.elm=e.elm,b){for(var y=0;y<i.create.length;++y)i.create[y](wi,v);var w=v.data.hook.insert;if(w.merged)for(var E=w.fns.slice(1),j=0;j<E.length;j++)E[j]()}else ki(v);v=v.parent}a(f)?_([n],0,0):a(n.tag)&&k(n)}}return P(e,u,c),e.elm}a(n)&&k(n)}}({nodeOps:xi,modules:[Ui,qi,Ki,Qi,sr,J?{create:Br,activate:Br,remove:function(n,e){!0!==n.data.show?Ar(n,e):e()}}:{}].concat(Li)});Y&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&qr(n,"input")}));var Lr={inserted:function(n,e,t,i){"select"===t.tag?(i.elm&&!i.elm._vOptions?Kn(t,"postpatch",(function(){Lr.componentUpdated(n,e,t)})):Dr(n,e,t.context),n._vOptions=[].map.call(n.options,Ur)):("textarea"===t.tag||bi(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Nr),n.addEventListener("compositionend",Rr),n.addEventListener("change",Rr),Y&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Dr(n,e,t.context);var i=n._vOptions,r=n._vOptions=[].map.call(n.options,Ur);if(r.some((function(n,e){return!O(n,i[e])})))(n.multiple?e.value.some((function(n){return Or(n,r)})):e.value!==e.oldValue&&Or(e.value,r))&&qr(n,"change")}}};function Dr(n,e,t){zr(n,e,t),(Q||X)&&setTimeout((function(){zr(n,e,t)}),0)}function zr(n,e,t){var i=e.value,r=n.multiple;if(!r||Array.isArray(i)){for(var o,a,s=0,l=n.options.length;s<l;s++)if(a=n.options[s],r)o=U(i,Ur(a))>-1,a.selected!==o&&(a.selected=o);else if(O(Ur(a),i))return void(n.selectedIndex!==s&&(n.selectedIndex=s));r||(n.selectedIndex=-1)}}function Or(n,e){return e.every((function(e){return!O(e,n)}))}function Ur(n){return"_value"in n?n._value:n.value}function Nr(n){n.target.composing=!0}function Rr(n){n.target.composing&&(n.target.composing=!1,qr(n.target,"input"))}function qr(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Fr(n){return!n.componentInstance||n.data&&n.data.transition?n:Fr(n.componentInstance._vnode)}var Mr={model:Lr,show:{bind:function(n,e,t){var i=e.value,r=(t=Fr(t)).data&&t.data.transition,o=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;i&&r?(t.data.show=!0,jr(t,(function(){n.style.display=o}))):n.style.display=i?o:"none"},update:function(n,e,t){var i=e.value;!i!=!e.oldValue&&((t=Fr(t)).data&&t.data.transition?(t.data.show=!0,i?jr(t,(function(){n.style.display=n.__vOriginalDisplay})):Ar(t,(function(){n.style.display="none"}))):n.style.display=i?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,i,r){r||(n.style.display=n.__vOriginalDisplay)}}},Gr={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function $r(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?$r(Ee(e.children)):n}function Vr(n){var e={},t=n.$options;for(var i in t.propsData)e[i]=n[i];var r=t._parentListeners;for(var i in r)e[T(i)]=r[i];return e}function Hr(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Kr=function(n){return n.tag||he(n)},Jr=function(n){return"show"===n.name},Wr={name:"transition",props:Gr,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Kr)).length){0;var i=this.mode;0;var r=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return r;var o=$r(r);if(!o)return r;if(this._leaving)return Hr(n,r);var a="__transition-".concat(this._uid,"-");o.key=null==o.key?o.isComment?a+"comment":a+o.tag:l(o.key)?0===String(o.key).indexOf(a)?o.key:a+o.key:o.key;var s=(o.data||(o.data={})).transition=Vr(this),c=this._vnode,d=$r(c);if(o.data.directives&&o.data.directives.some(Jr)&&(o.data.show=!0),d&&d.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(o,d)&&!he(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var u=d.data.transition=B({},s);if("out-in"===i)return this._leaving=!0,Kn(u,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Hr(n,r);if("in-out"===i){if(he(o))return c;var p,m=function(){p()};Kn(s,"afterEnter",m),Kn(s,"enterCancelled",m),Kn(u,"delayLeave",(function(n){p=n}))}}return r}}},Qr=B({tag:String,moveClass:String},Gr);function Yr(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Xr(n){n.data.newPos=n.elm.getBoundingClientRect()}function Zr(n){var e=n.data.pos,t=n.data.newPos,i=e.left-t.left,r=e.top-t.top;if(i||r){n.data.moved=!0;var o=n.elm.style;o.transform=o.WebkitTransform="translate(".concat(i,"px,").concat(r,"px)"),o.transitionDuration="0s"}}delete Qr.mode;var no={Transition:Wr,TransitionGroup:{props:Qr,beforeMount:function(){var n=this,e=this._update;this._update=function(t,i){var r=Ye(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,r(),e.call(n,t,i)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),i=this.prevChildren=this.children,r=this.$slots.default||[],o=this.children=[],a=Vr(this),s=0;s<r.length;s++){if((d=r[s]).tag)if(null!=d.key&&0!==String(d.key).indexOf("__vlist"))o.push(d),t[d.key]=d,(d.data||(d.data={})).transition=a;else;}if(i){var l=[],c=[];for(s=0;s<i.length;s++){var d;(d=i[s]).data.transition=a,d.data.pos=d.elm.getBoundingClientRect(),t[d.key]?l.push(d):c.push(d)}this.kept=n(e,null,l),this.removed=c}return n(e,null,o)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Yr),n.forEach(Xr),n.forEach(Zr),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,i=t.style;yr(t,e),i.transform=i.WebkitTransform=i.transitionDuration="",t.addEventListener(fr,t._moveCb=function n(i){i&&i.target!==t||i&&!/transform$/.test(i.propertyName)||(t.removeEventListener(fr,n),t._moveCb=null,kr(t,e))})}})))},methods:{hasMove:function(n,e){if(!mr)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){dr(t,n)})),cr(t,e),t.style.display="none",this.$el.appendChild(t);var i=Er(t);return this.$el.removeChild(t),this._hasMove=i.hasTransform}}}};function eo(n,e){for(var t in e)n[t]=e[t];return n}Ht.config.mustUseProp=function(n,e,t){return"value"===t&&ei(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Ht.config.isReservedTag=gi,Ht.config.isReservedAttr=ni,Ht.config.getTagNamespace=function(n){return fi(n)?"svg":"math"===n?"math":void 0},Ht.config.isUnknownElement=function(n){if(!J)return!0;if(gi(n))return!1;if(n=n.toLowerCase(),null!=vi[n])return vi[n];var e=document.createElement(n);return n.indexOf("-")>-1?vi[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:vi[n]=/HTMLUnknownElement/.test(e.toString())},B(Ht.options.directives,Mr),B(Ht.options.components,no),Ht.prototype.__patch__=J?Ir:L,Ht.prototype.$mount=function(n,e){return function(n,e,t){var i;n.$el=e,n.$options.render||(n.$options.render=hn),nt(n,"beforeMount"),i=function(){n._update(n._render(),t)},new Ve(n,i,L,{before:function(){n._isMounted&&!n._isDestroyed&&nt(n,"beforeUpdate")}},!0),t=!1;var r=n._preWatchers;if(r)for(var o=0;o<r.length;o++)r[o].run();return null==n.$vnode&&(n._isMounted=!0,nt(n,"mounted")),n}(this,n=n&&J?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},J&&setTimeout((function(){M.devtools&&sn&&sn.emit("init",Ht)}),0);var to=/[!'()*]/g,io=function(n){return"%"+n.charCodeAt(0).toString(16)},ro=/%2C/g,oo=function(n){return encodeURIComponent(n).replace(to,io).replace(ro,",")};function ao(n){try{return decodeURIComponent(n)}catch(n){0}return n}var so=function(n){return null==n||"object"==typeof n?n:String(n)};function lo(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),i=ao(t.shift()),r=t.length>0?ao(t.join("=")):null;void 0===e[i]?e[i]=r:Array.isArray(e[i])?e[i].push(r):e[i]=[e[i],r]})),e):e}function co(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return oo(e);if(Array.isArray(t)){var i=[];return t.forEach((function(n){void 0!==n&&(null===n?i.push(oo(e)):i.push(oo(e)+"="+oo(n)))})),i.join("&")}return oo(e)+"="+oo(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var uo=/\/?$/;function po(n,e,t,i){var r=i&&i.options.stringifyQuery,o=e.query||{};try{o=mo(o)}catch(n){}var a={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:o,params:e.params||{},fullPath:go(e,r),matched:n?fo(n):[]};return t&&(a.redirectedFrom=go(t,r)),Object.freeze(a)}function mo(n){if(Array.isArray(n))return n.map(mo);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=mo(n[t]);return e}return n}var ho=po(null,{path:"/"});function fo(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function go(n,e){var t=n.path,i=n.query;void 0===i&&(i={});var r=n.hash;return void 0===r&&(r=""),(t||"/")+(e||co)(i)+r}function vo(n,e,t){return e===ho?n===e:!!e&&(n.path&&e.path?n.path.replace(uo,"")===e.path.replace(uo,"")&&(t||n.hash===e.hash&&bo(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&bo(n.query,e.query)&&bo(n.params,e.params))))}function bo(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),i=Object.keys(e).sort();return t.length===i.length&&t.every((function(t,r){var o=n[t];if(i[r]!==t)return!1;var a=e[t];return null==o||null==a?o===a:"object"==typeof o&&"object"==typeof a?bo(o,a):String(o)===String(a)}))}function xo(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var i in t.instances){var r=t.instances[i],o=t.enteredCbs[i];if(r&&o){delete t.enteredCbs[i];for(var a=0;a<o.length;a++)r._isBeingDestroyed||o[a](r)}}}}var yo={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,i=e.children,r=e.parent,o=e.data;o.routerView=!0;for(var a=r.$createElement,s=t.name,l=r.$route,c=r._routerViewCache||(r._routerViewCache={}),d=0,u=!1;r&&r._routerRoot!==r;){var p=r.$vnode?r.$vnode.data:{};p.routerView&&d++,p.keepAlive&&r._directInactive&&r._inactive&&(u=!0),r=r.$parent}if(o.routerViewDepth=d,u){var m=c[s],h=m&&m.component;return h?(m.configProps&&ko(h,o,m.route,m.configProps),a(h,o,i)):a()}var f=l.matched[d],g=f&&f.components[s];if(!f||!g)return c[s]=null,a();c[s]={component:g},o.registerRouteInstance=function(n,e){var t=f.instances[s];(e&&t!==n||!e&&t===n)&&(f.instances[s]=e)},(o.hook||(o.hook={})).prepatch=function(n,e){f.instances[s]=e.componentInstance},o.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==f.instances[s]&&(f.instances[s]=n.componentInstance),xo(l)};var v=f.props&&f.props[s];return v&&(eo(c[s],{route:l,configProps:v}),ko(g,o,l,v)),a(g,o,i)}};function ko(n,e,t,i){var r=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,i);if(r){r=e.props=eo({},r);var o=e.attrs=e.attrs||{};for(var a in r)n.props&&a in n.props||(o[a]=r[a],delete r[a])}}function _o(n,e,t){var i=n.charAt(0);if("/"===i)return n;if("?"===i||"#"===i)return e+n;var r=e.split("/");t&&r[r.length-1]||r.pop();for(var o=n.replace(/^\//,"").split("/"),a=0;a<o.length;a++){var s=o[a];".."===s?r.pop():"."!==s&&r.push(s)}return""!==r[0]&&r.unshift(""),r.join("/")}function wo(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var Eo=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},To=Ro,Po=Bo,jo=function(n,e){return Lo(Bo(n,e),e)},Ao=Lo,Co=No,So=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Bo(n,e){for(var t,i=[],r=0,o=0,a="",s=e&&e.delimiter||"/";null!=(t=So.exec(n));){var l=t[0],c=t[1],d=t.index;if(a+=n.slice(o,d),o=d+l.length,c)a+=c[1];else{var u=n[o],p=t[2],m=t[3],h=t[4],f=t[5],g=t[6],v=t[7];a&&(i.push(a),a="");var b=null!=p&&null!=u&&u!==p,x="+"===g||"*"===g,y="?"===g||"*"===g,k=t[2]||s,_=h||f;i.push({name:m||r++,prefix:p||"",delimiter:k,optional:y,repeat:x,partial:b,asterisk:!!v,pattern:_?zo(_):v?".*":"[^"+Do(k)+"]+?"})}}return o<n.length&&(a+=n.substr(o)),a&&i.push(a),i}function Io(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function Lo(n,e){for(var t=new Array(n.length),i=0;i<n.length;i++)"object"==typeof n[i]&&(t[i]=new RegExp("^(?:"+n[i].pattern+")$",Uo(e)));return function(e,i){for(var r="",o=e||{},a=(i||{}).pretty?Io:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,d=o[l.name];if(null==d){if(l.optional){l.partial&&(r+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(Eo(d)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var u=0;u<d.length;u++){if(c=a(d[u]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");r+=(0===u?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(d).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):a(d),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');r+=l.prefix+c}}else r+=l}return r}}function Do(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function zo(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function Oo(n,e){return n.keys=e,n}function Uo(n){return n&&n.sensitive?"":"i"}function No(n,e,t){Eo(e)||(t=e||t,e=[]);for(var i=(t=t||{}).strict,r=!1!==t.end,o="",a=0;a<n.length;a++){var s=n[a];if("string"==typeof s)o+=Do(s);else{var l=Do(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),o+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var d=Do(t.delimiter||"/"),u=o.slice(-d.length)===d;return i||(o=(u?o.slice(0,-d.length):o)+"(?:"+d+"(?=$))?"),o+=r?"$":i&&u?"":"(?="+d+"|$)",Oo(new RegExp("^"+o,Uo(t)),e)}function Ro(n,e,t){return Eo(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var i=0;i<t.length;i++)e.push({name:i,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Oo(n,e)}(n,e):Eo(n)?function(n,e,t){for(var i=[],r=0;r<n.length;r++)i.push(Ro(n[r],e,t).source);return Oo(new RegExp("(?:"+i.join("|")+")",Uo(t)),e)}(n,e,t):function(n,e,t){return No(Bo(n,t),e,t)}(n,e,t)}To.parse=Po,To.compile=jo,To.tokensToFunction=Ao,To.tokensToRegExp=Co;var qo=Object.create(null);function Fo(n,e,t){e=e||{};try{var i=qo[n]||(qo[n]=To.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),i(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Mo(n,e,t,i){var r="string"==typeof n?{path:n}:n;if(r._normalized)return r;if(r.name){var o=(r=eo({},n)).params;return o&&"object"==typeof o&&(r.params=eo({},o)),r}if(!r.path&&r.params&&e){(r=eo({},r))._normalized=!0;var a=eo(eo({},e.params),r.params);if(e.name)r.name=e.name,r.params=a;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;r.path=Fo(s,a,e.path)}else 0;return r}var l=function(n){var e="",t="",i=n.indexOf("#");i>=0&&(e=n.slice(i),n=n.slice(0,i));var r=n.indexOf("?");return r>=0&&(t=n.slice(r+1),n=n.slice(0,r)),{path:n,query:t,hash:e}}(r.path||""),c=e&&e.path||"/",d=l.path?_o(l.path,c,t||r.append):c,u=function(n,e,t){void 0===e&&(e={});var i,r=t||lo;try{i=r(n||"")}catch(n){i={}}for(var o in e){var a=e[o];i[o]=Array.isArray(a)?a.map(so):so(a)}return i}(l.query,r.query,i&&i.options.parseQuery),p=r.hash||l.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:d,query:u,hash:p}}var Go,$o=function(){},Vo={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,i=this.$route,r=t.resolve(this.to,i,this.append),o=r.location,a=r.route,s=r.href,l={},c=t.options.linkActiveClass,d=t.options.linkExactActiveClass,u=null==c?"router-link-active":c,p=null==d?"router-link-exact-active":d,m=null==this.activeClass?u:this.activeClass,h=null==this.exactActiveClass?p:this.exactActiveClass,f=a.redirectedFrom?po(null,Mo(a.redirectedFrom),null,t):a;l[h]=vo(i,f,this.exactPath),l[m]=this.exact||this.exactPath?l[h]:function(n,e){return 0===n.path.replace(uo,"/").indexOf(e.path.replace(uo,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(i,f);var g=l[h]?this.ariaCurrentValue:null,v=function(n){Ho(n)&&(e.replace?t.replace(o,$o):t.push(o,$o))},b={click:Ho};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=v})):b[this.event]=v;var x={class:l},y=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:a,navigate:v,isActive:l[m],isExactActive:l[h]});if(y){if(1===y.length)return y[0];if(y.length>1||!y.length)return 0===y.length?n():n("span",{},y)}if("a"===this.tag)x.on=b,x.attrs={href:s,"aria-current":g};else{var k=function n(e){var t;if(e)for(var i=0;i<e.length;i++){if("a"===(t=e[i]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(k){k.isStatic=!1;var _=k.data=eo({},k.data);for(var w in _.on=_.on||{},_.on){var E=_.on[w];w in b&&(_.on[w]=Array.isArray(E)?E:[E])}for(var T in b)T in _.on?_.on[T].push(b[T]):_.on[T]=v;var P=k.data.attrs=eo({},k.data.attrs);P.href=s,P["aria-current"]=g}else x.on=b}return n(this.tag,x,this.$slots.default)}};function Ho(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Ko="undefined"!=typeof window;function Jo(n,e,t,i,r){var o=e||[],a=t||Object.create(null),s=i||Object.create(null);n.forEach((function(n){!function n(e,t,i,r,o,a){var s=r.path,l=r.name;0;var c=r.pathToRegexpOptions||{},d=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return wo(e.path+"/"+n)}(s,o,c.strict);"boolean"==typeof r.caseSensitive&&(c.sensitive=r.caseSensitive);var u={path:d,regex:Wo(d,c),components:r.components||{default:r.component},alias:r.alias?"string"==typeof r.alias?[r.alias]:r.alias:[],instances:{},enteredCbs:{},name:l,parent:o,matchAs:a,redirect:r.redirect,beforeEnter:r.beforeEnter,meta:r.meta||{},props:null==r.props?{}:r.components?r.props:{default:r.props}};r.children&&r.children.forEach((function(r){var o=a?wo(a+"/"+r.path):void 0;n(e,t,i,r,u,o)}));t[u.path]||(e.push(u.path),t[u.path]=u);if(void 0!==r.alias)for(var p=Array.isArray(r.alias)?r.alias:[r.alias],m=0;m<p.length;++m){0;var h={path:p[m],children:r.children};n(e,t,i,h,o,u.path||"/")}l&&(i[l]||(i[l]=u))}(o,a,s,n,r)}));for(var l=0,c=o.length;l<c;l++)"*"===o[l]&&(o.push(o.splice(l,1)[0]),c--,l--);return{pathList:o,pathMap:a,nameMap:s}}function Wo(n,e){return To(n,[],e)}function Qo(n,e){var t=Jo(n),i=t.pathList,r=t.pathMap,o=t.nameMap;function a(n,t,a){var s=Mo(n,t,!1,e),c=s.name;if(c){var d=o[c];if(!d)return l(null,s);var u=d.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in s.params)&&u.indexOf(p)>-1&&(s.params[p]=t.params[p]);return s.path=Fo(d.path,s.params),l(d,s,a)}if(s.path){s.params={};for(var m=0;m<i.length;m++){var h=i[m],f=r[h];if(Yo(f.regex,s.path,s.params))return l(f,s,a)}}return l(null,s)}function s(n,t){var i=n.redirect,r="function"==typeof i?i(po(n,t,null,e)):i;if("string"==typeof r&&(r={path:r}),!r||"object"!=typeof r)return l(null,t);var s=r,c=s.name,d=s.path,u=t.query,p=t.hash,m=t.params;if(u=s.hasOwnProperty("query")?s.query:u,p=s.hasOwnProperty("hash")?s.hash:p,m=s.hasOwnProperty("params")?s.params:m,c){o[c];return a({_normalized:!0,name:c,query:u,hash:p,params:m},void 0,t)}if(d){var h=function(n,e){return _o(n,e.parent?e.parent.path:"/",!0)}(d,n);return a({_normalized:!0,path:Fo(h,m),query:u,hash:p},void 0,t)}return l(null,t)}function l(n,t,i){return n&&n.redirect?s(n,i||t):n&&n.matchAs?function(n,e,t){var i=a({_normalized:!0,path:Fo(t,e.params)});if(i){var r=i.matched,o=r[r.length-1];return e.params=i.params,l(o,e)}return l(null,e)}(0,t,n.matchAs):po(n,t,i,e)}return{match:a,addRoute:function(n,e){var t="object"!=typeof n?o[n]:void 0;Jo([e||n],i,r,o,t),t&&t.alias.length&&Jo(t.alias.map((function(n){return{path:n,children:[e]}})),i,r,o,t)},getRoutes:function(){return i.map((function(n){return r[n]}))},addRoutes:function(n){Jo(n,i,r,o)}}}function Yo(n,e,t){var i=e.match(n);if(!i)return!1;if(!t)return!0;for(var r=1,o=i.length;r<o;++r){var a=n.keys[r-1];a&&(t[a.name||"pathMatch"]="string"==typeof i[r]?ao(i[r]):i[r])}return!0}var Xo=Ko&&window.performance&&window.performance.now?window.performance:Date;function Zo(){return Xo.now().toFixed(3)}var na=Zo();function ea(){return na}function ta(n){return na=n}var ia=Object.create(null);function ra(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=eo({},window.history.state);return t.key=ea(),window.history.replaceState(t,"",e),window.addEventListener("popstate",sa),function(){window.removeEventListener("popstate",sa)}}function oa(n,e,t,i){if(n.app){var r=n.options.scrollBehavior;r&&n.app.$nextTick((function(){var o=function(){var n=ea();if(n)return ia[n]}(),a=r.call(n,e,t,i?o:null);a&&("function"==typeof a.then?a.then((function(n){pa(n,o)})).catch((function(n){0})):pa(a,o))}))}}function aa(){var n=ea();n&&(ia[n]={x:window.pageXOffset,y:window.pageYOffset})}function sa(n){aa(),n.state&&n.state.key&&ta(n.state.key)}function la(n){return da(n.x)||da(n.y)}function ca(n){return{x:da(n.x)?n.x:window.pageXOffset,y:da(n.y)?n.y:window.pageYOffset}}function da(n){return"number"==typeof n}var ua=/^#\d/;function pa(n,e){var t,i="object"==typeof n;if(i&&"string"==typeof n.selector){var r=ua.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(r){var o=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),i=n.getBoundingClientRect();return{x:i.left-t.left-e.x,y:i.top-t.top-e.y}}(r,o={x:da((t=o).x)?t.x:0,y:da(t.y)?t.y:0})}else la(n)&&(e=ca(n))}else i&&la(n)&&(e=ca(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var ma,ha=Ko&&((-1===(ma=window.navigator.userAgent).indexOf("Android 2.")&&-1===ma.indexOf("Android 4.0")||-1===ma.indexOf("Mobile Safari")||-1!==ma.indexOf("Chrome")||-1!==ma.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function fa(n,e){aa();var t=window.history;try{if(e){var i=eo({},t.state);i.key=ea(),t.replaceState(i,"",n)}else t.pushState({key:ta(Zo())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function ga(n){fa(n,!0)}var va={redirected:2,aborted:4,cancelled:8,duplicated:16};function ba(n,e){return ya(n,e,va.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return ka.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function xa(n,e){return ya(n,e,va.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function ya(n,e,t,i){var r=new Error(i);return r._isRouter=!0,r.from=n,r.to=e,r.type=t,r}var ka=["params","query","hash"];function _a(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function wa(n,e){return _a(n)&&n._isRouter&&(null==e||n.type===e)}function Ea(n,e,t){var i=function(r){r>=n.length?t():n[r]?e(n[r],(function(){i(r+1)})):i(r+1)};i(0)}function Ta(n){return function(e,t,i){var r=!1,o=0,a=null;Pa(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){r=!0,o++;var l,c=Ca((function(e){var r;((r=e).__esModule||Aa&&"Module"===r[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Go.extend(e),t.components[s]=e,--o<=0&&i()})),d=Ca((function(n){var e="Failed to resolve async component "+s+": "+n;a||(a=_a(n)?n:new Error(e),i(a))}));try{l=n(c,d)}catch(n){d(n)}if(l)if("function"==typeof l.then)l.then(c,d);else{var u=l.component;u&&"function"==typeof u.then&&u.then(c,d)}}})),r||i()}}function Pa(n,e){return ja(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function ja(n){return Array.prototype.concat.apply([],n)}var Aa="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Ca(n){var e=!1;return function(){for(var t=[],i=arguments.length;i--;)t[i]=arguments[i];if(!e)return e=!0,n.apply(this,t)}}var Sa=function(n,e){this.router=n,this.base=function(n){if(!n)if(Ko){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=ho,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Ba(n,e,t,i){var r=Pa(n,(function(n,i,r,o){var a=function(n,e){"function"!=typeof n&&(n=Go.extend(n));return n.options[e]}(n,e);if(a)return Array.isArray(a)?a.map((function(n){return t(n,i,r,o)})):t(a,i,r,o)}));return ja(i?r.reverse():r)}function Ia(n,e){if(e)return function(){return n.apply(e,arguments)}}Sa.prototype.listen=function(n){this.cb=n},Sa.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Sa.prototype.onError=function(n){this.errorCbs.push(n)},Sa.prototype.transitionTo=function(n,e,t){var i,r=this;try{i=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var o=this.current;this.confirmTransition(i,(function(){r.updateRoute(i),e&&e(i),r.ensureURL(),r.router.afterHooks.forEach((function(n){n&&n(i,o)})),r.ready||(r.ready=!0,r.readyCbs.forEach((function(n){n(i)})))}),(function(n){t&&t(n),n&&!r.ready&&(wa(n,va.redirected)&&o===ho||(r.ready=!0,r.readyErrorCbs.forEach((function(e){e(n)}))))}))},Sa.prototype.confirmTransition=function(n,e,t){var i=this,r=this.current;this.pending=n;var o,a,s=function(n){!wa(n)&&_a(n)&&(i.errorCbs.length?i.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=r.matched.length-1;if(vo(n,r)&&l===c&&n.matched[l]===r.matched[c])return this.ensureURL(),n.hash&&oa(this.router,r,n,!1),s(((a=ya(o=r,n,va.duplicated,'Avoided redundant navigation to current location: "'+o.fullPath+'".')).name="NavigationDuplicated",a));var d=function(n,e){var t,i=Math.max(n.length,e.length);for(t=0;t<i&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),u=d.updated,p=d.deactivated,m=d.activated,h=[].concat(function(n){return Ba(n,"beforeRouteLeave",Ia,!0)}(p),this.router.beforeHooks,function(n){return Ba(n,"beforeRouteUpdate",Ia)}(u),m.map((function(n){return n.beforeEnter})),Ta(m)),f=function(e,t){if(i.pending!==n)return s(xa(r,n));try{e(n,r,(function(e){!1===e?(i.ensureURL(!0),s(function(n,e){return ya(n,e,va.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(r,n))):_a(e)?(i.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(ba(r,n)),"object"==typeof e&&e.replace?i.replace(e):i.push(e)):t(e)}))}catch(n){s(n)}};Ea(h,f,(function(){Ea(function(n){return Ba(n,"beforeRouteEnter",(function(n,e,t,i){return function(n,e,t){return function(i,r,o){return n(i,r,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),o(n)}))}}(n,t,i)}))}(m).concat(i.router.resolveHooks),f,(function(){if(i.pending!==n)return s(xa(r,n));i.pending=null,e(n),i.router.app&&i.router.app.$nextTick((function(){xo(n)}))}))}))},Sa.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Sa.prototype.setupListeners=function(){},Sa.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=ho,this.pending=null};var La=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Da(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,i=ha&&t;i&&this.listeners.push(ra());var r=function(){var t=n.current,r=Da(n.base);n.current===ho&&r===n._startLocation||n.transitionTo(r,(function(n){i&&oa(e,n,t,!0)}))};window.addEventListener("popstate",r),this.listeners.push((function(){window.removeEventListener("popstate",r)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var i=this,r=this.current;this.transitionTo(n,(function(n){fa(wo(i.base+n.fullPath)),oa(i.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var i=this,r=this.current;this.transitionTo(n,(function(n){ga(wo(i.base+n.fullPath)),oa(i.router,n,r,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Da(this.base)!==this.current.fullPath){var e=wo(this.base+this.current.fullPath);n?fa(e):ga(e)}},e.prototype.getCurrentLocation=function(){return Da(this.base)},e}(Sa);function Da(n){var e=window.location.pathname,t=e.toLowerCase(),i=n.toLowerCase();return!n||t!==i&&0!==t.indexOf(wo(i+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var za=function(n){function e(e,t,i){n.call(this,e,t),i&&function(n){var e=Da(n);if(!/^\/#/.test(e))return window.location.replace(wo(n+"/#"+e)),!0}(this.base)||Oa()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=ha&&e;t&&this.listeners.push(ra());var i=function(){var e=n.current;Oa()&&n.transitionTo(Ua(),(function(i){t&&oa(n.router,i,e,!0),ha||qa(i.fullPath)}))},r=ha?"popstate":"hashchange";window.addEventListener(r,i),this.listeners.push((function(){window.removeEventListener(r,i)}))}},e.prototype.push=function(n,e,t){var i=this,r=this.current;this.transitionTo(n,(function(n){Ra(n.fullPath),oa(i.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var i=this,r=this.current;this.transitionTo(n,(function(n){qa(n.fullPath),oa(i.router,n,r,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Ua()!==e&&(n?Ra(e):qa(e))},e.prototype.getCurrentLocation=function(){return Ua()},e}(Sa);function Oa(){var n=Ua();return"/"===n.charAt(0)||(qa("/"+n),!1)}function Ua(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Na(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Ra(n){ha?fa(Na(n)):window.location.hash=n}function qa(n){ha?ga(Na(n)):window.location.replace(Na(n))}var Fa=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var i=this;this.transitionTo(n,(function(n){i.stack=i.stack.slice(0,i.index+1).concat(n),i.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var i=this;this.transitionTo(n,(function(n){i.stack=i.stack.slice(0,i.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var i=this.stack[t];this.confirmTransition(i,(function(){var n=e.current;e.index=t,e.updateRoute(i),e.router.afterHooks.forEach((function(e){e&&e(i,n)}))}),(function(n){wa(n,va.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Sa),Ma=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Qo(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!ha&&!1!==n.fallback,this.fallback&&(e="hash"),Ko||(e="abstract"),this.mode=e,e){case"history":this.history=new La(this,n.base);break;case"hash":this.history=new za(this,n.base,this.fallback);break;case"abstract":this.history=new Fa(this,n.base);break;default:0}},Ga={currentRoute:{configurable:!0}};Ma.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Ga.currentRoute.get=function(){return this.history&&this.history.current},Ma.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof La||t instanceof za){var i=function(n){t.setupListeners(),function(n){var i=t.current,r=e.options.scrollBehavior;ha&&r&&"fullPath"in n&&oa(e,n,i,!1)}(n)};t.transitionTo(t.getCurrentLocation(),i,i)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Ma.prototype.beforeEach=function(n){return Va(this.beforeHooks,n)},Ma.prototype.beforeResolve=function(n){return Va(this.resolveHooks,n)},Ma.prototype.afterEach=function(n){return Va(this.afterHooks,n)},Ma.prototype.onReady=function(n,e){this.history.onReady(n,e)},Ma.prototype.onError=function(n){this.history.onError(n)},Ma.prototype.push=function(n,e,t){var i=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){i.history.push(n,e,t)}));this.history.push(n,e,t)},Ma.prototype.replace=function(n,e,t){var i=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){i.history.replace(n,e,t)}));this.history.replace(n,e,t)},Ma.prototype.go=function(n){this.history.go(n)},Ma.prototype.back=function(){this.go(-1)},Ma.prototype.forward=function(){this.go(1)},Ma.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Ma.prototype.resolve=function(n,e,t){var i=Mo(n,e=e||this.history.current,t,this),r=this.match(i,e),o=r.redirectedFrom||r.fullPath;return{location:i,route:r,href:function(n,e,t){var i="hash"===t?"#"+e:e;return n?wo(n+"/"+i):i}(this.history.base,o,this.mode),normalizedTo:i,resolved:r}},Ma.prototype.getRoutes=function(){return this.matcher.getRoutes()},Ma.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==ho&&this.history.transitionTo(this.history.getCurrentLocation())},Ma.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==ho&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Ma.prototype,Ga);var $a=Ma;function Va(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Ma.install=function n(e){if(!n.installed||Go!==e){n.installed=!0,Go=e;var t=function(n){return void 0!==n},i=function(n,e){var i=n.$options._parentVnode;t(i)&&t(i=i.data)&&t(i=i.registerRouteInstance)&&i(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,i(this,this)},destroyed:function(){i(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",yo),e.component("RouterLink",Vo);var r=e.config.optionMergeStrategies;r.beforeRouteEnter=r.beforeRouteLeave=r.beforeRouteUpdate=r.created}},Ma.version="3.6.5",Ma.isNavigationFailure=wa,Ma.NavigationFailureType=va,Ma.START_LOCATION=ho,Ko&&window.Vue&&window.Vue.use(Ma);t(111);t(17),t(136);var Ha={"components/AlgoliaSearchBox":()=>Promise.all([t.e(0),t.e(14)]).then(t.bind(null,390)),"components/ArchivesPage":()=>Promise.all([t.e(0),t.e(17)]).then(t.bind(null,344)),"components/ArticleInfo":()=>Promise.all([t.e(0),t.e(21)]).then(t.bind(null,345)),"components/BloggerBar":()=>Promise.all([t.e(0),t.e(22)]).then(t.bind(null,346)),"components/BodyBgImg":()=>Promise.all([t.e(0),t.e(23)]).then(t.bind(null,347)),"components/Buttons":()=>Promise.all([t.e(0),t.e(18)]).then(t.bind(null,348)),"components/Catalogue":()=>Promise.all([t.e(0),t.e(24)]).then(t.bind(null,349)),"components/CategoriesBar":()=>Promise.all([t.e(0),t.e(25)]).then(t.bind(null,308)),"components/CategoriesPage":()=>Promise.all([t.e(0),t.e(11)]).then(t.bind(null,350)),"components/DropdownLink":()=>Promise.all([t.e(0),t.e(15)]).then(t.bind(null,286)),"components/DropdownTransition":()=>Promise.all([t.e(0),t.e(26)]).then(t.bind(null,264)),"components/Footer":()=>Promise.all([t.e(0),t.e(27)]).then(t.bind(null,351)),"components/Home":()=>Promise.all([t.e(0),t.e(2),t.e(37)]).then(t.bind(null,378)),"components/MainLayout":()=>Promise.all([t.e(0),t.e(28)]).then(t.bind(null,278)),"components/NavLink":()=>t.e(38).then(t.bind(null,263)),"components/NavLinks":()=>Promise.all([t.e(0),t.e(13)]).then(t.bind(null,310)),"components/Navbar":()=>Promise.all([t.e(0),t.e(1)]).then(t.bind(null,377)),"components/Page":()=>Promise.all([t.e(0),t.e(3),t.e(35)]).then(t.bind(null,379)),"components/PageEdit":()=>Promise.all([t.e(0),t.e(19)]).then(t.bind(null,352)),"components/PageNav":()=>Promise.all([t.e(0),t.e(16)]).then(t.bind(null,353)),"components/Pagination":()=>Promise.all([t.e(0),t.e(29)]).then(t.bind(null,277)),"components/PostList":()=>Promise.all([t.e(0),t.e(30)]).then(t.bind(null,276)),"components/RightMenu":()=>Promise.all([t.e(0),t.e(31)]).then(t.bind(null,354)),"components/Sidebar":()=>Promise.all([t.e(0),t.e(10)]).then(t.bind(null,355)),"components/SidebarButton":()=>Promise.all([t.e(0),t.e(32)]).then(t.bind(null,357)),"components/SidebarGroup":()=>Promise.all([t.e(0),t.e(5)]).then(t.bind(null,311)),"components/SidebarLink":()=>Promise.all([t.e(0),t.e(33)]).then(t.bind(null,287)),"components/SidebarLinks":()=>Promise.all([t.e(0),t.e(5)]).then(t.bind(null,284)),"components/TagsBar":()=>Promise.all([t.e(0),t.e(34)]).then(t.bind(null,309)),"components/TagsPage":()=>Promise.all([t.e(0),t.e(12)]).then(t.bind(null,356)),"components/UpdateArticle":()=>Promise.all([t.e(0),t.e(36)]).then(t.bind(null,314)),"global-components/Badge":()=>Promise.all([t.e(0),t.e(6)]).then(t.bind(null,394)),"global-components/CodeBlock":()=>Promise.resolve().then(t.bind(null,99)),"global-components/CodeGroup":()=>Promise.resolve().then(t.bind(null,100)),"layouts/404":()=>Promise.all([t.e(0),t.e(7)]).then(t.bind(null,391)),"layouts/Layout":()=>Promise.all([t.e(0),t.e(1),t.e(2),t.e(3),t.e(4)]).then(t.bind(null,392)),NotFound:()=>Promise.all([t.e(0),t.e(7)]).then(t.bind(null,391)),Layout:()=>Promise.all([t.e(0),t.e(1),t.e(2),t.e(3),t.e(4)]).then(t.bind(null,392))},Ka={"v-dd6d37e4":()=>t.e(39).then(t.bind(null,395)),"v-3c5cb278":()=>t.e(40).then(t.bind(null,396)),"v-1139bec1":()=>t.e(42).then(t.bind(null,397)),"v-16a9958e":()=>t.e(41).then(t.bind(null,398)),"v-e6d91580":()=>t.e(43).then(t.bind(null,399)),"v-5df34b59":()=>t.e(44).then(t.bind(null,400)),"v-0c3eb4e8":()=>t.e(45).then(t.bind(null,401)),"v-aa898bb4":()=>t.e(46).then(t.bind(null,402)),"v-1e46750d":()=>t.e(47).then(t.bind(null,403)),"v-ccee1a68":()=>t.e(48).then(t.bind(null,404)),"v-288e6001":()=>t.e(50).then(t.bind(null,405)),"v-f15f1ada":()=>t.e(51).then(t.bind(null,406)),"v-6668a861":()=>t.e(54).then(t.bind(null,407)),"v-a45883c2":()=>t.e(52).then(t.bind(null,408)),"v-10f2e34e":()=>t.e(55).then(t.bind(null,409)),"v-bd714042":()=>t.e(53).then(t.bind(null,410)),"v-0dd17318":()=>t.e(57).then(t.bind(null,411)),"v-466444aa":()=>t.e(58).then(t.bind(null,412)),"v-1f12d3c2":()=>t.e(56).then(t.bind(null,413)),"v-3f115c5a":()=>t.e(59).then(t.bind(null,414)),"v-486047ee":()=>t.e(60).then(t.bind(null,415)),"v-49e30f62":()=>t.e(61).then(t.bind(null,416)),"v-0295a8c0":()=>t.e(62).then(t.bind(null,417)),"v-48703727":()=>t.e(49).then(t.bind(null,418)),"v-0d1f7517":()=>t.e(64).then(t.bind(null,419)),"v-7f8094fc":()=>t.e(70).then(t.bind(null,420)),"v-5e1f62f8":()=>t.e(69).then(t.bind(null,421)),"v-c3099e10":()=>t.e(73).then(t.bind(null,422)),"v-79e3d1ae":()=>t.e(75).then(t.bind(null,423)),"v-bf38e39a":()=>t.e(68).then(t.bind(null,424)),"v-ecc968b6":()=>t.e(66).then(t.bind(null,425)),"v-0bc1b9b4":()=>t.e(74).then(t.bind(null,426)),"v-7cd58e9b":()=>t.e(71).then(t.bind(null,427)),"v-319af327":()=>t.e(63).then(t.bind(null,428)),"v-1bc814a4":()=>t.e(65).then(t.bind(null,429)),"v-a521f62a":()=>t.e(77).then(t.bind(null,430)),"v-0373c099":()=>t.e(76).then(t.bind(null,431)),"v-4dbea03d":()=>t.e(78).then(t.bind(null,432)),"v-4a7c7cef":()=>t.e(80).then(t.bind(null,433)),"v-527901ce":()=>t.e(81).then(t.bind(null,434)),"v-0cf5f5ce":()=>t.e(72).then(t.bind(null,435)),"v-f177b3e6":()=>t.e(79).then(t.bind(null,436)),"v-7587d3fc":()=>t.e(82).then(t.bind(null,437)),"v-cecf59c6":()=>t.e(83).then(t.bind(null,438)),"v-ab6c5552":()=>t.e(84).then(t.bind(null,439)),"v-45eaf67a":()=>t.e(67).then(t.bind(null,440)),"v-1f62b379":()=>t.e(85).then(t.bind(null,441)),"v-66f28a6e":()=>t.e(88).then(t.bind(null,442)),"v-39ec134c":()=>t.e(87).then(t.bind(null,443)),"v-1081ce44":()=>t.e(89).then(t.bind(null,444)),"v-66f80783":()=>t.e(86).then(t.bind(null,445)),"v-4aec2599":()=>t.e(94).then(t.bind(null,446)),"v-28760263":()=>t.e(93).then(t.bind(null,447)),"v-857b513e":()=>t.e(91).then(t.bind(null,448)),"v-e792ddf8":()=>t.e(95).then(t.bind(null,449)),"v-32c8611a":()=>t.e(99).then(t.bind(null,450)),"v-7f5cbb59":()=>t.e(92).then(t.bind(null,451)),"v-5c9edb39":()=>t.e(98).then(t.bind(null,452)),"v-49401e23":()=>t.e(90).then(t.bind(null,453)),"v-31a7810b":()=>t.e(102).then(t.bind(null,454)),"v-65dcdf76":()=>t.e(100).then(t.bind(null,455)),"v-38c4edfa":()=>t.e(97).then(t.bind(null,456)),"v-78dda423":()=>t.e(101).then(t.bind(null,457)),"v-1bc85996":()=>t.e(104).then(t.bind(null,458)),"v-3bc0ad5e":()=>t.e(105).then(t.bind(null,459)),"v-3be97cb8":()=>t.e(110).then(t.bind(null,460)),"v-e5f4dafa":()=>t.e(106).then(t.bind(null,461)),"v-75583a06":()=>t.e(103).then(t.bind(null,462)),"v-61cadb70":()=>t.e(109).then(t.bind(null,463)),"v-0b3ccae2":()=>t.e(96).then(t.bind(null,464)),"v-12a20be9":()=>t.e(112).then(t.bind(null,465)),"v-47ac947e":()=>t.e(114).then(t.bind(null,466)),"v-14654b08":()=>t.e(108).then(t.bind(null,467)),"v-72ba3a16":()=>t.e(111).then(t.bind(null,468)),"v-35052366":()=>t.e(113).then(t.bind(null,469)),"v-170e5b70":()=>t.e(107).then(t.bind(null,470)),"v-4bf70beb":()=>t.e(115).then(t.bind(null,471)),"v-5b71b852":()=>t.e(116).then(t.bind(null,472)),"v-4e18d034":()=>t.e(117).then(t.bind(null,473)),"v-7f9d059f":()=>t.e(118).then(t.bind(null,474)),"v-476ed16d":()=>t.e(119).then(t.bind(null,475)),"v-3a3276c2":()=>t.e(120).then(t.bind(null,476)),"v-279b57f8":()=>t.e(121).then(t.bind(null,477)),"v-0c700bb1":()=>t.e(122).then(t.bind(null,478)),"v-2472c4c6":()=>t.e(123).then(t.bind(null,479)),"v-509f409b":()=>t.e(124).then(t.bind(null,480)),"v-1a482803":()=>t.e(126).then(t.bind(null,481)),"v-4b74d0db":()=>t.e(127).then(t.bind(null,482)),"v-59070e48":()=>t.e(129).then(t.bind(null,483)),"v-72ab0e2f":()=>t.e(131).then(t.bind(null,484)),"v-3bd47188":()=>t.e(128).then(t.bind(null,485)),"v-08ac2779":()=>t.e(130).then(t.bind(null,486)),"v-6cf98a73":()=>t.e(132).then(t.bind(null,487)),"v-47fabeb6":()=>t.e(133).then(t.bind(null,488)),"v-3a888ae4":()=>t.e(134).then(t.bind(null,489)),"v-4a02579b":()=>t.e(135).then(t.bind(null,490)),"v-30e085c9":()=>t.e(136).then(t.bind(null,491)),"v-0e8002ab":()=>t.e(137).then(t.bind(null,492)),"v-1e268ac6":()=>t.e(125).then(t.bind(null,493)),"v-3fce6544":()=>t.e(140).then(t.bind(null,494)),"v-1e09ee2b":()=>t.e(139).then(t.bind(null,495)),"v-6097fb0b":()=>t.e(138).then(t.bind(null,496))};function Ja(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Wa=/-(\w)/g,Qa=Ja(n=>n.replace(Wa,(n,e)=>e?e.toUpperCase():"")),Ya=/\B([A-Z])/g,Xa=Ja(n=>n.replace(Ya,"-$1").toLowerCase()),Za=Ja(n=>n.charAt(0).toUpperCase()+n.slice(1));function ns(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Za(Qa(e))):n(Za(e))||n(Xa(e))}const es=Object.assign({},Ha,Ka),ts=n=>es[n],is=n=>Ka[n],rs=n=>Ha[n],os=n=>Ht.component(n);function as(n){return ns(is,n)}function ss(n){return ns(rs,n)}function ls(n){return ns(ts,n)}function cs(n){return ns(os,n)}function ds(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!cs(n)&&ls(n)){const e=await ls(n)();Ht.component(n,e.default)}}))}function us(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var ps=t(96),ms=t.n(ps),hs=t(97),fs=t.n(hs),gs={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${fs()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=bs(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=xs(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return ms()([{name:"description",content:this.$description}],n,this.siteMeta,ys)},updateCanonicalLink(){vs(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",bs(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){xs(null,this.currentMetaTags),vs()}};function vs(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function bs(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function xs(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function ys(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var ks=t(48),_s={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(ks)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),i=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),r=window.innerHeight+t;for(let n=0;n<e.length;n++){const o=e[n],a=e[n+1],s=0===n&&0===t||t>=o.parentElement.offsetTop+10&&(!a||t<a.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(o.hash)){const t=o;if(r===i)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},ws=t(26),Es=t.n(ws),Ts={mounted(){Es.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Ht.component(n.name)||Es.a.start(),t()}),this.$router.afterEach(()=>{Es.a.done(),this.isSidebarOpen=!1})}};t(244),t(245);class Ps{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var js={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new Ps).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var i=document.head||document.getElementsByTagName("head")[0],r=document.createElement("style");r.type="text/css","top"===t&&i.firstChild?i.insertBefore(r,i.firstChild):i.appendChild(r),r.styleSheet?r.styleSheet.cssText=n:r.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var As={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},Cs={},Ss=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},Bs=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:As[n]},Is=function n(e,t,i){var r=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))r[n]=t[n];else{var e=n.replace("data","");r.dataset[e]=t[n]}})),i&&i.forEach((function(e){var t=e.tag,i=e.attrs,o=e.children;r.appendChild(n(t,i,o))})),r},Ls=function(n,e,t){var i,r=(i=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(i));return 1!==r.length||t?r:r[0]},Ds=function(n,e){var t,i,r=n.match(/<style>([\s\S]+)<\/style>/),o=n.match(/<template>([\s\S]+)<\/template>/),a=n.match(/<script>([\s\S]+)<\/script>/),s={css:r&&r[1].replace(/^\n|\n$/g,""),html:o&&o[1].replace(/^\n|\n$/g,""),js:a&&a[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=Ss(s.html),s.jsTpl=(t=s.js,i=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(i,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),i="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),r=window.Babel?window.Babel.transform(i,{presets:["es2015"]}).code:i,o=[eval][0](r);return o.template=e,o}(s.js,s.html);var l=Bs("vue");return s.jsLib.unshift(l),s},zs=function(n,e){var t,i=n.match(/<style>([\s\S]+)<\/style>/),r=n.match(/<html>([\s\S]+)<\/html>/),o=n.match(/<script>([\s\S]+)<\/script>/),a={css:i&&i[1].replace(/^\n|\n$/g,""),html:r&&r[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return a.htmlTpl=a.html,a.jsTpl=a.js,a.script=(t=a.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),a},Os=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Us(){var n=Ls(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=Ls(n,"vuepress-plugin-demo-block__code"),t=Ls(n,"vuepress-plugin-demo-block__display"),i=Ls(n,"vuepress-plugin-demo-block__footer"),r=Ls(t,"vuepress-plugin-demo-block__app"),o=decodeURIComponent(n.dataset.code),a=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);a=a?JSON.parse(a):{};var l=e.querySelector("div").clientHeight,c="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,i="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),r=new Function("return ".concat(i))(),o={js:r,css:r.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:Os(n),htmlTpl:Ss("")},a=Bs("react"),s=Bs("reactDOM");return o.jsLib.unshift(a,s),o}(o,a):"vanilla"===s?zs(o,a):Ds(o,a),d=Is("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(i.appendChild(d),d.addEventListener("click",Ns.bind(null,d,l,e,i)),Bs("jsfiddle")&&i.appendChild(function(n){var e=n.css,t=n.htmlTpl,i=n.jsTpl,r=n.jsLib,o=n.cssLib,a=r.concat(o).concat(Bs("cssLib")).concat(Bs("jsLib")).join(",");return Is("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:i}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:a}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),Bs("codepen")&&i.appendChild(function(n){var e=n.css,t=n.htmlTpl,i=n.jsTpl,r=n.jsLib,o=n.cssLib,a=JSON.stringify({css:e,html:t,js:i,js_external:r.concat(Bs("jsLib")).join(";"),css_external:o.concat(Bs("cssLib")).join(";"),layout:Bs("codepenLayout"),js_pre_processor:Bs("codepenJsProcessor"),editors:Bs("codepenEditors")});return Is("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:a}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==a.horizontal?a.horizontal:Bs("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var u=e.firstChild.cloneNode(!0);u.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(u)}if(c.css&&function(n){if(!Cs[n]){var e=Is("style",{innerHTML:n});document.body.appendChild(e),Cs[n]=!0}}(c.css),"react"===s)ReactDOM.render(React.createElement(c.js),r);else if("vue"===s){var p=(new(Vue.extend(c.script))).$mount();r.appendChild(p.$el)}else"vanilla"===s&&(r.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Us()}),300)}function Ns(n,e,t,i){var r="1"!==n.dataset.isExpand;t.style.height=r?"".concat(e,"px"):0,r?i.classList.add("vuepress-plugin-demo-block__show-link"):i.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=r?"1":"0"}var Rs={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Us()},updated:function(){Us()}},qs="auto",Fs="zoom-in",Ms="zoom-out",Gs="grab",$s="move";function Vs(n,e,t){var i=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r={passive:!1};i?n.addEventListener(e,t,r):n.removeEventListener(e,t,r)}function Hs(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Ks(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Js(n,e,t){!function(n){var e=Ws,t=Qs;if(n.transition){var i=n.transition;delete n.transition,n[e]=i}if(n.transform){var r=n.transform;delete n.transform,n[t]=r}}(e);var i=n.style,r={};for(var o in e)t&&(r[o]=i[o]||""),i[o]=e[o];return r}var Ws="transition",Qs="transform",Ys="transform",Xs="transitionend";var Zs=function(){},nl={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Zs,onClose:Zs,onGrab:Zs,onMove:Zs,onRelease:Zs,onBeforeOpen:Zs,onBeforeClose:Zs,onBeforeGrab:Zs,onBeforeRelease:Zs,onImageLoading:Zs,onImageLoaded:Zs},el={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),il(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var i=this.lastScrollPosition.x-e,r=this.lastScrollPosition.y-t,o=this.options.scrollThreshold;(Math.abs(r)>=o||Math.abs(i)>=o)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(tl(n)&&!il(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){tl(n)&&!il(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,i=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,i)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,i=e.clientY;this.move(t,i)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function tl(n){return 0===n.button}function il(n){return n.metaKey||n.ctrlKey}var rl={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Js(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Vs(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Js(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},ol="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},al=function(){function n(n,e){for(var t=0;t<e.length;t++){var i=e[t];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(n,i.key,i)}}return function(e,t,i){return t&&n(e.prototype,t),i&&n(e,i),e}}(),sl=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(n[i]=t[i])}return n},ll={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Ks(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,i=n.transitionDuration,r=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Gs:Ms,transition:Ys+"\n        "+i+"s\n        "+r,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Js(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Js(this.el,{transform:"none"})},grab:function(n,e,t){var i=cl(),r=i.x-n,o=i.y-e;Js(this.el,{cursor:$s,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var i=cl(),r=i.x-n,o=i.y-e;Js(this.el,{transition:Ys,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Js(this.el,this.styleClose)},restoreOpenStyle:function(){Js(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=cl(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,i=this.instance.options,r=i.customSize,o=i.scaleBase;if(!r&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(r&&"object"===(void 0===r?"undefined":ol(r)))return{x:r.width/this.rect.width,y:r.height/this.rect.height};var a=this.rect.width/2,s=this.rect.height/2,l=cl(),c={x:l.x-a,y:l.y-s},d=c.x/a,u=c.y/s,p=o+Math.min(d,u);if(r&&"string"==typeof r){var m=t||this.el.naturalWidth,h=e||this.el.naturalHeight,f=parseFloat(r)*m/(100*this.rect.width),g=parseFloat(r)*h/(100*this.rect.height);if(p>f||p>g)return{x:f,y:g}}return{x:p,y:p}}};function cl(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function dl(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(i){Vs(n,i,e[i],t)}))}var ul=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(ll),this.overlay=Object.create(rl),this.handler=Object.create(el),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=sl({},nl,e),this.overlay.init(this),this.handler.init(this)}return al(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Fs,Vs(n,"click",this.handler.click),this.options.preloadImage&&Hs(Ks(n)));return this}},{key:"config",value:function(n){return n?(sl(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var i="string"==typeof n?document.querySelector(n):n;if("IMG"===i.tagName){if(this.options.onBeforeOpen(i),this.target.init(i,this),!this.options.preloadImage){var r=this.target.srcOriginal;null!=r&&(this.options.onImageLoading(i),Hs(r,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Vs(document,"scroll",this.handler.scroll),Vs(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Vs(window,"resize",this.handler.resizeWindow);var o=function n(){Vs(i,Xs,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&dl(document,e.handler,!0),t(i)};return Vs(i,Xs,o),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=qs,this.overlay.fadeOut(),this.target.zoomOut(),Vs(document,"scroll",this.handler.scroll,!1),Vs(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Vs(window,"resize",this.handler.resizeWindow,!1);var i=function i(){Vs(t,Xs,i,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&dl(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Vs(t,Xs,i),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var r=this.target.el;this.options.onBeforeGrab(r),this.released=!1,this.target.grab(n,e,t);var o=function n(){Vs(r,Xs,n,!1),i(r)};return Vs(r,Xs,o),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=$s,this.target.move(n,e,t);var r=this.target.el,o=function n(){Vs(r,Xs,n,!1),i(r)};return Vs(r,Xs,o),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=qs,this.target.restoreOpenStyle();var i=function i(){Vs(t,Xs,i,!1),n.lock=!1,n.released=!0,e(t)};return Vs(t,Xs,i),this}}}]),n}();const pl=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),ml=Number("500");class hl{constructor(){this.instance=new ul(pl)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=ml){setTimeout(()=>this.update(n),e)}}var fl=[gs,_s,Ts,js,Rs,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new hl,this.$vuepress.zooming.updateDelay()}}],gl={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return us("layout",n),Ht.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},vl=t(0),bl=Object(vl.a)(gl,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(bl,"mixins",fl);const xl=[{name:"v-dd6d37e4",path:"/develop/language/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-dd6d37e4").then(t)}},{path:"/develop/language/index.html",redirect:"/develop/language/"},{path:"/00.目录页/01.sub01.编程语言.html",redirect:"/develop/language/"},{name:"v-3c5cb278",path:"/develop/framework/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-3c5cb278").then(t)}},{path:"/develop/framework/index.html",redirect:"/develop/framework/"},{path:"/00.目录页/01.sub02.开发框架.html",redirect:"/develop/framework/"},{name:"v-1139bec1",path:"/develop/storage/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-1139bec1").then(t)}},{path:"/develop/storage/index.html",redirect:"/develop/storage/"},{path:"/00.目录页/01.sub04.数据存储.html",redirect:"/develop/storage/"},{name:"v-16a9958e",path:"/develop/algorithm/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-16a9958e").then(t)}},{path:"/develop/algorithm/index.html",redirect:"/develop/algorithm/"},{path:"/00.目录页/01.sub03.数据结构与算法.html",redirect:"/develop/algorithm/"},{name:"v-e6d91580",path:"/develop/system/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-e6d91580").then(t)}},{path:"/develop/system/index.html",redirect:"/develop/system/"},{path:"/00.目录页/01.sub05.系统架构.html",redirect:"/develop/system/"},{name:"v-5df34b59",path:"/develop/network/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-5df34b59").then(t)}},{path:"/develop/network/index.html",redirect:"/develop/network/"},{path:"/00.目录页/01.sub06.计算机网络.html",redirect:"/develop/network/"},{name:"v-0c3eb4e8",path:"/develop/cloud/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-0c3eb4e8").then(t)}},{path:"/develop/cloud/index.html",redirect:"/develop/cloud/"},{path:"/00.目录页/01.sub07.云原生.html",redirect:"/develop/cloud/"},{name:"v-aa898bb4",path:"/develop/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-aa898bb4").then(t)}},{path:"/develop/index.html",redirect:"/develop/"},{path:"/00.目录页/01.开发.html",redirect:"/develop/"},{name:"v-1e46750d",path:"/tool/vcs/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-1e46750d").then(t)}},{path:"/tool/vcs/index.html",redirect:"/tool/vcs/"},{path:"/00.目录页/02.sub01版本控制.html",redirect:"/tool/vcs/"},{name:"v-ccee1a68",path:"/tool/network/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-ccee1a68").then(t)}},{path:"/tool/network/index.html",redirect:"/tool/network/"},{path:"/00.目录页/02.sub02网络工具.html",redirect:"/tool/network/"},{name:"v-288e6001",path:"/tool/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-288e6001").then(t)}},{path:"/tool/index.html",redirect:"/tool/"},{path:"/00.目录页/02.工具.html",redirect:"/tool/"},{name:"v-f15f1ada",path:"/note/paper/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-f15f1ada").then(t)}},{path:"/note/paper/index.html",redirect:"/note/paper/"},{path:"/00.目录页/03.sub01.学术搬砖.html",redirect:"/note/paper/"},{name:"v-6668a861",path:"/note/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-6668a861").then(t)}},{path:"/note/index.html",redirect:"/note/"},{path:"/00.目录页/03.学习笔记.html",redirect:"/note/"},{name:"v-a45883c2",path:"/note/project/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-a45883c2").then(t)}},{path:"/note/project/index.html",redirect:"/note/project/"},{path:"/00.目录页/03.sub02.实践项目.html",redirect:"/note/project/"},{name:"v-10f2e34e",path:"/life/year/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-10f2e34e").then(t)}},{path:"/life/year/index.html",redirect:"/life/year/"},{path:"/00.目录页/04.sub01.随写编年.html",redirect:"/life/year/"},{name:"v-bd714042",path:"/note/lecture/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-bd714042").then(t)}},{path:"/note/lecture/index.html",redirect:"/note/lecture/"},{path:"/00.目录页/03.sub03.讲座研讨.html",redirect:"/note/lecture/"},{name:"v-0dd17318",path:"/life/travel/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-0dd17318").then(t)}},{path:"/life/travel/index.html",redirect:"/life/travel/"},{path:"/00.目录页/04.sub03.旅行日记.html",redirect:"/life/travel/"},{name:"v-466444aa",path:"/life/art/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-466444aa").then(t)}},{path:"/life/art/index.html",redirect:"/life/art/"},{path:"/00.目录页/04.sub04.文艺时光.html",redirect:"/life/art/"},{name:"v-1f12d3c2",path:"/life/youth/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-1f12d3c2").then(t)}},{path:"/life/youth/index.html",redirect:"/life/youth/"},{path:"/00.目录页/04.sub02.追忆青春.html",redirect:"/life/youth/"},{name:"v-3f115c5a",path:"/life/cook/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-3f115c5a").then(t)}},{path:"/life/cook/index.html",redirect:"/life/cook/"},{path:"/00.目录页/04.sub05.烹调分享.html",redirect:"/life/cook/"},{name:"v-486047ee",path:"/life/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-486047ee").then(t)}},{path:"/life/index.html",redirect:"/life/"},{path:"/00.目录页/04.生活杂谈.html",redirect:"/life/"},{name:"v-49e30f62",path:"/resource/website/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-49e30f62").then(t)}},{path:"/resource/website/index.html",redirect:"/resource/website/"},{path:"/00.目录页/05.sub01实用网站.html",redirect:"/resource/website/"},{name:"v-0295a8c0",path:"/resource/project/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-0295a8c0").then(t)}},{path:"/resource/project/index.html",redirect:"/resource/project/"},{path:"/00.目录页/05.sub02优秀项目.html",redirect:"/resource/project/"},{name:"v-48703727",path:"/tool/develop/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-48703727").then(t)}},{path:"/tool/develop/index.html",redirect:"/tool/develop/"},{path:"/00.目录页/02.sub03.开发工具.html",redirect:"/tool/develop/"},{name:"v-0d1f7517",path:"/more/interview/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-0d1f7517").then(t)}},{path:"/more/interview/index.html",redirect:"/more/interview/"},{path:"/00.目录页/06.sub01.面试.html",redirect:"/more/interview/"},{name:"v-7f8094fc",path:"/pages/03e0a8/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-7f8094fc").then(t)}},{path:"/pages/03e0a8/index.html",redirect:"/pages/03e0a8/"},{path:"/01.开发/02.开发框架/01.前端/01.Vite构建工具介绍.html",redirect:"/pages/03e0a8/"},{name:"v-5e1f62f8",path:"/pages/f16b08/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-5e1f62f8").then(t)}},{path:"/pages/f16b08/index.html",redirect:"/pages/f16b08/"},{path:"/01.开发/01.编程语言/02.C++/02.C语言如何从一定范围内生成随机整数.html",redirect:"/pages/f16b08/"},{name:"v-c3099e10",path:"/pages/2d97a5/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-c3099e10").then(t)}},{path:"/pages/2d97a5/index.html",redirect:"/pages/2d97a5/"},{path:"/01.开发/02.开发框架/03.设计模式/03.设计模式之原型模式详解（Java实现）.html",redirect:"/pages/2d97a5/"},{name:"v-79e3d1ae",path:"/pages/2bc5dd/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-79e3d1ae").then(t)}},{path:"/pages/2bc5dd/index.html",redirect:"/pages/2bc5dd/"},{path:"/01.开发/02.开发框架/03.设计模式/05.设计模式之适配器模式详解（Java实现）.html",redirect:"/pages/2bc5dd/"},{name:"v-bf38e39a",path:"/pages/9c1ae3/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-bf38e39a").then(t)}},{path:"/pages/9c1ae3/index.html",redirect:"/pages/9c1ae3/"},{path:"/01.开发/01.编程语言/02.C++/01.C++11多线程 std::thread详解.html",redirect:"/pages/9c1ae3/"},{name:"v-ecc968b6",path:"/more/blog/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-ecc968b6").then(t)}},{path:"/more/blog/index.html",redirect:"/more/blog/"},{path:"/00.目录页/06.sub03.博客相关.html",redirect:"/more/blog/"},{name:"v-0bc1b9b4",path:"/pages/a1ff4f/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-0bc1b9b4").then(t)}},{path:"/pages/a1ff4f/index.html",redirect:"/pages/a1ff4f/"},{path:"/01.开发/02.开发框架/03.设计模式/04.设计模式之单例模式详解（Java实现）.html",redirect:"/pages/a1ff4f/"},{name:"v-7cd58e9b",path:"/pages/f4cb7a/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-7cd58e9b").then(t)}},{path:"/pages/f4cb7a/index.html",redirect:"/pages/f4cb7a/"},{path:"/01.开发/02.开发框架/03.设计模式/01.设计模式之工厂模式详解（Java实现）.html",redirect:"/pages/f4cb7a/"},{name:"v-319af327",path:"/resource/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-319af327").then(t)}},{path:"/resource/index.html",redirect:"/resource/"},{path:"/00.目录页/05.资源收藏.html",redirect:"/resource/"},{name:"v-1bc814a4",path:"/more/tip/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-1bc814a4").then(t)}},{path:"/more/tip/index.html",redirect:"/more/tip/"},{path:"/00.目录页/06.sub02.实用技巧.html",redirect:"/more/tip/"},{name:"v-a521f62a",path:"/pages/eac75e/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-a521f62a").then(t)}},{path:"/pages/eac75e/index.html",redirect:"/pages/eac75e/"},{path:"/01.开发/02.开发框架/03.设计模式/07.设计模式之组合模式详解（Java实现）.html",redirect:"/pages/eac75e/"},{name:"v-0373c099",path:"/pages/aab372/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-0373c099").then(t)}},{path:"/pages/aab372/index.html",redirect:"/pages/aab372/"},{path:"/01.开发/02.开发框架/03.设计模式/06.设计模式之桥接模式详解（Java实现）.html",redirect:"/pages/aab372/"},{name:"v-4dbea03d",path:"/pages/c49acf/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-4dbea03d").then(t)}},{path:"/pages/c49acf/index.html",redirect:"/pages/c49acf/"},{path:"/01.开发/02.开发框架/03.设计模式/08.设计模式之装饰模式详解（Java实现）.html",redirect:"/pages/c49acf/"},{name:"v-4a7c7cef",path:"/pages/933a7d/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-4a7c7cef").then(t)}},{path:"/pages/933a7d/index.html",redirect:"/pages/933a7d/"},{path:"/01.开发/02.开发框架/03.设计模式/10.设计模式之代理模式详解（Java实现）.html",redirect:"/pages/933a7d/"},{name:"v-527901ce",path:"/pages/31f81b/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-527901ce").then(t)}},{path:"/pages/31f81b/index.html",redirect:"/pages/31f81b/"},{path:"/01.开发/02.开发框架/03.设计模式/11.设计模式之命令模式详解（Java实现）.html",redirect:"/pages/31f81b/"},{name:"v-0cf5f5ce",path:"/pages/04c857/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-0cf5f5ce").then(t)}},{path:"/pages/04c857/index.html",redirect:"/pages/04c857/"},{path:"/01.开发/02.开发框架/03.设计模式/02.设计模式之建造者模式详解（Java实现）.html",redirect:"/pages/04c857/"},{name:"v-f177b3e6",path:"/pages/e40609/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-f177b3e6").then(t)}},{path:"/pages/e40609/index.html",redirect:"/pages/e40609/"},{path:"/01.开发/02.开发框架/03.设计模式/09.设计模式之外观模式详解（Java实现）.html",redirect:"/pages/e40609/"},{name:"v-7587d3fc",path:"/pages/e1f6d9/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-7587d3fc").then(t)}},{path:"/pages/e1f6d9/index.html",redirect:"/pages/e1f6d9/"},{path:"/01.开发/02.开发框架/03.设计模式/12.设计模式之观察者模式详解（Java实现）.html",redirect:"/pages/e1f6d9/"},{name:"v-cecf59c6",path:"/pages/b22ffc/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-cecf59c6").then(t)}},{path:"/pages/b22ffc/index.html",redirect:"/pages/b22ffc/"},{path:"/01.开发/02.开发框架/03.设计模式/13.设计模式之策略模式详解（Java）实现.html",redirect:"/pages/b22ffc/"},{name:"v-ab6c5552",path:"/pages/2aa461/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-ab6c5552").then(t)}},{path:"/pages/2aa461/index.html",redirect:"/pages/2aa461/"},{path:"/01.开发/02.开发框架/03.设计模式/14.设计模式之模板方法模式详解（Java实现）.html",redirect:"/pages/2aa461/"},{name:"v-45eaf67a",path:"/more/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-45eaf67a").then(t)}},{path:"/more/index.html",redirect:"/more/"},{path:"/00.目录页/06.更多.html",redirect:"/more/"},{name:"v-1f62b379",path:"/pages/71fd4b/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-1f62b379").then(t)}},{path:"/pages/71fd4b/index.html",redirect:"/pages/71fd4b/"},{path:"/01.开发/03.数据结构与算法/03.查找算法/01.二分查找.html",redirect:"/pages/71fd4b/"},{name:"v-66f28a6e",path:"/pages/243023/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-66f28a6e").then(t)}},{path:"/pages/243023/index.html",redirect:"/pages/243023/"},{path:"/01.开发/03.数据结构与算法/07.动态规划/01.数位DP.html",redirect:"/pages/243023/"},{name:"v-39ec134c",path:"/pages/088910/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-39ec134c").then(t)}},{path:"/pages/088910/index.html",redirect:"/pages/088910/"},{path:"/01.开发/03.数据结构与算法/06.数据结构/01.线段树入门.html",redirect:"/pages/088910/"},{name:"v-1081ce44",path:"/pages/671a5d/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-1081ce44").then(t)}},{path:"/pages/671a5d/index.html",redirect:"/pages/671a5d/"},{path:"/01.开发/03.数据结构与算法/07.动态规划/02.状压DP.html",redirect:"/pages/671a5d/"},{name:"v-66f80783",path:"/pages/41f1cd/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-66f80783").then(t)}},{path:"/pages/41f1cd/index.html",redirect:"/pages/41f1cd/"},{path:"/01.开发/03.数据结构与算法/05.位运算/01.位运算全面总结.html",redirect:"/pages/41f1cd/"},{name:"v-4aec2599",path:"/pages/affd0f/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-4aec2599").then(t)}},{path:"/pages/affd0f/index.html",redirect:"/pages/affd0f/"},{path:"/01.开发/03.数据结构与算法/08.图算法/04.Prim算法教程.html",redirect:"/pages/affd0f/"},{name:"v-28760263",path:"/pages/a97764/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-28760263").then(t)}},{path:"/pages/a97764/index.html",redirect:"/pages/a97764/"},{path:"/01.开发/03.数据结构与算法/08.图算法/03.Kruskal算法教程.html",redirect:"/pages/a97764/"},{name:"v-857b513e",path:"/pages/3610c3/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-857b513e").then(t)}},{path:"/pages/3610c3/index.html",redirect:"/pages/3610c3/"},{path:"/01.开发/03.数据结构与算法/08.图算法/01.Floyd算法教程.html",redirect:"/pages/3610c3/"},{name:"v-e792ddf8",path:"/pages/d66bf9/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-e792ddf8").then(t)}},{path:"/pages/d66bf9/index.html",redirect:"/pages/d66bf9/"},{path:"/01.开发/05.系统架构/01.Linux/01.Linux常用命令、管道、环境变量.html",redirect:"/pages/d66bf9/"},{name:"v-32c8611a",path:"/pages/d8622e/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-32c8611a").then(t)}},{path:"/pages/d8622e/index.html",redirect:"/pages/d8622e/"},{path:"/01.开发/05.系统架构/01.Linux/05.Linux execve函数详解.html",redirect:"/pages/d8622e/"},{name:"v-7f5cbb59",path:"/pages/180ec0/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-7f5cbb59").then(t)}},{path:"/pages/180ec0/index.html",redirect:"/pages/180ec0/"},{path:"/01.开发/03.数据结构与算法/08.图算法/02.Dijkstra算法教程.html",redirect:"/pages/180ec0/"},{name:"v-5c9edb39",path:"/pages/64b48d/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-5c9edb39").then(t)}},{path:"/pages/64b48d/index.html",redirect:"/pages/64b48d/"},{path:"/01.开发/05.系统架构/01.Linux/04.Linux_fork函数详解.html",redirect:"/pages/64b48d/"},{name:"v-49401e23",path:"/pages/243024/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-49401e23").then(t)}},{path:"/pages/243024/index.html",redirect:"/pages/243024/"},{path:"/01.开发/03.数据结构与算法/07.动态规划/03.HDU 4507 恨7不成妻 （数位DP套路题，详细解析）.html",redirect:"/pages/243024/"},{name:"v-31a7810b",path:"/pages/4b8a3a/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-31a7810b").then(t)}},{path:"/pages/4b8a3a/index.html",redirect:"/pages/4b8a3a/"},{path:"/01.开发/05.系统架构/02.操作系统/03.有限直接执行.html",redirect:"/pages/4b8a3a/"},{name:"v-65dcdf76",path:"/pages/77a74b/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-65dcdf76").then(t)}},{path:"/pages/77a74b/index.html",redirect:"/pages/77a74b/"},{path:"/01.开发/05.系统架构/02.操作系统/01.进程介绍.html",redirect:"/pages/77a74b/"},{name:"v-38c4edfa",path:"/pages/419777/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-38c4edfa").then(t)}},{path:"/pages/419777/index.html",redirect:"/pages/419777/"},{path:"/01.开发/05.系统架构/01.Linux/03.Linux用户和用户组教程.html",redirect:"/pages/419777/"},{name:"v-78dda423",path:"/pages/1d4493/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-78dda423").then(t)}},{path:"/pages/1d4493/index.html",redirect:"/pages/1d4493/"},{path:"/01.开发/05.系统架构/02.操作系统/02.进程API.html",redirect:"/pages/1d4493/"},{name:"v-1bc85996",path:"/pages/a1ad96/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-1bc85996").then(t)}},{path:"/pages/a1ad96/index.html",redirect:"/pages/a1ad96/"},{path:"/01.开发/05.系统架构/02.操作系统/05.多级反馈队列.html",redirect:"/pages/a1ad96/"},{name:"v-3bc0ad5e",path:"/pages/40a229/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-3bc0ad5e").then(t)}},{path:"/pages/40a229/index.html",redirect:"/pages/40a229/"},{path:"/01.开发/05.系统架构/02.操作系统/06.比例份额调度.html",redirect:"/pages/40a229/"},{name:"v-3be97cb8",path:"/pages/506cee/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-3be97cb8").then(t)}},{path:"/pages/506cee/index.html",redirect:"/pages/506cee/"},{path:"/01.开发/05.系统架构/02.操作系统/11.段.html",redirect:"/pages/506cee/"},{name:"v-e5f4dafa",path:"/pages/326999/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-e5f4dafa").then(t)}},{path:"/pages/326999/index.html",redirect:"/pages/326999/"},{path:"/01.开发/05.系统架构/02.操作系统/07.多CPU调度.html",redirect:"/pages/326999/"},{name:"v-75583a06",path:"/pages/f0c724/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-75583a06").then(t)}},{path:"/pages/f0c724/index.html",redirect:"/pages/f0c724/"},{path:"/01.开发/05.系统架构/02.操作系统/04.CPU调度.html",redirect:"/pages/f0c724/"},{name:"v-61cadb70",path:"/pages/542fcd/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-61cadb70").then(t)}},{path:"/pages/542fcd/index.html",redirect:"/pages/542fcd/"},{path:"/01.开发/05.系统架构/02.操作系统/10.地址转换.html",redirect:"/pages/542fcd/"},{name:"v-0b3ccae2",path:"/pages/b04f81/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-0b3ccae2").then(t)}},{path:"/pages/b04f81/index.html",redirect:"/pages/b04f81/"},{path:"/01.开发/05.系统架构/01.Linux/02.Linux常用文件管理命令.html",redirect:"/pages/b04f81/"},{name:"v-12a20be9",path:"/pages/69f0fb/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-12a20be9").then(t)}},{path:"/pages/69f0fb/index.html",redirect:"/pages/69f0fb/"},{path:"/01.开发/05.系统架构/02.操作系统/13.页.html",redirect:"/pages/69f0fb/"},{name:"v-47ac947e",path:"/pages/165f2d/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-47ac947e").then(t)}},{path:"/pages/165f2d/index.html",redirect:"/pages/165f2d/"},{path:"/01.开发/05.系统架构/02.操作系统/15.高级页表.html",redirect:"/pages/165f2d/"},{name:"v-14654b08",path:"/pages/174348/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-14654b08").then(t)}},{path:"/pages/174348/index.html",redirect:"/pages/174348/"},{path:"/01.开发/05.系统架构/02.操作系统/09.内存API.html",redirect:"/pages/174348/"},{name:"v-72ba3a16",path:"/pages/d34e64/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-72ba3a16").then(t)}},{path:"/pages/d34e64/index.html",redirect:"/pages/d34e64/"},{path:"/01.开发/05.系统架构/02.操作系统/12.空闲空间管理.html",redirect:"/pages/d34e64/"},{name:"v-35052366",path:"/pages/fe36b0/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-35052366").then(t)}},{path:"/pages/fe36b0/index.html",redirect:"/pages/fe36b0/"},{path:"/01.开发/05.系统架构/02.操作系统/14.快表.html",redirect:"/pages/fe36b0/"},{name:"v-170e5b70",path:"/pages/23b20c/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-170e5b70").then(t)}},{path:"/pages/23b20c/index.html",redirect:"/pages/23b20c/"},{path:"/01.开发/05.系统架构/02.操作系统/08.地址空间.html",redirect:"/pages/23b20c/"},{name:"v-4bf70beb",path:"/pages/65f57a/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-4bf70beb").then(t)}},{path:"/pages/65f57a/index.html",redirect:"/pages/65f57a/"},{path:"/01.开发/05.系统架构/02.操作系统/16.页面交换.html",redirect:"/pages/65f57a/"},{name:"v-5b71b852",path:"/pages/aeb7cb/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-5b71b852").then(t)}},{path:"/pages/aeb7cb/index.html",redirect:"/pages/aeb7cb/"},{path:"/01.开发/05.系统架构/02.操作系统/17.交换策略.html",redirect:"/pages/aeb7cb/"},{name:"v-4e18d034",path:"/pages/9f0f28/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-4e18d034").then(t)}},{path:"/pages/9f0f28/index.html",redirect:"/pages/9f0f28/"},{path:"/01.开发/05.系统架构/02.操作系统/18.完整VM系统.html",redirect:"/pages/9f0f28/"},{name:"v-7f9d059f",path:"/pages/12de46/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-7f9d059f").then(t)}},{path:"/pages/12de46/index.html",redirect:"/pages/12de46/"},{path:"/01.开发/07.云原生/01.容器化技术/01.Docker入门教程.html",redirect:"/pages/12de46/"},{name:"v-476ed16d",path:"/pages/4f7ea8/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-476ed16d").then(t)}},{path:"/pages/4f7ea8/index.html",redirect:"/pages/4f7ea8/"},{path:"/02.工具/01.版本控制/01.Git Commit 之道：规范化 Commit Message 写作指南.html",redirect:"/pages/4f7ea8/"},{name:"v-3a3276c2",path:"/pages/992deb/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-3a3276c2").then(t)}},{path:"/pages/992deb/index.html",redirect:"/pages/992deb/"},{path:"/02.工具/01.版本控制/02.Git教程.html",redirect:"/pages/992deb/"},{name:"v-279b57f8",path:"/pages/031ffb/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-279b57f8").then(t)}},{path:"/pages/031ffb/index.html",redirect:"/pages/031ffb/"},{path:"/02.工具/01.版本控制/03.Github搜索技巧.html",redirect:"/pages/031ffb/"},{name:"v-0c700bb1",path:"/pages/50ca39/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-0c700bb1").then(t)}},{path:"/pages/50ca39/index.html",redirect:"/pages/50ca39/"},{path:"/02.工具/02.网络工具/01.WireGuard组网教程.html",redirect:"/pages/50ca39/"},{name:"v-2472c4c6",path:"/pages/975871/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-2472c4c6").then(t)}},{path:"/pages/975871/index.html",redirect:"/pages/975871/"},{path:"/02.工具/02.网络工具/02.SSH教程.html",redirect:"/pages/975871/"},{name:"v-509f409b",path:"/pages/0fc47a/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-509f409b").then(t)}},{path:"/pages/0fc47a/index.html",redirect:"/pages/0fc47a/"},{path:"/02.工具/03.开发工具/01.Shell教程.html",redirect:"/pages/0fc47a/"},{name:"v-1a482803",path:"/pages/e7b5a5/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-1a482803").then(t)}},{path:"/pages/e7b5a5/index.html",redirect:"/pages/e7b5a5/"},{path:"/02.工具/03.开发工具/03.Vim教程.html",redirect:"/pages/e7b5a5/"},{name:"v-4b74d0db",path:"/pages/df386a/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-4b74d0db").then(t)}},{path:"/pages/df386a/index.html",redirect:"/pages/df386a/"},{path:"/03.学习笔记/04.闲杂文章/01.AI时代下的GPU生存工具包：每个开发人员必须了解的最基本知识.html",redirect:"/pages/df386a/"},{name:"v-59070e48",path:"/pages/608406/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-59070e48").then(t)}},{path:"/pages/608406/index.html",redirect:"/pages/608406/"},{path:"/04.生活杂谈/01.随写编年/02.2023年/01.雪韵初见·南京初雪.html",redirect:"/pages/608406/"},{name:"v-72ab0e2f",path:"/pages/04404f/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-72ab0e2f").then(t)}},{path:"/pages/04404f/index.html",redirect:"/pages/04404f/"},{path:"/05.资源收藏/01.实用网站/02.镜像.html",redirect:"/pages/04404f/"},{name:"v-3bd47188",path:"/pages/a0354f/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-3bd47188").then(t)}},{path:"/pages/a0354f/index.html",redirect:"/pages/a0354f/"},{path:"/04.生活杂谈/01.随写编年/01.年终总结/01.我的2023.html",redirect:"/pages/a0354f/"},{name:"v-08ac2779",path:"/pages/e6b9d0/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-08ac2779").then(t)}},{path:"/pages/e6b9d0/index.html",redirect:"/pages/e6b9d0/"},{path:"/05.资源收藏/01.实用网站/01.系统相关.html",redirect:"/pages/e6b9d0/"},{name:"v-6cf98a73",path:"/pages/0070df/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-6cf98a73").then(t)}},{path:"/pages/0070df/index.html",redirect:"/pages/0070df/"},{path:"/05.资源收藏/02.优秀项目/01.算法实现模版.html",redirect:"/pages/0070df/"},{name:"v-47fabeb6",path:"/pages/7634df/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-47fabeb6").then(t)}},{path:"/pages/7634df/index.html",redirect:"/pages/7634df/"},{path:"/05.资源收藏/02.优秀项目/02.设计模式实现模版.html",redirect:"/pages/7634df/"},{name:"v-3a888ae4",path:"/pages/9fd05a/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-3a888ae4").then(t)}},{path:"/pages/9fd05a/index.html",redirect:"/pages/9fd05a/"},{path:"/05.资源收藏/02.优秀项目/03.Go优秀资源.html",redirect:"/pages/9fd05a/"},{name:"v-4a02579b",path:"/about/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-4a02579b").then(t)}},{path:"/about/index.html",redirect:"/about/"},{path:"/07.关于/01.about.html",redirect:"/about/"},{name:"v-30e085c9",path:"/friend/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-30e085c9").then(t)}},{path:"/friend/index.html",redirect:"/friend/"},{path:"/08.友情链接/01.友情链接.html",redirect:"/friend/"},{name:"v-0e8002ab",path:"/archives/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-0e8002ab").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-1e268ac6",path:"/pages/c81c74/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-1e268ac6").then(t)}},{path:"/pages/c81c74/index.html",redirect:"/pages/c81c74/"},{path:"/02.工具/03.开发工具/02.Tmux教程.html",redirect:"/pages/c81c74/"},{name:"v-3fce6544",path:"/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-3fce6544").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-1e09ee2b",path:"/tags/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-1e09ee2b").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-6097fb0b",path:"/categories/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-6097fb0b").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{path:"*",component:bl}],yl={title:"",description:"",base:"/",headTags:[["link",{rel:"icon",href:"/img/favicon.ico"}],["meta",{name:"keywords",content:"python,Go,C++,git,github,markdown,database,mysql,redis"}],["meta",{name:"baidu-site-verification",content:"7F55weZDDc"}],["meta",{name:"theme-color",content:"#11a8cd"}]],pages:[{title:"编程语言",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.开发/01.编程语言",description:"编程语言"}},title:"编程语言",permalink:"/develop/language/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T14:08:35.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.sub01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80.html",relativePath:"00.目录页/01.sub01.编程语言.md",key:"v-dd6d37e4",path:"/develop/language/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:27:24",lastUpdatedTimestamp:1700821644e3},{title:"开发框架",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.开发/02.开发框架",description:"开发框架"}},title:"开发框架",permalink:"/develop/framework/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T14:10:02.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.sub02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6.html",relativePath:"00.目录页/01.sub02.开发框架.md",key:"v-3c5cb278",path:"/develop/framework/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:27:24",lastUpdatedTimestamp:1700821644e3},{title:"数据存储",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.开发/04.数据存储",description:"数据存储"}},title:"数据存储",permalink:"/develop/storage/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T14:10:00.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.sub04.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8.html",relativePath:"00.目录页/01.sub04.数据存储.md",key:"v-1139bec1",path:"/develop/storage/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:27:24",lastUpdatedTimestamp:1700821644e3},{title:"数据结构与算法",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.开发/03.数据结构与算法",description:"数据结构与算法"}},title:"数据结构与算法",permalink:"/develop/algorithm/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T14:10:05.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.sub03.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html",relativePath:"00.目录页/01.sub03.数据结构与算法.md",key:"v-16a9958e",path:"/develop/algorithm/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:27:24",lastUpdatedTimestamp:1700821644e3},{title:"系统架构",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.开发/05.系统架构",description:"系统架构"}},title:"系统架构",permalink:"/develop/system/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T14:10:02.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.sub05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.html",relativePath:"00.目录页/01.sub05.系统架构.md",key:"v-e6d91580",path:"/develop/system/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:27:24",lastUpdatedTimestamp:1700821644e3},{title:"计算机网络",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.开发/06.计算机网络",description:"计算机网络"}},title:"计算机网络",permalink:"/develop/network/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T14:10:02.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.sub06.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html",relativePath:"00.目录页/01.sub06.计算机网络.md",key:"v-5df34b59",path:"/develop/network/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:27:24",lastUpdatedTimestamp:1700821644e3},{title:"云原生",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.开发/07.云原生",description:"云原生"}},title:"云原生",permalink:"/develop/cloud/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T14:10:02.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.sub07.%E4%BA%91%E5%8E%9F%E7%94%9F.html",relativePath:"00.目录页/01.sub07.云原生.md",key:"v-0c3eb4e8",path:"/develop/cloud/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:27:24",lastUpdatedTimestamp:1700821644e3},{title:"开发",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.开发",imgUrl:"/img/web.png",description:"技术文章"}},title:"开发",date:"2020-03-11T21:50:53.000Z",permalink:"/develop/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.%E5%BC%80%E5%8F%91.html",relativePath:"00.目录页/01.开发.md",key:"v-aa898bb4",path:"/develop/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/23, 11:20:11",lastUpdatedTimestamp:1700709611e3},{title:"版本控制",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"02.工具/01.版本控制",description:"版本控制相关文章"}},title:"版本控制",permalink:"/tool/vcs/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T15:36:50.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.sub01%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6.html",relativePath:"00.目录页/02.sub01版本控制.md",key:"v-1e46750d",path:"/tool/vcs/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:39:24",lastUpdatedTimestamp:1700822364e3},{title:"网络工具",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"02.工具/02.网络工具",description:"网络工具介绍"}},title:"网络工具",permalink:"/tool/network/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T15:36:49.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.sub02%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7.html",relativePath:"00.目录页/02.sub02网络工具.md",key:"v-ccee1a68",path:"/tool/network/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:39:24",lastUpdatedTimestamp:1700822364e3},{title:"工具",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"02.工具",imgUrl:"/img/web.png",description:"工具使用教程"}},title:"工具",permalink:"/tool/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-23T10:57:08.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.%E5%B7%A5%E5%85%B7.html",relativePath:"00.目录页/02.工具.md",key:"v-288e6001",path:"/tool/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:39:24",lastUpdatedTimestamp:1700822364e3},{title:"学术搬砖",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"03.学习笔记/学术搬砖",description:"学术搬砖"}},title:"学术搬砖",permalink:"/note/paper/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-23T10:58:20.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.sub01.%E5%AD%A6%E6%9C%AF%E6%90%AC%E7%A0%96.html",relativePath:"00.目录页/03.sub01.学术搬砖.md",key:"v-f15f1ada",path:"/note/paper/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 19:47:19",lastUpdatedTimestamp:1700826439e3},{title:"学习笔记",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"03.学习笔记",imgUrl:"/img/other.png",description:"论文或者讲座等笔记"}},title:"学习笔记",permalink:"/note/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-23T10:58:20.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html",relativePath:"00.目录页/03.学习笔记.md",key:"v-6668a861",path:"/note/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:39:24",lastUpdatedTimestamp:1700822364e3},{title:"实践项目",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"03.学习笔记/02.实践项目",description:"实践项目"}},title:"实践项目",permalink:"/note/project/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-23T10:58:20.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.sub02.%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE.html",relativePath:"00.目录页/03.sub02.实践项目.md",key:"v-a45883c2",path:"/note/project/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 19:47:19",lastUpdatedTimestamp:1700826439e3},{title:"随写编年",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"04.生活杂谈/01.随写编年",description:"记录每年的日常"}},title:"随写编年",permalink:"/life/year/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T16:04:42.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.sub01.%E9%9A%8F%E5%86%99%E7%BC%96%E5%B9%B4.html",relativePath:"00.目录页/04.sub01.随写编年.md",key:"v-10f2e34e",path:"/life/year/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:39:24",lastUpdatedTimestamp:1700822364e3},{title:"学习笔记",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"03.学习笔记/03.讲座研讨",description:"讲座研讨"}},title:"学习笔记",permalink:"/note/lecture/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-23T10:58:20.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.sub03.%E8%AE%B2%E5%BA%A7%E7%A0%94%E8%AE%A8.html",relativePath:"00.目录页/03.sub03.讲座研讨.md",key:"v-bd714042",path:"/note/lecture/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 19:47:19",lastUpdatedTimestamp:1700826439e3},{title:"旅行日记",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"04.生活杂谈/03.旅行日记",description:"记录旅行"}},title:"旅行日记",permalink:"/life/travel/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T16:04:40.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.sub03.%E6%97%85%E8%A1%8C%E6%97%A5%E8%AE%B0.html",relativePath:"00.目录页/04.sub03.旅行日记.md",key:"v-0dd17318",path:"/life/travel/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:45:17",lastUpdatedTimestamp:1700822717e3},{title:"文艺时光",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"04.生活杂谈/04.文艺时光",description:"记录书影音"}},title:"文艺时光",permalink:"/life/art/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T16:18:37.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.sub04.%E6%96%87%E8%89%BA%E6%97%B6%E5%85%89.html",relativePath:"00.目录页/04.sub04.文艺时光.md",key:"v-466444aa",path:"/life/art/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:45:17",lastUpdatedTimestamp:1700822717e3},{title:"追忆青春",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"04.生活杂谈/02.追忆青春",description:"追忆青春"}},title:"追忆青春",permalink:"/life/youth/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T16:04:42.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.sub02.%E8%BF%BD%E5%BF%86%E9%9D%92%E6%98%A5.html",relativePath:"00.目录页/04.sub02.追忆青春.md",key:"v-1f12d3c2",path:"/life/youth/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:45:17",lastUpdatedTimestamp:1700822717e3},{title:"烹调分享",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"04.生活杂谈/05.烹调分享",description:"烹调分享"}},title:"烹调分享",permalink:"/life/cook/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T16:18:37.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.sub05.%E7%83%B9%E8%B0%83%E5%88%86%E4%BA%AB.html",relativePath:"00.目录页/04.sub05.烹调分享.md",key:"v-3f115c5a",path:"/life/cook/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:45:17",lastUpdatedTimestamp:1700822717e3},{title:"生活杂谈",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"04.生活杂谈",imgUrl:"/img/other.png",description:"记录生活"}},title:"生活杂谈",permalink:"/life/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T15:43:02.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88.html",relativePath:"00.目录页/04.生活杂谈.md",key:"v-486047ee",path:"/life/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:39:24",lastUpdatedTimestamp:1700822364e3},{title:"实用网站",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"05.资源收藏/01.实用网站",description:"实用网站收集"}},title:"实用网站",permalink:"/resource/website/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-23T11:18:33.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/05.sub01%E5%AE%9E%E7%94%A8%E7%BD%91%E7%AB%99.html",relativePath:"00.目录页/05.sub01实用网站.md",key:"v-49e30f62",path:"/resource/website/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 19:47:19",lastUpdatedTimestamp:1700826439e3},{title:"优秀项目",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"05.资源收藏/02.优秀项目",description:"优秀项目汇总"}},title:"优秀项目",permalink:"/resource/project/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-23T11:18:33.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/05.sub02%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE.html",relativePath:"00.目录页/05.sub02优秀项目.md",key:"v-0295a8c0",path:"/resource/project/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 19:47:19",lastUpdatedTimestamp:1700826439e3},{title:"开发工具",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"02.工具/03.开发工具",description:"开发工具介绍"}},title:"开发工具",permalink:"/tool/develop/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T15:36:52.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.sub03.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7.html",relativePath:"00.目录页/02.sub03.开发工具.md",key:"v-48703727",path:"/tool/develop/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:39:24",lastUpdatedTimestamp:1700822364e3},{title:"面试",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"06.更多/01.面试"}},title:"面试",permalink:"/more/interview/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T16:24:20.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/06.sub01.%E9%9D%A2%E8%AF%95.html",relativePath:"00.目录页/06.sub01.面试.md",key:"v-0d1f7517",path:"/more/interview/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:45:17",lastUpdatedTimestamp:1700822717e3},{title:"vite构建工具介绍",frontmatter:{title:"vite构建工具介绍",date:"2023-11-12T22:52:13.000Z",tags:["Vite"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/03e0a8/",categories:["开发","开发框架","前端"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/01.%E5%89%8D%E7%AB%AF/01.Vite%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D.html",relativePath:"01.开发/02.开发框架/01.前端/01.Vite构建工具介绍.md",key:"v-7f8094fc",path:"/pages/03e0a8/",headers:[{level:2,title:"1 构建工具",slug:"_1-构建工具",normalizedTitle:"1 构建工具",charIndex:2},{level:3,title:"1.1 什么是构建工具",slug:"_1-1-什么是构建工具",normalizedTitle:"1.1 什么是构建工具",charIndex:13},{level:3,title:"1.2 主流构建工具",slug:"_1-2-主流构建工具",normalizedTitle:"1.2 主流构建工具",charIndex:1058},{level:3,title:"1.3 vite相较于webpack的优势",slug:"_1-3-vite相较于webpack的优势",normalizedTitle:"1.3 vite相较于webpack的优势",charIndex:1172},{level:2,title:"2 vite启动项目初体验",slug:"_2-vite启动项目初体验",normalizedTitle:"2 vite启动项目初体验",charIndex:2555},{level:3,title:"2.1 你必须要理解的vite脚手架和vite",slug:"_2-1-你必须要理解的vite脚手架和vite",normalizedTitle:"2.1 你必须要理解的vite脚手架和vite",charIndex:2573},{level:3,title:"2.2 vite开箱即用",slug:"_2-2-vite开箱即用",normalizedTitle:"2.2 vite开箱即用",charIndex:3123},{level:3,title:"2.3 vite的预加载",slug:"_2-3-vite的预加载",normalizedTitle:"2.3 vite的预加载",charIndex:3568},{level:3,title:"2.4 vite配置文件处理细节",slug:"_2-4-vite配置文件处理细节",normalizedTitle:"2.4 vite配置文件处理细节",charIndex:4447},{level:3,title:"2.5 vue环境变量配置",slug:"_2-5-vue环境变量配置",normalizedTitle:"2.5 vue环境变量配置",charIndex:4741},{level:2,title:"3 vite 原理篇",slug:"_3-vite-原理篇",normalizedTitle:"3 vite 原理篇",charIndex:6801},{level:3,title:"3.1 vite是怎么让浏览器可以识别.vue文件呢",slug:"_3-1-vite是怎么让浏览器可以识别-vue文件呢",normalizedTitle:"3.1 vite是怎么让浏览器可以识别.vue文件呢",charIndex:6816},{level:3,title:"3.2 使用path.resolve的原因",slug:"_3-2-使用path-resolve的原因",normalizedTitle:"3.2 使用path.resolve的原因",charIndex:7452},{level:2,title:"4 vite与css",slug:"_4-vite与css",normalizedTitle:"4 vite与css",charIndex:7996},{level:3,title:"4.1 在vite中处理css",slug:"_4-1-在vite中处理css",normalizedTitle:"4.1 在vite中处理css",charIndex:8011},{level:3,title:"4.2 css文件类型",slug:"_4-2-css文件类型",normalizedTitle:"4.2 css文件类型",charIndex:8729},{level:3,title:"4.3 vite.config.js中css配置",slug:"_4-3-vite-config-js中css配置",normalizedTitle:"4.3 vite.config.js中css配置",charIndex:10064},{level:4,title:"4.3.1 module篇",slug:"_4-3-1-module篇",normalizedTitle:"4.3.1 module篇",charIndex:10140},{level:4,title:"4.3.2 preprocessorOption篇",slug:"_4-3-2-preprocessoroption篇",normalizedTitle:"4.3.2 preprocessoroption篇",charIndex:11017},{level:4,title:"4.3.2 postcss篇",slug:"_4-3-2-postcss篇",normalizedTitle:"4.3.2 postcss篇",charIndex:11469},{level:2,title:"5 vite相关知识",slug:"_5-vite相关知识",normalizedTitle:"5 vite相关知识",charIndex:12117},{level:3,title:"5.1 vite加载静态资源",slug:"_5-1-vite加载静态资源",normalizedTitle:"5.1 vite加载静态资源",charIndex:12132},{level:3,title:"5.2 vite在生产环境中对静态资源的处理",slug:"_5-2-vite在生产环境中对静态资源的处理",normalizedTitle:"5.2 vite在生产环境中对静态资源的处理",charIndex:12748},{level:3,title:"5.3 vite常用插件",slug:"_5-3-vite常用插件",normalizedTitle:"5.3 vite常用插件",charIndex:13312},{level:4,title:"5.3.1 vite-aliases",slug:"_5-3-1-vite-aliases",normalizedTitle:"5.3.1 vite-aliases",charIndex:13400},{level:4,title:"5.3.2 vite-plugin-html",slug:"_5-3-2-vite-plugin-html",normalizedTitle:"5.3.2 vite-plugin-html",charIndex:15411},{level:4,title:"5.3.3 vite-plugin-mock",slug:"_5-3-3-vite-plugin-mock",normalizedTitle:"5.3.3 vite-plugin-mock",charIndex:17533},{level:4,title:"5.3.4 其他插件",slug:"_5-3-4-其他插件",normalizedTitle:"5.3.4 其他插件",charIndex:17906}],headersStr:"1 构建工具 1.1 什么是构建工具 1.2 主流构建工具 1.3 vite相较于webpack的优势 2 vite启动项目初体验 2.1 你必须要理解的vite脚手架和vite 2.2 vite开箱即用 2.3 vite的预加载 2.4 vite配置文件处理细节 2.5 vue环境变量配置 3 vite 原理篇 3.1 vite是怎么让浏览器可以识别.vue文件呢 3.2 使用path.resolve的原因 4 vite与css 4.1 在vite中处理css 4.2 css文件类型 4.3 vite.config.js中css配置 4.3.1 module篇 4.3.2 preprocessorOption篇 4.3.2 postcss篇 5 vite相关知识 5.1 vite加载静态资源 5.2 vite在生产环境中对静态资源的处理 5.3 vite常用插件 5.3.1 vite-aliases 5.3.2 vite-plugin-html 5.3.3 vite-plugin-mock 5.3.4 其他插件",content:'# 1 构建工具\n\n\n# 1.1 什么是构建工具\n\n> 浏览器它只认识html，css，js\n\n企业级项目里都可能具备哪些功能？\n\n 1. typescript：使用tsc工具将ts代码转换为js代码；\n 2. React/Vue：安装react-compiler/vue-compiler，将我们写的jsx文件或者.vue文件转换为render函数；\n 3. less/sass/postcss/component-style：我们有需要安装less-loader,sass-loader等一系列编译工具转换为css代码；\n 4. 语法降级：babel可以将es的新语法转换旧版浏览器可以接受的语法；\n 5. 体积优化：uglifyjs可以将我们的代码进行压缩变成体积更小性能更高的文件。\n\n> 以上稍微改一点，就会很麻烦，所以我们希望有一个构建工具可以将以上工具全部集成到一起，实现上述功能，我们只需要关注我们写的代码即可。即构建工具可以帮我们自动去tsc，react-comiler，less，babel，uglifyjs全部走一遍，让我们不用每次关心我们的代码在浏览器运行。\n\n> 打包：将我们写的浏览器不认识的代码，交给构建工具进行编译处理的过程就叫做打包，打包完成以后会给我们一个浏览器可以认识的文件。\n\n构建工具承担了以下脏活累活：\n\n 1. 模块化开发支持：支持直接从node_modules里引入代码 + 多种模块化支持\n 2. 处理代码兼容性：比如babel语法降级，less，ts语法转换（不是构建工具做的，构建工具将这些语法对应的处理工具集成进来自动化处理）\n 3. 提高项目性能：压缩文件，代码分割\n 4. 优化开发体验：\n    * 构建工具会帮你自动监听文件的变化，当文件变化以后自动帮你调用对应的集成工具进行重新打包，然后再浏览器重新运行（整个过程叫做热更新，hot replacement）\n    * 开发服务器：跨域的问题，用react-cli create-react-element vue-cli解决跨域的问题\n\n> 我们只需要首次给构建工具提供一个配置文件（这个配置文件也不是必须的，没有它也会默认处理），有了集成的配置文件以后，我们就可以在下次需要更新的时候调用一次对应的命令即可，如果再结合热更新，我们就更加不需要管任何东西，这就是构建工具去做的事情，它让我们不用关心生产的带啊吗也不用关心代码如何在浏览器运行，只需要关心我们的开发怎么写的爽怎么写就好了。\n\n\n# 1.2 主流构建工具\n\n * webpack\n * vite\n * parcel\n * esbuild\n * rollup\n * grunt\n * gulp\n\n> 国内主流还是webpack，vite和esbuild。\n\n\n# 1.3 vite相较于webpack的优势\n\n> 然而，当我们开始构建越来越大型的应用时，需要处理的 JavaScript 代码量也呈指数级增长。包含数千个模块的大型项目相当普遍。基于 JavaScript 开发的工具就会开始遇到性能瓶颈：==通常需要很长时间（甚至是几分钟！）才能启动开发服务器，即使使用模块热替换（HMR），文件修改后的效果也需要几秒钟才能在浏览器中反映出来。==如此循环往复，迟钝的反馈会极大地影响开发者的开发效率和幸福感。\n\n起因：我们的项目越大，构建工具（webpack）所要处理的js代码就越多【跟webpack的一个构建过程（工作流程有关）】\n\n造成的结果：构建工具需要很长时间才能启动开发服务器（把项目跑起来）\n\nyarn start\nyarn dev\n\nnpm run dev\nnpm run start\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n> webpack不能改，如果要改，则会动到webpack的大动脉。\n> \n> // 这段代码最终回到浏览器里去运行\n> const lodash = require("lodash"); // commonjs 规范\n> import Vue from "vue"; // es6 module\n> \n> // webpack是允许我们这么写的，webpack会这样转换\n> const lodash = webpack_require("loadsh");\n> const Vue = webpack_require("vue");\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> \n> webpack的编译原理，AST抽象语法分析的工具，分析出js文件有哪些导入导出操作\n> \n> 构建工具是运行在服务端的\n> \n> (function(modules) {\n>     function webpack_require() {}\n>     // 入口是index.js\n>     // 通过webpack的配置文件得来的：webpack.config.js ./src/index.js\n>     modules[entry](webpack_require);\n> }, ({\n>     "index.js": (webpack_require) => {\n>         const lodash = webpack_require("lodash");\n> \t\tconst Vue = webpack_require("vue");\n>     }\n> }))\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> \n> \n> 因为webpack支持模块化，它一开始就必须要统一模块化代码，所以意味着它需要将所有的依赖读一遍。\n> \n> vite会不会直接把webpack干翻？vite是基于es modules的，侧重点不一样，webpack更多的关注兼容性，而vite关注浏览器端的开发体验。\n\n\n# 2 vite启动项目初体验\n\n\n# 2.1 你必须要理解的vite脚手架和vite\n\n> vite官网搭建vite项目文档教程：https://cn.vitejs.dev/guide/#scaffolding-your-first-vite-project\n\n比如我们敲了yarn create vite\n\n 1. 帮我们全局安装了一个东西：create-vite（vite的脚手架）\n 2. 直接运行这个create-vite bin目录下的一个执行配置\n\n误区：认为官网中使用对应的yarn create构建项目的过程也是vite在做的事情\n\n> 我们之前接触过vue-cli，create-vite和vite的关系是：create-vite内置了vite。使用vue-cli会内置webpack\n\n先学习的就是vite，暂时不会使用yarn create vite my-vue-app --template vue。vue-cli可以和webpack分的很清楚。\n\n> vue-cli给我们提供已经精装修的模板。\n> \n> 我们自己搭建一个项目：下载vite，vue，post-css，less，label\n> \n> vue-cli/create-vite给了一套精装修的模板：什么都下好了，并且给你做了最佳实践的配置\n\n\n# 2.2 vite开箱即用\n\n> 开箱即用（out of box）：不需要做任何额外的配置就可以使用vite来帮你处理构建工作\n\n在默认情况下，我们的esmodule去导入资源的时候，要么是绝对路径，要么是相对路径，既然我们现在的最佳实践是node_modules，那么为什么es官方在我们导入非绝对路径和非相对路径的资源的时候不默认帮我们搜寻node_modules？\n\n> 浏览器环境中的安全性原因是一个主要考虑因素。如果浏览器默认搜索node_modules目录，那么恶意的代码可能会利用这个功能访问和执行不受信任的模块代码，从而导致安全风险。通过限制导入路径，浏览器可以更好地控制模块的来源和访问权限。\n> \n> 另外，性能也是一个重要的考虑因素。浏览器默认只支持绝对路径和相对路径的导入，可以在编译时静态解析模块依赖关系，从而提高加载和执行模块的效率。如果浏览器要搜索node_modules目录，可能需要进行额外的文件系统操作和路径解析，增加了加载模块的时间和资源消耗。\n\n\n# 2.3 vite的预加载\n\nimport _ from "lodash"; // lodash可能也import了其他的东西\n\nimport _vite_cjsImport0_lodash from "/node_modules/.vite/deps/loadsh.js?v=ebe57916";\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n在处理的过程中如果说看到了有非绝对路径或者相对路径的引用，则会尝试开启路径补全\n\n找寻依赖的过程是自当前目录依次向上查找的过程，直到搜寻到根目录或者搜寻到对应依赖为止 /user/node_modules/lodash, ../\n\n> 区分生产环境和开发环境：\n> \n> yarn dev ----\x3e 开发（每次依赖预构建所重新构建的相对路径都是正确的）\n> \n> vite会全权交给一个叫做rollup的库去完成生产环境的打包\n> \n> 缓存 ----\x3e\n> \n> 实际上vite在考虑另外一个问题的时候就顺便把这个问题解决了\n> \n> commonjs 规范的导出 module.exports\n> \n> 有的包是以commonjs规范的格式导出 axios\n> \n> 依赖预构建：首先vite会找到对应的依赖，然后调用esbuild（对js语法进行处理的一个库），将其他规范的代码转换成esmodule规范，然后放到当前目录下的node_modules/.vite/deps，同时对esmodule规范的各个模块进行统一集成\n\n所以它解决了3个问题：\n\n 1. 不同的第三方包会有不同的导出格式（这个是vite没法约束人家的事情）\n 2. 对路径的处理上可以直接使用.vite/deps，方便路径重写\n 3. 叫做网络多包传输的性能问题（也是原生esmodule规范不敢支持node_modules的原因之一），有了依赖预构建以后无论它有多少的额外的export和import，vite都会尽可能的将他们集成最后只生成一个或者几个模块\n\nvite.config.js === webpack.config.js\n\n\n# 2.4 vite配置文件处理细节\n\n 1. vite配置文件的语法提示\n    \n    1. 如果你使用的是webstorm，那你可以得到很好的语法补全\n    2. 如果你使用的是vscode或者其他编辑器，则需要做一些特殊处理\n\n 2. 关于环境的处理\n    \n    > 过去我们使用webpack的时候，我们需要区分配置文件的一个环境：\n    > \n    >  * webpack.dev.config\n    >  * webpack.prod.config\n    >  * webpack.base.config\n    >  * webpackmerge\n\n\n# 2.5 vue环境变量配置\n\n> 环境变量：会根据当前的代码环境产生值的变化的变量就叫做环境变量\n> \n> 代码环境：\n> \n>  1. 开发环境：开发环境是开发人员进行软件开发和调试的地方。在开发环境中，开发人员可以进行代码编写、调试、测试和验证。这个环境通常是本地的开发机器，开发人员可以通过使用 Vite 的开发服务器（dev server）来提供实时的重新加载（live reloading）和模块热替换（hot module replacement）功能，以便更快地进行开发和调试。\n>  2. 测试环境：测试环境是用于进行软件测试的环境。在测试环境中，开发人员和测试人员可以对软件进行不同类型的测试，例如单元测试、集成测试和端到端测试。在测试环境中，可以使用 Vite 构建工具生成测试所需的构建文件，并在模拟的环境中进行测试。\n>  3. 预发布环境：预发布环境是在软件发布之前进行最后测试和验证的环境。在预发布环境中，可以对软件进行更全面的测试，以确保它符合发布的质量标准。这个环境通常是一个类似于生产环境的环境，但在实际发布之前，可能会使用一些模拟数据和模拟系统进行测试。\n>  4. 灰度环境：灰度环境是在软件发布后逐步向用户群体推出新功能或更新的环境。在灰度环境中，新的软件版本或功能将部署到一小部分用户中，以便测试其稳定性和兼容性。这个环境类似于生产环境，但只有一部分用户能够访问新的功能或更新。\n>  5. 生产环境：生产环境是最终向用户提供服务的环境。在生产环境中，已经通过了开发、测试、预发布和灰度环境的验证，并且已准备好为最终用户提供稳定、可靠的服务。在生产环境中，通常会使用 Vite 构建工具生成用于部署的生产级别的构建文件，并进行必要的优化和压缩，以提供最佳的性能和用户体验。\n\n我们在和后端同学对接的时候，前端在开发环境中请求的后端API地址和生产环境请求的后端API地址是一个吗？肯定不是一个\n\n * 开发和测试：http://test.api/\n * 生产：https://api/\n\n> 在vite中的环境变量处理：\n> \n> vite内置了dotenv这个第三方库，会自动读取.env文件，并解析这个文件中的对应的环境变量，并将其注入到process对象下（但是vite考虑到和其他配置的一些冲突问题，它不会直接注入到process对象下）\n> \n> 涉及到vite.config.js中的一些配置：\n> \n>  * root\n>  * envDir：用来配置当前环境变量的文件地址\n> \n> vite给我们提供了一些补偿措施：我们可以调用vite的loadEnv来手动确认env文件\n> \n> porcess.cwd方法：返回node进程的工作目录\n\n> 小知识：为什么vite.config.js可以书写成esmodule的形式，这是因为vite他在读取这个vite.config.js的时候会率先node去解析文件语法，如果发现你是esmodule规范则会直接将你的esmodule规范替换成common js规范\n\n> .env：所有环境都需要用到的环境变量\n> \n> .env.development：开发环境需要用到的环境变量（默认情况下vite将我们的开发环境取名为development）\n> \n> .env.production：生产环境需要用到的环境变量（默认情况下vite将我们的生产环境取名为production）\n> \n> yarn dev --mode development 会将mode设置为development传递进来\n> \n> 当我们调用loadenv的时候，它会做如下几件事情：\n> \n>  1. 直接找到.env文件不解释，并解析其中的环境变量，放到一个对象里\n> \n>  2. 会将传进来的mode这个变量的值进行拼接：env.development，并根据我们提供的目录去取对应配置文件并进行解析，并放进一个对象\n> \n>  3. 我们可以理解为\n>     \n>     const baseEnvConfig = 读取.env配置\n>     const modeEnvConfig = 读取env相关配置\n>     const lastEnvConfig = {...baseEnvConfig, ...modeEnvConfig}\n>     \n>     \n>     1\n>     2\n>     3\n>     \n>     1\n>     2\n>     3\n>     \n\n如果是客户端，vite会将对应的环境变量注入到import.meta.env里去\n\nvite做了一个拦截，为了防止我们将隐私性的变量直接送到import.meta.env中，所以做了一层拦截，如果你的环境变量不是以VITE开头的，他就不会帮你注入到客户端中去，如果我们想要更改这个前缀，可以去使用envPrefix配置。\n\n\n# 3 vite 原理篇\n\n\n# 3.1 vite是怎么让浏览器可以识别.vue文件呢\n\nVite 是一个现代化的前端构建工具，它使用了一种名为单文件组件（Single File Components）的技术来让浏览器能够识别和加载 .vue 文件。\n\n在传统的前端开发中，浏览器无法直接识别和加载 .vue 文件，因为 .vue 文件包含了 HTML、CSS 和 JavaScript 代码，而浏览器只能识别和执行 JavaScript 文件。\n\nVite 利用了构建工具和打包器的能力，在开发阶段将 .vue 文件转换为浏览器可以识别的形式。它借助特定的编译器（如 Vue 编译器）将 .vue 文件的模板、样式和脚本部分分别提取出来，并将它们转换为浏览器可以理解的代码。\n\n具体地说，Vite 使用了名为 "vue-loader" 的工具来解析和转换 .vue 文件。这个工具会解析 .vue 文件的内容，提取出其中的模板、样式和脚本，并将它们转化为独立的代码块。然后，Vite 使用浏览器原生的 ES 模块导入机制，通过 <script type="module"> 标签将这些代码块加载到浏览器中。\n\n当浏览器遇到 <script type="module"> 标签时，它会将标签中的 JavaScript 代码作为一个独立的模块加载和执行。Vite 利用这个特性，将 .vue 文件中的模板、样式和脚本部分分别作为独立的模块加载到浏览器中，并在浏览器中动态组合它们，构建出最终的组件。\n\n\n# 3.2 使用path.resolve的原因\n\n> 在使用路径时，尽量使用 path.resolve 方法可以确保路径的可靠性和跨平台性。以下是几个使用 path.resolve 方法的好处：\n> \n>  1. 处理相对路径和绝对路径：path.resolve 方法可以接受多个参数，将它们解析为一个绝对路径。这意味着你可以使用相对路径作为参数，并将其解析为相对于当前工作目录的绝对路径。这对于确定准确的文件路径非常有用。\n>  2. 解决跨平台路径问题：在不同的操作系统中，对于路径分隔符和路径表示法有所差异。使用 path.resolve 方法可以确保生成的路径在不同的操作系统下都是有效的，因为它会自动根据当前操作系统调整路径分隔符和表示法。\n>  3. 处理路径拼接和规范化：path.resolve 方法会将传入的路径片段进行拼接，并返回一个规范化的路径。这意味着它会解析和处理路径中的 ..、. 等相对路径符号，确保生成的路径是规范化的、干净的路径。\n>  4. 确保路径的存在性：使用 path.resolve 方法生成的路径是确保存在的，它不会检查路径是否有效或文件是否存在，但会确保路径的格式正确。这可以帮助你在操作文件系统时提供正确的路径，避免出现错误或异常。\n\n\n# 4 vite与css\n\n\n# 4.1 在vite中处理css\n\n> vite天生就支持对css文件的直接处理\n\n 1. vite在读取到main.js文件中引用到了index.css\n 2. 直接使用fs模块去读取index.css中文件内容\n 3. 直接创建一个style标签，将index.css中文件内容直接copy到style标签里\n 4. 将style标签插入到index.html的head中\n 5. 将css文件中的内容直接替换为js脚本（方便热更新或者css模块化），同时设置Content-Type为js，从而让浏览器以JS脚本的形式来执行该css后缀的文件\n\n> 场景：\n> \n>  * 一个组件最外层的元素类名一般取名： wrapper\n>  * 一个组件最底层的元素类名一般取名：footer\n> \n> 但你取了footer这个名字，别人因为没有看过你这个组件的源代码，也可能去取名footer这个类名，最后可能会导致样式被覆盖（因为类名重复），这就是我们在协同开发很容易出现的问题\n\ncssmodule就是来解决这个问题的：\n\n 1. module.css（module是一种约定，表示需要开启css模块化）\n 2. 他会将你的所有类名进行一定规则的替换（将footer替换为_footer_i22st_1）\n 3. 同时创建一个映射对象{ footer: "_footer_i22st_1"}\n 4. 将替换过后的内容塞进style标签里然后放入到head标签中（能够读到index.html的文件内容）\n 5. 将componentA.module.css内容全部抹除，替换为JS脚本\n 6. 将创建的映射对象在脚本中默认导出\n\n\n# 4.2 css文件类型\n\n>  1. CSS（.css）：CSS 是层叠样式表的标准文件格式，它使用类似于选择器和属性的语法来描述网页的样式。CSS 是前端开发中最常见的样式表语言，浏览器原生支持。\n>  2. LESS（.less）：LESS 是 CSS 的拓展，它引入了变量、嵌套规则、Mixin（混入）等功能，以简化 CSS 的编写和维护。LESS 文件需要在开发阶段通过 LESS 编译器转换为标准的 CSS 文件，然后在浏览器中加载。\n>  3. SCSS/SASS（.scss/.sass）：SCSS（Sassy CSS）和 SASS（Syntactically Awesome Style Sheets）也是 CSS 的拓展，提供了类似 LESS 的功能，如变量、嵌套规则和 Mixin。SCSS 与 SASS 的语法略有不同，但都需要通过编译器将其转换为标准的 CSS 文件。\n\n/* SCSS */\n.container {\n  width: 100%;\n\n  .header {\n    background-color: #333;\n    color: #fff;\n    padding: 10px;\n  }\n\n  .content {\n    padding: 20px;\n\n    p {\n      margin-bottom: 10px;\n    }\n\n    a {\n      color: #f00;\n      text-decoration: none;\n\n      &:hover {\n        text-decoration: underline;\n      }\n    }\n  }\n\n  .footer {\n    background-color: #333;\n    color: #fff;\n    padding: 10px;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n在这个示例中，.container 是最外层的容器选择器，它包含了 .header、.content 和 .footer 子选择器。通过嵌套定义，我们可以更直观地表示这些选择器之间的层次结构。\n\n此外，嵌套定义还可以减少重复代码的编写。在上述示例中，.header 和 .footer 具有相同的背景颜色、文字颜色和内边距，通过嵌套定义，我们只需在父选择器中指定一次即可，避免了重复的样式声明。\n\n另外，嵌套定义还可以方便地应用伪类和伪元素样式。在示例中，嵌套定义了 a 元素的样式，并使用 &:hover 表示其悬停状态下的样式，这样可以更直观地表示选择器之间的关系。\n\n通过使用嵌套定义，我们可以更清晰地组织和维护样式代码，减少了冗余和重复的工作，提高了代码的可读性和可维护性。\n\n\n# 4.3 vite.config.js中css配置\n\n> 在vite.config.js中我们通过css属性去控制整个vite对于css的处理行为\n\n# 4.3.1 module篇\n\ncss: { \n    \n    modules: { \n    }\n}\ncss: { // 对css的行为进行配置\n  // modules配置最终会丢给postcss modules\n  modules: { // 是对css模块化的默认行为进行覆盖\n    localsConvention: \'camelCase\', // 修改生成的配置对象的 key 的展示形式为驼峰命名\n    scopeBehaviour: \'global\', // 配置当前的模块化行为为全局化\n    generateScopedName: \'[name]__[local]___[hash:base64:5]\', // 指定生成的类名的命名规则\n    hashPrefix: \'my-app\', // 生成的 hash 的前缀\n    globalModulePaths: [\'path/to/global/styles\'] // 不参与 CSS 模块化的路径\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * localsConvention：修改生成的配置对象的key的展示形式（驼峰还是中划线形式）\n * scopeBehaviour：配置当前的模块化行为是模块化还是全局化（有hash就是开启了模块化的一个标志，因为它可以保证产生不同的hash值来控制我们的样式类名不被覆盖）\n * generateScopedName：[name_[local]_[hash:5]]，指定生成的类名的命名规则（可以配置为函数，也可以配置成字符串规则）\n * hashPrefix：生成的hash会根据你的类名进行生成，如果想要你生成的hash更加的独特一点，你可以配置hashPrefix，你配置的这个字符串会参与到最终的hash生成\n * globalModulePaths：代表你不想参与到css模块化的路径\n\n# 4.3.2 preprocessorOption篇\n\n> 主要是用来配置css预处理的一些全局参数\n\ncss: {\n  preprocessorOptions: {\n    // 配置 CSS 预处理器的全局参数\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n在 preprocessorOptions 中，你可以配置 CSS 预处理器的一些全局参数，具体参数的配置取决于你使用的预处理器（如 Sass、Less 等）。这里可以配置一些通用的选项，比如：\n\n * additionalData：额外的全局样式数据，可以在每个 CSS 文件的顶部注入，例如共享的变量、混合器等。\n * sass：用于配置 Sass 预处理器的选项，如 sass 选项中的 indentedSyntax 表示是否使用缩进语法。\n * less：用于配置 Less 预处理器的选项，如 less 选项中的 javascriptEnabled 表示是否启用 Less 中的 JavaScript 表达式。\n\n# 4.3.2 postcss篇\n\nimport autoprefixer from \'autoprefixer\';\n\nexport default {\n  // ...\n  css: {\n    postcss: {\n      plugins: [\n        autoprefixer(), // 配置 PostCSS 插件，例如 Autoprefixer\n        // 其他的 PostCSS 插件...\n      ]\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在 postcss 配置项中，你可以指定要使用的 PostCSS 插件。在示例中，我们使用了一个常见的插件 Autoprefixer，它用于自动添加 CSS 浏览器前缀，以提供跨浏览器兼容性。\n\n你可以根据需要，将其他的 PostCSS 插件添加到 plugins 数组中。这些插件可以用于执行各种 CSS 处理任务，例如压缩、优化、转换等。\n\n需要注意的是，为了使用特定的 PostCSS 插件，你需要在项目中安装这些插件的相应依赖，并在 vite.config.js 文件中进行正确的导入和配置。\n\n此外，你还可以在 postcss 配置项中设置其他选项，例如 config、sourceMap 等，以满足特定的需求。具体的配置选项和语法规则可以参考 PostCSS 插件的文档或相关资源。\n\n\n# 5 vite相关知识\n\n\n# 5.1 vite加载静态资源\n\n> 什么是静态资源？\n> \n> 静态资源是指不需要经过构建处理的文件，例如图片、视频、字体等，除了动态API以外，百分之九十九的资源都被视作静态资源\n\nvite对静态资源基本上是开箱即用的，除了一些特殊情况（svg）\n\n要加载静态资源，你可以将它们放置在你的项目目录中的任何位置。通常，你可以将这些静态资源放置在你的项目根目录下的 public 文件夹中，这是一个预定义的静态资源文件夹。当你在代码中引用这些静态资源时，Vite 会自动将它们提供给你的应用程序。\n\n例如，如果在你的项目中有一个名为 public 的文件夹，并且在其中有一个图片文件 logo.png，你可以在代码中像下面这样引用它：\n\n<img src="/logo.png" alt="Logo" />\n\n\n1\n\n1\n\n\nVite 会自动将此路径解析为相应的静态资源，并将其提供给你的应用程序。\n\n需要注意的是，在 Vite 中，你可以使用相对于根目录的绝对路径来引用静态资源，而无需考虑模块化的路径解析。这是因为 Vite 使用自己的开发服务器，能够在运行时动态处理这些静态资源的请求。\n\n对于某些特殊的静态资源，如 SVG 文件，你可能需要额外的配置来确保正确加载。对于 SVG 文件，你可以使用 @vitejs/plugin-svg 插件来处理。你可以按照 Vite 官方文档中的说明，添加该插件并进行相应的配置。\n\n\n# 5.2 vite在生产环境中对静态资源的处理\n\n>  1. 静态资源的导入和处理： 在你的代码中，如果有静态资源的导入语句（如图片、字体、CSS 文件等），Vite 会根据这些导入语句自动处理这些资源。\n>  2. 资源优化和压缩： Vite 会对导入的静态资源进行优化和压缩，以减小文件大小并提升加载性能。这包括但不限于压缩图片、压缩和合并 CSS 文件等操作。\n>  3. 指纹化文件名： 为了更好的缓存管理和更新机制，Vite 会为处理后的静态资源生成带有指纹的文件名。这意味着每个文件都会有一个唯一的哈希值作为文件名的一部分，例如 logo.8e4c5f7b.png。当文件内容发生变化时，哈希值也会发生变化，从而确保客户端能够正确地缓存和更新静态资源。\n>  4. 输出静态资源： 处理后的静态资源会被输出到构建目录（默认为 dist）中。Vite 会根据资源类型生成相应的文件，如图片会生成 .png、.jpg 等文件，CSS 文件会生成 .css 文件等。\n>  5. 引用静态资源： 在你的 HTML 文件或生成的代码中，Vite 会自动更新静态资源的引用路径，以指向构建目录中的正确文件。这样，在生产环境中，你可以直接使用相对于构建目录的路径来引用静态资源，而无需关心开发环境中的模块解析和路径处理。\n\n\n# 5.3 vite常用插件\n\n> 插件是什么？\n> \n> vite会在生命周期的不同阶段中调用不同的插件以达到不同的目的\n> \n> 生命周期：vite从开始执行到执行结束\n\n# 5.3.1 vite-aliases\n\n> 作用：别名自动生成\n> \n> 安装：yarn add vite-aliases -D\n> \n> 将其添加到vite.config.js中\n> \n> // vite.config.js\n> import { ViteAliases } from \'vite-aliases\'\n> \n> export default {\n>   plugins: [\n>     ViteAliases()\n>   ]\n> };\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n\nvite-aliases的可选配置项如下：\n\nViteAliases({\n  /**\n  * Relative path to the project directory\n  */\n  dir: \'src\',\n\n  /**\n  * Prefix symbol for the aliases\n  */\n  prefix: \'~\',\n\n  /**\n  * Allow searching for subdirectories\n  */\n  deep: true,\n\n  /**\n  * Search depthlevel for subdirectories\n  */\n  depth: 1,\n\n  /**\n  * Creates a Logfile\n  * use `logPath` to change the location\n  */\n  createLog: false,\n\n  /**\n  * Path for Logfile\n  */\n  logPath: \'src/logs\',\n\n  /**\n  * Create global project directory alias\n  */\n  createGlobalAlias: true,\n\n  /**\n  * Turns duplicates into camelCased path aliases\n  */\n  adjustDuplicates: false,\n\n  /**\n  * Used paths in JS/TS configs will now be relative to baseUrl\n  */\n  useAbsolute: false,\n\n  /**\n  * Adds seperate index paths\n  * approach created by @davidohlin\n  */\n  useIndexes: false,\n\n  /**\n  * Generates paths in IDE config file\n  * works with JS or TS\n  */\n  useConfig: true,\n\n  /**\n  * Override config paths\n  */\n  ovrConfig: false,\n\n  /**\n  * Will generate Paths in tsconfig\n  * used in combination with `useConfig`\n  * Typescript will be auto detected\n  */\n  dts: false,\n\n  /**\n  * Disables any terminal output\n  */\n  silent: true,\n\n  /**\n  * Root path of Vite project\n  */\n  root: process.cwd()\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n\n# 5.3.2 vite-plugin-html\n\n> 功能：\n> \n>  1. HTML 压缩能力\n>  2. EJS 模版能力\n>  3. 多页应用支持\n>  4. 支持自定义entry\n>  5. 支持自定义template\n> \n> 安装：yarn add vite-plugin-html -D\n> \n> 将其添加到vite.config.js中\n\n> 用法：\n> \n> 将EJS标签添加到index.html中\n> \n> <head>\n>   <meta charset="UTF-8" />\n>   <link rel="icon" href="/favicon.ico" />\n>   <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n>   <title><%- title %></title>\n>   <%- injectScript %>\n> </head>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> \n> 在vite.config.js中配置，该方法可以根据需要引入需要的功能\n> \n> import { defineConfig, Plugin } from \'vite\'\n> import vue from \'@vitejs/plugin-vue\'\n> \n> import { createHtmlPlugin } from \'vite-plugin-html\'\n> \n> export default defineConfig({\n>   plugins: [\n>     vue(),\n>     createHtmlPlugin({\n>       minify: true,\n>       /**\n>        * After writing entry here, you will not need to add script tags in `index.html`, the original tags need to be deleted\n>        * @default src/main.ts\n>        */\n>       entry: \'src/main.ts\',\n>       /**\n>        * If you want to store `index.html` in the specified folder, you can modify it, otherwise no configuration is required\n>        * @default index.html\n>        */\n>       template: \'public/index.html\',\n> \n>       /**\n>        * Data that needs to be injected into the index.html ejs template\n>        */\n>       inject: {\n>         data: {\n>           title: \'index\',\n>           injectScript: `<script src="./inject.js"><\/script>`,\n>         },\n>         tags: [\n>           {\n>             injectTo: \'body-prepend\',\n>             tag: \'div\',\n>             attrs: {\n>               id: \'tag\',\n>             },\n>           },\n>         ],\n>       },\n>     }),\n>   ],\n> })\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n> 19\n> 20\n> 21\n> 22\n> 23\n> 24\n> 25\n> 26\n> 27\n> 28\n> 29\n> 30\n> 31\n> 32\n> 33\n> 34\n> 35\n> 36\n> 37\n> 38\n> 39\n> 40\n> 41\n> 42\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n> 19\n> 20\n> 21\n> 22\n> 23\n> 24\n> 25\n> 26\n> 27\n> 28\n> 29\n> 30\n> 31\n> 32\n> 33\n> 34\n> 35\n> 36\n> 37\n> 38\n> 39\n> 40\n> 41\n> 42\n\n# 5.3.3 vite-plugin-mock\n\n> mock数据：模拟数据\n> \n> 前后端一般是并行开发，用户列表（接口文档）\n> \n> mock数据，去做你前端的工作\n> \n>  1. 简单方式：直接去写死一两个数据，方便调试。\n>     * 缺陷：没法做海量数据测试\n>     * 没法获得一些标准数据\n>     * 没法去感知http的异常\n>  2. mockjs：模拟海量数据的，vite-plugin-mock的依赖项是mockjs\n\n> 安装：\n> \n> yarn add mockjs -D\n> yarn add vite-plugin-mock -D\n> \n> \n> 1\n> 2\n> \n> 1\n> 2\n> \n> \n> 使用方法：https://github.com/vbenjs/vite-plugin-mock\n\n# 5.3.4 其他插件\n\n插件地址',normalizedContent:'# 1 构建工具\n\n\n# 1.1 什么是构建工具\n\n> 浏览器它只认识html，css，js\n\n企业级项目里都可能具备哪些功能？\n\n 1. typescript：使用tsc工具将ts代码转换为js代码；\n 2. react/vue：安装react-compiler/vue-compiler，将我们写的jsx文件或者.vue文件转换为render函数；\n 3. less/sass/postcss/component-style：我们有需要安装less-loader,sass-loader等一系列编译工具转换为css代码；\n 4. 语法降级：babel可以将es的新语法转换旧版浏览器可以接受的语法；\n 5. 体积优化：uglifyjs可以将我们的代码进行压缩变成体积更小性能更高的文件。\n\n> 以上稍微改一点，就会很麻烦，所以我们希望有一个构建工具可以将以上工具全部集成到一起，实现上述功能，我们只需要关注我们写的代码即可。即构建工具可以帮我们自动去tsc，react-comiler，less，babel，uglifyjs全部走一遍，让我们不用每次关心我们的代码在浏览器运行。\n\n> 打包：将我们写的浏览器不认识的代码，交给构建工具进行编译处理的过程就叫做打包，打包完成以后会给我们一个浏览器可以认识的文件。\n\n构建工具承担了以下脏活累活：\n\n 1. 模块化开发支持：支持直接从node_modules里引入代码 + 多种模块化支持\n 2. 处理代码兼容性：比如babel语法降级，less，ts语法转换（不是构建工具做的，构建工具将这些语法对应的处理工具集成进来自动化处理）\n 3. 提高项目性能：压缩文件，代码分割\n 4. 优化开发体验：\n    * 构建工具会帮你自动监听文件的变化，当文件变化以后自动帮你调用对应的集成工具进行重新打包，然后再浏览器重新运行（整个过程叫做热更新，hot replacement）\n    * 开发服务器：跨域的问题，用react-cli create-react-element vue-cli解决跨域的问题\n\n> 我们只需要首次给构建工具提供一个配置文件（这个配置文件也不是必须的，没有它也会默认处理），有了集成的配置文件以后，我们就可以在下次需要更新的时候调用一次对应的命令即可，如果再结合热更新，我们就更加不需要管任何东西，这就是构建工具去做的事情，它让我们不用关心生产的带啊吗也不用关心代码如何在浏览器运行，只需要关心我们的开发怎么写的爽怎么写就好了。\n\n\n# 1.2 主流构建工具\n\n * webpack\n * vite\n * parcel\n * esbuild\n * rollup\n * grunt\n * gulp\n\n> 国内主流还是webpack，vite和esbuild。\n\n\n# 1.3 vite相较于webpack的优势\n\n> 然而，当我们开始构建越来越大型的应用时，需要处理的 javascript 代码量也呈指数级增长。包含数千个模块的大型项目相当普遍。基于 javascript 开发的工具就会开始遇到性能瓶颈：==通常需要很长时间（甚至是几分钟！）才能启动开发服务器，即使使用模块热替换（hmr），文件修改后的效果也需要几秒钟才能在浏览器中反映出来。==如此循环往复，迟钝的反馈会极大地影响开发者的开发效率和幸福感。\n\n起因：我们的项目越大，构建工具（webpack）所要处理的js代码就越多【跟webpack的一个构建过程（工作流程有关）】\n\n造成的结果：构建工具需要很长时间才能启动开发服务器（把项目跑起来）\n\nyarn start\nyarn dev\n\nnpm run dev\nnpm run start\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n> webpack不能改，如果要改，则会动到webpack的大动脉。\n> \n> // 这段代码最终回到浏览器里去运行\n> const lodash = require("lodash"); // commonjs 规范\n> import vue from "vue"; // es6 module\n> \n> // webpack是允许我们这么写的，webpack会这样转换\n> const lodash = webpack_require("loadsh");\n> const vue = webpack_require("vue");\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> \n> webpack的编译原理，ast抽象语法分析的工具，分析出js文件有哪些导入导出操作\n> \n> 构建工具是运行在服务端的\n> \n> (function(modules) {\n>     function webpack_require() {}\n>     // 入口是index.js\n>     // 通过webpack的配置文件得来的：webpack.config.js ./src/index.js\n>     modules[entry](webpack_require);\n> }, ({\n>     "index.js": (webpack_require) => {\n>         const lodash = webpack_require("lodash");\n> \t\tconst vue = webpack_require("vue");\n>     }\n> }))\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> \n> \n> 因为webpack支持模块化，它一开始就必须要统一模块化代码，所以意味着它需要将所有的依赖读一遍。\n> \n> vite会不会直接把webpack干翻？vite是基于es modules的，侧重点不一样，webpack更多的关注兼容性，而vite关注浏览器端的开发体验。\n\n\n# 2 vite启动项目初体验\n\n\n# 2.1 你必须要理解的vite脚手架和vite\n\n> vite官网搭建vite项目文档教程：https://cn.vitejs.dev/guide/#scaffolding-your-first-vite-project\n\n比如我们敲了yarn create vite\n\n 1. 帮我们全局安装了一个东西：create-vite（vite的脚手架）\n 2. 直接运行这个create-vite bin目录下的一个执行配置\n\n误区：认为官网中使用对应的yarn create构建项目的过程也是vite在做的事情\n\n> 我们之前接触过vue-cli，create-vite和vite的关系是：create-vite内置了vite。使用vue-cli会内置webpack\n\n先学习的就是vite，暂时不会使用yarn create vite my-vue-app --template vue。vue-cli可以和webpack分的很清楚。\n\n> vue-cli给我们提供已经精装修的模板。\n> \n> 我们自己搭建一个项目：下载vite，vue，post-css，less，label\n> \n> vue-cli/create-vite给了一套精装修的模板：什么都下好了，并且给你做了最佳实践的配置\n\n\n# 2.2 vite开箱即用\n\n> 开箱即用（out of box）：不需要做任何额外的配置就可以使用vite来帮你处理构建工作\n\n在默认情况下，我们的esmodule去导入资源的时候，要么是绝对路径，要么是相对路径，既然我们现在的最佳实践是node_modules，那么为什么es官方在我们导入非绝对路径和非相对路径的资源的时候不默认帮我们搜寻node_modules？\n\n> 浏览器环境中的安全性原因是一个主要考虑因素。如果浏览器默认搜索node_modules目录，那么恶意的代码可能会利用这个功能访问和执行不受信任的模块代码，从而导致安全风险。通过限制导入路径，浏览器可以更好地控制模块的来源和访问权限。\n> \n> 另外，性能也是一个重要的考虑因素。浏览器默认只支持绝对路径和相对路径的导入，可以在编译时静态解析模块依赖关系，从而提高加载和执行模块的效率。如果浏览器要搜索node_modules目录，可能需要进行额外的文件系统操作和路径解析，增加了加载模块的时间和资源消耗。\n\n\n# 2.3 vite的预加载\n\nimport _ from "lodash"; // lodash可能也import了其他的东西\n\nimport _vite_cjsimport0_lodash from "/node_modules/.vite/deps/loadsh.js?v=ebe57916";\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n在处理的过程中如果说看到了有非绝对路径或者相对路径的引用，则会尝试开启路径补全\n\n找寻依赖的过程是自当前目录依次向上查找的过程，直到搜寻到根目录或者搜寻到对应依赖为止 /user/node_modules/lodash, ../\n\n> 区分生产环境和开发环境：\n> \n> yarn dev ----\x3e 开发（每次依赖预构建所重新构建的相对路径都是正确的）\n> \n> vite会全权交给一个叫做rollup的库去完成生产环境的打包\n> \n> 缓存 ----\x3e\n> \n> 实际上vite在考虑另外一个问题的时候就顺便把这个问题解决了\n> \n> commonjs 规范的导出 module.exports\n> \n> 有的包是以commonjs规范的格式导出 axios\n> \n> 依赖预构建：首先vite会找到对应的依赖，然后调用esbuild（对js语法进行处理的一个库），将其他规范的代码转换成esmodule规范，然后放到当前目录下的node_modules/.vite/deps，同时对esmodule规范的各个模块进行统一集成\n\n所以它解决了3个问题：\n\n 1. 不同的第三方包会有不同的导出格式（这个是vite没法约束人家的事情）\n 2. 对路径的处理上可以直接使用.vite/deps，方便路径重写\n 3. 叫做网络多包传输的性能问题（也是原生esmodule规范不敢支持node_modules的原因之一），有了依赖预构建以后无论它有多少的额外的export和import，vite都会尽可能的将他们集成最后只生成一个或者几个模块\n\nvite.config.js === webpack.config.js\n\n\n# 2.4 vite配置文件处理细节\n\n 1. vite配置文件的语法提示\n    \n    1. 如果你使用的是webstorm，那你可以得到很好的语法补全\n    2. 如果你使用的是vscode或者其他编辑器，则需要做一些特殊处理\n\n 2. 关于环境的处理\n    \n    > 过去我们使用webpack的时候，我们需要区分配置文件的一个环境：\n    > \n    >  * webpack.dev.config\n    >  * webpack.prod.config\n    >  * webpack.base.config\n    >  * webpackmerge\n\n\n# 2.5 vue环境变量配置\n\n> 环境变量：会根据当前的代码环境产生值的变化的变量就叫做环境变量\n> \n> 代码环境：\n> \n>  1. 开发环境：开发环境是开发人员进行软件开发和调试的地方。在开发环境中，开发人员可以进行代码编写、调试、测试和验证。这个环境通常是本地的开发机器，开发人员可以通过使用 vite 的开发服务器（dev server）来提供实时的重新加载（live reloading）和模块热替换（hot module replacement）功能，以便更快地进行开发和调试。\n>  2. 测试环境：测试环境是用于进行软件测试的环境。在测试环境中，开发人员和测试人员可以对软件进行不同类型的测试，例如单元测试、集成测试和端到端测试。在测试环境中，可以使用 vite 构建工具生成测试所需的构建文件，并在模拟的环境中进行测试。\n>  3. 预发布环境：预发布环境是在软件发布之前进行最后测试和验证的环境。在预发布环境中，可以对软件进行更全面的测试，以确保它符合发布的质量标准。这个环境通常是一个类似于生产环境的环境，但在实际发布之前，可能会使用一些模拟数据和模拟系统进行测试。\n>  4. 灰度环境：灰度环境是在软件发布后逐步向用户群体推出新功能或更新的环境。在灰度环境中，新的软件版本或功能将部署到一小部分用户中，以便测试其稳定性和兼容性。这个环境类似于生产环境，但只有一部分用户能够访问新的功能或更新。\n>  5. 生产环境：生产环境是最终向用户提供服务的环境。在生产环境中，已经通过了开发、测试、预发布和灰度环境的验证，并且已准备好为最终用户提供稳定、可靠的服务。在生产环境中，通常会使用 vite 构建工具生成用于部署的生产级别的构建文件，并进行必要的优化和压缩，以提供最佳的性能和用户体验。\n\n我们在和后端同学对接的时候，前端在开发环境中请求的后端api地址和生产环境请求的后端api地址是一个吗？肯定不是一个\n\n * 开发和测试：http://test.api/\n * 生产：https://api/\n\n> 在vite中的环境变量处理：\n> \n> vite内置了dotenv这个第三方库，会自动读取.env文件，并解析这个文件中的对应的环境变量，并将其注入到process对象下（但是vite考虑到和其他配置的一些冲突问题，它不会直接注入到process对象下）\n> \n> 涉及到vite.config.js中的一些配置：\n> \n>  * root\n>  * envdir：用来配置当前环境变量的文件地址\n> \n> vite给我们提供了一些补偿措施：我们可以调用vite的loadenv来手动确认env文件\n> \n> porcess.cwd方法：返回node进程的工作目录\n\n> 小知识：为什么vite.config.js可以书写成esmodule的形式，这是因为vite他在读取这个vite.config.js的时候会率先node去解析文件语法，如果发现你是esmodule规范则会直接将你的esmodule规范替换成common js规范\n\n> .env：所有环境都需要用到的环境变量\n> \n> .env.development：开发环境需要用到的环境变量（默认情况下vite将我们的开发环境取名为development）\n> \n> .env.production：生产环境需要用到的环境变量（默认情况下vite将我们的生产环境取名为production）\n> \n> yarn dev --mode development 会将mode设置为development传递进来\n> \n> 当我们调用loadenv的时候，它会做如下几件事情：\n> \n>  1. 直接找到.env文件不解释，并解析其中的环境变量，放到一个对象里\n> \n>  2. 会将传进来的mode这个变量的值进行拼接：env.development，并根据我们提供的目录去取对应配置文件并进行解析，并放进一个对象\n> \n>  3. 我们可以理解为\n>     \n>     const baseenvconfig = 读取.env配置\n>     const modeenvconfig = 读取env相关配置\n>     const lastenvconfig = {...baseenvconfig, ...modeenvconfig}\n>     \n>     \n>     1\n>     2\n>     3\n>     \n>     1\n>     2\n>     3\n>     \n\n如果是客户端，vite会将对应的环境变量注入到import.meta.env里去\n\nvite做了一个拦截，为了防止我们将隐私性的变量直接送到import.meta.env中，所以做了一层拦截，如果你的环境变量不是以vite开头的，他就不会帮你注入到客户端中去，如果我们想要更改这个前缀，可以去使用envprefix配置。\n\n\n# 3 vite 原理篇\n\n\n# 3.1 vite是怎么让浏览器可以识别.vue文件呢\n\nvite 是一个现代化的前端构建工具，它使用了一种名为单文件组件（single file components）的技术来让浏览器能够识别和加载 .vue 文件。\n\n在传统的前端开发中，浏览器无法直接识别和加载 .vue 文件，因为 .vue 文件包含了 html、css 和 javascript 代码，而浏览器只能识别和执行 javascript 文件。\n\nvite 利用了构建工具和打包器的能力，在开发阶段将 .vue 文件转换为浏览器可以识别的形式。它借助特定的编译器（如 vue 编译器）将 .vue 文件的模板、样式和脚本部分分别提取出来，并将它们转换为浏览器可以理解的代码。\n\n具体地说，vite 使用了名为 "vue-loader" 的工具来解析和转换 .vue 文件。这个工具会解析 .vue 文件的内容，提取出其中的模板、样式和脚本，并将它们转化为独立的代码块。然后，vite 使用浏览器原生的 es 模块导入机制，通过 <script type="module"> 标签将这些代码块加载到浏览器中。\n\n当浏览器遇到 <script type="module"> 标签时，它会将标签中的 javascript 代码作为一个独立的模块加载和执行。vite 利用这个特性，将 .vue 文件中的模板、样式和脚本部分分别作为独立的模块加载到浏览器中，并在浏览器中动态组合它们，构建出最终的组件。\n\n\n# 3.2 使用path.resolve的原因\n\n> 在使用路径时，尽量使用 path.resolve 方法可以确保路径的可靠性和跨平台性。以下是几个使用 path.resolve 方法的好处：\n> \n>  1. 处理相对路径和绝对路径：path.resolve 方法可以接受多个参数，将它们解析为一个绝对路径。这意味着你可以使用相对路径作为参数，并将其解析为相对于当前工作目录的绝对路径。这对于确定准确的文件路径非常有用。\n>  2. 解决跨平台路径问题：在不同的操作系统中，对于路径分隔符和路径表示法有所差异。使用 path.resolve 方法可以确保生成的路径在不同的操作系统下都是有效的，因为它会自动根据当前操作系统调整路径分隔符和表示法。\n>  3. 处理路径拼接和规范化：path.resolve 方法会将传入的路径片段进行拼接，并返回一个规范化的路径。这意味着它会解析和处理路径中的 ..、. 等相对路径符号，确保生成的路径是规范化的、干净的路径。\n>  4. 确保路径的存在性：使用 path.resolve 方法生成的路径是确保存在的，它不会检查路径是否有效或文件是否存在，但会确保路径的格式正确。这可以帮助你在操作文件系统时提供正确的路径，避免出现错误或异常。\n\n\n# 4 vite与css\n\n\n# 4.1 在vite中处理css\n\n> vite天生就支持对css文件的直接处理\n\n 1. vite在读取到main.js文件中引用到了index.css\n 2. 直接使用fs模块去读取index.css中文件内容\n 3. 直接创建一个style标签，将index.css中文件内容直接copy到style标签里\n 4. 将style标签插入到index.html的head中\n 5. 将css文件中的内容直接替换为js脚本（方便热更新或者css模块化），同时设置content-type为js，从而让浏览器以js脚本的形式来执行该css后缀的文件\n\n> 场景：\n> \n>  * 一个组件最外层的元素类名一般取名： wrapper\n>  * 一个组件最底层的元素类名一般取名：footer\n> \n> 但你取了footer这个名字，别人因为没有看过你这个组件的源代码，也可能去取名footer这个类名，最后可能会导致样式被覆盖（因为类名重复），这就是我们在协同开发很容易出现的问题\n\ncssmodule就是来解决这个问题的：\n\n 1. module.css（module是一种约定，表示需要开启css模块化）\n 2. 他会将你的所有类名进行一定规则的替换（将footer替换为_footer_i22st_1）\n 3. 同时创建一个映射对象{ footer: "_footer_i22st_1"}\n 4. 将替换过后的内容塞进style标签里然后放入到head标签中（能够读到index.html的文件内容）\n 5. 将componenta.module.css内容全部抹除，替换为js脚本\n 6. 将创建的映射对象在脚本中默认导出\n\n\n# 4.2 css文件类型\n\n>  1. css（.css）：css 是层叠样式表的标准文件格式，它使用类似于选择器和属性的语法来描述网页的样式。css 是前端开发中最常见的样式表语言，浏览器原生支持。\n>  2. less（.less）：less 是 css 的拓展，它引入了变量、嵌套规则、mixin（混入）等功能，以简化 css 的编写和维护。less 文件需要在开发阶段通过 less 编译器转换为标准的 css 文件，然后在浏览器中加载。\n>  3. scss/sass（.scss/.sass）：scss（sassy css）和 sass（syntactically awesome style sheets）也是 css 的拓展，提供了类似 less 的功能，如变量、嵌套规则和 mixin。scss 与 sass 的语法略有不同，但都需要通过编译器将其转换为标准的 css 文件。\n\n/* scss */\n.container {\n  width: 100%;\n\n  .header {\n    background-color: #333;\n    color: #fff;\n    padding: 10px;\n  }\n\n  .content {\n    padding: 20px;\n\n    p {\n      margin-bottom: 10px;\n    }\n\n    a {\n      color: #f00;\n      text-decoration: none;\n\n      &:hover {\n        text-decoration: underline;\n      }\n    }\n  }\n\n  .footer {\n    background-color: #333;\n    color: #fff;\n    padding: 10px;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n在这个示例中，.container 是最外层的容器选择器，它包含了 .header、.content 和 .footer 子选择器。通过嵌套定义，我们可以更直观地表示这些选择器之间的层次结构。\n\n此外，嵌套定义还可以减少重复代码的编写。在上述示例中，.header 和 .footer 具有相同的背景颜色、文字颜色和内边距，通过嵌套定义，我们只需在父选择器中指定一次即可，避免了重复的样式声明。\n\n另外，嵌套定义还可以方便地应用伪类和伪元素样式。在示例中，嵌套定义了 a 元素的样式，并使用 &:hover 表示其悬停状态下的样式，这样可以更直观地表示选择器之间的关系。\n\n通过使用嵌套定义，我们可以更清晰地组织和维护样式代码，减少了冗余和重复的工作，提高了代码的可读性和可维护性。\n\n\n# 4.3 vite.config.js中css配置\n\n> 在vite.config.js中我们通过css属性去控制整个vite对于css的处理行为\n\n# 4.3.1 module篇\n\ncss: { \n    \n    modules: { \n    }\n}\ncss: { // 对css的行为进行配置\n  // modules配置最终会丢给postcss modules\n  modules: { // 是对css模块化的默认行为进行覆盖\n    localsconvention: \'camelcase\', // 修改生成的配置对象的 key 的展示形式为驼峰命名\n    scopebehaviour: \'global\', // 配置当前的模块化行为为全局化\n    generatescopedname: \'[name]__[local]___[hash:base64:5]\', // 指定生成的类名的命名规则\n    hashprefix: \'my-app\', // 生成的 hash 的前缀\n    globalmodulepaths: [\'path/to/global/styles\'] // 不参与 css 模块化的路径\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * localsconvention：修改生成的配置对象的key的展示形式（驼峰还是中划线形式）\n * scopebehaviour：配置当前的模块化行为是模块化还是全局化（有hash就是开启了模块化的一个标志，因为它可以保证产生不同的hash值来控制我们的样式类名不被覆盖）\n * generatescopedname：[name_[local]_[hash:5]]，指定生成的类名的命名规则（可以配置为函数，也可以配置成字符串规则）\n * hashprefix：生成的hash会根据你的类名进行生成，如果想要你生成的hash更加的独特一点，你可以配置hashprefix，你配置的这个字符串会参与到最终的hash生成\n * globalmodulepaths：代表你不想参与到css模块化的路径\n\n# 4.3.2 preprocessoroption篇\n\n> 主要是用来配置css预处理的一些全局参数\n\ncss: {\n  preprocessoroptions: {\n    // 配置 css 预处理器的全局参数\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n在 preprocessoroptions 中，你可以配置 css 预处理器的一些全局参数，具体参数的配置取决于你使用的预处理器（如 sass、less 等）。这里可以配置一些通用的选项，比如：\n\n * additionaldata：额外的全局样式数据，可以在每个 css 文件的顶部注入，例如共享的变量、混合器等。\n * sass：用于配置 sass 预处理器的选项，如 sass 选项中的 indentedsyntax 表示是否使用缩进语法。\n * less：用于配置 less 预处理器的选项，如 less 选项中的 javascriptenabled 表示是否启用 less 中的 javascript 表达式。\n\n# 4.3.2 postcss篇\n\nimport autoprefixer from \'autoprefixer\';\n\nexport default {\n  // ...\n  css: {\n    postcss: {\n      plugins: [\n        autoprefixer(), // 配置 postcss 插件，例如 autoprefixer\n        // 其他的 postcss 插件...\n      ]\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在 postcss 配置项中，你可以指定要使用的 postcss 插件。在示例中，我们使用了一个常见的插件 autoprefixer，它用于自动添加 css 浏览器前缀，以提供跨浏览器兼容性。\n\n你可以根据需要，将其他的 postcss 插件添加到 plugins 数组中。这些插件可以用于执行各种 css 处理任务，例如压缩、优化、转换等。\n\n需要注意的是，为了使用特定的 postcss 插件，你需要在项目中安装这些插件的相应依赖，并在 vite.config.js 文件中进行正确的导入和配置。\n\n此外，你还可以在 postcss 配置项中设置其他选项，例如 config、sourcemap 等，以满足特定的需求。具体的配置选项和语法规则可以参考 postcss 插件的文档或相关资源。\n\n\n# 5 vite相关知识\n\n\n# 5.1 vite加载静态资源\n\n> 什么是静态资源？\n> \n> 静态资源是指不需要经过构建处理的文件，例如图片、视频、字体等，除了动态api以外，百分之九十九的资源都被视作静态资源\n\nvite对静态资源基本上是开箱即用的，除了一些特殊情况（svg）\n\n要加载静态资源，你可以将它们放置在你的项目目录中的任何位置。通常，你可以将这些静态资源放置在你的项目根目录下的 public 文件夹中，这是一个预定义的静态资源文件夹。当你在代码中引用这些静态资源时，vite 会自动将它们提供给你的应用程序。\n\n例如，如果在你的项目中有一个名为 public 的文件夹，并且在其中有一个图片文件 logo.png，你可以在代码中像下面这样引用它：\n\n<img src="/logo.png" alt="logo" />\n\n\n1\n\n1\n\n\nvite 会自动将此路径解析为相应的静态资源，并将其提供给你的应用程序。\n\n需要注意的是，在 vite 中，你可以使用相对于根目录的绝对路径来引用静态资源，而无需考虑模块化的路径解析。这是因为 vite 使用自己的开发服务器，能够在运行时动态处理这些静态资源的请求。\n\n对于某些特殊的静态资源，如 svg 文件，你可能需要额外的配置来确保正确加载。对于 svg 文件，你可以使用 @vitejs/plugin-svg 插件来处理。你可以按照 vite 官方文档中的说明，添加该插件并进行相应的配置。\n\n\n# 5.2 vite在生产环境中对静态资源的处理\n\n>  1. 静态资源的导入和处理： 在你的代码中，如果有静态资源的导入语句（如图片、字体、css 文件等），vite 会根据这些导入语句自动处理这些资源。\n>  2. 资源优化和压缩： vite 会对导入的静态资源进行优化和压缩，以减小文件大小并提升加载性能。这包括但不限于压缩图片、压缩和合并 css 文件等操作。\n>  3. 指纹化文件名： 为了更好的缓存管理和更新机制，vite 会为处理后的静态资源生成带有指纹的文件名。这意味着每个文件都会有一个唯一的哈希值作为文件名的一部分，例如 logo.8e4c5f7b.png。当文件内容发生变化时，哈希值也会发生变化，从而确保客户端能够正确地缓存和更新静态资源。\n>  4. 输出静态资源： 处理后的静态资源会被输出到构建目录（默认为 dist）中。vite 会根据资源类型生成相应的文件，如图片会生成 .png、.jpg 等文件，css 文件会生成 .css 文件等。\n>  5. 引用静态资源： 在你的 html 文件或生成的代码中，vite 会自动更新静态资源的引用路径，以指向构建目录中的正确文件。这样，在生产环境中，你可以直接使用相对于构建目录的路径来引用静态资源，而无需关心开发环境中的模块解析和路径处理。\n\n\n# 5.3 vite常用插件\n\n> 插件是什么？\n> \n> vite会在生命周期的不同阶段中调用不同的插件以达到不同的目的\n> \n> 生命周期：vite从开始执行到执行结束\n\n# 5.3.1 vite-aliases\n\n> 作用：别名自动生成\n> \n> 安装：yarn add vite-aliases -d\n> \n> 将其添加到vite.config.js中\n> \n> // vite.config.js\n> import { vitealiases } from \'vite-aliases\'\n> \n> export default {\n>   plugins: [\n>     vitealiases()\n>   ]\n> };\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n\nvite-aliases的可选配置项如下：\n\nvitealiases({\n  /**\n  * relative path to the project directory\n  */\n  dir: \'src\',\n\n  /**\n  * prefix symbol for the aliases\n  */\n  prefix: \'~\',\n\n  /**\n  * allow searching for subdirectories\n  */\n  deep: true,\n\n  /**\n  * search depthlevel for subdirectories\n  */\n  depth: 1,\n\n  /**\n  * creates a logfile\n  * use `logpath` to change the location\n  */\n  createlog: false,\n\n  /**\n  * path for logfile\n  */\n  logpath: \'src/logs\',\n\n  /**\n  * create global project directory alias\n  */\n  createglobalalias: true,\n\n  /**\n  * turns duplicates into camelcased path aliases\n  */\n  adjustduplicates: false,\n\n  /**\n  * used paths in js/ts configs will now be relative to baseurl\n  */\n  useabsolute: false,\n\n  /**\n  * adds seperate index paths\n  * approach created by @davidohlin\n  */\n  useindexes: false,\n\n  /**\n  * generates paths in ide config file\n  * works with js or ts\n  */\n  useconfig: true,\n\n  /**\n  * override config paths\n  */\n  ovrconfig: false,\n\n  /**\n  * will generate paths in tsconfig\n  * used in combination with `useconfig`\n  * typescript will be auto detected\n  */\n  dts: false,\n\n  /**\n  * disables any terminal output\n  */\n  silent: true,\n\n  /**\n  * root path of vite project\n  */\n  root: process.cwd()\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n\n# 5.3.2 vite-plugin-html\n\n> 功能：\n> \n>  1. html 压缩能力\n>  2. ejs 模版能力\n>  3. 多页应用支持\n>  4. 支持自定义entry\n>  5. 支持自定义template\n> \n> 安装：yarn add vite-plugin-html -d\n> \n> 将其添加到vite.config.js中\n\n> 用法：\n> \n> 将ejs标签添加到index.html中\n> \n> <head>\n>   <meta charset="utf-8" />\n>   <link rel="icon" href="/favicon.ico" />\n>   <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n>   <title><%- title %></title>\n>   <%- injectscript %>\n> </head>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> \n> 在vite.config.js中配置，该方法可以根据需要引入需要的功能\n> \n> import { defineconfig, plugin } from \'vite\'\n> import vue from \'@vitejs/plugin-vue\'\n> \n> import { createhtmlplugin } from \'vite-plugin-html\'\n> \n> export default defineconfig({\n>   plugins: [\n>     vue(),\n>     createhtmlplugin({\n>       minify: true,\n>       /**\n>        * after writing entry here, you will not need to add script tags in `index.html`, the original tags need to be deleted\n>        * @default src/main.ts\n>        */\n>       entry: \'src/main.ts\',\n>       /**\n>        * if you want to store `index.html` in the specified folder, you can modify it, otherwise no configuration is required\n>        * @default index.html\n>        */\n>       template: \'public/index.html\',\n> \n>       /**\n>        * data that needs to be injected into the index.html ejs template\n>        */\n>       inject: {\n>         data: {\n>           title: \'index\',\n>           injectscript: `<script src="./inject.js"><\/script>`,\n>         },\n>         tags: [\n>           {\n>             injectto: \'body-prepend\',\n>             tag: \'div\',\n>             attrs: {\n>               id: \'tag\',\n>             },\n>           },\n>         ],\n>       },\n>     }),\n>   ],\n> })\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n> 19\n> 20\n> 21\n> 22\n> 23\n> 24\n> 25\n> 26\n> 27\n> 28\n> 29\n> 30\n> 31\n> 32\n> 33\n> 34\n> 35\n> 36\n> 37\n> 38\n> 39\n> 40\n> 41\n> 42\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n> 19\n> 20\n> 21\n> 22\n> 23\n> 24\n> 25\n> 26\n> 27\n> 28\n> 29\n> 30\n> 31\n> 32\n> 33\n> 34\n> 35\n> 36\n> 37\n> 38\n> 39\n> 40\n> 41\n> 42\n\n# 5.3.3 vite-plugin-mock\n\n> mock数据：模拟数据\n> \n> 前后端一般是并行开发，用户列表（接口文档）\n> \n> mock数据，去做你前端的工作\n> \n>  1. 简单方式：直接去写死一两个数据，方便调试。\n>     * 缺陷：没法做海量数据测试\n>     * 没法获得一些标准数据\n>     * 没法去感知http的异常\n>  2. mockjs：模拟海量数据的，vite-plugin-mock的依赖项是mockjs\n\n> 安装：\n> \n> yarn add mockjs -d\n> yarn add vite-plugin-mock -d\n> \n> \n> 1\n> 2\n> \n> 1\n> 2\n> \n> \n> 使用方法：https://github.com/vbenjs/vite-plugin-mock\n\n# 5.3.4 其他插件\n\n插件地址',charsets:{cjk:!0}},{title:"如何使用C语言从一定范围内生成随机整数？",frontmatter:{title:"如何使用C语言从一定范围内生成随机整数？",author:{name:"Pursuit",link:"https://github.com/unique-pure"},categories:["开发","编程语言","C/C++"],date:"2024-03-27T22:20:31.000Z",permalink:"/pages/f16b08/",tags:[null],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.C++/02.C%E8%AF%AD%E8%A8%80%E5%A6%82%E4%BD%95%E4%BB%8E%E4%B8%80%E5%AE%9A%E8%8C%83%E5%9B%B4%E5%86%85%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B4%E6%95%B0.html",relativePath:"01.开发/01.编程语言/02.C++/02.C语言如何从一定范围内生成随机整数.md",key:"v-5e1f62f8",path:"/pages/f16b08/",headersStr:null,content:"出处\n\n如何使用C语言生成随机数？例如希望生成一段特定范围的随机数，如[1,6][1,6][1,6]来模拟掷骰子。\n\n> 到目前为止，所有答案在数学上都是错误的。返回 rand() % N 并不统一给出 [0, N) 范围内的数字，除非 N 除以 rand() 返回的区间长度（即是 2 的幂）。此外，我们不知道 rand() 的模数是否独立：它们有可能是 0, 1, 2, ... ，这是均匀的但不是很随机。唯一似乎合理的假设是 rand() 给出泊松分布：任何两个相同大小的非重叠子区间均可能且独立。对于一组有限的值，这意味着均匀分布，并且还确保 rand() 的值很好地分散。\n> \n> 这意味着更改 rand() 范围的唯一正确方法是将其分为多个框；例如，如果 RAND_MAX == 11 并且您想要 1..6 的范围，则应将 {0,1} 分配给 1，将 {2,3} 分配给 2，依此类推在。这些是不相交的、大小相等的区间，因此是均匀且独立分布的。\n> \n> 使用浮点除法的建议在数学上是合理的，但原则上存在舍入问题。也许 double 的精度足以使其工作；也许不是。我不知道，也不想弄清楚；无论如何，答案取决于系统。\n> \n> 正确的方法是使用整数运算。也就是说，您想要如下所示的内容：\n> \n> #include <stdlib.h> // For random(), RAND_MAX\n> \n> // Assumes 0 <= max <= RAND_MAX\n> // Returns in the closed interval [0, max]\n> long random_at_most(long max) {\n>   unsigned long\n>     // max <= RAND_MAX < ULONG_MAX, so this is okay.\n>     num_bins = (unsigned long) max + 1,\n>     num_rand = (unsigned long) RAND_MAX + 1,\n>     bin_size = num_rand / num_bins,\n>     defect   = num_rand % num_bins;\n> \n>   long x;\n>   do {\n>    x = random();\n>   }\n>   // This is carefully written not to overflow\n>   while (num_rand - defect <= (unsigned long)x);\n> \n>   // Truncated division is intentional\n>   return x/bin_size;\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n> 19\n> 20\n> 21\n> 22\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n> 19\n> 20\n> 21\n> 22\n> \n> \n> 为了获得完全均匀的分布，循环是必要的。例如，如果给你 0 到 2 之间的随机数，而你只想要 0 到 1 之间的数字，你就继续拉，直到没有 2 为止；不难检查这是否以相同的概率给出 0 或 1。 这里使用 random() 而不是 rand() 因为它具有更好的分布（如 rand() 的手册页所述）。\n> \n> 如果你想获得默认范围 [0, RAND_MAX] 之外的随机值，那么你必须做一些棘手的事情。也许最方便的方法是定义一个函数 random_extended() 提取 n 位（使用 random_at_most() ）并返回 [0, 2**n) ，然后应用 random_at_most() 用 random_extended() 代替 random() （并用 2**n - 1 代替 RAND_MAX ）来提取随机值小于 2**n ，假设您有一个可以保存这样的值的数字类型。最后，当然，您可以使用 min + random_at_most(max - min) 获取 [min, max] 中的值，包括负值。\n\n这段代码通过以下方式确保生成的随机数在闭区间 [0, max] 内均匀分布：\n\n 1. 确定随机数的范围和数量：\n    * num_bins 表示生成的随机数的数量，即 max 的值加一，因为随机数生成器的范围是左闭右开的。\n    * num_rand 表示随机数生成器的最大值加一，表示总的可能的随机数的数量。\n 2. 计算每个区间的大小：\n    * bin_size 表示每个区间的大小，即将随机数的总数量除以可能的随机数的数量，以确保每个随机数的概率相等。\n 3. 处理不能均匀分配的情况：\n    * defect 表示随机数总数量除以可能的随机数数量的余数，用于处理不能均匀分配的情况。\n 4. 生成随机数并检查范围：\n    * 使用 do-while 循环来生成随机数，并检查生成的随机数是否在指定的范围内，如果不在范围内则重新生成，直到生成的随机数在指定范围内。\n 5. 返回均匀分布的随机数：\n    * 将生成的随机数除以区间大小得到的结果，即在闭区间 [0, max] 内均匀分布的随机数。\n\n通过以上步骤，代码确保了生成的随机数在指定范围内且分布均匀。",normalizedContent:"出处\n\n如何使用c语言生成随机数？例如希望生成一段特定范围的随机数，如[1,6][1,6][1,6]来模拟掷骰子。\n\n> 到目前为止，所有答案在数学上都是错误的。返回 rand() % n 并不统一给出 [0, n) 范围内的数字，除非 n 除以 rand() 返回的区间长度（即是 2 的幂）。此外，我们不知道 rand() 的模数是否独立：它们有可能是 0, 1, 2, ... ，这是均匀的但不是很随机。唯一似乎合理的假设是 rand() 给出泊松分布：任何两个相同大小的非重叠子区间均可能且独立。对于一组有限的值，这意味着均匀分布，并且还确保 rand() 的值很好地分散。\n> \n> 这意味着更改 rand() 范围的唯一正确方法是将其分为多个框；例如，如果 rand_max == 11 并且您想要 1..6 的范围，则应将 {0,1} 分配给 1，将 {2,3} 分配给 2，依此类推在。这些是不相交的、大小相等的区间，因此是均匀且独立分布的。\n> \n> 使用浮点除法的建议在数学上是合理的，但原则上存在舍入问题。也许 double 的精度足以使其工作；也许不是。我不知道，也不想弄清楚；无论如何，答案取决于系统。\n> \n> 正确的方法是使用整数运算。也就是说，您想要如下所示的内容：\n> \n> #include <stdlib.h> // for random(), rand_max\n> \n> // assumes 0 <= max <= rand_max\n> // returns in the closed interval [0, max]\n> long random_at_most(long max) {\n>   unsigned long\n>     // max <= rand_max < ulong_max, so this is okay.\n>     num_bins = (unsigned long) max + 1,\n>     num_rand = (unsigned long) rand_max + 1,\n>     bin_size = num_rand / num_bins,\n>     defect   = num_rand % num_bins;\n> \n>   long x;\n>   do {\n>    x = random();\n>   }\n>   // this is carefully written not to overflow\n>   while (num_rand - defect <= (unsigned long)x);\n> \n>   // truncated division is intentional\n>   return x/bin_size;\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n> 19\n> 20\n> 21\n> 22\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n> 19\n> 20\n> 21\n> 22\n> \n> \n> 为了获得完全均匀的分布，循环是必要的。例如，如果给你 0 到 2 之间的随机数，而你只想要 0 到 1 之间的数字，你就继续拉，直到没有 2 为止；不难检查这是否以相同的概率给出 0 或 1。 这里使用 random() 而不是 rand() 因为它具有更好的分布（如 rand() 的手册页所述）。\n> \n> 如果你想获得默认范围 [0, rand_max] 之外的随机值，那么你必须做一些棘手的事情。也许最方便的方法是定义一个函数 random_extended() 提取 n 位（使用 random_at_most() ）并返回 [0, 2**n) ，然后应用 random_at_most() 用 random_extended() 代替 random() （并用 2**n - 1 代替 rand_max ）来提取随机值小于 2**n ，假设您有一个可以保存这样的值的数字类型。最后，当然，您可以使用 min + random_at_most(max - min) 获取 [min, max] 中的值，包括负值。\n\n这段代码通过以下方式确保生成的随机数在闭区间 [0, max] 内均匀分布：\n\n 1. 确定随机数的范围和数量：\n    * num_bins 表示生成的随机数的数量，即 max 的值加一，因为随机数生成器的范围是左闭右开的。\n    * num_rand 表示随机数生成器的最大值加一，表示总的可能的随机数的数量。\n 2. 计算每个区间的大小：\n    * bin_size 表示每个区间的大小，即将随机数的总数量除以可能的随机数的数量，以确保每个随机数的概率相等。\n 3. 处理不能均匀分配的情况：\n    * defect 表示随机数总数量除以可能的随机数数量的余数，用于处理不能均匀分配的情况。\n 4. 生成随机数并检查范围：\n    * 使用 do-while 循环来生成随机数，并检查生成的随机数是否在指定的范围内，如果不在范围内则重新生成，直到生成的随机数在指定范围内。\n 5. 返回均匀分布的随机数：\n    * 将生成的随机数除以区间大小得到的结果，即在闭区间 [0, max] 内均匀分布的随机数。\n\n通过以上步骤，代码确保了生成的随机数在指定范围内且分布均匀。",charsets:{cjk:!0},lastUpdated:"2024/03/28, 15:29:33",lastUpdatedTimestamp:1711610973e3},{title:"设计模式之原型模式详解（Java实现）",frontmatter:{title:"设计模式之原型模式详解（Java实现）",date:"2022-04-24T09:19:55.000Z",tags:["原型模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/2d97a5/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89.html",relativePath:"01.开发/02.开发框架/03.设计模式/03.设计模式之原型模式详解（Java实现）.md",key:"v-c3099e10",path:"/pages/2d97a5/",headers:[{level:2,title:"1 原型模式介绍",slug:"_1-原型模式介绍",normalizedTitle:"1 原型模式介绍",charIndex:2},{level:2,title:"2 原型模式详解",slug:"_2-原型模式详解",normalizedTitle:"2 原型模式详解",charIndex:1183},{level:3,title:"2.1 原型模式结构",slug:"_2-1-原型模式结构",normalizedTitle:"2.1 原型模式结构",charIndex:1196},{level:3,title:"2.2 深克隆与浅克隆",slug:"_2-2-深克隆与浅克隆",normalizedTitle:"2.2 深克隆与浅克隆",charIndex:1464},{level:4,title:"2.2.1 浅克隆",slug:"_2-2-1-浅克隆",normalizedTitle:"2.2.1 浅克隆",charIndex:1566},{level:4,title:"2.2.2 深克隆",slug:"_2-2-2-深克隆",normalizedTitle:"2.2.2 深克隆",charIndex:1735},{level:3,title:"2.3 原型模式实现",slug:"_2-3-原型模式实现",normalizedTitle:"2.3 原型模式实现",charIndex:1858},{level:4,title:"2.3.1 通用实现方法",slug:"_2-3-1-通用实现方法",normalizedTitle:"2.3.1 通用实现方法",charIndex:1919},{level:4,title:"2.3.2 Java语言中的clone()方法和Cloneable接口",slug:"_2-3-2-java语言中的clone-方法和cloneable接口",normalizedTitle:"2.3.2 java语言中的clone()方法和cloneable接口",charIndex:2869},{level:3,title:"2.4 原型模式应用举例",slug:"_2-4-原型模式应用举例",normalizedTitle:"2.4 原型模式应用举例",charIndex:3743},{level:2,title:"3 原型管理器",slug:"_3-原型管理器",normalizedTitle:"3 原型管理器",charIndex:4251},{level:3,title:"3.1 原型管理器实现",slug:"_3-1-原型管理器实现",normalizedTitle:"3.1 原型管理器实现",charIndex:4263},{level:3,title:"3.2 原型管理器应用举例",slug:"_3-2-原型管理器应用举例",normalizedTitle:"3.2 原型管理器应用举例",charIndex:5324}],headersStr:"1 原型模式介绍 2 原型模式详解 2.1 原型模式结构 2.2 深克隆与浅克隆 2.2.1 浅克隆 2.2.2 深克隆 2.3 原型模式实现 2.3.1 通用实现方法 2.3.2 Java语言中的clone()方法和Cloneable接口 2.4 原型模式应用举例 3 原型管理器 3.1 原型管理器实现 3.2 原型管理器应用举例",content:'# 1 原型模式介绍\n\n原型模式（Prototype Pattern）是一种对象创建型模式，它是使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。\n\n它的工作原理很简单：将一个原型对象传给要发动创建的对象（即客户端对象），这个要发动创建的对象通过请求原型对象复制自己来实现创建过程。\n\n\n\n> 意图： 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。\n> \n> 主要解决： 在运行期建立和删除原型。\n> \n> 何时使用： 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。\n> \n> 如何解决： 利用已有的一个原型对象，快速地生成和原型对象一样的实例。\n> \n> 关键代码： 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些"易变类"拥有稳定的接口。\n> \n> 应用实例： 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。\n> \n> 优点： 1、性能提高。 2、逃避构造函数的约束。\n> \n> 缺点： 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。\n> \n> 使用场景： 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。\n> \n> 注意事项： 与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。\n\n\n# 2 原型模式详解\n\n\n# 2.1 原型模式结构\n\n原型模式包含以下3个角色。\n\n 1. Prototype（抽象原型类）：它是声明克隆方法的接口，是所有具体原型类的公共父类，它可以是抽象类也可以是接口，甚至还可以是具体实现类。\n 2. ConcretePrototype（具体原型类）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。\n 3. Client（客户类）：在客户类中，让一个原型对象克隆自身从而创建一个新的对象，只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。\n\n\n# 2.2 深克隆与浅克隆\n\n根据在复制原型对象的同时是否复制包含在原型对象中引用类型的成员变量，原型模式的克隆机制可分为两种，即浅克隆（Shallow Clone）和深克隆（Deep Clone）。\n\n# 2.2.1 浅克隆\n\n在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。简单来说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。\n\n\n\n# 2.2.2 深克隆\n\n在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。\n\n\n\n\n# 2.3 原型模式实现\n\n实现原型模式的关键在于如何实现克隆方法。这里介绍两种在Java语言中最常用的克隆实现方法。\n\n# 2.3.1 通用实现方法\n\n通用的克隆实现方法是在具体原型类的克隆方法中实例化一个与自身类型相同的对象并将其返回，同时将相关的参数传入新创建的对象中，保证它们的成员变量相同。\n\n典型的抽象原型类代码如下：\n\npublic abstract class Prototype {\n    public abstract Prototype clone();\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n典型的具体原型类代码如下：\n\npublic class ConcretePrototype extends Prototype {\n    private String name; // 成员变量\n    public void setName(String name) {\n        this.name = name;\n    }\n    public void getName() {\n        return this.name;\n    }\n    // 克隆方法实现\n    public Prototype clone() {\n        Prototype prototype = new ConcretePrototype(); // 创建新对象\n        prototype.setName(this.name);\n        return prototype;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这样我们就只需要在客户类中创建一个ConcretePrototype对象作为原型对象，然后调用其clone()方法即可得到对应的克隆对象。\n\n此方法是原型模式的通用实现，它与编程语言本身的特性无关，其他面向对象编程语言也可以使用这种形式来实现对原型对象的克隆。\n\n在这种通用实现方法中，可通过手工编写clone()方法来实现浅克隆和深克隆。对于引用类型的对象，可以在clone()方法中通过赋值的方式来实现复制，这是一种浅克隆实现方案；如果在clone()方法中通过创建一个全新的成员对象来实现复制，则是一种深克隆实现方案。\n\n# 2.3.2 Java语言中的clone()方法和Cloneable接口\n\n在Java语言中，所有的Java类均继承自java.lang.Object类，Object类提供了一个clone()方法，可以将一个Java对象复制一份。因此在Java中可以直接使用Object提供clone()方法来实现对象的浅克隆。\n\n需要注意的是能够实现克隆的Java类都必须实现一个标识接口Cloneable，表示这个Java类支持被复制。如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将会抛出一个CloneNotSupportedException异常。如下代码所示：\n\npublic class ConcretePrototype implements Cloneable {\n    public Prototype clone() {\n        Object object = null;\n        try {\n            object = super.clone(); // 浅克隆\n        } catch (CloneNotSupportedException exception) {\n            System.err.println("Not support Cloneable");\n        }\n        return (Prototype)object;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n为了获取对象的一个克隆，可以直接利用Object类的clone()方法，其具体步骤如下：\n\n 1. 在派生类中覆盖基类的clone()方法，并声明为public。\n 2. 在派生类的clone()方法中调用super.clone()。\n 3. 派生类需实现Cloneable接口。\n\n此时，Object类相当于抽象原型类，所有实现了Cloneable接口的类相当于具体原型类。\n\n\n# 2.4 原型模式应用举例\n\n * 题目描述\n   \n   某数据处理软件需要增加一个图表复制功能。在图表对象（DataChart）中包含一个数据集对象(DataSet)。数据集对象用于封装要显示的数据，用户可以通过界面上的复制按钮将该图表复制一份，复制后，即可得到新的图表对象，然后可以修改新图表的编号、颜色、数据。试用原型模式设计软件实现深克隆。\n\n * UML类图\n   \n   在该设计方案中，DataChart 类包含一个 DataSet 对象，在复制 DataChart 对象的同时将 复制 DataSet 对象，因此需要使用深克隆技术，可使用流来实现深克隆。其中Serializable是java.io包中定义的、用于实现Java类的序列化操作而提供的一个语义级别的接口。Serializable序列化接口没有任何方法或者字段，只是用于标识可序列化的语义。实现了Serializable接口的类可以被ObjectOutputStream转换为字节流，同时也可以通过ObjectInputStream再将其解析为对象。故我们实现这个接口即可使用流来实现深克隆\n\n * 代码\n   \n   代码地址\n\n\n# 3 原型管理器\n\n\n# 3.1 原型管理器实现\n\n原型管理器(Prototype Manager)是将多个原型对象存储在一个集合中供客户端使用，它是一个专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象， 如果需要某个原型对象的一个克隆，可以通过复制集合中对应的原型对象来获得。 在原型管理器中针对抽象原型类进行编程，以便扩展。 其结构如图所示：\n\n\n\n其中典型的原型管理器PrototypeManager类的实现代码片段如下：\n\npackage prototype_pattern;\n\nimport java.util.Hashtable;\n\n/**\n * @author Cnc_hzf\n * @date 2022/4/22 15:00\n */\npublic class PrototypeManager {\n    private Hashtable prototypeTable = new Hashtable(); // 使用Hashtable存储原型对象\n    public PrototypeManager() {\n        prototypeTable.put("A", new ConcretePrototypeA());\n        prototypeTable.put("B", new ConcretePrototypeB());\n    }\n    public void add(String key, Prototype prototype) {\n        prototypeTable.put(key, prototype);\n    }\n    public Prototype get(String key) {\n        Prototype clone = ((Prototype) prototypeTable.get(key)).clone(); // 通过克隆方法创建新对象\n        return clone;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n在实际开发中可以将PrototypeManger设计为单例类，确保系统中有且仅有一个PrototypeManager对象，这样既有利于节省系统资源，还可以更好地对原型管理器对象进行控制。\n\n\n# 3.2 原型管理器应用举例\n\n * 题目描述\n   \n   > 某公司需要创建一个公文管理器，公文管理器中需要提供一个集合对象来存储一些公文模板，用户可以通过复制这些模板快速的创建新的公文，试使用带有原型管理器的原型模式来设计该公文管理器并使用Java代码编程模拟。\n\n * UML类图\n   \n   \n   \n   其中，OfficialDocument （抽象公文类）充当抽象原型类，其子类 FAR（Feasibility Analysis Report，可行性分析报告）和 SRS（Software Requirements Specification，软件需求规格说明书）充当具体原型类，PrototypeManager 充当原型管理器。\n\n * 代码\n   \n   代码地址',normalizedContent:'# 1 原型模式介绍\n\n原型模式（prototype pattern）是一种对象创建型模式，它是使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。\n\n它的工作原理很简单：将一个原型对象传给要发动创建的对象（即客户端对象），这个要发动创建的对象通过请求原型对象复制自己来实现创建过程。\n\n\n\n> 意图： 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。\n> \n> 主要解决： 在运行期建立和删除原型。\n> \n> 何时使用： 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。\n> \n> 如何解决： 利用已有的一个原型对象，快速地生成和原型对象一样的实例。\n> \n> 关键代码： 1、实现克隆操作，在 java 继承 cloneable，重写 clone()，在 .net 中可以使用 object 类的 memberwiseclone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些"易变类"拥有稳定的接口。\n> \n> 应用实例： 1、细胞分裂。 2、java 中的 object clone() 方法。\n> \n> 优点： 1、性能提高。 2、逃避构造函数的约束。\n> \n> 缺点： 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 cloneable 接口。\n> \n> 使用场景： 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 java 融为浑然一体，大家可以随手拿来使用。\n> \n> 注意事项： 与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 cloneable，重写，深拷贝是通过实现 serializable 读取二进制流。\n\n\n# 2 原型模式详解\n\n\n# 2.1 原型模式结构\n\n原型模式包含以下3个角色。\n\n 1. prototype（抽象原型类）：它是声明克隆方法的接口，是所有具体原型类的公共父类，它可以是抽象类也可以是接口，甚至还可以是具体实现类。\n 2. concreteprototype（具体原型类）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。\n 3. client（客户类）：在客户类中，让一个原型对象克隆自身从而创建一个新的对象，只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。\n\n\n# 2.2 深克隆与浅克隆\n\n根据在复制原型对象的同时是否复制包含在原型对象中引用类型的成员变量，原型模式的克隆机制可分为两种，即浅克隆（shallow clone）和深克隆（deep clone）。\n\n# 2.2.1 浅克隆\n\n在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。简单来说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。\n\n\n\n# 2.2.2 深克隆\n\n在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。\n\n\n\n\n# 2.3 原型模式实现\n\n实现原型模式的关键在于如何实现克隆方法。这里介绍两种在java语言中最常用的克隆实现方法。\n\n# 2.3.1 通用实现方法\n\n通用的克隆实现方法是在具体原型类的克隆方法中实例化一个与自身类型相同的对象并将其返回，同时将相关的参数传入新创建的对象中，保证它们的成员变量相同。\n\n典型的抽象原型类代码如下：\n\npublic abstract class prototype {\n    public abstract prototype clone();\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n典型的具体原型类代码如下：\n\npublic class concreteprototype extends prototype {\n    private string name; // 成员变量\n    public void setname(string name) {\n        this.name = name;\n    }\n    public void getname() {\n        return this.name;\n    }\n    // 克隆方法实现\n    public prototype clone() {\n        prototype prototype = new concreteprototype(); // 创建新对象\n        prototype.setname(this.name);\n        return prototype;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这样我们就只需要在客户类中创建一个concreteprototype对象作为原型对象，然后调用其clone()方法即可得到对应的克隆对象。\n\n此方法是原型模式的通用实现，它与编程语言本身的特性无关，其他面向对象编程语言也可以使用这种形式来实现对原型对象的克隆。\n\n在这种通用实现方法中，可通过手工编写clone()方法来实现浅克隆和深克隆。对于引用类型的对象，可以在clone()方法中通过赋值的方式来实现复制，这是一种浅克隆实现方案；如果在clone()方法中通过创建一个全新的成员对象来实现复制，则是一种深克隆实现方案。\n\n# 2.3.2 java语言中的clone()方法和cloneable接口\n\n在java语言中，所有的java类均继承自java.lang.object类，object类提供了一个clone()方法，可以将一个java对象复制一份。因此在java中可以直接使用object提供clone()方法来实现对象的浅克隆。\n\n需要注意的是能够实现克隆的java类都必须实现一个标识接口cloneable，表示这个java类支持被复制。如果一个类没有实现这个接口但是调用了clone()方法，java编译器将会抛出一个clonenotsupportedexception异常。如下代码所示：\n\npublic class concreteprototype implements cloneable {\n    public prototype clone() {\n        object object = null;\n        try {\n            object = super.clone(); // 浅克隆\n        } catch (clonenotsupportedexception exception) {\n            system.err.println("not support cloneable");\n        }\n        return (prototype)object;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n为了获取对象的一个克隆，可以直接利用object类的clone()方法，其具体步骤如下：\n\n 1. 在派生类中覆盖基类的clone()方法，并声明为public。\n 2. 在派生类的clone()方法中调用super.clone()。\n 3. 派生类需实现cloneable接口。\n\n此时，object类相当于抽象原型类，所有实现了cloneable接口的类相当于具体原型类。\n\n\n# 2.4 原型模式应用举例\n\n * 题目描述\n   \n   某数据处理软件需要增加一个图表复制功能。在图表对象（datachart）中包含一个数据集对象(dataset)。数据集对象用于封装要显示的数据，用户可以通过界面上的复制按钮将该图表复制一份，复制后，即可得到新的图表对象，然后可以修改新图表的编号、颜色、数据。试用原型模式设计软件实现深克隆。\n\n * uml类图\n   \n   在该设计方案中，datachart 类包含一个 dataset 对象，在复制 datachart 对象的同时将 复制 dataset 对象，因此需要使用深克隆技术，可使用流来实现深克隆。其中serializable是java.io包中定义的、用于实现java类的序列化操作而提供的一个语义级别的接口。serializable序列化接口没有任何方法或者字段，只是用于标识可序列化的语义。实现了serializable接口的类可以被objectoutputstream转换为字节流，同时也可以通过objectinputstream再将其解析为对象。故我们实现这个接口即可使用流来实现深克隆\n\n * 代码\n   \n   代码地址\n\n\n# 3 原型管理器\n\n\n# 3.1 原型管理器实现\n\n原型管理器(prototype manager)是将多个原型对象存储在一个集合中供客户端使用，它是一个专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象， 如果需要某个原型对象的一个克隆，可以通过复制集合中对应的原型对象来获得。 在原型管理器中针对抽象原型类进行编程，以便扩展。 其结构如图所示：\n\n\n\n其中典型的原型管理器prototypemanager类的实现代码片段如下：\n\npackage prototype_pattern;\n\nimport java.util.hashtable;\n\n/**\n * @author cnc_hzf\n * @date 2022/4/22 15:00\n */\npublic class prototypemanager {\n    private hashtable prototypetable = new hashtable(); // 使用hashtable存储原型对象\n    public prototypemanager() {\n        prototypetable.put("a", new concreteprototypea());\n        prototypetable.put("b", new concreteprototypeb());\n    }\n    public void add(string key, prototype prototype) {\n        prototypetable.put(key, prototype);\n    }\n    public prototype get(string key) {\n        prototype clone = ((prototype) prototypetable.get(key)).clone(); // 通过克隆方法创建新对象\n        return clone;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n在实际开发中可以将prototypemanger设计为单例类，确保系统中有且仅有一个prototypemanager对象，这样既有利于节省系统资源，还可以更好地对原型管理器对象进行控制。\n\n\n# 3.2 原型管理器应用举例\n\n * 题目描述\n   \n   > 某公司需要创建一个公文管理器，公文管理器中需要提供一个集合对象来存储一些公文模板，用户可以通过复制这些模板快速的创建新的公文，试使用带有原型管理器的原型模式来设计该公文管理器并使用java代码编程模拟。\n\n * uml类图\n   \n   \n   \n   其中，officialdocument （抽象公文类）充当抽象原型类，其子类 far（feasibility analysis report，可行性分析报告）和 srs（software requirements specification，软件需求规格说明书）充当具体原型类，prototypemanager 充当原型管理器。\n\n * 代码\n   \n   代码地址',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"设计模式之适配器模式详解（Java实现）",frontmatter:{title:"设计模式之适配器模式详解（Java实现）",date:"2022-04-24T18:54:37.000Z",tags:["适配器模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/2bc5dd/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89.html",relativePath:"01.开发/02.开发框架/03.设计模式/05.设计模式之适配器模式详解（Java实现）.md",key:"v-79e3d1ae",path:"/pages/2bc5dd/",headers:[{level:2,title:"1 适配器模式介绍",slug:"_1-适配器模式介绍",normalizedTitle:"1 适配器模式介绍",charIndex:2},{level:2,title:"2 适配器模式详解",slug:"_2-适配器模式详解",normalizedTitle:"2 适配器模式详解",charIndex:1166},{level:3,title:"2.1 适配器模式结构",slug:"_2-1-适配器模式结构",normalizedTitle:"2.1 适配器模式结构",charIndex:1180},{level:3,title:"2.2 适配器模式实现",slug:"_2-2-适配器模式实现",normalizedTitle:"2.2 适配器模式实现",charIndex:1600},{level:4,title:"2.2.1 类适配器",slug:"_2-2-1-类适配器",normalizedTitle:"2.2.1 类适配器",charIndex:1615},{level:4,title:"2.2.2 对象适配器",slug:"_2-2-2-对象适配器",normalizedTitle:"2.2.2 对象适配器",charIndex:2049},{level:3,title:"2.3 适配器模式应用举例",slug:"_2-3-适配器模式应用举例",normalizedTitle:"2.3 适配器模式应用举例",charIndex:2642},{level:2,title:"3 缺省适配器模式",slug:"_3-缺省适配器模式",normalizedTitle:"3 缺省适配器模式",charIndex:2981},{level:2,title:"4 双向适配器",slug:"_4-双向适配器",normalizedTitle:"4 双向适配器",charIndex:3755}],headersStr:"1 适配器模式介绍 2 适配器模式详解 2.1 适配器模式结构 2.2 适配器模式实现 2.2.1 类适配器 2.2.2 对象适配器 2.3 适配器模式应用举例 3 缺省适配器模式 4 双向适配器",content:'# 1 适配器模式介绍\n\n\n\n在现实生活中生活用电220V和笔记电脑20V不兼容，我们需要引入 AC Adapter（交流电适配器），在软件开发中我们也会存在不兼容的结构，这个时候就需要引入适配器模式。\n\n适配器模式（Adapter Pattern）可以将一个类的接口和另一个类的接口匹配起来，而无需修改原来的适配者接口和抽象目标接口。\n\n它将一个类的接口转换称客户希望的另一个接口，让那些接口不兼容的类可以一起工作。\n\n适配器模式的别名为包装器模式（Wrapper Pattern），它既可以作为类结构模式，也可以作为对象结构型模式。在适配器模式的定义中所提及的接口是指广义的接口，它可以表示为方法或者方法的集合。\n\n> 主要解决： 主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。\n> \n> 何时使用： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）\n> \n> 如何解决： 继承或依赖（推荐）。\n> \n> 关键代码： 适配器继承或依赖已有的对象，实现想要的目标接口。\n> \n> 应用实例： 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。\n> \n> 优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。\n> \n> 缺点： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。\n> \n> 使用场景： 有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。\n> \n> 注意事项： 适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。\n\n\n# 2 适配器模式详解\n\n\n# 2.1 适配器模式结构\n\n类适配器模式的结构图如下：\n\n\n\n对象适配器模式的结构图如下：\n\n\n\n由上图可知，适配器模式包含以下3个角色。\n\n 1. Target（目标抽象类）：目标抽象类定义客户所需的接口，可以是一个抽象类或者接口，也可以是具体类。在类适配器中，由于Java语言不支持多重继承，它只能是接口。\n 2. Adapter（适配器类）：它可以调用另一个接口 ，作为一个转换器，对Adaptee和Target进行适配。适配器Adapter是适配器模式的核心，在类适配器中，它通过实现Target接口并继承Adaptee类来使二者产生联系，在对象适配器中，它通过继承Target并关联一个Adaptee对象来使二者产生联系。\n 3. Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体的类，包含了客户希望使用的业务方法，在某些情况下甚至没有适配者类的代码。\n\n\n# 2.2 适配器模式实现\n\n# 2.2.1 类适配器\n\n根据上图，在类适配器中适配者类Adaptee没有request方法，而客户端期待这个方法，但在适配者类中实现了specificRequest()方法，该方法提供的实现正式客户端所需要的。为了使客户端能够使用适配者类，提供了一个中间类，即适配器类Adapter，适配器类实现了抽象目标类接口Target，并继承了适配者类，在适配器类的request()方法中调用所继承的适配者类的specificRequest()方法，达到了适配的目的。\n\n因为适配器类与适配者类使继承关系，所以这种适配器模式称为类适配器模式。典型的类适配器代码如下：\n\npublic class Adapter extends Adaptee implements Target {\n    public void request() {\n        super.specificRequest();\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n# 2.2.2 对象适配器\n\n根据上图，在对象适配器中适配者类Adaptee没有request方法，而客户端期待这个方法，但在适配者类中实现了specificRequest()方法，该方法提供的实现正式客户端所需要的。为了使客户端能够使用适配者类，需要提供一个包装类Adapter，即适配器类。\n\n这个包装类包装了一个适配者的实例，从而将客户端与适配者衔接起来，在适配器的request()方法中调用适配者的specificRequest()方法。\n\n因为适配器类与适配者类是关联关系，所以这种适配器模式称为对象适配器模式。典型的对象适配器代码如下：\n\npublic class Adapter extends Target {\n    // 维持一个对适配者对象的引用\n    private Adaptee adaptee;\n    \n    public Adapter(Adaptee adaptee) {\n        this.adaptee = adaptee;\n    }\n    public void request() {\n        // 转发调用\n        adaptee.specificRequest();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2.3 适配器模式应用举例\n\n * 题目描述\n   \n   > 某公司欲开发一款儿童玩具汽车，为了更好地吸引小朋友的注意力，该玩具汽车在移动过程中伴随着灯光闪烁和声音提示。在该公司以往的产品中已经实现了控制灯光闪烁（例如警灯闪烁）和声音提示（例如警笛音效）的程序，为了重用先前的代码并且使得汽车控制软件具有更好的灵活性和扩展性，现使用适配器模式设计该玩具汽车控制软件。\n\n * UML类图\n   \n   使用对象适配器模式来实现，其UML类图如下：\n   \n   \n   \n   其中，CarController类充当抽象目标，PoliceSound和PoliceLamp类充当适配者，PoliceCarAdapter充当适配器。\n\n * 代码\n   \n   代码地址\n\n\n# 3 缺省适配器模式\n\n缺省适配器模式(Default Adapter Pattern)：当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。其结构图如下：\n\n\n\n由上图可知，在缺省适配器模式中包含以下3个角色：\n\n 1. ServiceInterface（适配者接口）：它是一个接口，通常在接口中声明了大量的方法。\n 2. AbstractServiceClass（缺省适配器类）：它是缺省适配器模式的核心类，使用空方法的形式实现了在ServiceInterface接口中声明的方法。通常将它定义为抽象类，因为对它进行实例化没有任何意义。\n 3. ConcreteServiceClass（具体业务类）：它是缺省适配器类的子类，在没有引入适配器之前它需要实现适配者接口，因此需要实现在适配者接口中定义的所有方法，而对于一些无须使用的方法不得不提供空实现。在有了缺省适配器之后可以直接继承该适配者类，根据需要有选择性地覆盖在适配器类中定义的方法。\n\n缺省适配器类的典型代码如下：\n\npublic abstract class AbstractServiceClass implements ServiceInterface {\n    public void serviceMethod1() {  }  //空方法\n    public void serviceMethod2() {  }  //空方法\n    public void serviceMethod3() {  }  //空方法\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 4 双向适配器\n\n在对象适配器的使用过程中，如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类的方法，那么该适配器就是一个双向适配器。其结构图如下：\n\n\n\n其典型代码如下：\n\npublic class Adapter implements Target,Adaptee {\n    // 同时维持对抽象目标类和适配者类的引用\n    private Target target;\n    private Adaptee adaptee;\n  \n    public Adapter(Target target) {\n        this.target = target;\n    }\n  \n    public Adapter(Adaptee adaptee) {\n        this.adaptee = adaptee;\n    }\n  \n    public void request() {\n        adaptee.specificRequest();\n    }\n  \n    public void specificRequest() {\n        target.request();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n',normalizedContent:'# 1 适配器模式介绍\n\n\n\n在现实生活中生活用电220v和笔记电脑20v不兼容，我们需要引入 ac adapter（交流电适配器），在软件开发中我们也会存在不兼容的结构，这个时候就需要引入适配器模式。\n\n适配器模式（adapter pattern）可以将一个类的接口和另一个类的接口匹配起来，而无需修改原来的适配者接口和抽象目标接口。\n\n它将一个类的接口转换称客户希望的另一个接口，让那些接口不兼容的类可以一起工作。\n\n适配器模式的别名为包装器模式（wrapper pattern），它既可以作为类结构模式，也可以作为对象结构型模式。在适配器模式的定义中所提及的接口是指广义的接口，它可以表示为方法或者方法的集合。\n\n> 主要解决： 主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。\n> \n> 何时使用： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）\n> \n> 如何解决： 继承或依赖（推荐）。\n> \n> 关键代码： 适配器继承或依赖已有的对象，实现想要的目标接口。\n> \n> 应用实例： 1、美国电器 110v，中国 220v，就要有一个适配器将 110v 转化为 220v。 2、java jdk 1.1 提供了 enumeration 接口，而在 1.2 中提供了 iterator 接口，想要使用 1.2 的 jdk，则要将以前系统的 enumeration 接口转化为 iterator 接口，这时就需要适配器模式。 3、在 linux 上运行 windows 程序。 4、java 中的 jdbc。\n> \n> 优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。\n> \n> 缺点： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 a 接口，其实内部被适配成了 b 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 java 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。\n> \n> 使用场景： 有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。\n> \n> 注意事项： 适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。\n\n\n# 2 适配器模式详解\n\n\n# 2.1 适配器模式结构\n\n类适配器模式的结构图如下：\n\n\n\n对象适配器模式的结构图如下：\n\n\n\n由上图可知，适配器模式包含以下3个角色。\n\n 1. target（目标抽象类）：目标抽象类定义客户所需的接口，可以是一个抽象类或者接口，也可以是具体类。在类适配器中，由于java语言不支持多重继承，它只能是接口。\n 2. adapter（适配器类）：它可以调用另一个接口 ，作为一个转换器，对adaptee和target进行适配。适配器adapter是适配器模式的核心，在类适配器中，它通过实现target接口并继承adaptee类来使二者产生联系，在对象适配器中，它通过继承target并关联一个adaptee对象来使二者产生联系。\n 3. adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体的类，包含了客户希望使用的业务方法，在某些情况下甚至没有适配者类的代码。\n\n\n# 2.2 适配器模式实现\n\n# 2.2.1 类适配器\n\n根据上图，在类适配器中适配者类adaptee没有request方法，而客户端期待这个方法，但在适配者类中实现了specificrequest()方法，该方法提供的实现正式客户端所需要的。为了使客户端能够使用适配者类，提供了一个中间类，即适配器类adapter，适配器类实现了抽象目标类接口target，并继承了适配者类，在适配器类的request()方法中调用所继承的适配者类的specificrequest()方法，达到了适配的目的。\n\n因为适配器类与适配者类使继承关系，所以这种适配器模式称为类适配器模式。典型的类适配器代码如下：\n\npublic class adapter extends adaptee implements target {\n    public void request() {\n        super.specificrequest();\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n# 2.2.2 对象适配器\n\n根据上图，在对象适配器中适配者类adaptee没有request方法，而客户端期待这个方法，但在适配者类中实现了specificrequest()方法，该方法提供的实现正式客户端所需要的。为了使客户端能够使用适配者类，需要提供一个包装类adapter，即适配器类。\n\n这个包装类包装了一个适配者的实例，从而将客户端与适配者衔接起来，在适配器的request()方法中调用适配者的specificrequest()方法。\n\n因为适配器类与适配者类是关联关系，所以这种适配器模式称为对象适配器模式。典型的对象适配器代码如下：\n\npublic class adapter extends target {\n    // 维持一个对适配者对象的引用\n    private adaptee adaptee;\n    \n    public adapter(adaptee adaptee) {\n        this.adaptee = adaptee;\n    }\n    public void request() {\n        // 转发调用\n        adaptee.specificrequest();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2.3 适配器模式应用举例\n\n * 题目描述\n   \n   > 某公司欲开发一款儿童玩具汽车，为了更好地吸引小朋友的注意力，该玩具汽车在移动过程中伴随着灯光闪烁和声音提示。在该公司以往的产品中已经实现了控制灯光闪烁（例如警灯闪烁）和声音提示（例如警笛音效）的程序，为了重用先前的代码并且使得汽车控制软件具有更好的灵活性和扩展性，现使用适配器模式设计该玩具汽车控制软件。\n\n * uml类图\n   \n   使用对象适配器模式来实现，其uml类图如下：\n   \n   \n   \n   其中，carcontroller类充当抽象目标，policesound和policelamp类充当适配者，policecaradapter充当适配器。\n\n * 代码\n   \n   代码地址\n\n\n# 3 缺省适配器模式\n\n缺省适配器模式(default adapter pattern)：当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。其结构图如下：\n\n\n\n由上图可知，在缺省适配器模式中包含以下3个角色：\n\n 1. serviceinterface（适配者接口）：它是一个接口，通常在接口中声明了大量的方法。\n 2. abstractserviceclass（缺省适配器类）：它是缺省适配器模式的核心类，使用空方法的形式实现了在serviceinterface接口中声明的方法。通常将它定义为抽象类，因为对它进行实例化没有任何意义。\n 3. concreteserviceclass（具体业务类）：它是缺省适配器类的子类，在没有引入适配器之前它需要实现适配者接口，因此需要实现在适配者接口中定义的所有方法，而对于一些无须使用的方法不得不提供空实现。在有了缺省适配器之后可以直接继承该适配者类，根据需要有选择性地覆盖在适配器类中定义的方法。\n\n缺省适配器类的典型代码如下：\n\npublic abstract class abstractserviceclass implements serviceinterface {\n    public void servicemethod1() {  }  //空方法\n    public void servicemethod2() {  }  //空方法\n    public void servicemethod3() {  }  //空方法\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 4 双向适配器\n\n在对象适配器的使用过程中，如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类的方法，那么该适配器就是一个双向适配器。其结构图如下：\n\n\n\n其典型代码如下：\n\npublic class adapter implements target,adaptee {\n    // 同时维持对抽象目标类和适配者类的引用\n    private target target;\n    private adaptee adaptee;\n  \n    public adapter(target target) {\n        this.target = target;\n    }\n  \n    public adapter(adaptee adaptee) {\n        this.adaptee = adaptee;\n    }\n  \n    public void request() {\n        adaptee.specificrequest();\n    }\n  \n    public void specificrequest() {\n        target.request();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"C++11多线程 std::thread详解",frontmatter:{title:"C++11多线程 std::thread详解",date:"2022-04-07T21:04:13.000Z",tags:["多线程"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/9c1ae3/",categories:["开发","编程语言","C/C++"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.C++/01.C++11%E5%A4%9A%E7%BA%BF%E7%A8%8B%20std::thread%E8%AF%A6%E8%A7%A3.html",relativePath:"01.开发/01.编程语言/02.C++/01.C++11多线程 std::thread详解.md",key:"v-bf38e39a",path:"/pages/9c1ae3/",headers:[{level:2,title:"1 前言",slug:"_1-前言",normalizedTitle:"1 前言",charIndex:2},{level:2,title:"2 std::thread",slug:"_2-std-thread",normalizedTitle:"2 std::thread",charIndex:398},{level:3,title:"2.1 构造函数",slug:"_2-1-构造函数",normalizedTitle:"2.1 构造函数",charIndex:416},{level:3,title:"2.2 观察器",slug:"_2-2-观察器",normalizedTitle:"2.2 观察器",charIndex:3502},{level:4,title:"2.2.1 std::thread::joinable",slug:"_2-2-1-std-thread-joinable",normalizedTitle:"2.2.1 std::thread::joinable",charIndex:3513},{level:4,title:"2.2.2 std::thread::get_id",slug:"_2-2-2-std-thread-get-id",normalizedTitle:"2.2.2 std::thread::get_id",charIndex:4384},{level:3,title:"2.3 操作",slug:"_2-3-操作",normalizedTitle:"2.3 操作",charIndex:5123},{level:4,title:"2.3.1 std::thread::join",slug:"_2-3-1-std-thread-join",normalizedTitle:"2.3.1 std::thread::join",charIndex:5133},{level:4,title:"2.3.2 std::thread::detach",slug:"_2-3-2-std-thread-detach",normalizedTitle:"2.3.2 std::thread::detach",charIndex:6211}],headersStr:"1 前言 2 std::thread 2.1 构造函数 2.2 观察器 2.2.1 std::thread::joinable 2.2.2 std::thread::get_id 2.3 操作 2.3.1 std::thread::join 2.3.2 std::thread::detach",content:'# 1 前言\n\n> 我们知道，当程序运行起来，生成一个进程，该进程所属的主线程开始自动运行，C/C++的主线程就是main函数；当主线程从main()函数返回，则整个进程执行完毕。\n\n所以主线程是从main()开始执行，其中我们自己创建的线程，也需要从一个函数开始运行（初始函数），一旦这个函数运行完毕，线程也结束运行。所以整个进程是否执行完毕的标志是：主线程是否执行完，如果主线程执行完毕了，就代表整个进程执行完毕了，此时如果其他子线程还没有执行完，也会被强行终止（符合大部分规律，也有例外）。\n\n我们需要明白，如果有两个线程在跑，相当于整个程序中有两条线在同时走，即使一条被阻塞，另一条也能运行。\n\n在C++11以前，使用线程库特别麻烦，C++11提供了一个新标准线程库，即thread，意味着C++语言本身增加对多线程的支持，意味着可移植性（跨平台），这大大减少开发人员的工作量。\n\n\n# 2 std::thread\n\n\n# 2.1 构造函数\n\n构造函数如下，其含义分别注释：\n\nthread() noexcept; // 创建不代表线程的新线程对象。\nthread( thread&& other ) noexcept; // 移动构造函数。构造表示曾为 other 所表示的执行线程的 thread 对象。此调用后 other 不再表示执行线程。一般需要使用move方法\ntemplate< class Function, class... Args > \n   explicit thread( Function&& f, Args&&... args ); // 构造新的 std::thread 对象并将它与执行线程关联。新的执行线程开始执行。其中f为可调用函数对象，args为传递的函数参数，一定要相互对应。\nthread(const thread&) = delete; // 复制构造函数被删除，线程不可复制。\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n创建线程对象总共有以下几种方法：\n\n#include <iostream>\n#include <thread>\n#include <unistd.h> // 提供sleep函数\n\nvoid sum(int a, int b) {\n    std::cout << a + b << std::endl;\n}\nint main() {\n    std::thread t1(); // 不是线程，使用第一种构造方法\n    int a = 1, b = 2;\n    std::thread t2(sum, a, b); // 是线程，按值传递，使用第三种构造方法\n    std::thread t3(sum, std::ref(a), std::ref(b)); // 是线程，按引用传递，使用第三种构造方法\n    std::thread t4(std::move(t2)); // t3现在是线程，运行sum，t2不再是线程。这是使用第二种构造方法。\n    t2.join();\n    t4.join();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n官网上的给的代码如下（这种种类更多，适合用来分析学习，上面列举的内容实际上就够用了）：\n\n#include <iostream>\n#include <utility>\n#include <thread>\n#include <chrono>\n \nvoid f1(int n)\n{\n    for (int i = 0; i < 5; ++i) {\n        std::cout << "Thread 1 executing\\n";\n        ++n;\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    }\n}\n \nvoid f2(int& n)\n{\n    for (int i = 0; i < 5; ++i) {\n        std::cout << "Thread 2 executing\\n";\n        ++n;\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    }\n}\n \nclass foo\n{\npublic:\n    void bar()\n    {\n        for (int i = 0; i < 5; ++i) {\n            std::cout << "Thread 3 executing\\n";\n            ++n;\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        }\n    }\n    int n = 0;\n};\n \nclass baz\n{\npublic:\n    void operator()()\n    {\n        for (int i = 0; i < 5; ++i) {\n            std::cout << "Thread 4 executing\\n";\n            ++n;\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        }\n    }\n    int n = 0;\n};\n \nint main()\n{\n    int n = 0;\n    foo f;\n    baz b;\n    std::thread t1; // t1 is not a thread\n    std::thread t2(f1, n + 1); // pass by value\n    std::thread t3(f2, std::ref(n)); // pass by reference\n    std::thread t4(std::move(t3)); // t4 is now running f2(). t3 is no longer a thread\n    std::thread t5(&foo::bar, &f); // t5 runs foo::bar() on object f\n    std::thread t6(b); // t6 runs baz::operator() on a copy of object b\n    t2.join();\n    t4.join();\n    t5.join();\n    t6.join();\n    std::cout << "Final value of n is " << n << \'\\n\';\n    std::cout << "Final value of f.n (foo::n) is " << f.n << \'\\n\';\n    std::cout << "Final value of b.n (baz::n) is " << b.n << \'\\n\';\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n\n# 2.2 观察器\n\n# 2.2.1 std::thread::joinable\n\nbool joinable() const noexcept;\n\n\n1\n\n1\n\n\n这个函数用来检查this是否标识了一个活动的执行线程，即如果this标识了一个活动的执行线程，就返回true，否则返回false。\n\n#include <iostream>\n#include <thread>\n#include <chrono>\n \nvoid foo()\n{\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n}\n \nint main()\n{\n    std::thread t;\n    std::cout << "before starting, joinable: " << std::boolalpha << t.joinable()\n              << \'\\n\';\n \n    t = std::thread(foo);\n    std::cout << "after starting, joinable: " << t.joinable() \n              << \'\\n\';\n \n    t.join();\n    std::cout << "after joining, joinable: " << t.joinable() \n              << \'\\n\';\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\nOutput:\n\nbefore starting, joinable: false\nafter starting, joinable: true\nafter joining, joinable: false\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n# 2.2.2 std::thread::get_id\n\nstd::thread::id get_id() const noexcept;\n\n\n1\n\n1\n\n\n返回标识与 *this 关联的线程的 std::thread::id 。如果没有关联线程，则返回默认构造的std::thread::id。\n\n#include <iostream>\n#include <thread>\n#include <chrono>\n \nvoid foo()\n{\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n}\n \nint main()\n{\n    std::thread t1(foo);\n    std::thread::id t1_id = t1.get_id();\n \n    std::thread t2(foo);\n    std::thread::id t2_id = t2.get_id();\n \n    std::cout << "t1\'s id: " << t1_id << \'\\n\';\n    std::cout << "t2\'s id: " << t2_id << \'\\n\';\n \n    t1.join();\n    t2.join();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\nPossible output:\n\nt1\'s id: 2\nt2\'s id: 3\n\n\n1\n2\n\n1\n2\n\n\n\n# 2.3 操作\n\n# 2.3.1 std::thread::join\n\nvoid join();\n\n\n1\n\n1\n\n\n阻塞当前线程直至 *this所标识的线程结束其执行。*this 所标识的线程的完成同步于对应的从 join() 成功返回。*this 自身上不进行同步。同时从多个线程在同一 thread 对象上调用 join() 构成数据竞争，导致未定义行为。\n\n可能引发的异常为：std::system_error\n\n#include <iostream>\n#include <thread>\n#include <chrono>\n \nvoid foo()\n{\n    // simulate expensive operation\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n}\n \nvoid bar()\n{\n    // simulate expensive operation\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n}\n \nint main()\n{\n    std::cout << "starting first helper...\\n";\n    std::thread helper1(foo);\n \n    std::cout << "starting second helper...\\n";\n    std::thread helper2(bar);\n \n    std::cout << "waiting for helpers to finish..." << std::endl;\n    helper1.join();\n    helper2.join();\n \n    std::cout << "done!\\n";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\nOutput:\n\nstarting first helper...\nstarting second helper...\nwaiting for helpers to finish...\ndone!\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n# 2.3.2 std::thread::detach\n\nvoid detach();\n\n\n1\n\n1\n\n\n从 thread 对象分离执行线程，允许执行独立地持续。一旦该线程退出，则释放任何分配的资源。调用 detach 后 *this 不再占有任何线程。\n\n可能引发的异常为：std::system_error\n\n#include <iostream>\n#include <chrono>\n#include <thread>\n \nvoid independentThread() \n{\n    std::cout << "Starting concurrent thread.\\n";\n    std::this_thread::sleep_for(std::chrono::seconds(2));\n    std::cout << "Exiting concurrent thread.\\n";\n}\n \nvoid threadCaller() \n{\n    std::cout << "Starting thread caller.\\n";\n    std::thread t(independentThread);\n    t.detach();\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    std::cout << "Exiting thread caller.\\n";\n}\n \nint main() \n{\n    threadCaller();\n    std::this_thread::sleep_for(std::chrono::seconds(5));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\nPossible output:\n\nStarting thread caller.\nStarting concurrent thread.\nExiting thread caller.\nExiting concurrent thread.\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n这个示例即表明了主线程将先执行完。',normalizedContent:'# 1 前言\n\n> 我们知道，当程序运行起来，生成一个进程，该进程所属的主线程开始自动运行，c/c++的主线程就是main函数；当主线程从main()函数返回，则整个进程执行完毕。\n\n所以主线程是从main()开始执行，其中我们自己创建的线程，也需要从一个函数开始运行（初始函数），一旦这个函数运行完毕，线程也结束运行。所以整个进程是否执行完毕的标志是：主线程是否执行完，如果主线程执行完毕了，就代表整个进程执行完毕了，此时如果其他子线程还没有执行完，也会被强行终止（符合大部分规律，也有例外）。\n\n我们需要明白，如果有两个线程在跑，相当于整个程序中有两条线在同时走，即使一条被阻塞，另一条也能运行。\n\n在c++11以前，使用线程库特别麻烦，c++11提供了一个新标准线程库，即thread，意味着c++语言本身增加对多线程的支持，意味着可移植性（跨平台），这大大减少开发人员的工作量。\n\n\n# 2 std::thread\n\n\n# 2.1 构造函数\n\n构造函数如下，其含义分别注释：\n\nthread() noexcept; // 创建不代表线程的新线程对象。\nthread( thread&& other ) noexcept; // 移动构造函数。构造表示曾为 other 所表示的执行线程的 thread 对象。此调用后 other 不再表示执行线程。一般需要使用move方法\ntemplate< class function, class... args > \n   explicit thread( function&& f, args&&... args ); // 构造新的 std::thread 对象并将它与执行线程关联。新的执行线程开始执行。其中f为可调用函数对象，args为传递的函数参数，一定要相互对应。\nthread(const thread&) = delete; // 复制构造函数被删除，线程不可复制。\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n创建线程对象总共有以下几种方法：\n\n#include <iostream>\n#include <thread>\n#include <unistd.h> // 提供sleep函数\n\nvoid sum(int a, int b) {\n    std::cout << a + b << std::endl;\n}\nint main() {\n    std::thread t1(); // 不是线程，使用第一种构造方法\n    int a = 1, b = 2;\n    std::thread t2(sum, a, b); // 是线程，按值传递，使用第三种构造方法\n    std::thread t3(sum, std::ref(a), std::ref(b)); // 是线程，按引用传递，使用第三种构造方法\n    std::thread t4(std::move(t2)); // t3现在是线程，运行sum，t2不再是线程。这是使用第二种构造方法。\n    t2.join();\n    t4.join();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n官网上的给的代码如下（这种种类更多，适合用来分析学习，上面列举的内容实际上就够用了）：\n\n#include <iostream>\n#include <utility>\n#include <thread>\n#include <chrono>\n \nvoid f1(int n)\n{\n    for (int i = 0; i < 5; ++i) {\n        std::cout << "thread 1 executing\\n";\n        ++n;\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    }\n}\n \nvoid f2(int& n)\n{\n    for (int i = 0; i < 5; ++i) {\n        std::cout << "thread 2 executing\\n";\n        ++n;\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    }\n}\n \nclass foo\n{\npublic:\n    void bar()\n    {\n        for (int i = 0; i < 5; ++i) {\n            std::cout << "thread 3 executing\\n";\n            ++n;\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        }\n    }\n    int n = 0;\n};\n \nclass baz\n{\npublic:\n    void operator()()\n    {\n        for (int i = 0; i < 5; ++i) {\n            std::cout << "thread 4 executing\\n";\n            ++n;\n            std::this_thread::sleep_for(std::chrono::milliseconds(10));\n        }\n    }\n    int n = 0;\n};\n \nint main()\n{\n    int n = 0;\n    foo f;\n    baz b;\n    std::thread t1; // t1 is not a thread\n    std::thread t2(f1, n + 1); // pass by value\n    std::thread t3(f2, std::ref(n)); // pass by reference\n    std::thread t4(std::move(t3)); // t4 is now running f2(). t3 is no longer a thread\n    std::thread t5(&foo::bar, &f); // t5 runs foo::bar() on object f\n    std::thread t6(b); // t6 runs baz::operator() on a copy of object b\n    t2.join();\n    t4.join();\n    t5.join();\n    t6.join();\n    std::cout << "final value of n is " << n << \'\\n\';\n    std::cout << "final value of f.n (foo::n) is " << f.n << \'\\n\';\n    std::cout << "final value of b.n (baz::n) is " << b.n << \'\\n\';\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n\n# 2.2 观察器\n\n# 2.2.1 std::thread::joinable\n\nbool joinable() const noexcept;\n\n\n1\n\n1\n\n\n这个函数用来检查this是否标识了一个活动的执行线程，即如果this标识了一个活动的执行线程，就返回true，否则返回false。\n\n#include <iostream>\n#include <thread>\n#include <chrono>\n \nvoid foo()\n{\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n}\n \nint main()\n{\n    std::thread t;\n    std::cout << "before starting, joinable: " << std::boolalpha << t.joinable()\n              << \'\\n\';\n \n    t = std::thread(foo);\n    std::cout << "after starting, joinable: " << t.joinable() \n              << \'\\n\';\n \n    t.join();\n    std::cout << "after joining, joinable: " << t.joinable() \n              << \'\\n\';\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\noutput:\n\nbefore starting, joinable: false\nafter starting, joinable: true\nafter joining, joinable: false\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n# 2.2.2 std::thread::get_id\n\nstd::thread::id get_id() const noexcept;\n\n\n1\n\n1\n\n\n返回标识与 *this 关联的线程的 std::thread::id 。如果没有关联线程，则返回默认构造的std::thread::id。\n\n#include <iostream>\n#include <thread>\n#include <chrono>\n \nvoid foo()\n{\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n}\n \nint main()\n{\n    std::thread t1(foo);\n    std::thread::id t1_id = t1.get_id();\n \n    std::thread t2(foo);\n    std::thread::id t2_id = t2.get_id();\n \n    std::cout << "t1\'s id: " << t1_id << \'\\n\';\n    std::cout << "t2\'s id: " << t2_id << \'\\n\';\n \n    t1.join();\n    t2.join();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\npossible output:\n\nt1\'s id: 2\nt2\'s id: 3\n\n\n1\n2\n\n1\n2\n\n\n\n# 2.3 操作\n\n# 2.3.1 std::thread::join\n\nvoid join();\n\n\n1\n\n1\n\n\n阻塞当前线程直至 *this所标识的线程结束其执行。*this 所标识的线程的完成同步于对应的从 join() 成功返回。*this 自身上不进行同步。同时从多个线程在同一 thread 对象上调用 join() 构成数据竞争，导致未定义行为。\n\n可能引发的异常为：std::system_error\n\n#include <iostream>\n#include <thread>\n#include <chrono>\n \nvoid foo()\n{\n    // simulate expensive operation\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n}\n \nvoid bar()\n{\n    // simulate expensive operation\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n}\n \nint main()\n{\n    std::cout << "starting first helper...\\n";\n    std::thread helper1(foo);\n \n    std::cout << "starting second helper...\\n";\n    std::thread helper2(bar);\n \n    std::cout << "waiting for helpers to finish..." << std::endl;\n    helper1.join();\n    helper2.join();\n \n    std::cout << "done!\\n";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\noutput:\n\nstarting first helper...\nstarting second helper...\nwaiting for helpers to finish...\ndone!\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n# 2.3.2 std::thread::detach\n\nvoid detach();\n\n\n1\n\n1\n\n\n从 thread 对象分离执行线程，允许执行独立地持续。一旦该线程退出，则释放任何分配的资源。调用 detach 后 *this 不再占有任何线程。\n\n可能引发的异常为：std::system_error\n\n#include <iostream>\n#include <chrono>\n#include <thread>\n \nvoid independentthread() \n{\n    std::cout << "starting concurrent thread.\\n";\n    std::this_thread::sleep_for(std::chrono::seconds(2));\n    std::cout << "exiting concurrent thread.\\n";\n}\n \nvoid threadcaller() \n{\n    std::cout << "starting thread caller.\\n";\n    std::thread t(independentthread);\n    t.detach();\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    std::cout << "exiting thread caller.\\n";\n}\n \nint main() \n{\n    threadcaller();\n    std::this_thread::sleep_for(std::chrono::seconds(5));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\npossible output:\n\nstarting thread caller.\nstarting concurrent thread.\nexiting thread caller.\nexiting concurrent thread.\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n这个示例即表明了主线程将先执行完。',charsets:{cjk:!0},lastUpdated:"2024/03/27, 22:22:21",lastUpdatedTimestamp:1711549341e3},{title:"更多",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"06.更多/03.博客相关"}},title:"更多",permalink:"/more/blog/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T16:24:22.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/06.sub03.%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3.html",relativePath:"00.目录页/06.sub03.博客相关.md",key:"v-ecc968b6",path:"/more/blog/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:45:17",lastUpdatedTimestamp:1700822717e3},{title:"设计模式之单例模式详解（Java实现）",frontmatter:{title:"设计模式之单例模式详解（Java实现）",date:"2022-04-24T09:19:38.000Z",tags:["单例模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/a1ff4f/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/04.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89.html",relativePath:"01.开发/02.开发框架/03.设计模式/04.设计模式之单例模式详解（Java实现）.md",key:"v-0bc1b9b4",path:"/pages/a1ff4f/",headers:[{level:2,title:"1 单例模式介绍",slug:"_1-单例模式介绍",normalizedTitle:"1 单例模式介绍",charIndex:2},{level:2,title:"2 单例模式详解",slug:"_2-单例模式详解",normalizedTitle:"2 单例模式详解",charIndex:849},{level:3,title:"2.1 单例模式结构",slug:"_2-1-单例模式结构",normalizedTitle:"2.1 单例模式结构",charIndex:862},{level:3,title:"2.2 单例模式实现",slug:"_2-2-单例模式实现",normalizedTitle:"2.2 单例模式实现",charIndex:1098},{level:3,title:"2.3 单例模式应用举例",slug:"_2-3-单例模式应用举例",normalizedTitle:"2.3 单例模式应用举例",charIndex:1514},{level:2,title:"3 饿汉式单例与懒汉式单例",slug:"_3-饿汉式单例与懒汉式单例",normalizedTitle:"3 饿汉式单例与懒汉式单例",charIndex:1931},{level:3,title:"3.1 饿汉式单例",slug:"_3-1-饿汉式单例",normalizedTitle:"3.1 饿汉式单例",charIndex:1949},{level:3,title:"3.2 懒汉式单例与双重检查锁定",slug:"_3-2-懒汉式单例与双重检查锁定",normalizedTitle:"3.2 懒汉式单例与双重检查锁定",charIndex:2382},{level:3,title:"3.3 饿汉式单例类与懒汉式单例类的比较",slug:"_3-3-饿汉式单例类与懒汉式单例类的比较",normalizedTitle:"3.3 饿汉式单例类与懒汉式单例类的比较",charIndex:4340},{level:2,title:"4 使用静态内部类实现单例模式",slug:"_4-使用静态内部类实现单例模式",normalizedTitle:"4 使用静态内部类实现单例模式",charIndex:4504}],headersStr:"1 单例模式介绍 2 单例模式详解 2.1 单例模式结构 2.2 单例模式实现 2.3 单例模式应用举例 3 饿汉式单例与懒汉式单例 3.1 饿汉式单例 3.2 懒汉式单例与双重检查锁定 3.3 饿汉式单例类与懒汉式单例类的比较 4 使用静态内部类实现单例模式",content:"# 1 单例模式介绍\n\n单例模式（Singleton Pattern）确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。\n\n例如Windows任务管理器，在正常情况下只能打开唯一一个任务管理器。\n\n\n\n单例模式是一种对象创建型模式，其有三个要点：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。\n\n> 主要解决： 一个全局使用的类频繁地创建与销毁。\n> \n> 何时使用： 当您想控制实例数目，节省系统资源的时候。\n> \n> 如何解决： 判断系统是否已经有这个单例，如果有则返回，如果没有则创建。\n> \n> 关键代码： 构造函数是私有的。\n> \n> 应用实例：\n> \n>  * 1、一个班级只有一个班主任。\n>  * 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。\n>  * 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。\n> \n> 优点：\n> \n>  * 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。\n>  * 2、避免对资源的多重占用（比如写文件操作）。\n> \n> 缺点： 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。\n> \n> 使用场景：\n> \n>  * 1、要求生产唯一序列号。\n>  * 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。\n>  * 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。\n> \n> 注意事项： getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。\n\n\n# 2 单例模式详解\n\n\n# 2.1 单例模式结构\n\n单例模式是结构最简单的设计模式，它只包含一个类，即单例类。单例模式的结构图如下。\n\n\n\n由图可知，单例模式只包含一个单例角色，也就是Singleton。对于Singleton（单例），在单例类的内部创建它的唯一实例，并通过静态方法getInstance()让客户端可以使用它的唯一实例；为了防止在外部对单例类实例化，将其构造函数的可见性设为private；在单例类内部定义了一个Singleton类型的静态对象作为可供外部访问的唯一实例。\n\n\n# 2.2 单例模式实现\n\n典型的单例模式的实现代码如下：\n\npublic class Singleton {\n    // 静态私有成员变量\n    private static Singleton instance = null;  \n    // 私有构造函数\n    private Singleton() {   \n    }\n    \n    // 静态公有工厂方法，返回唯一实例\n    public static Singleton getInstance() {\n        if(instance == null)\n            instance = new Singleton(); \n        return instance;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 2.3 单例模式应用举例\n\n * 题目描述\n   \n   > 某软件公司承接了一个服务器负载均衡(Load Balance)软件的开发工作，该软件运行在一台负载均衡服务器上，可以将并发访问和数据流量分发到服务器集群中的多台设备上进行并发处理，提高了系统的整体处理能力，缩短了响应时间。由于集群中的服务器需要动态删减，且客户端请求需要统一分发，因此需要确保负载均衡器的唯一性，只能有一个负载均衡器来负责服务器的管理和请求的分发，否则将会带来服务器状态的不一致以及请求分配冲突等问题。如何确保负载均衡器的唯一性是该软件成功的关键，试使用单例模式设计服务器负载均衡器。\n\n * UML类图\n   \n   \n   \n   其中将负载均衡器LoadBalance设计为单例类，其中包含一个存储服务器信息的集合serverList，每次在serverList中随机选择一台服务器来响应客户端的请求。\n\n * 代码\n   \n   代码地址\n\n\n# 3 饿汉式单例与懒汉式单例\n\n\n# 3.1 饿汉式单例\n\n饿汉式单例（Eager Singleton）是实现起来最简单的单例类，饿汉式单例类结构图如下。\n\n\n\n有图中我们可以看出，由于在定义静态变量的时候实例化单例类，因此在类加载时单例对象就已创建，代码如下：\n\npublic class EagerSingleton { \n    private static final EagerSingleton instance = new EagerSingleton(); \n    private EagerSingleton() { } \n\n    public static EagerSingleton getInstance() {\n        return instance; \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n当类被加载时，静态变量instance会被初始化，此时类的私有构造函数就会被调用，单例类的唯一实例将被创建。\n\n\n# 3.2 懒汉式单例与双重检查锁定\n\n与饿汉式单例相同的是，懒汉式单例（Lazy Singleton）的构造函数也是私有的；与饿汉式单例类不同的是，懒汉式单例类在第一次被引用时将自己实例化，在懒汉式单例类被加载时不会将自己实例化。懒汉式单例类的结构图如下。\n\n\n\n但如果多个线程同时访问将导致创建多个单例对象！这个时候为了避免多个线程同时调用getInstance()方法，可以使用关键字synchronized，代码如下：\n\npublic class LazySingleton { \n    private static LazySingleton instance = null; \n\n    private LazySingleton() { } \n\n    // 使用synchronized关键字对方法加锁，确保任意时刻只有一个线程可以执行该方法\n    synchronized public static LazySingleton getInstance() { \n        if (instance == null) {\n            instance = new LazySingleton(); \n        }\n        return instance; \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在上述懒汉式单例类中，在getInstance()方法前面增加了关键字synchronized进行线程锁定，已处理多个线程同时访问问题。但我们每次调用getInstance()时都需要进行线程锁定判断，在多线程高并发环境中将会导致性能大大降低。因此可以继续对懒汉式单例进行改进，我们发现无需对getInstance()方法进行锁定，仅需锁定代码段instance = new LazySingleton()即可。故可进行如下改进：\n\npublic static LazySingleton getInstance() { \n    if (instance == null) {\n        synchronized (LazySingleton.class) {\n            instance = new LazySingleton(); \n        }\n    }\n    return instance; \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n问题看似解决，但如果使用上述代码，实际上还是会存在单例对象不唯一的情况。因为线程A和线程B如果同时进入判断，由于锁的原因，一个会先创建，但是另一个并不知道对象已经创建，这样就会导致产生多个实例对象。违背了单例模式的设计思想。我们需要使用双重检查锁定，即在锁内再进行一次instance == null的判断。使用双重检查锁定实现的懒汉式单例类的完整代码如下：\n\npublic class LazySingleton { \n    private volatile static LazySingleton instance = null; \n\n    private LazySingleton() { } \n\n    public static LazySingleton getInstance() { \n        //第一重判断\n        if (instance == null) {\n            //锁定代码块\n            synchronized (LazySingleton.class) {\n                //第二重判断\n                if (instance == null) {\n                    instance = new LazySingleton(); //创建单例实例\n                }\n            }\n        }\n    return instance; \n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n需要注意的时，如果使用双重检查锁定来实现懒汉式单例类，需要在静态成员变量instance之前增加修饰符volatile，被volatile修饰的成员变量可以确保多个线程都能够正确处理。\n\n\n# 3.3 饿汉式单例类与懒汉式单例类的比较\n\n * 饿汉式单例类：无须考虑多个线程同时访问的问题；调用速度和反应时间优于懒汉式单例；资源利用效率不及懒汉式单例；系统加载时间可能会比较长。\n * 懒汉式单例类：实现了延迟加载；必须处理好多个线程同时访问的问题；需通过双重检查锁定等机制进行控制，将导致系统性能受到一定影响。\n\n\n# 4 使用静态内部类实现单例模式\n\n饿汉式单例类不能实现延迟加载，不管将来用不用始终占用内存；懒汉式单例类安全控制烦琐，而且性能受影响。可见它们都存在一些问题，为了克服这些问题，在Java语言中可以通过Initialization on Demand Holder（IoDH）技术来实现单例模式。\n\n在IoDH中，需要在单例类中增加一个静态内部类，在该内部类中创建单例对象，再将该单例对象通过getInstance()方法返回给外部使用，实现代码如下：\n\n//Initialization on Demand Holder\npublic class Singleton {\n    private Singleton() {\n    }\n\n    //静态内部类\n    private static class HolderClass {\n        private final static Singleton instance = new Singleton();\n    }\n\n    public static Singleton getInstance() {\n        return HolderClass.instance;\n    }\n\n    public static void main(String args[]) {\n        Singleton s1, s2; \n        s1 = Singleton.getInstance();\n        s2 = Singleton.getInstance();\n        System.out.println(s1==s2);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n通过使用IoDH既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为一种最好的Java语言单例模式实现方式；其缺点是与编程语言本身的特性相关，很多面向对象语言并不支持IoDH。",normalizedContent:"# 1 单例模式介绍\n\n单例模式（singleton pattern）确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。\n\n例如windows任务管理器，在正常情况下只能打开唯一一个任务管理器。\n\n\n\n单例模式是一种对象创建型模式，其有三个要点：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。\n\n> 主要解决： 一个全局使用的类频繁地创建与销毁。\n> \n> 何时使用： 当您想控制实例数目，节省系统资源的时候。\n> \n> 如何解决： 判断系统是否已经有这个单例，如果有则返回，如果没有则创建。\n> \n> 关键代码： 构造函数是私有的。\n> \n> 应用实例：\n> \n>  * 1、一个班级只有一个班主任。\n>  * 2、windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。\n>  * 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。\n> \n> 优点：\n> \n>  * 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。\n>  * 2、避免对资源的多重占用（比如写文件操作）。\n> \n> 缺点： 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。\n> \n> 使用场景：\n> \n>  * 1、要求生产唯一序列号。\n>  * 2、web 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。\n>  * 3、创建的一个对象需要消耗的资源过多，比如 i/o 与数据库的连接等。\n> \n> 注意事项： getinstance() 方法中需要使用同步锁 synchronized (singleton.class) 防止多线程同时进入造成 instance 被多次实例化。\n\n\n# 2 单例模式详解\n\n\n# 2.1 单例模式结构\n\n单例模式是结构最简单的设计模式，它只包含一个类，即单例类。单例模式的结构图如下。\n\n\n\n由图可知，单例模式只包含一个单例角色，也就是singleton。对于singleton（单例），在单例类的内部创建它的唯一实例，并通过静态方法getinstance()让客户端可以使用它的唯一实例；为了防止在外部对单例类实例化，将其构造函数的可见性设为private；在单例类内部定义了一个singleton类型的静态对象作为可供外部访问的唯一实例。\n\n\n# 2.2 单例模式实现\n\n典型的单例模式的实现代码如下：\n\npublic class singleton {\n    // 静态私有成员变量\n    private static singleton instance = null;  \n    // 私有构造函数\n    private singleton() {   \n    }\n    \n    // 静态公有工厂方法，返回唯一实例\n    public static singleton getinstance() {\n        if(instance == null)\n            instance = new singleton(); \n        return instance;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 2.3 单例模式应用举例\n\n * 题目描述\n   \n   > 某软件公司承接了一个服务器负载均衡(load balance)软件的开发工作，该软件运行在一台负载均衡服务器上，可以将并发访问和数据流量分发到服务器集群中的多台设备上进行并发处理，提高了系统的整体处理能力，缩短了响应时间。由于集群中的服务器需要动态删减，且客户端请求需要统一分发，因此需要确保负载均衡器的唯一性，只能有一个负载均衡器来负责服务器的管理和请求的分发，否则将会带来服务器状态的不一致以及请求分配冲突等问题。如何确保负载均衡器的唯一性是该软件成功的关键，试使用单例模式设计服务器负载均衡器。\n\n * uml类图\n   \n   \n   \n   其中将负载均衡器loadbalance设计为单例类，其中包含一个存储服务器信息的集合serverlist，每次在serverlist中随机选择一台服务器来响应客户端的请求。\n\n * 代码\n   \n   代码地址\n\n\n# 3 饿汉式单例与懒汉式单例\n\n\n# 3.1 饿汉式单例\n\n饿汉式单例（eager singleton）是实现起来最简单的单例类，饿汉式单例类结构图如下。\n\n\n\n有图中我们可以看出，由于在定义静态变量的时候实例化单例类，因此在类加载时单例对象就已创建，代码如下：\n\npublic class eagersingleton { \n    private static final eagersingleton instance = new eagersingleton(); \n    private eagersingleton() { } \n\n    public static eagersingleton getinstance() {\n        return instance; \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n当类被加载时，静态变量instance会被初始化，此时类的私有构造函数就会被调用，单例类的唯一实例将被创建。\n\n\n# 3.2 懒汉式单例与双重检查锁定\n\n与饿汉式单例相同的是，懒汉式单例（lazy singleton）的构造函数也是私有的；与饿汉式单例类不同的是，懒汉式单例类在第一次被引用时将自己实例化，在懒汉式单例类被加载时不会将自己实例化。懒汉式单例类的结构图如下。\n\n\n\n但如果多个线程同时访问将导致创建多个单例对象！这个时候为了避免多个线程同时调用getinstance()方法，可以使用关键字synchronized，代码如下：\n\npublic class lazysingleton { \n    private static lazysingleton instance = null; \n\n    private lazysingleton() { } \n\n    // 使用synchronized关键字对方法加锁，确保任意时刻只有一个线程可以执行该方法\n    synchronized public static lazysingleton getinstance() { \n        if (instance == null) {\n            instance = new lazysingleton(); \n        }\n        return instance; \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在上述懒汉式单例类中，在getinstance()方法前面增加了关键字synchronized进行线程锁定，已处理多个线程同时访问问题。但我们每次调用getinstance()时都需要进行线程锁定判断，在多线程高并发环境中将会导致性能大大降低。因此可以继续对懒汉式单例进行改进，我们发现无需对getinstance()方法进行锁定，仅需锁定代码段instance = new lazysingleton()即可。故可进行如下改进：\n\npublic static lazysingleton getinstance() { \n    if (instance == null) {\n        synchronized (lazysingleton.class) {\n            instance = new lazysingleton(); \n        }\n    }\n    return instance; \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n问题看似解决，但如果使用上述代码，实际上还是会存在单例对象不唯一的情况。因为线程a和线程b如果同时进入判断，由于锁的原因，一个会先创建，但是另一个并不知道对象已经创建，这样就会导致产生多个实例对象。违背了单例模式的设计思想。我们需要使用双重检查锁定，即在锁内再进行一次instance == null的判断。使用双重检查锁定实现的懒汉式单例类的完整代码如下：\n\npublic class lazysingleton { \n    private volatile static lazysingleton instance = null; \n\n    private lazysingleton() { } \n\n    public static lazysingleton getinstance() { \n        //第一重判断\n        if (instance == null) {\n            //锁定代码块\n            synchronized (lazysingleton.class) {\n                //第二重判断\n                if (instance == null) {\n                    instance = new lazysingleton(); //创建单例实例\n                }\n            }\n        }\n    return instance; \n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n需要注意的时，如果使用双重检查锁定来实现懒汉式单例类，需要在静态成员变量instance之前增加修饰符volatile，被volatile修饰的成员变量可以确保多个线程都能够正确处理。\n\n\n# 3.3 饿汉式单例类与懒汉式单例类的比较\n\n * 饿汉式单例类：无须考虑多个线程同时访问的问题；调用速度和反应时间优于懒汉式单例；资源利用效率不及懒汉式单例；系统加载时间可能会比较长。\n * 懒汉式单例类：实现了延迟加载；必须处理好多个线程同时访问的问题；需通过双重检查锁定等机制进行控制，将导致系统性能受到一定影响。\n\n\n# 4 使用静态内部类实现单例模式\n\n饿汉式单例类不能实现延迟加载，不管将来用不用始终占用内存；懒汉式单例类安全控制烦琐，而且性能受影响。可见它们都存在一些问题，为了克服这些问题，在java语言中可以通过initialization on demand holder（iodh）技术来实现单例模式。\n\n在iodh中，需要在单例类中增加一个静态内部类，在该内部类中创建单例对象，再将该单例对象通过getinstance()方法返回给外部使用，实现代码如下：\n\n//initialization on demand holder\npublic class singleton {\n    private singleton() {\n    }\n\n    //静态内部类\n    private static class holderclass {\n        private final static singleton instance = new singleton();\n    }\n\n    public static singleton getinstance() {\n        return holderclass.instance;\n    }\n\n    public static void main(string args[]) {\n        singleton s1, s2; \n        s1 = singleton.getinstance();\n        s2 = singleton.getinstance();\n        system.out.println(s1==s2);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n通过使用iodh既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为一种最好的java语言单例模式实现方式；其缺点是与编程语言本身的特性相关，很多面向对象语言并不支持iodh。",charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"设计模式之工厂模式详解（Java实现）",frontmatter:{title:"设计模式之工厂模式详解（Java实现）",date:"2022-04-21T21:37:32.000Z",tags:["工厂模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/f4cb7a/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89.html",relativePath:"01.开发/02.开发框架/03.设计模式/01.设计模式之工厂模式详解（Java实现）.md",key:"v-7cd58e9b",path:"/pages/f4cb7a/",headers:[{level:2,title:"1 工厂模式介绍",slug:"_1-工厂模式介绍",normalizedTitle:"1 工厂模式介绍",charIndex:2},{level:2,title:"2 工厂模式详解",slug:"_2-工厂模式详解",normalizedTitle:"2 工厂模式详解",charIndex:730},{level:3,title:"2.1 简单工厂模式",slug:"_2-1-简单工厂模式",normalizedTitle:"2.1 简单工厂模式",charIndex:743},{level:4,title:"2.1.1 简单工厂模式结构",slug:"_2-1-1-简单工厂模式结构",normalizedTitle:"2.1.1 简单工厂模式结构",charIndex:757},{level:4,title:"2.1.2 简单工厂模式实现",slug:"_2-1-2-简单工厂模式实现",normalizedTitle:"2.1.2 简单工厂模式实现",charIndex:1078},{level:4,title:"2.1.3 简单工厂模式应用举例",slug:"_2-1-3-简单工厂模式应用举例",normalizedTitle:"2.1.3 简单工厂模式应用举例",charIndex:1961},{level:3,title:"2.2 工厂方法模式",slug:"_2-2-工厂方法模式",normalizedTitle:"2.2 工厂方法模式",charIndex:2270},{level:4,title:"2.2.1 工厂方法模式结构",slug:"_2-2-1-工厂方法模式结构",normalizedTitle:"2.2.1 工厂方法模式结构",charIndex:2284},{level:4,title:"2.2.2 工厂方法模式实现",slug:"_2-2-2-工厂方法模式实现",normalizedTitle:"2.2.2 工厂方法模式实现",charIndex:2739},{level:4,title:"2.2.3 工厂方法模式应用举例",slug:"_2-2-3-工厂方法模式应用举例",normalizedTitle:"2.2.3 工厂方法模式应用举例",charIndex:3443},{level:3,title:"2.3 抽象工厂模式",slug:"_2-3-抽象工厂模式",normalizedTitle:"2.3 抽象工厂模式",charIndex:3875},{level:4,title:"2.3.1 抽象工厂模式结构",slug:"_2-3-1-抽象工厂模式结构",normalizedTitle:"2.3.1 抽象工厂模式结构",charIndex:3889},{level:4,title:"2.3.2 抽象工厂模式实现",slug:"_2-3-2-抽象工厂模式实现",normalizedTitle:"2.3.2 抽象工厂模式实现",charIndex:4438},{level:4,title:"2.2.3 抽象工厂模式应用举例",slug:"_2-2-3-抽象工厂模式应用举例",normalizedTitle:"2.2.3 抽象工厂模式应用举例",charIndex:4955}],headersStr:"1 工厂模式介绍 2 工厂模式详解 2.1 简单工厂模式 2.1.1 简单工厂模式结构 2.1.2 简单工厂模式实现 2.1.3 简单工厂模式应用举例 2.2 工厂方法模式 2.2.1 工厂方法模式结构 2.2.2 工厂方法模式实现 2.2.3 工厂方法模式应用举例 2.3 抽象工厂模式 2.3.1 抽象工厂模式结构 2.3.2 抽象工厂模式实现 2.2.3 抽象工厂模式应用举例",content:'# 1 工厂模式介绍\n\n工厂顾名思义就是创建产品，根据产品是具体产品还是具体工厂可分为简单工厂模式（Simple Factory Pattern）和工厂方法模式（Factory Method Pattern），根据工厂的抽象程度可分为工厂方法模式和抽象工厂模式（Abstract Factory Pattern）。该模式用于封装和管理对象的创建，是一种创建型模式。\n\n这样看我们工厂模式（Factory Pattern）可以分为三类，但其中简单工厂其实不是一个标准的的设计模式。GOF 23 种设计模式中只有「工厂方法模式」与「抽象工厂模式」。简单工厂模式可以看为工厂方法模式的一种特例。\n\n在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。\n\n它的优点如下：\n\n * 可以使代码结构清晰，有效地封装变化。\n * 对调用者屏蔽具体的产品类\n * 降低耦合度。\n\n> 适用场景：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。\n> \n> 其次，工厂模式是一种典型的解耦模式，迪米特法则在工厂模式中表现的尤为明显。假如调用者自己组装产品需要增加依赖关系时，可以考虑使用工厂模式，将会大大降低对象之间的耦合度。再次，由于工厂模式是依靠抽象架构的，它把实例化产品的任务交由实现类完成，扩展性比较好。也就是说，当需要系统有比较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装。\n\n\n# 2 工厂模式详解\n\n\n# 2.1 简单工厂模式\n\n# 2.1.1 简单工厂模式结构\n\n该模式对对象创建管理方式最为简单，因为其仅仅简单的对不同类对象的创建进行了一层薄薄的封装。该模式通过向工厂传递类型来指定要创建的对象，其UML类图如下：\n\n\n\n其中根据上图可知，简单工厂模式包含以下3个角色。\n\n 1. Factory（工厂角色）：即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；其可以被外界直接调用，创建所需的产品对象。\n 2. AbstractProduct（抽象产品角色）：它是工厂类创建的所有对象的父类，封装了各种产品对象的共有方法。\n 3. Product1（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。\n\n# 2.1.2 简单工厂模式实现\n\n典型的抽象产品类代码如下：\n\npublic abstract class AbstractProduct {\n    // 所有产品类的公共业务方法\n    public void methodSame() {\n        // 公有方法的实现\n    }\n    // 声明抽象业务方法\n    public abstract void methodDiff() {\n        \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n典型的具体产品类的代码如下：\n\npublic class Product1 extends AbstractProduct {\n    // 实现业务方法\n    public void methodDiff() {\n        // 业务方法的实现\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n典型的工厂类的代码如下：\n\npublic class Factory {\n    // 静态工厂方法\n    public static AbstractProduct createProduct(String arg) {\n        AbstractProduct product = null;\n        if (arg.equalsIgnoreCase("1")) {\n            product = new Product1();\n        } else if (arg.equalsIgnoreCase("2")) {\n            product = new Product2();\n        }\n        return product;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n客户端代码中，通过调用工厂类的工厂方法即可得到产品对象。\n\n# 2.1.3 简单工厂模式应用举例\n\n * 题目描述\n   \n   > 使用简单工厂模式设计一个可以创建不同几何图形（Shape），如Circle，Rectangle，Triangle等绘图工具类，每个几何图形均具有绘制draw()和擦除erase()两个方法；要求在绘制不支持的几何图形时，抛出一个UnsuppShapeException异常，绘制类图并使用Java语言实现。\n\n * UML类图\n   \n   \n   \n   其中，Shape接口充当抽象产品，其子类Circle、Rectangle、Triangle等充当具体产品，ShapeFactory充当工厂类。\n\n * 代码\n   \n   代码地址\n\n\n# 2.2 工厂方法模式\n\n# 2.2.1 工厂方法模式结构\n\n和简单工厂模式中工厂负责生产所有产品相比，工厂方法模式将生成具体产品的任务分发给具体的产品工厂，也就是定义一个抽象工厂，其定义了产品的生产接口，但不负责具体的产品，将生产任务交给不同的派生类工厂。这样不用通过指定类型来创建对象了。其UML类图如下：\n\n\n\n由上图可知，工厂方法模式包含以下四个角色。\n\n 1. AbstractProduct（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的公共父类。\n 2. Product1（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。\n 3. AbstractFactory（抽象工厂）：在抽象工厂类中声明了工厂方法，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。\n 4. ConcreteFactory1（具体工厂）：它是抽象工厂类的子类，实现了在抽象工厂中声明的工厂方法，并可由客户端调用，返回一个具体产品类的实例。\n\n# 2.2.2 工厂方法模式实现\n\n典型的抽象产品类代码如下：\n\npublic abstract class AbstractProduct {\n    // 所有产品类的公共业务方法\n    public void methodSame() {\n        // 公有方法的实现\n    }\n    // 声明抽象业务方法\n    public abstract void methodDiff() {\n        \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n典型的具体产品类的代码如下：\n\npublic class Product1 extends AbstractProduct {\n    // 实现业务方法\n    public void methodDiff() {\n        // 业务方法的实现\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n典型的抽象工厂代码如下：\n\npublic interface AbstractFactory {\n    public Product createProduct();\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n典型的具体工厂代码如下：\n\npublic class ConcreteFactory1 implements Factory {\n    public Product createProduct() {\n        return new Product1();\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n# 2.2.3 工厂方法模式应用举例\n\n * 题目描述\n   \n   > 现需要设计一个程序来读取多种不同类型的图片格式，针对每一种图片格式都设计一个图片读取器（ImgReader），如gif图片读取器（GifReader）用于读取gif格式的图片,jpg图片读取器（JpgReader）用于读取jpg格式的图片。图片读取器对象通过图片读取器工厂ImgReaderFactory来创建。ImgReaderFactory是一个抽象类，用于定义创建图片读取器的工厂方法，其GifReaderFactory和JpgReaderFactory用于创建具体的图片读取器对象。\n\n * UML类图\n\n\n\n其中，接口ImageReaderFactory充当抽象工厂，GifReaderFactory和JpgReaderFactory充当具体工厂，ImageReader充当抽象产品，GifReader和JpgReader充当具体产品。\n\n * 代码\n   \n   代码地址\n\n\n# 2.3 抽象工厂模式\n\n# 2.3.1 抽象工厂模式结构\n\n上面两种模式不管工厂怎么拆分抽象，都只是针对一类产品（AbstractProduct），应该怎么表示呢？\n\n最简单的方式是把2中介绍的工厂方法模式完全复制一份，不过这次生产的是另一类产品。但同时也就意味着我们要完全复制和修改原来生产管理的所有代码，显然这是一个笨办法，并不利于扩展和维护。\n\n抽象工厂模式通过在AbstarctFactory中增加创建产品的接口，并在具体子工厂中实现新加产品的创建，当然前提是子工厂支持生产该产品。否则继承的这个接口可以什么也不干。其UML图如下：\n\n\n\n由上图可知，抽象工厂模式包含以下四个角色。\n\n 1. AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。\n 2. Product1（具体产品）：它定义具体工厂生产的具体产品的具体产品对象，实现抽象产品接口中声明的业务方法。\n 3. AbstractFactory（抽象工厂）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。\n 4. ConcreteFactory1（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。\n\n# 2.3.2 抽象工厂模式实现\n\n抽象工厂类典型代码如下：\n\npublic interface AbstractFactory {\n    public AbstractProduct1 createProduct1(); // 工厂方法一\n    public AbstractProduct2 createProduct2(); // 工厂方法、二\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n具体工厂类典型代码如下：\n\npublic class ConcreteFactory1 implements AbstractFactory {\n    // 工厂方法一\n    public AbstractProduct1 createProduct1() {\n        return new Product1();\n    }\n    // 工厂方法二\n    public AbstractProduct2 createProduct2() {\n        return new Product2();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 2.2.3 抽象工厂模式应用举例\n\n * 题目描述\n   \n   > 抽象工厂模式最早的应用是用于创建分属于不同操作系统的视窗构建。比如:命令按键(Button)与文字框(Text)都是视窗构件，在Unix、Windows和Linux操作系统的视窗环境中，这两个构件有不同的本地实现，它们的细节也有所不同。试使用抽象工厂模式来设计并模拟实现该结构。\n\n * UML类图\n   \n   \n   \n   其中，接口AbstractFactory充当抽象工厂，其子类WindowsFactory、UnixFactory和LinuxFactory充当具体工厂；Text和Button充当抽象产品，其子类WindowsText、UnixText、LinuxText和WindowsButton、UnixButton、LinuxButton充当具体产品。\n\n * 代码\n   \n   代码地址',normalizedContent:'# 1 工厂模式介绍\n\n工厂顾名思义就是创建产品，根据产品是具体产品还是具体工厂可分为简单工厂模式（simple factory pattern）和工厂方法模式（factory method pattern），根据工厂的抽象程度可分为工厂方法模式和抽象工厂模式（abstract factory pattern）。该模式用于封装和管理对象的创建，是一种创建型模式。\n\n这样看我们工厂模式（factory pattern）可以分为三类，但其中简单工厂其实不是一个标准的的设计模式。gof 23 种设计模式中只有「工厂方法模式」与「抽象工厂模式」。简单工厂模式可以看为工厂方法模式的一种特例。\n\n在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。\n\n它的优点如下：\n\n * 可以使代码结构清晰，有效地封装变化。\n * 对调用者屏蔽具体的产品类\n * 降低耦合度。\n\n> 适用场景：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。\n> \n> 其次，工厂模式是一种典型的解耦模式，迪米特法则在工厂模式中表现的尤为明显。假如调用者自己组装产品需要增加依赖关系时，可以考虑使用工厂模式，将会大大降低对象之间的耦合度。再次，由于工厂模式是依靠抽象架构的，它把实例化产品的任务交由实现类完成，扩展性比较好。也就是说，当需要系统有比较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装。\n\n\n# 2 工厂模式详解\n\n\n# 2.1 简单工厂模式\n\n# 2.1.1 简单工厂模式结构\n\n该模式对对象创建管理方式最为简单，因为其仅仅简单的对不同类对象的创建进行了一层薄薄的封装。该模式通过向工厂传递类型来指定要创建的对象，其uml类图如下：\n\n\n\n其中根据上图可知，简单工厂模式包含以下3个角色。\n\n 1. factory（工厂角色）：即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；其可以被外界直接调用，创建所需的产品对象。\n 2. abstractproduct（抽象产品角色）：它是工厂类创建的所有对象的父类，封装了各种产品对象的共有方法。\n 3. product1（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。\n\n# 2.1.2 简单工厂模式实现\n\n典型的抽象产品类代码如下：\n\npublic abstract class abstractproduct {\n    // 所有产品类的公共业务方法\n    public void methodsame() {\n        // 公有方法的实现\n    }\n    // 声明抽象业务方法\n    public abstract void methoddiff() {\n        \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n典型的具体产品类的代码如下：\n\npublic class product1 extends abstractproduct {\n    // 实现业务方法\n    public void methoddiff() {\n        // 业务方法的实现\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n典型的工厂类的代码如下：\n\npublic class factory {\n    // 静态工厂方法\n    public static abstractproduct createproduct(string arg) {\n        abstractproduct product = null;\n        if (arg.equalsignorecase("1")) {\n            product = new product1();\n        } else if (arg.equalsignorecase("2")) {\n            product = new product2();\n        }\n        return product;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n客户端代码中，通过调用工厂类的工厂方法即可得到产品对象。\n\n# 2.1.3 简单工厂模式应用举例\n\n * 题目描述\n   \n   > 使用简单工厂模式设计一个可以创建不同几何图形（shape），如circle，rectangle，triangle等绘图工具类，每个几何图形均具有绘制draw()和擦除erase()两个方法；要求在绘制不支持的几何图形时，抛出一个unsuppshapeexception异常，绘制类图并使用java语言实现。\n\n * uml类图\n   \n   \n   \n   其中，shape接口充当抽象产品，其子类circle、rectangle、triangle等充当具体产品，shapefactory充当工厂类。\n\n * 代码\n   \n   代码地址\n\n\n# 2.2 工厂方法模式\n\n# 2.2.1 工厂方法模式结构\n\n和简单工厂模式中工厂负责生产所有产品相比，工厂方法模式将生成具体产品的任务分发给具体的产品工厂，也就是定义一个抽象工厂，其定义了产品的生产接口，但不负责具体的产品，将生产任务交给不同的派生类工厂。这样不用通过指定类型来创建对象了。其uml类图如下：\n\n\n\n由上图可知，工厂方法模式包含以下四个角色。\n\n 1. abstractproduct（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的公共父类。\n 2. product1（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。\n 3. abstractfactory（抽象工厂）：在抽象工厂类中声明了工厂方法，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。\n 4. concretefactory1（具体工厂）：它是抽象工厂类的子类，实现了在抽象工厂中声明的工厂方法，并可由客户端调用，返回一个具体产品类的实例。\n\n# 2.2.2 工厂方法模式实现\n\n典型的抽象产品类代码如下：\n\npublic abstract class abstractproduct {\n    // 所有产品类的公共业务方法\n    public void methodsame() {\n        // 公有方法的实现\n    }\n    // 声明抽象业务方法\n    public abstract void methoddiff() {\n        \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n典型的具体产品类的代码如下：\n\npublic class product1 extends abstractproduct {\n    // 实现业务方法\n    public void methoddiff() {\n        // 业务方法的实现\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n典型的抽象工厂代码如下：\n\npublic interface abstractfactory {\n    public product createproduct();\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n典型的具体工厂代码如下：\n\npublic class concretefactory1 implements factory {\n    public product createproduct() {\n        return new product1();\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n# 2.2.3 工厂方法模式应用举例\n\n * 题目描述\n   \n   > 现需要设计一个程序来读取多种不同类型的图片格式，针对每一种图片格式都设计一个图片读取器（imgreader），如gif图片读取器（gifreader）用于读取gif格式的图片,jpg图片读取器（jpgreader）用于读取jpg格式的图片。图片读取器对象通过图片读取器工厂imgreaderfactory来创建。imgreaderfactory是一个抽象类，用于定义创建图片读取器的工厂方法，其gifreaderfactory和jpgreaderfactory用于创建具体的图片读取器对象。\n\n * uml类图\n\n\n\n其中，接口imagereaderfactory充当抽象工厂，gifreaderfactory和jpgreaderfactory充当具体工厂，imagereader充当抽象产品，gifreader和jpgreader充当具体产品。\n\n * 代码\n   \n   代码地址\n\n\n# 2.3 抽象工厂模式\n\n# 2.3.1 抽象工厂模式结构\n\n上面两种模式不管工厂怎么拆分抽象，都只是针对一类产品（abstractproduct），应该怎么表示呢？\n\n最简单的方式是把2中介绍的工厂方法模式完全复制一份，不过这次生产的是另一类产品。但同时也就意味着我们要完全复制和修改原来生产管理的所有代码，显然这是一个笨办法，并不利于扩展和维护。\n\n抽象工厂模式通过在abstarctfactory中增加创建产品的接口，并在具体子工厂中实现新加产品的创建，当然前提是子工厂支持生产该产品。否则继承的这个接口可以什么也不干。其uml图如下：\n\n\n\n由上图可知，抽象工厂模式包含以下四个角色。\n\n 1. abstractproduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。\n 2. product1（具体产品）：它定义具体工厂生产的具体产品的具体产品对象，实现抽象产品接口中声明的业务方法。\n 3. abstractfactory（抽象工厂）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。\n 4. concretefactory1（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。\n\n# 2.3.2 抽象工厂模式实现\n\n抽象工厂类典型代码如下：\n\npublic interface abstractfactory {\n    public abstractproduct1 createproduct1(); // 工厂方法一\n    public abstractproduct2 createproduct2(); // 工厂方法、二\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n具体工厂类典型代码如下：\n\npublic class concretefactory1 implements abstractfactory {\n    // 工厂方法一\n    public abstractproduct1 createproduct1() {\n        return new product1();\n    }\n    // 工厂方法二\n    public abstractproduct2 createproduct2() {\n        return new product2();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 2.2.3 抽象工厂模式应用举例\n\n * 题目描述\n   \n   > 抽象工厂模式最早的应用是用于创建分属于不同操作系统的视窗构建。比如:命令按键(button)与文字框(text)都是视窗构件，在unix、windows和linux操作系统的视窗环境中，这两个构件有不同的本地实现，它们的细节也有所不同。试使用抽象工厂模式来设计并模拟实现该结构。\n\n * uml类图\n   \n   \n   \n   其中，接口abstractfactory充当抽象工厂，其子类windowsfactory、unixfactory和linuxfactory充当具体工厂；text和button充当抽象产品，其子类windowstext、unixtext、linuxtext和windowsbutton、unixbutton、linuxbutton充当具体产品。\n\n * 代码\n   \n   代码地址',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"资源收藏",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"05.资源收藏",imgUrl:"/img/other.png",description:"相关资源收藏"}},title:"资源收藏",permalink:"/resource/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-23T11:18:33.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/05.%E8%B5%84%E6%BA%90%E6%94%B6%E8%97%8F.html",relativePath:"00.目录页/05.资源收藏.md",key:"v-319af327",path:"/resource/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:39:24",lastUpdatedTimestamp:1700822364e3},{title:"更多",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"06.更多/02.实用技巧"}},title:"更多",permalink:"/more/tip/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T16:24:23.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/06.sub02.%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7.html",relativePath:"00.目录页/06.sub02.实用技巧.md",key:"v-1bc814a4",path:"/more/tip/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:45:17",lastUpdatedTimestamp:1700822717e3},{title:"设计模式之组合模式详解（Java实现）",frontmatter:{title:"设计模式之组合模式详解（Java实现）",date:"2022-04-25T19:58:27.000Z",tags:["组合模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/eac75e/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/07.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89.html",relativePath:"01.开发/02.开发框架/03.设计模式/07.设计模式之组合模式详解（Java实现）.md",key:"v-a521f62a",path:"/pages/eac75e/",headers:[{level:2,title:"1 组合模式介绍",slug:"_1-组合模式介绍",normalizedTitle:"1 组合模式介绍",charIndex:2},{level:2,title:"2 组合模式详解",slug:"_2-组合模式详解",normalizedTitle:"2 组合模式详解",charIndex:750},{level:3,title:"2.1 组合模式结构",slug:"_2-1-组合模式结构",normalizedTitle:"2.1 组合模式结构",charIndex:763},{level:3,title:"2.2 组合模式实现",slug:"_2-2-组合模式实现",normalizedTitle:"2.2 组合模式实现",charIndex:1163},{level:3,title:"2.3 组合模式应用举例",slug:"_2-3-组合模式应用举例",normalizedTitle:"2.3 组合模式应用举例",charIndex:2521},{level:2,title:"3 透明组合模式和安全组合模式",slug:"_3-透明组合模式和安全组合模式",normalizedTitle:"3 透明组合模式和安全组合模式",charIndex:2838}],headersStr:"1 组合模式介绍 2 组合模式详解 2.1 组合模式结构 2.2 组合模式实现 2.3 组合模式应用举例 3 透明组合模式和安全组合模式",content:"# 1 组合模式介绍\n\n在我们的树形目录结构中，包含文件和文件夹两类不同的元素，如下图。\n\n\n\n其中文件夹中可以包含文件，也可以继续包含文件夹；而在文件中不能再包含子文件或者子文件夹。\n\n那么我们可以将文件夹看作是容器（Container），将文件看作是叶子（Leaf）。那如何一致的对待容器对象和叶子对象呢？\n\n组合模式（Composite Pattern）让客户端可以统一对待单个对象和组合对象。这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。\n\n> 主要解决： 它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。\n> \n> 何时使用： 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。\n> \n> 如何解决： 树枝和叶子实现统一接口，树枝内部组合该接口。\n> \n> 关键代码： 树枝内部组合该接口，并且含有内部属性 List，里面放 Component。\n> \n> 应用实例： 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。\n> \n> 优点： 1、高层模块调用简单。 2、节点自由增加。\n> \n> 缺点： 在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。\n> \n> 使用场景： 部分、整体场景，如树形菜单，文件、文件夹的管理。\n> \n> 注意事项： 定义时为具体类。\n\n\n# 2 组合模式详解\n\n\n# 2.1 组合模式结构\n\n组合模式的结构如图所示：\n\n\n\n由图可知，组合模式包含以下3个角色。\n\n 1. Component（抽象构件）：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。\n 2. Leaf（叶子构件）：它在组合结构中表示叶子结点对象，叶子结点没有子结点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过抛出异常、提示错误等方式进行处理。\n 3. Composite（容器构件）：它在组合结构中表示容器结点对象，容器结点包含子结点，其子结点可以是叶子结点，也可以是容器结点，它提供一个集合用于存储子结点，实现类在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子结点的业务方法。\n\n\n# 2.2 组合模式实现\n\n对于组合模式中的抽象构件角色，其典型代码如下：\n\npublic abstract class Component {\n    public abstract void addComponent(Component c); // 增加成员\n    public abstract void remove(Component c); // 删除成员\n    public abstract Component getChild(int i); // 获取成员\n    public abstract void operation(); // 业务方法\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n对于组合模式中的叶子构件角色，其典型代码如下：\n\npublic class Leaf extends Component {\n    public void add(Component c) {\n        // 异常处理或错误提示\n    }\n    public void remove(Component c) {\n        // 异常处理或错误提示\n    }\n    public void getChild(int i) {\n        // 异常处理或错误提示\n    }\n    public void operation() {\n        // 叶子构件具体业务方法的实现\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n对于组合模式中的容器构件角色，其典型代码如下：\n\nimport java.util.*;\n\npublic class Composite extends Component {\n    private ArrayList<Component> list = new ArrayList<Component>();\n    \n    public void add(Component c) {\n        list.add(c);\n    }\n    public void remove(Component c) {\n        list.remove(c);\n    }\n    public void getChild(int i) {\n        return (Componnent) list.get(i);\n    }\n    public void operation() {\n        // 容器构件具体业务方法的实现，将递归调用成员构件的业务方法\n        for (Object object : list) {\n            ((Component)obj).operation();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 2.3 组合模式应用举例\n\n * 题目描述\n   \n   > 某软件公司欲开发一个杀毒(Antivirus)软件，该软件既可以对某个文件夹(Folder)杀毒，也可以对某个指定的文件(File)进行杀毒。该杀毒软件还可以根据各类文件的特点，为不同类型的文件提供不同的杀毒方式，例如图像文件(ImageFile)和文本文件(TextFile)的杀毒方式就有所差异。现使用组合模式来设计该杀毒软件的整体框架。\n\n * UML类图\n   \n   其中，AbstractFile充当抽象构件类，Folder充当容器构件类，ImageFile、TextFile和VideoFile充当叶子构件类。\n\n * 代码\n   \n   代码地址\n\n\n# 3 透明组合模式和安全组合模式\n\n组合模式根据抽象构件的定义形式又可以分为透明组合模式和安全组合模式。\n\n * 透明组合模式\n   \n   \n   \n   根据结构图我们可以看出抽象构件Component中声明了所有用于管理成员对象的方法，包括add()、remove()，以及getChild()等方法，在客户端看来，叶子对象与容器对象所提供的方法是一致的，客户端可以一致地对待所有的对象，缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的。\n\n * 安全组合模式\n   \n   \n   \n   根据结构图可以看出抽象构件Component中没有声明任何用于管理成员对象的方法，而是在Composite类中声明并实现这些方法，对于叶子对象，客户端不可能调用到这些方法。缺点是不够透明，客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。但在实际应用中，安全组合模式的使用频率也非常高。",normalizedContent:"# 1 组合模式介绍\n\n在我们的树形目录结构中，包含文件和文件夹两类不同的元素，如下图。\n\n\n\n其中文件夹中可以包含文件，也可以继续包含文件夹；而在文件中不能再包含子文件或者子文件夹。\n\n那么我们可以将文件夹看作是容器（container），将文件看作是叶子（leaf）。那如何一致的对待容器对象和叶子对象呢？\n\n组合模式（composite pattern）让客户端可以统一对待单个对象和组合对象。这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。\n\n> 主要解决： 它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。\n> \n> 何时使用： 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。\n> \n> 如何解决： 树枝和叶子实现统一接口，树枝内部组合该接口。\n> \n> 关键代码： 树枝内部组合该接口，并且含有内部属性 list，里面放 component。\n> \n> 应用实例： 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。 2、在 java awt 和 swing 中，对于 button 和 checkbox 是树叶，container 是树枝。\n> \n> 优点： 1、高层模块调用简单。 2、节点自由增加。\n> \n> 缺点： 在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。\n> \n> 使用场景： 部分、整体场景，如树形菜单，文件、文件夹的管理。\n> \n> 注意事项： 定义时为具体类。\n\n\n# 2 组合模式详解\n\n\n# 2.1 组合模式结构\n\n组合模式的结构如图所示：\n\n\n\n由图可知，组合模式包含以下3个角色。\n\n 1. component（抽象构件）：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。\n 2. leaf（叶子构件）：它在组合结构中表示叶子结点对象，叶子结点没有子结点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过抛出异常、提示错误等方式进行处理。\n 3. composite（容器构件）：它在组合结构中表示容器结点对象，容器结点包含子结点，其子结点可以是叶子结点，也可以是容器结点，它提供一个集合用于存储子结点，实现类在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子结点的业务方法。\n\n\n# 2.2 组合模式实现\n\n对于组合模式中的抽象构件角色，其典型代码如下：\n\npublic abstract class component {\n    public abstract void addcomponent(component c); // 增加成员\n    public abstract void remove(component c); // 删除成员\n    public abstract component getchild(int i); // 获取成员\n    public abstract void operation(); // 业务方法\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n对于组合模式中的叶子构件角色，其典型代码如下：\n\npublic class leaf extends component {\n    public void add(component c) {\n        // 异常处理或错误提示\n    }\n    public void remove(component c) {\n        // 异常处理或错误提示\n    }\n    public void getchild(int i) {\n        // 异常处理或错误提示\n    }\n    public void operation() {\n        // 叶子构件具体业务方法的实现\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n对于组合模式中的容器构件角色，其典型代码如下：\n\nimport java.util.*;\n\npublic class composite extends component {\n    private arraylist<component> list = new arraylist<component>();\n    \n    public void add(component c) {\n        list.add(c);\n    }\n    public void remove(component c) {\n        list.remove(c);\n    }\n    public void getchild(int i) {\n        return (componnent) list.get(i);\n    }\n    public void operation() {\n        // 容器构件具体业务方法的实现，将递归调用成员构件的业务方法\n        for (object object : list) {\n            ((component)obj).operation();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 2.3 组合模式应用举例\n\n * 题目描述\n   \n   > 某软件公司欲开发一个杀毒(antivirus)软件，该软件既可以对某个文件夹(folder)杀毒，也可以对某个指定的文件(file)进行杀毒。该杀毒软件还可以根据各类文件的特点，为不同类型的文件提供不同的杀毒方式，例如图像文件(imagefile)和文本文件(textfile)的杀毒方式就有所差异。现使用组合模式来设计该杀毒软件的整体框架。\n\n * uml类图\n   \n   其中，abstractfile充当抽象构件类，folder充当容器构件类，imagefile、textfile和videofile充当叶子构件类。\n\n * 代码\n   \n   代码地址\n\n\n# 3 透明组合模式和安全组合模式\n\n组合模式根据抽象构件的定义形式又可以分为透明组合模式和安全组合模式。\n\n * 透明组合模式\n   \n   \n   \n   根据结构图我们可以看出抽象构件component中声明了所有用于管理成员对象的方法，包括add()、remove()，以及getchild()等方法，在客户端看来，叶子对象与容器对象所提供的方法是一致的，客户端可以一致地对待所有的对象，缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的。\n\n * 安全组合模式\n   \n   \n   \n   根据结构图可以看出抽象构件component中没有声明任何用于管理成员对象的方法，而是在composite类中声明并实现这些方法，对于叶子对象，客户端不可能调用到这些方法。缺点是不够透明，客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。但在实际应用中，安全组合模式的使用频率也非常高。",charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"设计模式之桥接模式详解（Java实现）",frontmatter:{title:"设计模式之桥接模式详解（Java实现）",date:"2022-04-24T21:25:59.000Z",tags:["桥接模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/aab372/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/06.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89.html",relativePath:"01.开发/02.开发框架/03.设计模式/06.设计模式之桥接模式详解（Java实现）.md",key:"v-0373c099",path:"/pages/aab372/",headers:[{level:2,title:"1 桥接模式介绍",slug:"_1-桥接模式介绍",normalizedTitle:"1 桥接模式介绍",charIndex:2},{level:2,title:"2 桥接模式详解",slug:"_2-桥接模式详解",normalizedTitle:"2 桥接模式详解",charIndex:975},{level:3,title:"2.1 桥接模式结构",slug:"_2-1-桥接模式结构",normalizedTitle:"2.1 桥接模式结构",charIndex:988},{level:3,title:"2.2 桥接模式实现",slug:"_2-2-桥接模式实现",normalizedTitle:"2.2 桥接模式实现",charIndex:1692},{level:3,title:"2.3 桥接模式应用实例",slug:"_2-3-桥接模式应用实例",normalizedTitle:"2.3 桥接模式应用实例",charIndex:2867}],headersStr:"1 桥接模式介绍 2 桥接模式详解 2.1 桥接模式结构 2.2 桥接模式实现 2.3 桥接模式应用实例",content:"# 1 桥接模式介绍\n\n毛笔和蜡笔是两种很常见的文具，它们都归属于画笔。假设我们需要大、中、小3种型号的画笔，能够绘制12种不同的颜色。那么我们的解决方案如下：\n\n\n\n显然，在毛笔中，我们将颜色和型号进行了分离，增加新的颜色或者型号对另一方没有影响，即用软件工程中的术语，可以认为在蜡笔中颜色和型号之间存在较强的耦合性，而毛笔很好地将二者解耦，使用起来非常灵活，扩展也较为方便。\n\n在软件开发中也有一种设计模式可以用来处理上述类似的具有多变化维度的情况，它就是桥接模式（Bridge Pattern）。它将抽象部分与它的实现部分解耦，使得两者都能独立变化。\n\n桥接模式又被称为柄体(Handle and Body)模式或接口(Interface)模式，用抽象关联取代了传统的多层继承，将类之间的静态继承关系转换为动态的对象组合关系。\n\n> 主要解决： 在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。\n> \n> 何时使用： 实现系统可能有多个角度分类，每一种角度都可能变化。\n> \n> **如何解决：**把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。\n> \n> 关键代码： 抽象类依赖实现类。\n> \n> 应用实例： 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。\n> \n> 优点： 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。\n> \n> **缺点：**桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。\n> \n> 使用场景： 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。\n> \n> 注意事项： 对于两个独立变化的维度，使用桥接模式再适合不过了。\n\n\n# 2 桥接模式详解\n\n\n# 2.1 桥接模式结构\n\n桥接模式的结构图如下：\n\n\n\n由上图可知，桥接模式包括以下4个角色。\n\n 1. Abstraction（抽象类）：它是用于定义抽象类的接口，通常是抽象类而不是接口，其中定义了一个Implementor（实现类接口）类型的对象并可以维护该对象，它与Implementor之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。\n 2. RefinedAbstraction（扩充抽象类）：它扩充由Abstraction定义的接口，通常情况下它不再是抽象类而是具体类，实现了在Abstraction中声明的抽象业务方法，在RefinedAbstraction中可以调用在Implementor中定义的业务方法。\n 3. Implementor（实现类接口）：它是定义实现类的接口，这个接口不一定要与Abstraction的接口完全一致，事实上这两个接口可以完全不同。一般而言，Implementor接口仅提供基本操作，而Abstraction定义的接口可能会做更多更复杂的操作。Implementor接口对这些基本操作进行了声明，而具体实现交给其子类。通过关联关系，在Abstraction中不仅拥有自己的方法，还可以调用到Implementor中定义的方法，使用关联关系代替继承关系。\n 4. ConcreteImplementor（具体实现类）：它具体实现了Implementor接口，在不同的ConcreteImplementor中提供基本操作的不同实现，在程序运行时ConcreteImplementor对象将替换其父类对象，提供给抽象类具体的业务操作方法。\n\n\n# 2.2 桥接模式实现\n\n在具体编码实现时，由于在桥接模式中存在两个独立变化的维度，为了降低两者之间的耦合度，首先需要针对两个不同的维度提取抽象类和实现类接口，并建立一个抽象关联关系。对于“实现部分维度”，典型的接口代码如下：\n\npublic interface Implementor {\n    public void operationImpl();\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n在实现Implementor接口的子类ConcreteImplementor中实现了在该接口中声明的方法，用于定义与该维度相对应的一些具体方法，代码如下：\n\npublic class ConcreteImplementor implements Implementor {\n    public void operationImpl() {\n        //具体业务方法的实现\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n对于另一“抽象部分”维度而言，其典型的抽象类代码如下：\n\npublic abstract class Abstraction {\n    protected Implementor impl; //定义实现类接口对象\n\n    public void setImpl(Implementor impl) {\n        this.impl = impl;\n    }\n\n    public abstract void operation(); //声明抽象业务方法\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n在抽象类Abstraction中定义了一个实现类接口类型的成员对象impl，再通过Setter方法或者构造方法以注入的方式给该对象赋值。一般将该对象的可见性定义为protected，以便在其子类中访问Implementor的方法，其子类一般称为扩充对象类或细化抽象类（RefinedAbstraction），典型的RefinedAbstraction类代码如下：\n\npublic class RefinedAbstraction extends Abstraction {\n    public void operation() {\n        //业务代码\n        impl.operationImpl(); //调用实现类的方法\n        //业务代码\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n对于客户端而言，可以针对两个维度的抽象层编程，在程序运行时再动态确定两个维度的子类，动态组合对象，将两个独立变化的维度完全解耦，以便能够灵活地扩充任一维度而对另一维度不造成任何影响。\n\n\n# 2.3 桥接模式应用实例\n\n * 题目描述\n   \n   > 某软件公司欲开发一个数据转换工具，可以将数据库中的数据转换成多种文件格式，例如TXT、XML、PDF等格式，同时该工具需要支持多种不同的数据库。试用桥接模式对其进行设计。\n\n * UML类图\n   \n   \n   \n   其中，FileConvertor 充当抽象类角色，TXTConvertor、XMLConvertor 和 PDFConvertor 充当扩充抽象类角色，DataHandler 充当实现类接口角色，OracleHandler 和SQLServerHandler充当具体实现类角色。\n\n * 代码\n   \n   代码地址",normalizedContent:"# 1 桥接模式介绍\n\n毛笔和蜡笔是两种很常见的文具，它们都归属于画笔。假设我们需要大、中、小3种型号的画笔，能够绘制12种不同的颜色。那么我们的解决方案如下：\n\n\n\n显然，在毛笔中，我们将颜色和型号进行了分离，增加新的颜色或者型号对另一方没有影响，即用软件工程中的术语，可以认为在蜡笔中颜色和型号之间存在较强的耦合性，而毛笔很好地将二者解耦，使用起来非常灵活，扩展也较为方便。\n\n在软件开发中也有一种设计模式可以用来处理上述类似的具有多变化维度的情况，它就是桥接模式（bridge pattern）。它将抽象部分与它的实现部分解耦，使得两者都能独立变化。\n\n桥接模式又被称为柄体(handle and body)模式或接口(interface)模式，用抽象关联取代了传统的多层继承，将类之间的静态继承关系转换为动态的对象组合关系。\n\n> 主要解决： 在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。\n> \n> 何时使用： 实现系统可能有多个角度分类，每一种角度都可能变化。\n> \n> **如何解决：**把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。\n> \n> 关键代码： 抽象类依赖实现类。\n> \n> 应用实例： 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。\n> \n> 优点： 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。\n> \n> **缺点：**桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。\n> \n> 使用场景： 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。\n> \n> 注意事项： 对于两个独立变化的维度，使用桥接模式再适合不过了。\n\n\n# 2 桥接模式详解\n\n\n# 2.1 桥接模式结构\n\n桥接模式的结构图如下：\n\n\n\n由上图可知，桥接模式包括以下4个角色。\n\n 1. abstraction（抽象类）：它是用于定义抽象类的接口，通常是抽象类而不是接口，其中定义了一个implementor（实现类接口）类型的对象并可以维护该对象，它与implementor之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。\n 2. refinedabstraction（扩充抽象类）：它扩充由abstraction定义的接口，通常情况下它不再是抽象类而是具体类，实现了在abstraction中声明的抽象业务方法，在refinedabstraction中可以调用在implementor中定义的业务方法。\n 3. implementor（实现类接口）：它是定义实现类的接口，这个接口不一定要与abstraction的接口完全一致，事实上这两个接口可以完全不同。一般而言，implementor接口仅提供基本操作，而abstraction定义的接口可能会做更多更复杂的操作。implementor接口对这些基本操作进行了声明，而具体实现交给其子类。通过关联关系，在abstraction中不仅拥有自己的方法，还可以调用到implementor中定义的方法，使用关联关系代替继承关系。\n 4. concreteimplementor（具体实现类）：它具体实现了implementor接口，在不同的concreteimplementor中提供基本操作的不同实现，在程序运行时concreteimplementor对象将替换其父类对象，提供给抽象类具体的业务操作方法。\n\n\n# 2.2 桥接模式实现\n\n在具体编码实现时，由于在桥接模式中存在两个独立变化的维度，为了降低两者之间的耦合度，首先需要针对两个不同的维度提取抽象类和实现类接口，并建立一个抽象关联关系。对于“实现部分维度”，典型的接口代码如下：\n\npublic interface implementor {\n    public void operationimpl();\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n在实现implementor接口的子类concreteimplementor中实现了在该接口中声明的方法，用于定义与该维度相对应的一些具体方法，代码如下：\n\npublic class concreteimplementor implements implementor {\n    public void operationimpl() {\n        //具体业务方法的实现\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n对于另一“抽象部分”维度而言，其典型的抽象类代码如下：\n\npublic abstract class abstraction {\n    protected implementor impl; //定义实现类接口对象\n\n    public void setimpl(implementor impl) {\n        this.impl = impl;\n    }\n\n    public abstract void operation(); //声明抽象业务方法\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n在抽象类abstraction中定义了一个实现类接口类型的成员对象impl，再通过setter方法或者构造方法以注入的方式给该对象赋值。一般将该对象的可见性定义为protected，以便在其子类中访问implementor的方法，其子类一般称为扩充对象类或细化抽象类（refinedabstraction），典型的refinedabstraction类代码如下：\n\npublic class refinedabstraction extends abstraction {\n    public void operation() {\n        //业务代码\n        impl.operationimpl(); //调用实现类的方法\n        //业务代码\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n对于客户端而言，可以针对两个维度的抽象层编程，在程序运行时再动态确定两个维度的子类，动态组合对象，将两个独立变化的维度完全解耦，以便能够灵活地扩充任一维度而对另一维度不造成任何影响。\n\n\n# 2.3 桥接模式应用实例\n\n * 题目描述\n   \n   > 某软件公司欲开发一个数据转换工具，可以将数据库中的数据转换成多种文件格式，例如txt、xml、pdf等格式，同时该工具需要支持多种不同的数据库。试用桥接模式对其进行设计。\n\n * uml类图\n   \n   \n   \n   其中，fileconvertor 充当抽象类角色，txtconvertor、xmlconvertor 和 pdfconvertor 充当扩充抽象类角色，datahandler 充当实现类接口角色，oraclehandler 和sqlserverhandler充当具体实现类角色。\n\n * 代码\n   \n   代码地址",charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"设计模式之装饰模式详解（Java实现）",frontmatter:{title:"设计模式之装饰模式详解（Java实现）",date:"2022-04-28T15:31:32.000Z",tags:["装饰模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/c49acf/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/08.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89.html",relativePath:"01.开发/02.开发框架/03.设计模式/08.设计模式之装饰模式详解（Java实现）.md",key:"v-4dbea03d",path:"/pages/c49acf/",headers:[{level:2,title:"1 装饰模式介绍",slug:"_1-装饰模式介绍",normalizedTitle:"1 装饰模式介绍",charIndex:2},{level:2,title:"2 装饰模式详解",slug:"_2-装饰模式详解",normalizedTitle:"2 装饰模式详解",charIndex:776},{level:3,title:"2.1 装饰模式结构",slug:"_2-1-装饰模式结构",normalizedTitle:"2.1 装饰模式结构",charIndex:789},{level:3,title:"2.2 装饰模式实现",slug:"_2-2-装饰模式实现",normalizedTitle:"2.2 装饰模式实现",charIndex:1257},{level:3,title:"2.3 装饰模式应用举例",slug:"_2-3-装饰模式应用举例",normalizedTitle:"2.3 装饰模式应用举例",charIndex:2277},{level:2,title:"3 透明装饰模式和半透明装饰模式",slug:"_3-透明装饰模式和半透明装饰模式",normalizedTitle:"3 透明装饰模式和半透明装饰模式",charIndex:2667}],headersStr:"1 装饰模式介绍 2 装饰模式详解 2.1 装饰模式结构 2.2 装饰模式实现 2.3 装饰模式应用举例 3 透明装饰模式和半透明装饰模式",content:'# 1 装饰模式介绍\n\n在生活中，我们往往会给图片增加一些边框等来装饰图片，可以让图片变得更漂亮，如下图，就是对小狗图片的装饰。\n\n\n\n在软件设计中，我们也有一种类似图片的技术可以对已有对象（图片）的功能进行扩展（装修），以获得更加符合用户需求的对象，使得对象具有更加强大的功能。这种技术对应于一种被称之为装饰模式（Decorator Pattern）的设计模式。装饰模式能动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案。引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩展原有类的功能\n\n> 主要解决： 一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。\n> \n> 何时使用： 在不想增加很多子类的情况下扩展类。\n> \n> 如何解决： 将具体功能职责划分，同时继承装饰者模式。\n> \n> 关键代码： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。\n> \n> 应用实例： 1、孙悟空有 72 变，当他变成"庙宇"后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。\n> \n> 优点： 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。\n> \n> 缺点： 多层装饰比较复杂。\n> \n> 使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。\n> \n> 注意事项： 可代替继承。\n\n\n# 2 装饰模式详解\n\n\n# 2.1 装饰模式结构\n\n装饰模式的结构如图所示：\n\n\n\n由结构图可知，装饰模式包含以下4个角色。\n\n 1. Component（抽象构件）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。\n 2. ConcreteComponent（具体构件）：它是抽象构件的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰类可以给它增加额外的职责（方法）。\n 3. Decorator（抽象装饰类）：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。\n 4. ConcreteDecorator（具体装饰类）：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用于扩充该对象的行为。\n\n\n# 2.2 装饰模式实现\n\n抽象构件类典型代码：\n\npublic abstract class Component {\n    public abstract void operation();\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n具体构件类典型代码：\n\npublic class ConcreteComponent extends Component {\n    public void operation() {\n        //实现基本功能    \n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n抽象装饰类典型代码：\n\npublic class Decorator extends Component {\n    private Component component; //维持一个对抽象构件对象的引用\n\n    //注入一个抽象构件类型的对象\n    public Decorator(Component component) {\n        this.component=component;\n    }\n\n    public void operation() {\n        component.operation();  //调用原有业务方法\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n具体装饰类典型代码：\n\npublic class ConcreteDecorator extends Decorator {\n    public ConcreteDecorator(Component component) {\n        super(component); \n    }\n\n    public void operation() {\n        super.operation(); //调用原有业务方法\n        addedBehavior(); //调用新增业务方法\n    }\n\n    //新增业务方法\n    public void addedBehavior() { \n        ……\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2.3 装饰模式应用举例\n\n * 题目描述\n   \n   > 简单的手机（SimplePhone）再接收到来电的时候，会发出声音提醒主人；而现在我们需要为该手机添加一项功能，在接收来电的时候，除了声音还能产生振动（JarPhone）；还可以得到更高级的手机（ComplexPhone），来电的时候，它不仅能够发声，产生振动，而且还有灯光在闪烁提示。现在用装饰模式来模拟一下手机的升级过程，要求绘制类图并编程实现。\n\n * UML类图\n\n\n\n其中，Cellphone 为抽象类，声明了来电方法 receiveCall()，SimplePhone 为简单手机类， 提供了声音提示，JarPhone 和 ComplexPhone 分别提供了振动提示和灯光闪烁提示。 PhoneDecorator 是抽象装饰者，它维持一个对父类对象的引用。\n\n * 代码\n   \n   代码地址\n\n\n# 3 透明装饰模式和半透明装饰模式\n\n 1. 透明装饰模式\n    \n    要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型。对于客户端而言，具体构件对象和具体装饰对象没有任何区别。可以让客户端透明地使用装饰之前的对象和装饰之后的对象，无须关心它们的区别。可以对一个已装饰过的对象进行多次装实例：\n    \n    ……\n    Component component_o,component_d1,component_d2; //全部使用抽象构件定义\n    component_o = new ConcreteComponent();\n    component_d1 = new ConcreteDecorator1(component_o);\n    component_d2 = new ConcreteDecorator2(component_d1);\n    component_d2.operation();\n    //无法单独调用component_d2的addedBehavior()方法\n    ……\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 2. 半透明装饰模式\n    \n    用具体装饰类型来定义装饰之后的对象，而具体构件使用抽象构件类型来定义。对于客户端而言，具体构件类型无须关心，是透明的；但是具体装饰类型必须指定，这是不透明的。可以给系统带来更多的灵活性，设计相对简单，使用起来也非常方便，客户端使用具体装饰类型来定义装饰后的对象，因此可以单独调用addedBehavior()方法。最大的缺点在于不能实现对同一个对象的多次装饰，而且客户端需要有区别地对待装饰之前的对象和装饰之后的对象。实例：\n    \n    ……\n    Component component_o; //使用抽象构件类型定义\n    component_o = new ConcreteComponent();\n    component_o.operation();\n    ConcreteDecorator component_d; //使用具体装饰类型定义\n    component_d = new ConcreteDecorator(component_o);\n    component_d.operation();\n    component_d.addedBehavior(); //单独调用新增业务方法\n    ……\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    ',normalizedContent:'# 1 装饰模式介绍\n\n在生活中，我们往往会给图片增加一些边框等来装饰图片，可以让图片变得更漂亮，如下图，就是对小狗图片的装饰。\n\n\n\n在软件设计中，我们也有一种类似图片的技术可以对已有对象（图片）的功能进行扩展（装修），以获得更加符合用户需求的对象，使得对象具有更加强大的功能。这种技术对应于一种被称之为装饰模式（decorator pattern）的设计模式。装饰模式能动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案。引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩展原有类的功能\n\n> 主要解决： 一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。\n> \n> 何时使用： 在不想增加很多子类的情况下扩展类。\n> \n> 如何解决： 将具体功能职责划分，同时继承装饰者模式。\n> \n> 关键代码： 1、component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 component 类，具体扩展类重写父类方法。\n> \n> 应用实例： 1、孙悟空有 72 变，当他变成"庙宇"后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。\n> \n> 优点： 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。\n> \n> 缺点： 多层装饰比较复杂。\n> \n> 使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。\n> \n> 注意事项： 可代替继承。\n\n\n# 2 装饰模式详解\n\n\n# 2.1 装饰模式结构\n\n装饰模式的结构如图所示：\n\n\n\n由结构图可知，装饰模式包含以下4个角色。\n\n 1. component（抽象构件）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。\n 2. concretecomponent（具体构件）：它是抽象构件的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰类可以给它增加额外的职责（方法）。\n 3. decorator（抽象装饰类）：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。\n 4. concretedecorator（具体装饰类）：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用于扩充该对象的行为。\n\n\n# 2.2 装饰模式实现\n\n抽象构件类典型代码：\n\npublic abstract class component {\n    public abstract void operation();\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n具体构件类典型代码：\n\npublic class concretecomponent extends component {\n    public void operation() {\n        //实现基本功能    \n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n抽象装饰类典型代码：\n\npublic class decorator extends component {\n    private component component; //维持一个对抽象构件对象的引用\n\n    //注入一个抽象构件类型的对象\n    public decorator(component component) {\n        this.component=component;\n    }\n\n    public void operation() {\n        component.operation();  //调用原有业务方法\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n具体装饰类典型代码：\n\npublic class concretedecorator extends decorator {\n    public concretedecorator(component component) {\n        super(component); \n    }\n\n    public void operation() {\n        super.operation(); //调用原有业务方法\n        addedbehavior(); //调用新增业务方法\n    }\n\n    //新增业务方法\n    public void addedbehavior() { \n        ……\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2.3 装饰模式应用举例\n\n * 题目描述\n   \n   > 简单的手机（simplephone）再接收到来电的时候，会发出声音提醒主人；而现在我们需要为该手机添加一项功能，在接收来电的时候，除了声音还能产生振动（jarphone）；还可以得到更高级的手机（complexphone），来电的时候，它不仅能够发声，产生振动，而且还有灯光在闪烁提示。现在用装饰模式来模拟一下手机的升级过程，要求绘制类图并编程实现。\n\n * uml类图\n\n\n\n其中，cellphone 为抽象类，声明了来电方法 receivecall()，simplephone 为简单手机类， 提供了声音提示，jarphone 和 complexphone 分别提供了振动提示和灯光闪烁提示。 phonedecorator 是抽象装饰者，它维持一个对父类对象的引用。\n\n * 代码\n   \n   代码地址\n\n\n# 3 透明装饰模式和半透明装饰模式\n\n 1. 透明装饰模式\n    \n    要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型。对于客户端而言，具体构件对象和具体装饰对象没有任何区别。可以让客户端透明地使用装饰之前的对象和装饰之后的对象，无须关心它们的区别。可以对一个已装饰过的对象进行多次装实例：\n    \n    ……\n    component component_o,component_d1,component_d2; //全部使用抽象构件定义\n    component_o = new concretecomponent();\n    component_d1 = new concretedecorator1(component_o);\n    component_d2 = new concretedecorator2(component_d1);\n    component_d2.operation();\n    //无法单独调用component_d2的addedbehavior()方法\n    ……\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 2. 半透明装饰模式\n    \n    用具体装饰类型来定义装饰之后的对象，而具体构件使用抽象构件类型来定义。对于客户端而言，具体构件类型无须关心，是透明的；但是具体装饰类型必须指定，这是不透明的。可以给系统带来更多的灵活性，设计相对简单，使用起来也非常方便，客户端使用具体装饰类型来定义装饰后的对象，因此可以单独调用addedbehavior()方法。最大的缺点在于不能实现对同一个对象的多次装饰，而且客户端需要有区别地对待装饰之前的对象和装饰之后的对象。实例：\n    \n    ……\n    component component_o; //使用抽象构件类型定义\n    component_o = new concretecomponent();\n    component_o.operation();\n    concretedecorator component_d; //使用具体装饰类型定义\n    component_d = new concretedecorator(component_o);\n    component_d.operation();\n    component_d.addedbehavior(); //单独调用新增业务方法\n    ……\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    ',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"设计模式之代理模式详解（Java实现）",frontmatter:{title:"设计模式之代理模式详解（Java实现）",date:"2022-04-30T09:21:54.000Z",tags:["代理模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/933a7d/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89.html",relativePath:"01.开发/02.开发框架/03.设计模式/10.设计模式之代理模式详解（Java实现）.md",key:"v-4a7c7cef",path:"/pages/933a7d/",headers:[{level:2,title:"1 代理模式介绍",slug:"_1-代理模式介绍",normalizedTitle:"1 代理模式介绍",charIndex:2},{level:2,title:"2 代理模式详解",slug:"_2-代理模式详解",normalizedTitle:"2 代理模式详解",charIndex:1014},{level:3,title:"2.1 代理模式结构",slug:"_2-1-代理模式结构",normalizedTitle:"2.1 代理模式结构",charIndex:1027},{level:3,title:"2.2 代理模式实现",slug:"_2-2-代理模式实现",normalizedTitle:"2.2 代理模式实现",charIndex:1527},{level:3,title:"2.3 代理模式应用举例",slug:"_2-3-代理模式应用举例",normalizedTitle:"2.3 代理模式应用举例",charIndex:2350}],headersStr:"1 代理模式介绍 2 代理模式详解 2.1 代理模式结构 2.2 代理模式实现 2.3 代理模式应用举例",content:"# 1 代理模式介绍\n\n代理模式（Proxy Pattern）是常用的结构型设计模式之一，当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，代理对象在客户端对象和目标对象之间起到中介的作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。\n\n代理模式的变化形式非常多，常见的代理形式有远程代理、保护代理、虚拟代理、缓冲代理、智能引用代理等。\n\n> 主要解决： 在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。\n> \n> 何时使用： 想在访问一个类时做一些控制。\n> \n> 如何解决： 增加中间层。\n> \n> 关键代码： 实现与被代理类组合。\n> \n> 应用实例： 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。\n> \n> 优点： 1、职责清晰。 2、高扩展性。 3、智能化。\n> \n> 缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。\n> \n> 使用场景： 按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。\n> \n> 注意事项： 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。\n\n\n# 2 代理模式详解\n\n\n# 2.1 代理模式结构\n\n代理模式的结构比较简单，其核心是代理类，为了让客户端能够一致地对待真实对象和代理对象，在代理模式中引入了抽象层，其结构图如下：\n\n\n\n由图可知，代理模式包含以下3个角色。\n\n 1. Subject（抽象主题角色）：它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。\n\n 2. Proxy（代理主题角色）：它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供了一个与真实主题角色相同的接口，以便任何时候都可以代替真实主题；代理主题角色还可以控制真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。\n    \n    通常，在代理主题角色中客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅单纯调用真实主题对象中的操作。\n\n 3. RealSubject（真实主题角色）：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接使用真实主题角色中定义的操作。\n\n\n# 2.2 代理模式实现\n\n典型的抽象主题类代码如下：\n\npublic abstract class Subject {\n    public abstract void request();\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n真实主题类继承了抽象主题类，提供了业务方法的具体实现，其典型代码如下：\n\npublic class RealSubject extends Subject {\n    public void request() {\n        // 业务方法的具体实现代码\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n代理类也是抽象主题类的子类，它维持一个对真实主题对象的引用，调用在真实主题中实现的业务方法，在调用时可以在原有业务方法的基础上附加一些新的方法对功能进行扩充或约束。最简单的代理类实现代码如下：\n\npublic class Proxy extends Subject {\n    // 维持一个对真实主题对象的引用\n    private RealSubject realSubject = new RealSubject();\n    \n    public void preRequest() {\n        ...\n    }\n    public void request() {\n        preRequest();\n        // 调用真实主题对象的方法\n        realSubject.request();\n        postRequest();\n    }\n    public void postRequest() {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 2.3 代理模式应用举例\n\n * 题目描述\n   \n   > 在一个论坛中已注册用户和游客的权限不同，已注册的用户拥有发帖、修改自己的注册信息、修改自己的帖子等功能；而游客只能看到别人发的帖子，没有其他权限。使用保护代理来设计该权限管理模块。\n\n * UML类图\n   \n   \n   \n   其中，AbstractPermission 为抽象主题角色，PermissionProxy 为代理主题角色， RealPermission 为真实主题角色。\n\n * 代码\n   \n   代码地址",normalizedContent:"# 1 代理模式介绍\n\n代理模式（proxy pattern）是常用的结构型设计模式之一，当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，代理对象在客户端对象和目标对象之间起到中介的作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。\n\n代理模式的变化形式非常多，常见的代理形式有远程代理、保护代理、虚拟代理、缓冲代理、智能引用代理等。\n\n> 主要解决： 在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。\n> \n> 何时使用： 想在访问一个类时做一些控制。\n> \n> 如何解决： 增加中间层。\n> \n> 关键代码： 实现与被代理类组合。\n> \n> 应用实例： 1、windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。\n> \n> 优点： 1、职责清晰。 2、高扩展性。 3、智能化。\n> \n> 缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。\n> \n> 使用场景： 按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、copy-on-write 代理。 4、保护（protect or access）代理。 5、cache代理。 6、防火墙（firewall）代理。 7、同步化（synchronization）代理。 8、智能引用（smart reference）代理。\n> \n> 注意事项： 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。\n\n\n# 2 代理模式详解\n\n\n# 2.1 代理模式结构\n\n代理模式的结构比较简单，其核心是代理类，为了让客户端能够一致地对待真实对象和代理对象，在代理模式中引入了抽象层，其结构图如下：\n\n\n\n由图可知，代理模式包含以下3个角色。\n\n 1. subject（抽象主题角色）：它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。\n\n 2. proxy（代理主题角色）：它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供了一个与真实主题角色相同的接口，以便任何时候都可以代替真实主题；代理主题角色还可以控制真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。\n    \n    通常，在代理主题角色中客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅单纯调用真实主题对象中的操作。\n\n 3. realsubject（真实主题角色）：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接使用真实主题角色中定义的操作。\n\n\n# 2.2 代理模式实现\n\n典型的抽象主题类代码如下：\n\npublic abstract class subject {\n    public abstract void request();\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n真实主题类继承了抽象主题类，提供了业务方法的具体实现，其典型代码如下：\n\npublic class realsubject extends subject {\n    public void request() {\n        // 业务方法的具体实现代码\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n代理类也是抽象主题类的子类，它维持一个对真实主题对象的引用，调用在真实主题中实现的业务方法，在调用时可以在原有业务方法的基础上附加一些新的方法对功能进行扩充或约束。最简单的代理类实现代码如下：\n\npublic class proxy extends subject {\n    // 维持一个对真实主题对象的引用\n    private realsubject realsubject = new realsubject();\n    \n    public void prerequest() {\n        ...\n    }\n    public void request() {\n        prerequest();\n        // 调用真实主题对象的方法\n        realsubject.request();\n        postrequest();\n    }\n    public void postrequest() {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 2.3 代理模式应用举例\n\n * 题目描述\n   \n   > 在一个论坛中已注册用户和游客的权限不同，已注册的用户拥有发帖、修改自己的注册信息、修改自己的帖子等功能；而游客只能看到别人发的帖子，没有其他权限。使用保护代理来设计该权限管理模块。\n\n * uml类图\n   \n   \n   \n   其中，abstractpermission 为抽象主题角色，permissionproxy 为代理主题角色， realpermission 为真实主题角色。\n\n * 代码\n   \n   代码地址",charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"设计模式之命令模式详解（Java实现）",frontmatter:{title:"设计模式之命令模式详解（Java实现）",date:"2022-04-30T15:21:42.000Z",tags:["命令模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/31f81b/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89.html",relativePath:"01.开发/02.开发框架/03.设计模式/11.设计模式之命令模式详解（Java实现）.md",key:"v-527901ce",path:"/pages/31f81b/",headers:[{level:2,title:"1 命令模式介绍",slug:"_1-命令模式介绍",normalizedTitle:"1 命令模式介绍",charIndex:2},{level:2,title:"2 命令模式详解",slug:"_2-命令模式详解",normalizedTitle:"2 命令模式详解",charIndex:1113},{level:3,title:"2.1 命令模式结构",slug:"_2-1-命令模式结构",normalizedTitle:"2.1 命令模式结构",charIndex:1126},{level:3,title:"2.2 命令模式实现",slug:"_2-2-命令模式实现",normalizedTitle:"2.2 命令模式实现",charIndex:1653},{level:3,title:"2.3 命令模式应用举例",slug:"_2-3-命令模式应用举例",normalizedTitle:"2.3 命令模式应用举例",charIndex:2757},{level:2,title:"3 实现命令队列",slug:"_3-实现命令队列",normalizedTitle:"3 实现命令队列",charIndex:3136}],headersStr:"1 命令模式介绍 2 命令模式详解 2.1 命令模式结构 2.2 命令模式实现 2.3 命令模式应用举例 3 实现命令队列",content:'# 1 命令模式介绍\n\n在现实生活中人们通过使用开关来控制一些电器的打开和关闭，例如电灯或者排气扇，如下图。\n\n\n\n我们可以将开关看成一个请求发送者，电灯或者排气扇则是请求的最终接收者和处理者。开关和电灯之间并不存在直接耦合关系，它们通过电线连接在一起，使用不同的电线可以连接不同的请求接收者，只需要更换一根电线，相同的发送者（开关）即可对应不同的接收者（电器）。\n\n在软件开发中也存在很多与开关和电器类似的请求发送者和接收者对象，例如按钮和事件处理类。为了降低系统的耦合度，将请求的发送者和接收者解耦，我们可以使用命令模式（Command Pattern）来设计系统。\n\n在命令模式中发送者与接收者之间引入了新的命令对象（类似电线），将发送者的请求封装在命令对象中，再通过命令对象来调用接收者的方法。它可以使请求发送者和接收者完全解耦，发送者和接收者之间没有直接引用的关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。\n\n> 定义： 将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。\n> \n> 主要解决： 在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。\n> \n> 何时使用： 在某些场合，比如要对行为进行"记录、撤销/重做、事务"等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将"行为请求者"与"行为实现者"解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。\n> \n> 如何解决： 通过调用者调用接受者执行命令，顺序：调用者→命令→接受者。\n> \n> 关键代码： 定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口\n> \n> 应用实例： struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。\n> \n> 优点： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。\n> \n> 缺点： 使用命令模式可能会导致某些系统有过多的具体命令类。\n> \n> 使用场景： 认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。\n> \n> 注意事项： 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。\n\n\n# 2 命令模式详解\n\n\n# 2.1 命令模式结构\n\n命令模式的核心在于引入了抽象命令类和具体命令类，通过命令类来降低发送者和接收者的耦合度，请求发送者只需指定一个命令对象，再通过命令对象来调用请求接收者的处理方法，结构图如下：\n\n\n\n由图可知，命令模式包含以下4个角色。\n\n 1. Command（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作。\n 2. ConcreteCommand（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。具体命令类在实现execute()方法时将调用接收者对象的相关操作(Action)。\n 3. Invoker（调用者）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求接收者的相关操作。\n 4. Receiver（接收者）：接收者执行与请求相关的操作，具体实现对请求的业务处理。\n\n\n# 2.2 命令模式实现\n\n典型的抽象命令类代码如下：\n\npublic abstract class Command {\n    public abstract void execute();\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n对于请求发送者（即调用者）而言，将针对抽象命令类进行编程，可以通过构造函数或者Setter方法在运行时注入具体命令类对象，并在业务方法中调用命令对象的execute()方法，其典型代码如下：\n\npublic class Invoker {\n    private Command command;\n    \n    // 构造注入\n    public Invoker(Command command) {\n        this.command = command;\n    }\n    \n    // 设值注入\n    public setCommand(Command command) {\n        this.command = command;\n    }\n    \n    // 业务方法，用于调用命令类中的execute()方法\n    public void call() {\n        command.execute();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n具体命令类继承了抽象命令类，它与请求接收者关联，实现了在抽象命令类中声明的execute()方法，并在实现时调用接收者的请求响应方法。其典型代码如下：\n\npublic class ConcreteCommand extends Command {\n    private Receiver receiver; //维持一个对请求接收者对象的引用\n\n    public void execute() {\n        receiver.action(); //调用请求接收者的业务处理方法action()\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n请求接收者Receiver具体实现对请求的业务处理，它拥有action()方法，用于执行与请求相关操作，其典型代码如下：\n\npublic class Receiver {\n    public void action() {\n        //具体操作\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 2.3 命令模式应用举例\n\n * 题目描述\n   \n   > 为了用户使用方便，某系统提供了一系列功能键，用户可以自定义功能键的功能，例如功能键FunctionButton可以用于退出系统（由SystemExitClass类来实现），也可以用于显示帮助文档（由DisplayHelpClass类来实现）。\n   > \n   > 用户可以通过修改配置文件来改变功能键的用途，现使用命令模式来设计该系统，使得功能键类与功能类之间解耦，可为同一个功能键设置不同的功能。\n\n * UML类图\n\n\n\n其中，FunctionButton充当请求调用者，SystemExitClass和DisplayHelpClass充当请求接收者，Command是抽象命令类，ExitCommand和HelpCommand充当具体命令类。\n\n * 代码\n   \n   代码地址\n\n\n# 3 实现命令队列\n\n有时候，当一个请求发送者发送一个请求时有不止一个请求接收者产生响应，这些请求接收者将逐个执行业务方法，完成对请求的处理，此时可以通过命令队列来实现。\n\n命令队列的实现方法有多种形式，其中最常用、灵活性最好的一种方式就是增加一个CommandQueue类，由该类负责存储多个命令对象，而不同的命令对象可以对应不同的请求接收者。CommandQueue类的典型代码如下：\n\npackage homework;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class CommandQueue {\n    private List<Command> commandList = new ArrayList();\n    public void addCommand(Command command) {\n        commandList.add(command);\n    }\n    public void removeCommand(Command command) {\n        commandList.remove(command);\n    }\n\n    /**\n     * 循环调用每一个命令对象的execute()方法\n     */\n    public void execute() {\n        for (Command command : commandList) {\n            command.execute();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n在增加命令队列类CommandQueue以后，请求发送者Invoker将针对CommandQueue编程。即将Command修改为CommandQueue即可。',normalizedContent:'# 1 命令模式介绍\n\n在现实生活中人们通过使用开关来控制一些电器的打开和关闭，例如电灯或者排气扇，如下图。\n\n\n\n我们可以将开关看成一个请求发送者，电灯或者排气扇则是请求的最终接收者和处理者。开关和电灯之间并不存在直接耦合关系，它们通过电线连接在一起，使用不同的电线可以连接不同的请求接收者，只需要更换一根电线，相同的发送者（开关）即可对应不同的接收者（电器）。\n\n在软件开发中也存在很多与开关和电器类似的请求发送者和接收者对象，例如按钮和事件处理类。为了降低系统的耦合度，将请求的发送者和接收者解耦，我们可以使用命令模式（command pattern）来设计系统。\n\n在命令模式中发送者与接收者之间引入了新的命令对象（类似电线），将发送者的请求封装在命令对象中，再通过命令对象来调用接收者的方法。它可以使请求发送者和接收者完全解耦，发送者和接收者之间没有直接引用的关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。\n\n> 定义： 将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。\n> \n> 主要解决： 在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。\n> \n> 何时使用： 在某些场合，比如要对行为进行"记录、撤销/重做、事务"等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将"行为请求者"与"行为实现者"解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。\n> \n> 如何解决： 通过调用者调用接受者执行命令，顺序：调用者→命令→接受者。\n> \n> 关键代码： 定义三个角色：1、received 真正的命令执行对象 2、command 3、invoker 使用命令对象的入口\n> \n> 应用实例： struts 1 中的 action 核心控制器 actionservlet 只有一个，相当于 invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 command。\n> \n> 优点： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。\n> \n> 缺点： 使用命令模式可能会导致某些系统有过多的具体命令类。\n> \n> 使用场景： 认为是命令的地方都可以使用命令模式，比如： 1、gui 中每一个按钮都是一条命令。 2、模拟 cmd。\n> \n> 注意事项： 系统需要支持命令的撤销(undo)操作和恢复(redo)操作，也可以考虑使用命令模式，见命令模式的扩展。\n\n\n# 2 命令模式详解\n\n\n# 2.1 命令模式结构\n\n命令模式的核心在于引入了抽象命令类和具体命令类，通过命令类来降低发送者和接收者的耦合度，请求发送者只需指定一个命令对象，再通过命令对象来调用请求接收者的处理方法，结构图如下：\n\n\n\n由图可知，命令模式包含以下4个角色。\n\n 1. command（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作。\n 2. concretecommand（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。具体命令类在实现execute()方法时将调用接收者对象的相关操作(action)。\n 3. invoker（调用者）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求接收者的相关操作。\n 4. receiver（接收者）：接收者执行与请求相关的操作，具体实现对请求的业务处理。\n\n\n# 2.2 命令模式实现\n\n典型的抽象命令类代码如下：\n\npublic abstract class command {\n    public abstract void execute();\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n对于请求发送者（即调用者）而言，将针对抽象命令类进行编程，可以通过构造函数或者setter方法在运行时注入具体命令类对象，并在业务方法中调用命令对象的execute()方法，其典型代码如下：\n\npublic class invoker {\n    private command command;\n    \n    // 构造注入\n    public invoker(command command) {\n        this.command = command;\n    }\n    \n    // 设值注入\n    public setcommand(command command) {\n        this.command = command;\n    }\n    \n    // 业务方法，用于调用命令类中的execute()方法\n    public void call() {\n        command.execute();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n具体命令类继承了抽象命令类，它与请求接收者关联，实现了在抽象命令类中声明的execute()方法，并在实现时调用接收者的请求响应方法。其典型代码如下：\n\npublic class concretecommand extends command {\n    private receiver receiver; //维持一个对请求接收者对象的引用\n\n    public void execute() {\n        receiver.action(); //调用请求接收者的业务处理方法action()\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n请求接收者receiver具体实现对请求的业务处理，它拥有action()方法，用于执行与请求相关操作，其典型代码如下：\n\npublic class receiver {\n    public void action() {\n        //具体操作\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 2.3 命令模式应用举例\n\n * 题目描述\n   \n   > 为了用户使用方便，某系统提供了一系列功能键，用户可以自定义功能键的功能，例如功能键functionbutton可以用于退出系统（由systemexitclass类来实现），也可以用于显示帮助文档（由displayhelpclass类来实现）。\n   > \n   > 用户可以通过修改配置文件来改变功能键的用途，现使用命令模式来设计该系统，使得功能键类与功能类之间解耦，可为同一个功能键设置不同的功能。\n\n * uml类图\n\n\n\n其中，functionbutton充当请求调用者，systemexitclass和displayhelpclass充当请求接收者，command是抽象命令类，exitcommand和helpcommand充当具体命令类。\n\n * 代码\n   \n   代码地址\n\n\n# 3 实现命令队列\n\n有时候，当一个请求发送者发送一个请求时有不止一个请求接收者产生响应，这些请求接收者将逐个执行业务方法，完成对请求的处理，此时可以通过命令队列来实现。\n\n命令队列的实现方法有多种形式，其中最常用、灵活性最好的一种方式就是增加一个commandqueue类，由该类负责存储多个命令对象，而不同的命令对象可以对应不同的请求接收者。commandqueue类的典型代码如下：\n\npackage homework;\n\nimport java.util.arraylist;\nimport java.util.list;\n\npublic class commandqueue {\n    private list<command> commandlist = new arraylist();\n    public void addcommand(command command) {\n        commandlist.add(command);\n    }\n    public void removecommand(command command) {\n        commandlist.remove(command);\n    }\n\n    /**\n     * 循环调用每一个命令对象的execute()方法\n     */\n    public void execute() {\n        for (command command : commandlist) {\n            command.execute();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n在增加命令队列类commandqueue以后，请求发送者invoker将针对commandqueue编程。即将command修改为commandqueue即可。',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"设计模式之建造者模式详解（Java实现）",frontmatter:{title:"设计模式之建造者模式详解（Java实现）",date:"2022-04-24T09:20:17.000Z",tags:["建造者模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/04c857/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89.html",relativePath:"01.开发/02.开发框架/03.设计模式/02.设计模式之建造者模式详解（Java实现）.md",key:"v-0cf5f5ce",path:"/pages/04c857/",headers:[{level:2,title:"1 建造者模式介绍",slug:"_1-建造者模式介绍",normalizedTitle:"1 建造者模式介绍",charIndex:2},{level:2,title:"2 建造者模式详解",slug:"_2-建造者模式详解",normalizedTitle:"2 建造者模式详解",charIndex:655},{level:3,title:"2.1 建造者模式结构",slug:"_2-1-建造者模式结构",normalizedTitle:"2.1 建造者模式结构",charIndex:669},{level:3,title:"2.2 建造者模式实现",slug:"_2-2-建造者模式实现",normalizedTitle:"2.2 建造者模式实现",charIndex:1182},{level:3,title:"2.3 建造者模式应用举例",slug:"_2-3-建造者模式应用举例",normalizedTitle:"2.3 建造者模式应用举例",charIndex:2619}],headersStr:"1 建造者模式介绍 2 建造者模式详解 2.1 建造者模式结构 2.2 建造者模式实现 2.3 建造者模式应用举例",content:'# 1 建造者模式介绍\n\n建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n\n一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。\n\n> 意图： 将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。\n> \n> 主要解决： 主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。\n> \n> 何时使用： 一些基本部件不会变，而其组合经常变化的时候。\n> \n> 如何解决： 将变与不变分离开。\n> \n> 关键代码： 建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。\n> \n> 应用实例： 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。 2、JAVA 中的 StringBuilder。\n> \n> 优点： 1、建造者独立，易扩展。 2、便于控制细节风险。\n> \n> 缺点： 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。\n> \n> 使用场景： 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。\n> \n> 注意事项： 与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。\n\n\n# 2 建造者模式详解\n\n\n# 2.1 建造者模式结构\n\n建造者模式的UML类图如下：\n\n\n\n由上图可知，建造者模式包含以下4个角色。\n\n 1. Builder（抽象建造者）：它为创建一个产品对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildPartX()（如图中的buildPartA()、buildPathB()等），它们用于创建复杂对象的各个部件；另一类方法是getResult（），它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。\n 2. ConcreteBuilder（具体建造者）：它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确所创建的复杂对象，还可以提供一个方法返回创建好的复杂产品对象（该方法也可以由抽象建造者实现）。\n 3. Product（产品）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。\n 4. Director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。\n\n\n# 2.2 建造者模式实现\n\n典型的复杂对象类的代码如下：\n\npublic class Product {\n    private String partA; // 定义部件，部件可以是任意类型，包括值类型和引用类型\n    private String partB;\n    private String partC;\n    // 属性的Getter和Setter方法省略\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n典型的抽象建造者类的代码如下：\n\npublic abstract class Builder {\n    // 创建产品对象\n    protected Product product = new Product();\n    \n    public abstract void buildPartA();\n    public abstract void buildPartB();\n    public abstract void buildPartC();\n    \n    // 返回产品对象\n    public Product getResult() {\n        return product;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n典型的具体建造者类的代码如下：\n\npublic class ConcreteBuilder1 extends Builder {\n    public void buildPartA() {\n        product.setPartA("A1");\n    }\n    public void buildPartB() {\n        product.setPartA("B1");\n    }\n    public void buildPartC() {\n        product.setPartA("C1");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n典型的指挥者类的代码如下：\n\npublic class Director {\n    private Builder builder;\n    \n    public Director(Builder builder) {\n        this.builder = builder;\n    }\n    public void setBuilder(Builder builder) {\n        this.builder = builder;\n    }\n    // 产品的构建与组装方法\n    public Product construct() {\n        builder.buildPartA();\n        builder.buildPartB();\n        builder.buildPartC();\n        return builder.getResult();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 2.3 建造者模式应用举例\n\n * 题目描述\n   \n   > 计算机组装工厂可以将CPU、内存、硬盘、主机、显示器等硬件设备组装在一起构成一台完整的计算机，且构成的计算机可以是笔记本，也可以是台式机，还可以是不提供显示器的服务器主机。对于用户而言，无须关心计算机的组成设备和组装过程，工厂返回给用户的。是完整的计算机对象，使用建造者模式实现计算机组装过程。\n\n * UML类图\n   \n   \n   \n   其中，Computer充当符合产品，ComputerBuilder充当抽象建造者，Notebook、Desktop和Server充当具体建造者，ComputerAssembleDirector充当指挥者，其assemble()方法用于定义产品的构造过程。\n\n * 代码\n   \n   代码地址',normalizedContent:'# 1 建造者模式介绍\n\n建造者模式（builder pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n\n一个 builder 类会一步一步构造最终的对象。该 builder 类是独立于其他对象的。\n\n> 意图： 将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。\n> \n> 主要解决： 主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。\n> \n> 何时使用： 一些基本部件不会变，而其组合经常变化的时候。\n> \n> 如何解决： 将变与不变分离开。\n> \n> 关键代码： 建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。\n> \n> 应用实例： 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。 2、java 中的 stringbuilder。\n> \n> 优点： 1、建造者独立，易扩展。 2、便于控制细节风险。\n> \n> 缺点： 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。\n> \n> 使用场景： 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。\n> \n> 注意事项： 与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。\n\n\n# 2 建造者模式详解\n\n\n# 2.1 建造者模式结构\n\n建造者模式的uml类图如下：\n\n\n\n由上图可知，建造者模式包含以下4个角色。\n\n 1. builder（抽象建造者）：它为创建一个产品对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildpartx()（如图中的buildparta()、buildpathb()等），它们用于创建复杂对象的各个部件；另一类方法是getresult（），它们用于返回复杂对象。builder既可以是抽象类，也可以是接口。\n 2. concretebuilder（具体建造者）：它实现了builder接口，实现各个部件的具体构造和装配方法，定义并明确所创建的复杂对象，还可以提供一个方法返回创建好的复杂产品对象（该方法也可以由抽象建造者实现）。\n 3. product（产品）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。\n 4. director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。\n\n\n# 2.2 建造者模式实现\n\n典型的复杂对象类的代码如下：\n\npublic class product {\n    private string parta; // 定义部件，部件可以是任意类型，包括值类型和引用类型\n    private string partb;\n    private string partc;\n    // 属性的getter和setter方法省略\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n典型的抽象建造者类的代码如下：\n\npublic abstract class builder {\n    // 创建产品对象\n    protected product product = new product();\n    \n    public abstract void buildparta();\n    public abstract void buildpartb();\n    public abstract void buildpartc();\n    \n    // 返回产品对象\n    public product getresult() {\n        return product;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n典型的具体建造者类的代码如下：\n\npublic class concretebuilder1 extends builder {\n    public void buildparta() {\n        product.setparta("a1");\n    }\n    public void buildpartb() {\n        product.setparta("b1");\n    }\n    public void buildpartc() {\n        product.setparta("c1");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n典型的指挥者类的代码如下：\n\npublic class director {\n    private builder builder;\n    \n    public director(builder builder) {\n        this.builder = builder;\n    }\n    public void setbuilder(builder builder) {\n        this.builder = builder;\n    }\n    // 产品的构建与组装方法\n    public product construct() {\n        builder.buildparta();\n        builder.buildpartb();\n        builder.buildpartc();\n        return builder.getresult();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 2.3 建造者模式应用举例\n\n * 题目描述\n   \n   > 计算机组装工厂可以将cpu、内存、硬盘、主机、显示器等硬件设备组装在一起构成一台完整的计算机，且构成的计算机可以是笔记本，也可以是台式机，还可以是不提供显示器的服务器主机。对于用户而言，无须关心计算机的组成设备和组装过程，工厂返回给用户的。是完整的计算机对象，使用建造者模式实现计算机组装过程。\n\n * uml类图\n   \n   \n   \n   其中，computer充当符合产品，computerbuilder充当抽象建造者，notebook、desktop和server充当具体建造者，computerassembledirector充当指挥者，其assemble()方法用于定义产品的构造过程。\n\n * 代码\n   \n   代码地址',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"设计模式之外观模式详解（Java实现）",frontmatter:{title:"设计模式之外观模式详解（Java实现）",date:"2022-04-30T09:18:49.000Z",tags:["外观模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/e40609/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/09.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89.html",relativePath:"01.开发/02.开发框架/03.设计模式/09.设计模式之外观模式详解（Java实现）.md",key:"v-f177b3e6",path:"/pages/e40609/",headers:[{level:2,title:"1 外观模式概述",slug:"_1-外观模式概述",normalizedTitle:"1 外观模式概述",charIndex:2},{level:2,title:"2 外观模式详解",slug:"_2-外观模式详解",normalizedTitle:"2 外观模式详解",charIndex:789},{level:3,title:"2.1 外观模式结构",slug:"_2-1-外观模式结构",normalizedTitle:"2.1 外观模式结构",charIndex:802},{level:3,title:"2.2 外观模式实现",slug:"_2-2-外观模式实现",normalizedTitle:"2.2 外观模式实现",charIndex:1142},{level:3,title:"2.3 外观模式应用举例",slug:"_2-3-外观模式应用举例",normalizedTitle:"2.3 外观模式应用举例",charIndex:2105},{level:2,title:"3 抽象外观类",slug:"_3-抽象外观类",normalizedTitle:"3 抽象外观类",charIndex:2451}],headersStr:"1 外观模式概述 2 外观模式详解 2.1 外观模式结构 2.2 外观模式实现 2.3 外观模式应用举例 3 抽象外观类",content:'# 1 外观模式概述\n\n在软件开发中，有时候为了完成一项较为复杂的功能，一个客户类需要和多个业务类交互，而这些需要交互的业务类经常会作为一个整体出现，由于设计的类比较多，导致使用代码较为复杂，此时特别需要一个类似服务员的角色，由它来负责和多个业务类进行交互，而客户类只需要与该类进行交互。外观模式（Facade Pattern）通过引入一个新的外观类(Facade)来负责和多个业务类【子系统(Subsystem)，所指的子系统是一个广义的概念，它可以是一个类、一个功能模块、系统的一个组成部分或者一个完整的系统】进行交互，而客户类只需与外观类交互。\n\n\n\n它为子系统中的一组接口提供了一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n\n> 主要解决： 降低访问复杂系统的内部子系统时的复杂度，简化客户端之间的接口。\n> \n> 何时使用： 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个"接待员"即可。 2、定义系统的入口。\n> \n> 如何解决： 客户端不与系统耦合，外观类与系统耦合。\n> \n> 关键代码： 在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。\n> \n> 应用实例： 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 2、JAVA 的三层开发模式。\n> \n> 优点： 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。\n> \n> **缺点：**不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。\n> \n> 使用场景： 1、为复杂的模块或子系统提供外界访问的模块。 2、子系统相对独立。 3、预防低水平人员带来的风险。\n> \n> 注意事项： 在层次化结构中，可以使用外观模式定义系统中每一层的入口。\n\n\n# 2 外观模式详解\n\n\n# 2.1 外观模式结构\n\n外观模式没有一个一般化的类图描述，下图可以用来描述外观模式的结构图。\n\n\n\n由上图可知，外观模式包含以下两个角色。\n\n 1. Facade（外观角色）：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统，传递给相应的子系统对象处理。\n 2. SubSystem（子系统角色）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。\n\n\n# 2.2 外观模式实现\n\n子系统类通常是一些业务类，实现了一些具体的、独立的业务功能，其典型代码如下：\n\npublic class SubSystemA {\n    public void methodA() {\n        //业务实现代码\n    }\n}\npublic class SubSystemB {\n    public void methodB() {\n        //业务实现代码\n    }\n}\npublic class SubSystemC {\n    public void methodC() {\n        //业务实现代码\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n外观类的典型代码如下：\n\npublic class Facade {\n    private SubSystemA obj1 = new SubSystemA();\n    private SubSystemB obj2 = new SubSystemB();\n    private SubSystemC obj3 = new SubSystemC();\n\n    public void method() {\n        obj1.method();\n        obj2.method();\n        obj3.method();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n由于在外观类中维持了对子系统对象的引用，客户端可以通过外观类来间接调用子系统对象的业务方法，而无须与子系统对象直接交互。在引入外观类后，客户端代码变得非常简单，其典型代码如下：\n\npublic class Client {\n    public static void main(String args[]) {\n        Facade facade = new Facade();\n        facade.method();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2.3 外观模式应用举例\n\n * 题目描述\n   \n   > 某软件公司要开发一个可应用于多个软件的文件加密模块，该模块可以对文件中的数据进行加密并将加密之后的数据存储在一个新文件中，具体的流程包括3个部分，分别是读取源文件、加密、保存加密之后的文件，其中，读取文件和保存文件使用流来实现，加密操作通过求模运算实现。这3个操作相对独立，为了实现代码的独立重用，让设计更符合单一职责原则，这3个操作的业务代码封装在3个不同的类中。 现使用外观模式设计该文件加密模块。\n\n * UML类图\n   \n   \n   \n   其中，EncryptFacade充当外观类，FileReader、CipherMachine和FileWriter充当子系统类。\n\n * 代码\n   \n   代码地址\n\n\n# 3 抽象外观类\n\n在标准的外观模式的结构图中，如果需要增加、删除或更换与外观类交互的子系统类，必须修改外观类或客户端的源代码，这将违背开闭原则，因此可以通过引入抽象外观类对系统进行改进，在一定程度上解决该问题。\n\n如2.3中的题目我们需要更换一个加密类，如果我们需要增加一个新的外观类NewEncryptFacade与FileReader类、FileWriter类以及新增加的NewClipherMachine类交互，虽然原有系统类库无须作修改，但是因为客户端代码中原来针对EncryptFacade类进行编程，现在需要修改为NewEncryptFacade类，所以需要修改客户端源代码。如何在不修改客户端代码的前提下使用新的外观类呢？那么我们可以引入一个抽象外观类，客户端针对抽象外观类编程即可。结构图如下：\n\n\n\n修改后的代码如下：\n\n代码地址',normalizedContent:'# 1 外观模式概述\n\n在软件开发中，有时候为了完成一项较为复杂的功能，一个客户类需要和多个业务类交互，而这些需要交互的业务类经常会作为一个整体出现，由于设计的类比较多，导致使用代码较为复杂，此时特别需要一个类似服务员的角色，由它来负责和多个业务类进行交互，而客户类只需要与该类进行交互。外观模式（facade pattern）通过引入一个新的外观类(facade)来负责和多个业务类【子系统(subsystem)，所指的子系统是一个广义的概念，它可以是一个类、一个功能模块、系统的一个组成部分或者一个完整的系统】进行交互，而客户类只需与外观类交互。\n\n\n\n它为子系统中的一组接口提供了一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n\n> 主要解决： 降低访问复杂系统的内部子系统时的复杂度，简化客户端之间的接口。\n> \n> 何时使用： 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个"接待员"即可。 2、定义系统的入口。\n> \n> 如何解决： 客户端不与系统耦合，外观类与系统耦合。\n> \n> 关键代码： 在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。\n> \n> 应用实例： 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 2、java 的三层开发模式。\n> \n> 优点： 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。\n> \n> **缺点：**不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。\n> \n> 使用场景： 1、为复杂的模块或子系统提供外界访问的模块。 2、子系统相对独立。 3、预防低水平人员带来的风险。\n> \n> 注意事项： 在层次化结构中，可以使用外观模式定义系统中每一层的入口。\n\n\n# 2 外观模式详解\n\n\n# 2.1 外观模式结构\n\n外观模式没有一个一般化的类图描述，下图可以用来描述外观模式的结构图。\n\n\n\n由上图可知，外观模式包含以下两个角色。\n\n 1. facade（外观角色）：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统，传递给相应的子系统对象处理。\n 2. subsystem（子系统角色）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。\n\n\n# 2.2 外观模式实现\n\n子系统类通常是一些业务类，实现了一些具体的、独立的业务功能，其典型代码如下：\n\npublic class subsystema {\n    public void methoda() {\n        //业务实现代码\n    }\n}\npublic class subsystemb {\n    public void methodb() {\n        //业务实现代码\n    }\n}\npublic class subsystemc {\n    public void methodc() {\n        //业务实现代码\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n外观类的典型代码如下：\n\npublic class facade {\n    private subsystema obj1 = new subsystema();\n    private subsystemb obj2 = new subsystemb();\n    private subsystemc obj3 = new subsystemc();\n\n    public void method() {\n        obj1.method();\n        obj2.method();\n        obj3.method();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n由于在外观类中维持了对子系统对象的引用，客户端可以通过外观类来间接调用子系统对象的业务方法，而无须与子系统对象直接交互。在引入外观类后，客户端代码变得非常简单，其典型代码如下：\n\npublic class client {\n    public static void main(string args[]) {\n        facade facade = new facade();\n        facade.method();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2.3 外观模式应用举例\n\n * 题目描述\n   \n   > 某软件公司要开发一个可应用于多个软件的文件加密模块，该模块可以对文件中的数据进行加密并将加密之后的数据存储在一个新文件中，具体的流程包括3个部分，分别是读取源文件、加密、保存加密之后的文件，其中，读取文件和保存文件使用流来实现，加密操作通过求模运算实现。这3个操作相对独立，为了实现代码的独立重用，让设计更符合单一职责原则，这3个操作的业务代码封装在3个不同的类中。 现使用外观模式设计该文件加密模块。\n\n * uml类图\n   \n   \n   \n   其中，encryptfacade充当外观类，filereader、ciphermachine和filewriter充当子系统类。\n\n * 代码\n   \n   代码地址\n\n\n# 3 抽象外观类\n\n在标准的外观模式的结构图中，如果需要增加、删除或更换与外观类交互的子系统类，必须修改外观类或客户端的源代码，这将违背开闭原则，因此可以通过引入抽象外观类对系统进行改进，在一定程度上解决该问题。\n\n如2.3中的题目我们需要更换一个加密类，如果我们需要增加一个新的外观类newencryptfacade与filereader类、filewriter类以及新增加的newcliphermachine类交互，虽然原有系统类库无须作修改，但是因为客户端代码中原来针对encryptfacade类进行编程，现在需要修改为newencryptfacade类，所以需要修改客户端源代码。如何在不修改客户端代码的前提下使用新的外观类呢？那么我们可以引入一个抽象外观类，客户端针对抽象外观类编程即可。结构图如下：\n\n\n\n修改后的代码如下：\n\n代码地址',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"设计模式之观察者模式详解（Java实现）",frontmatter:{title:"设计模式之观察者模式详解（Java实现）",date:"2022-05-01T09:43:00.000Z",tags:["观察者模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/e1f6d9/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89.html",relativePath:"01.开发/02.开发框架/03.设计模式/12.设计模式之观察者模式详解（Java实现）.md",key:"v-7587d3fc",path:"/pages/e1f6d9/",headers:[{level:2,title:"1 观察者模式介绍",slug:"_1-观察者模式介绍",normalizedTitle:"1 观察者模式介绍",charIndex:2},{level:2,title:"2 观察者模式详解",slug:"_2-观察者模式详解",normalizedTitle:"2 观察者模式详解",charIndex:1190},{level:3,title:"2.1 观察者模式结构",slug:"_2-1-观察者模式结构",normalizedTitle:"2.1 观察者模式结构",charIndex:1204},{level:3,title:"2.2 观察者模式实现",slug:"_2-2-观察者模式实现",normalizedTitle:"2.2 观察者模式实现",charIndex:1801},{level:3,title:"2.3 观察者模式应用举例",slug:"_2-3-观察者模式应用举例",normalizedTitle:"2.3 观察者模式应用举例",charIndex:3090},{level:2,title:"3 观察者模式与MVC",slug:"_3-观察者模式与mvc",normalizedTitle:"3 观察者模式与mvc",charIndex:3413}],headersStr:"1 观察者模式介绍 2 观察者模式详解 2.1 观察者模式结构 2.2 观察者模式实现 2.3 观察者模式应用举例 3 观察者模式与MVC",content:"# 1 观察者模式介绍\n\n“红灯停，绿灯行”。在这个过程中，交通信号灯是汽车的观察目标，而汽车则是观察者。随着交通信号灯的变化，汽车的行为也随之变化，一盏交通信号灯可以指挥多辆汽车。\n\n\n\n在软件系统中有些对象之间也存在类似交通信号灯和汽车之间的关系，一个对象的状态或行为的变化将导致其他对象的状态或行为也发生改变。观察者模式（Observer Pattern）则是用于建立一种对象与对象之间的依赖关系，使得每当一个对象状态发生改变时其相关依赖对象皆得到通知并被自动更新。发生改变的对象称为观察目标，被通知的对象称为观察者，一个观察目标可以对应多个观察者。它有如下别名：\n\n * 发布-订阅(Publish/Subscribe)模式\n * 模型-视图(Model/View)模式\n * 源-监听器(Source/Listener)模式\n * 从属者(Dependents)模式\n\n> 主要解决： 一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。\n> \n> 何时使用： 一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。\n> \n> 如何解决： 使用面向对象技术，可以将这种依赖关系弱化。\n> \n> 关键代码： 在抽象类里有一个 ArrayList 存放观察者们。\n> \n> 应用实例： 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。\n> \n> 优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。\n> \n> 缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。\n> \n> 使用场景：\n> \n>  * 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。\n>  * 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。\n>  * 一个对象必须通知其他对象，而并不知道这些对象是谁。\n>  * 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。\n> \n> 注意事项： 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。\n\n\n# 2 观察者模式详解\n\n\n# 2.1 观察者模式结构\n\n观察者模式结构中通常包括观察目标和观察者两个继承层次结构，其结构图如下：\n\n\n\n由图可知，观察者模式包含以下4个角色。\n\n 1. Subject（目标）：目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供了一系列方法来增加和删除观察者对象，同时它定义了通知方法notify()。目标类可以是接口，也可以是抽象类或具体类。\n 2. ConcreteSubject（具体目标）：具体目标是目标类的子类，它通常包含有经常发生改变的数据，当它的状态发生改变时它向各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法。如果无须扩展目标类，具体目标类可以省略。\n 3. Observer（观察者）：观察者将对观察目标的改变做出反映，观察者一般定义为接口，该接口声明了更新数据的方法update()，因此又称为抽象观察者。\n 4. ConcreteObserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者Observer中定义的update()方法。通常在实现时可以调用具体目标类的attach()方法将自己添加到目标类的集合中或者通过detach()方法将自己从目标类的集合中删除。\n\n\n# 2.2 观察者模式实现\n\n抽象目标类典型代码如下：\n\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic abstract class Subject {\n    //定义一个观察者集合用于存储所有观察者对象\n    protected List<Observer> observers = new ArrayList();\n\n    //注册方法，用于向观察者集合中增加一个观察者\n    public void attach(Observer observer) {\n        observers.add(observer);\n    }\n\n    //注销方法，用于在观察者集合中删除一个观察者\n    public void detach(Observer observer) {\n        observers.remove(observer);\n    }\n\n    //声明抽象通知方法\n    public abstract void notify();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n具体目标类典型代码如下：\n\npublic class ConcreteSubject extends Subject {\n    //实现通知方法\n    public void notify() {\n        //遍历观察者集合，调用每一个观察者的响应方法\n        for(Observer obs:observers) {\n            obs.update();\n        }\n    } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n抽象观察者典型代码如下：\n\npublic interface Observer {\n    //声明响应方法\n    public void update();\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n具体观察者典型代码如下：\n\npublic class ConcreteObserver implements Observer {\n    //实现响应方法\n    public void update() {\n        //具体响应代码\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n * 有时候在具体观察者类ConcreteObserver中需要使用到具体目标类ConcreteSubject中的状态（属性），会存在关联或依赖关系。\n * 如果在具体层之间具有关联关系，系统的扩展性将受到一定的影响，增加新的具体目标类有时候需要修改原有观察者的代码，在一定程度上违背了开闭原则，但是如果原有观察者类无须关联新增的具体目标，则系统扩展性不受影响。\n\n\n# 2.3 观察者模式应用举例\n\n * 题目描述\n   \n   > 在某多人联机对战游戏中，多个玩家可以加入同一战队组成联盟，当战队中的某一成员受到敌人攻击时将给所有其他盟友发送通知，盟友收到通知后将做出响应。现使用观察者模式设计并实现该过程，以实现战队成员之间的联动。\n\n * 题目分析\n   \n   战队成员之间的联动过程：联盟成员受到攻击——>发送通知给盟友——>盟友做出响应。\n\n * UML类图\n   \n   其中，AllyControlCenter充当抽象目标类，ConcreteAllyControlCenter充当具体目标类，Observer充当抽象观察者，Player充当具体观察者。\n\n * 代码\n   \n   代码地址\n\n\n# 3 观察者模式与MVC\n\n在当前流行的MVC（Model-View-Controller）架构中也应用了观察者模式，MVC是一种架构模式，它包含了3个角色，即模型(Model)，视图(View)和控制器(Controller)。其中，模型可对应于观察者模式中的观察目标，而视图对应于观察者，控制器可充当两者之间的中介者。当模型层的数据发生改变时，视图层将自动改变其显示内容。MVC的结构图如下：\n\n",normalizedContent:"# 1 观察者模式介绍\n\n“红灯停，绿灯行”。在这个过程中，交通信号灯是汽车的观察目标，而汽车则是观察者。随着交通信号灯的变化，汽车的行为也随之变化，一盏交通信号灯可以指挥多辆汽车。\n\n\n\n在软件系统中有些对象之间也存在类似交通信号灯和汽车之间的关系，一个对象的状态或行为的变化将导致其他对象的状态或行为也发生改变。观察者模式（observer pattern）则是用于建立一种对象与对象之间的依赖关系，使得每当一个对象状态发生改变时其相关依赖对象皆得到通知并被自动更新。发生改变的对象称为观察目标，被通知的对象称为观察者，一个观察目标可以对应多个观察者。它有如下别名：\n\n * 发布-订阅(publish/subscribe)模式\n * 模型-视图(model/view)模式\n * 源-监听器(source/listener)模式\n * 从属者(dependents)模式\n\n> 主要解决： 一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。\n> \n> 何时使用： 一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。\n> \n> 如何解决： 使用面向对象技术，可以将这种依赖关系弱化。\n> \n> 关键代码： 在抽象类里有一个 arraylist 存放观察者们。\n> \n> 应用实例： 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。\n> \n> 优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。\n> \n> 缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。\n> \n> 使用场景：\n> \n>  * 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。\n>  * 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。\n>  * 一个对象必须通知其他对象，而并不知道这些对象是谁。\n>  * 需要在系统中创建一个触发链，a对象的行为将影响b对象，b对象的行为将影响c对象……，可以使用观察者模式创建一种链式触发机制。\n> \n> 注意事项： 1、java 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。\n\n\n# 2 观察者模式详解\n\n\n# 2.1 观察者模式结构\n\n观察者模式结构中通常包括观察目标和观察者两个继承层次结构，其结构图如下：\n\n\n\n由图可知，观察者模式包含以下4个角色。\n\n 1. subject（目标）：目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供了一系列方法来增加和删除观察者对象，同时它定义了通知方法notify()。目标类可以是接口，也可以是抽象类或具体类。\n 2. concretesubject（具体目标）：具体目标是目标类的子类，它通常包含有经常发生改变的数据，当它的状态发生改变时它向各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法。如果无须扩展目标类，具体目标类可以省略。\n 3. observer（观察者）：观察者将对观察目标的改变做出反映，观察者一般定义为接口，该接口声明了更新数据的方法update()，因此又称为抽象观察者。\n 4. concreteobserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者observer中定义的update()方法。通常在实现时可以调用具体目标类的attach()方法将自己添加到目标类的集合中或者通过detach()方法将自己从目标类的集合中删除。\n\n\n# 2.2 观察者模式实现\n\n抽象目标类典型代码如下：\n\nimport java.util.list;\nimport java.util.arraylist;\n\npublic abstract class subject {\n    //定义一个观察者集合用于存储所有观察者对象\n    protected list<observer> observers = new arraylist();\n\n    //注册方法，用于向观察者集合中增加一个观察者\n    public void attach(observer observer) {\n        observers.add(observer);\n    }\n\n    //注销方法，用于在观察者集合中删除一个观察者\n    public void detach(observer observer) {\n        observers.remove(observer);\n    }\n\n    //声明抽象通知方法\n    public abstract void notify();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n具体目标类典型代码如下：\n\npublic class concretesubject extends subject {\n    //实现通知方法\n    public void notify() {\n        //遍历观察者集合，调用每一个观察者的响应方法\n        for(observer obs:observers) {\n            obs.update();\n        }\n    } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n抽象观察者典型代码如下：\n\npublic interface observer {\n    //声明响应方法\n    public void update();\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n具体观察者典型代码如下：\n\npublic class concreteobserver implements observer {\n    //实现响应方法\n    public void update() {\n        //具体响应代码\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n * 有时候在具体观察者类concreteobserver中需要使用到具体目标类concretesubject中的状态（属性），会存在关联或依赖关系。\n * 如果在具体层之间具有关联关系，系统的扩展性将受到一定的影响，增加新的具体目标类有时候需要修改原有观察者的代码，在一定程度上违背了开闭原则，但是如果原有观察者类无须关联新增的具体目标，则系统扩展性不受影响。\n\n\n# 2.3 观察者模式应用举例\n\n * 题目描述\n   \n   > 在某多人联机对战游戏中，多个玩家可以加入同一战队组成联盟，当战队中的某一成员受到敌人攻击时将给所有其他盟友发送通知，盟友收到通知后将做出响应。现使用观察者模式设计并实现该过程，以实现战队成员之间的联动。\n\n * 题目分析\n   \n   战队成员之间的联动过程：联盟成员受到攻击——>发送通知给盟友——>盟友做出响应。\n\n * uml类图\n   \n   其中，allycontrolcenter充当抽象目标类，concreteallycontrolcenter充当具体目标类，observer充当抽象观察者，player充当具体观察者。\n\n * 代码\n   \n   代码地址\n\n\n# 3 观察者模式与mvc\n\n在当前流行的mvc（model-view-controller）架构中也应用了观察者模式，mvc是一种架构模式，它包含了3个角色，即模型(model)，视图(view)和控制器(controller)。其中，模型可对应于观察者模式中的观察目标，而视图对应于观察者，控制器可充当两者之间的中介者。当模型层的数据发生改变时，视图层将自动改变其显示内容。mvc的结构图如下：\n\n",charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"设计模式之策略模式详解（Java实现）",frontmatter:{title:"设计模式之策略模式详解（Java实现）",date:"2022-05-01T09:44:58.000Z",tags:["策略模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/b22ffc/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%EF%BC%89%E5%AE%9E%E7%8E%B0.html",relativePath:"01.开发/02.开发框架/03.设计模式/13.设计模式之策略模式详解（Java）实现.md",key:"v-cecf59c6",path:"/pages/b22ffc/",headers:[{level:2,title:"1 策略模式介绍",slug:"_1-策略模式介绍",normalizedTitle:"1 策略模式介绍",charIndex:2},{level:2,title:"2 策略模式详解",slug:"_2-策略模式详解",normalizedTitle:"2 策略模式详解",charIndex:483},{level:3,title:"2.1 策略模式结构",slug:"_2-1-策略模式结构",normalizedTitle:"2.1 策略模式结构",charIndex:496},{level:3,title:"2.2 策略模式实现",slug:"_2-2-策略模式实现",normalizedTitle:"2.2 策略模式实现",charIndex:823},{level:3,title:"2.3 策略模式应用举例",slug:"_2-3-策略模式应用举例",normalizedTitle:"2.3 策略模式应用举例",charIndex:1457}],headersStr:"1 策略模式介绍 2 策略模式详解 2.1 策略模式结构 2.2 策略模式实现 2.3 策略模式应用举例",content:"# 1 策略模式介绍\n\n在很多情况下，实现某个目标的途径不止一条，例如在外出旅游时游客可以选择多种不同的出行方式，可根据实际情况来确定最适合的出行方式。\n\n\n\n在软件开发中，也常常会遇到类似的情况，实现某个功能有多种算法，一种常用的方法是通过硬编码将所有的算法集中在一个类中，在该类中提供多个方法，每个方法对应一个算法；当然也可以将这些算法封装在一个统一的方法中，通过if...else...等条件判断选择。这两种实现方法都可以称为硬编码。但这样的方式封装了大量的算法，代码非常复杂，维护也很困难。\n\n策略模式（Strategy Pattern）定义一些独立的类来封装不同的算法，每一个类封装一种具体的算法，在这里每一个封装算法的类都可以称为一种策略（Strategy），为了保证这些策略在使用时具有一致性，一般会提供一个抽象的策略类来做算法的声明，而每种算法对应于一个具体策略类。\n\n策略模式定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法可以独立于使用它们的客户而变化。它又称为政策（Policy）模式，是一种对象行为型模式。\n\n\n# 2 策略模式详解\n\n\n# 2.1 策略模式结构\n\n其结构图如下：\n\n\n\n由图可知，策略模式包含以下3个角色。\n\n 1. Context（环境类）：环境类是使用算法的角色，它在解决某个问题时可以采用多种策略。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略。\n 2. Strategy（抽象策略类）：抽象策略类为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法。\n 3. ConcreteStrategy（具体策略类）：具体策略类实现了在抽象策略类中声明的算法，在运行时具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务功能。\n\n\n# 2.2 策略模式实现\n\n抽象策略类典型代码如下：\n\npublic abstract class AbstractStrategy {\n    // 声明抽象算法\n    public abstract void algorithm();\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n具体策略类典型代码如下：\n\npublic class ConcreteStrategyA extends AbstractStrategy {\n    // 算法的具体实现\n    public void algorithm() {\n        // 算法A\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n环境类典型代码如下：\n\npublic class Context {\n    private AbstractStrategy strategy; // 维持一个对抽象策略类的引用\n    public void setStrategy(AbstractStrategy strategy) {\n        this.strategy = strategy;\n    }\n    // 调用策略类中的算法\n    public void algorithm() {\n        strategy.algorithm();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 2.3 策略模式应用举例\n\n * 题目描述\n   \n   > 某软件公司为某电影院开发了一套影院售票系统，在该系统中需要为不同类型的用户提供不同的电影票打折方式，具体打折方案如下：* (1) 学生凭学生证可享受票价8折优惠。 (2) 年龄在10周岁及以下的儿童可享受每张票减免10元的优惠（原始票价需大于等于20元）。 (3) 影院VIP用户除享受票价半价优惠外还可进行积分，积分累计到一定额度可换取电影院赠送的奖品。 该系统在将来可能还要根据需要引入新的打折方式。现使用策略模式设计该影院售票系统的打折方案。\n\n * UML类图\n   \n   其中，MovieTicket充当环境类角色，Discount充当抽象策略角色，StudentDiscount、ChildrenDiscount和VIPDiscount充当具体策略角色。\n\n * 代码\n   \n   代码地址",normalizedContent:"# 1 策略模式介绍\n\n在很多情况下，实现某个目标的途径不止一条，例如在外出旅游时游客可以选择多种不同的出行方式，可根据实际情况来确定最适合的出行方式。\n\n\n\n在软件开发中，也常常会遇到类似的情况，实现某个功能有多种算法，一种常用的方法是通过硬编码将所有的算法集中在一个类中，在该类中提供多个方法，每个方法对应一个算法；当然也可以将这些算法封装在一个统一的方法中，通过if...else...等条件判断选择。这两种实现方法都可以称为硬编码。但这样的方式封装了大量的算法，代码非常复杂，维护也很困难。\n\n策略模式（strategy pattern）定义一些独立的类来封装不同的算法，每一个类封装一种具体的算法，在这里每一个封装算法的类都可以称为一种策略（strategy），为了保证这些策略在使用时具有一致性，一般会提供一个抽象的策略类来做算法的声明，而每种算法对应于一个具体策略类。\n\n策略模式定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法可以独立于使用它们的客户而变化。它又称为政策（policy）模式，是一种对象行为型模式。\n\n\n# 2 策略模式详解\n\n\n# 2.1 策略模式结构\n\n其结构图如下：\n\n\n\n由图可知，策略模式包含以下3个角色。\n\n 1. context（环境类）：环境类是使用算法的角色，它在解决某个问题时可以采用多种策略。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略。\n 2. strategy（抽象策略类）：抽象策略类为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法。\n 3. concretestrategy（具体策略类）：具体策略类实现了在抽象策略类中声明的算法，在运行时具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务功能。\n\n\n# 2.2 策略模式实现\n\n抽象策略类典型代码如下：\n\npublic abstract class abstractstrategy {\n    // 声明抽象算法\n    public abstract void algorithm();\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n具体策略类典型代码如下：\n\npublic class concretestrategya extends abstractstrategy {\n    // 算法的具体实现\n    public void algorithm() {\n        // 算法a\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n环境类典型代码如下：\n\npublic class context {\n    private abstractstrategy strategy; // 维持一个对抽象策略类的引用\n    public void setstrategy(abstractstrategy strategy) {\n        this.strategy = strategy;\n    }\n    // 调用策略类中的算法\n    public void algorithm() {\n        strategy.algorithm();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 2.3 策略模式应用举例\n\n * 题目描述\n   \n   > 某软件公司为某电影院开发了一套影院售票系统，在该系统中需要为不同类型的用户提供不同的电影票打折方式，具体打折方案如下：* (1) 学生凭学生证可享受票价8折优惠。 (2) 年龄在10周岁及以下的儿童可享受每张票减免10元的优惠（原始票价需大于等于20元）。 (3) 影院vip用户除享受票价半价优惠外还可进行积分，积分累计到一定额度可换取电影院赠送的奖品。 该系统在将来可能还要根据需要引入新的打折方式。现使用策略模式设计该影院售票系统的打折方案。\n\n * uml类图\n   \n   其中，movieticket充当环境类角色，discount充当抽象策略角色，studentdiscount、childrendiscount和vipdiscount充当具体策略角色。\n\n * 代码\n   \n   代码地址",charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"设计模式之模板方法模式详解（Java实现）",frontmatter:{title:"设计模式之模板方法模式详解（Java实现）",date:"2022-05-01T09:44:58.000Z",tags:["模板方法模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/2aa461/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89.html",relativePath:"01.开发/02.开发框架/03.设计模式/14.设计模式之模板方法模式详解（Java实现）.md",key:"v-ab6c5552",path:"/pages/2aa461/",headers:[{level:2,title:"1 模板方法模式介绍",slug:"_1-模板方法模式介绍",normalizedTitle:"1 模板方法模式介绍",charIndex:2},{level:2,title:"2 模板方法模式详解",slug:"_2-模板方法模式详解",normalizedTitle:"2 模板方法模式详解",charIndex:912},{level:3,title:"2.1 模板方法模式结构",slug:"_2-1-模板方法模式结构",normalizedTitle:"2.1 模板方法模式结构",charIndex:927},{level:3,title:"2.2 模板方法模式实现",slug:"_2-2-模板方法模式实现",normalizedTitle:"2.2 模板方法模式实现",charIndex:1319},{level:3,title:"2.3 模板方法模式应用举例",slug:"_2-3-模板方法模式应用举例",normalizedTitle:"2.3 模板方法模式应用举例",charIndex:2870}],headersStr:"1 模板方法模式介绍 2 模板方法模式详解 2.1 模板方法模式结构 2.2 模板方法模式实现 2.3 模板方法模式应用举例",content:"# 1 模板方法模式介绍\n\n在软件开发中，某个方法的实现需要多个步骤，其中有些步骤是固定的，而有些步骤并不固定，存在可变性。为了提高代码的复用性和系统的灵活性，可以使用一种称为模板方法模式（Template Method Pattern）的设计模式来对这类情况进行设计。在模板方法模式中将实现功能的每一个步骤所对应的方法称为基本方法，而将调用这些基本方法同时定义基本方法的执行次序的方法称为模板方法。\n\n模板方法模式定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。它是结构最简单的行为型设计模式，在其结构中只存在父类与子类的继承关系。\n\n模板方法模式将一些复杂流程的实现步骤封装在一系列基本方法中，在抽象父类中提供一个称之为模板方法的方法来定义这些基本方法的执行次序，而通过其子类来覆盖某些步骤，从而使得相同的算法框架可以有不同的执行结果。\n\n> 主要解决： 一些方法通用，却在每一个子类都重新写了这一方法。\n> \n> 何时使用： 有一些通用的方法。\n> \n> 如何解决： 将这些通用算法抽象出来。\n> \n> 关键代码： 在抽象类实现，其他步骤在子类实现。\n> \n> 应用实例： 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。\n> \n> 优点： 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。\n> \n> 缺点： 每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。\n> \n> 使用场景： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。\n> \n> 注意事项： 为防止恶意操作，一般模板方法都加上 final 关键词。\n\n\n# 2 模板方法模式详解\n\n\n# 2.1 模板方法模式结构\n\n模板方法模式的结构比较简单，其核心是抽象类和其中的模板方法设计，其结构图如下：\n\n\n\n由上图可知，模板方法模式包含以下两个角色。\n\n 1. AbstractClass（抽象类）：在抽象类中定义了一系列基本操作（Primitive Operations），这些基本操作可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤。同时在抽象类中实现了一个模板方法（Template Method），用于定义一个算法的框架，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法。\n 2. ConcreteClass（具体子类）：它是抽象类的子类，用于实现在父类中声明的抽象基本操作以及完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体基本操作。\n\n\n# 2.2 模板方法模式实现\n\n在实现模板方法模式时，开发抽象类的软件设计师和开发具体子类的软件设计师之间可以进行协作。\n\n * 模板方法\n   \n   一个模板方法就是将定义在抽象类中的把基本操作方法组合在一起形成一个总算法或一个总行为的方法。这个模板方法定义在抽象类中，并由子类不加修改地完全继承下来。由于模板方法是具体方法，因此模板方法模式中的抽象层只能是抽象类，而不是接口。\n\n * 基本方法\n   \n   基本方法是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为3种，即抽象方法（Abstract Method）、具体方法（Concrete Method）和钩子方法（Hook Method）。\n   \n   * 抽象方法：一个抽象方法由抽象类声明、由其具体子类实现。\n   * 具体方法：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。\n   * 钩子方法：一个钩子方法由一个抽象类或具体类声明并实现，而其子类可能会加以扩展。通常在父类中给出的实现是一个空实现，并以该空实现作为方法的默认实现。当然，钩子方法也可以提供一个非空的默认实现。\n   \n   抽象类的典型代码如下：\n   \n   public abstract class AbstractClass {\n       //模板方法\n       public void templateMethod() {\n           primitiveOperation1();\n           primitiveOperation2();\n           primitiveOperation3();\n   }\n   \n       //基本方法—具体方法\n       public void primitiveOperation1() {\n           //实现代码\n       }\n   \n       //基本方法—抽象方法\n       public abstract void primitiveOperation2();    \n   \n       //基本方法—钩子方法\n       public void primitiveOperation3()   \n       {  }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n   \n   具体子类的典型代码如下：\n   \n   public class ConcreteClass extends AbstractClass {\n       public void primitiveOperation2() {\n           //实现代码\n       }\n   \n       public void primitiveOperation3() {\n           //实现代码\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n\n# 2.3 模板方法模式应用举例\n\n * 题目描述\n   \n   > 某软件公司要为某银行的业务支撑系统开发一个利息计算模块，利息的计算流程如下： (1) 系统根据账号和密码验证用户信息，如果用户信息错误，则系统显示出错提示。 (2) 如果用户信息正确，则根据用户类型的不同使用不同的利息计算公式计算利息（如活期账户和定期账户具有不同的利息计算公式）。 (3) 系统显示利息。 现使用模板方法模式设计该利息计算模块。\n\n * UML类图\n   \n   \n   \n   其中，Account充当抽象类角色，CurrentAccount和SavingAccount充当具体子类角色。\n\n * 代码\n   \n   代码地址",normalizedContent:"# 1 模板方法模式介绍\n\n在软件开发中，某个方法的实现需要多个步骤，其中有些步骤是固定的，而有些步骤并不固定，存在可变性。为了提高代码的复用性和系统的灵活性，可以使用一种称为模板方法模式（template method pattern）的设计模式来对这类情况进行设计。在模板方法模式中将实现功能的每一个步骤所对应的方法称为基本方法，而将调用这些基本方法同时定义基本方法的执行次序的方法称为模板方法。\n\n模板方法模式定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。它是结构最简单的行为型设计模式，在其结构中只存在父类与子类的继承关系。\n\n模板方法模式将一些复杂流程的实现步骤封装在一系列基本方法中，在抽象父类中提供一个称之为模板方法的方法来定义这些基本方法的执行次序，而通过其子类来覆盖某些步骤，从而使得相同的算法框架可以有不同的执行结果。\n\n> 主要解决： 一些方法通用，却在每一个子类都重新写了这一方法。\n> \n> 何时使用： 有一些通用的方法。\n> \n> 如何解决： 将这些通用算法抽象出来。\n> \n> 关键代码： 在抽象类实现，其他步骤在子类实现。\n> \n> 应用实例： 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 session、关闭 session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。\n> \n> 优点： 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。\n> \n> 缺点： 每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。\n> \n> 使用场景： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。\n> \n> 注意事项： 为防止恶意操作，一般模板方法都加上 final 关键词。\n\n\n# 2 模板方法模式详解\n\n\n# 2.1 模板方法模式结构\n\n模板方法模式的结构比较简单，其核心是抽象类和其中的模板方法设计，其结构图如下：\n\n\n\n由上图可知，模板方法模式包含以下两个角色。\n\n 1. abstractclass（抽象类）：在抽象类中定义了一系列基本操作（primitive operations），这些基本操作可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤。同时在抽象类中实现了一个模板方法（template method），用于定义一个算法的框架，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法。\n 2. concreteclass（具体子类）：它是抽象类的子类，用于实现在父类中声明的抽象基本操作以及完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体基本操作。\n\n\n# 2.2 模板方法模式实现\n\n在实现模板方法模式时，开发抽象类的软件设计师和开发具体子类的软件设计师之间可以进行协作。\n\n * 模板方法\n   \n   一个模板方法就是将定义在抽象类中的把基本操作方法组合在一起形成一个总算法或一个总行为的方法。这个模板方法定义在抽象类中，并由子类不加修改地完全继承下来。由于模板方法是具体方法，因此模板方法模式中的抽象层只能是抽象类，而不是接口。\n\n * 基本方法\n   \n   基本方法是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为3种，即抽象方法（abstract method）、具体方法（concrete method）和钩子方法（hook method）。\n   \n   * 抽象方法：一个抽象方法由抽象类声明、由其具体子类实现。\n   * 具体方法：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。\n   * 钩子方法：一个钩子方法由一个抽象类或具体类声明并实现，而其子类可能会加以扩展。通常在父类中给出的实现是一个空实现，并以该空实现作为方法的默认实现。当然，钩子方法也可以提供一个非空的默认实现。\n   \n   抽象类的典型代码如下：\n   \n   public abstract class abstractclass {\n       //模板方法\n       public void templatemethod() {\n           primitiveoperation1();\n           primitiveoperation2();\n           primitiveoperation3();\n   }\n   \n       //基本方法—具体方法\n       public void primitiveoperation1() {\n           //实现代码\n       }\n   \n       //基本方法—抽象方法\n       public abstract void primitiveoperation2();    \n   \n       //基本方法—钩子方法\n       public void primitiveoperation3()   \n       {  }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n   \n   具体子类的典型代码如下：\n   \n   public class concreteclass extends abstractclass {\n       public void primitiveoperation2() {\n           //实现代码\n       }\n   \n       public void primitiveoperation3() {\n           //实现代码\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n\n# 2.3 模板方法模式应用举例\n\n * 题目描述\n   \n   > 某软件公司要为某银行的业务支撑系统开发一个利息计算模块，利息的计算流程如下： (1) 系统根据账号和密码验证用户信息，如果用户信息错误，则系统显示出错提示。 (2) 如果用户信息正确，则根据用户类型的不同使用不同的利息计算公式计算利息（如活期账户和定期账户具有不同的利息计算公式）。 (3) 系统显示利息。 现使用模板方法模式设计该利息计算模块。\n\n * uml类图\n   \n   \n   \n   其中，account充当抽象类角色，currentaccount和savingaccount充当具体子类角色。\n\n * 代码\n   \n   代码地址",charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"更多",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"06.更多",imgUrl:"/img/other.png"}},title:"更多",permalink:"/more/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T16:11:05.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/06.%E6%9B%B4%E5%A4%9A.html",relativePath:"00.目录页/06.更多.md",key:"v-45eaf67a",path:"/more/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:39:24",lastUpdatedTimestamp:1700822364e3},{title:"二分查找的奇技淫巧",frontmatter:{title:"二分查找的奇技淫巧",date:"2020-01-21T16:15:34.000Z",tags:["二分查找"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/71fd4b/",categories:["开发","数据结构与算法","查找算法"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/03.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/03.%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/01.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html",relativePath:"01.开发/03.数据结构与算法/03.查找算法/01.二分查找.md",key:"v-1f62b379",path:"/pages/71fd4b/",headers:[{level:2,title:"1 二分搜索升天词",slug:"_1-二分搜索升天词",normalizedTitle:"1 二分搜索升天词",charIndex:2},{level:2,title:"2 手写二分查找模板",slug:"_2-手写二分查找模板",normalizedTitle:"2 手写二分查找模板",charIndex:33},{level:3,title:"2.1 版本1",slug:"_2-1-版本1",normalizedTitle:"2.1 版本1",charIndex:140},{level:3,title:"2.2 版本2",slug:"_2-2-版本2",normalizedTitle:"2.2 版本2",charIndex:630},{level:2,title:"3 利用C++自带的lowerbound和upperbound函数",slug:"_3-利用c-自带的lower-bound和upper-bound函数",normalizedTitle:"3 利用c++自带的lowerbound和upperbound函数",charIndex:null},{level:3,title:"3.1 自带函数源码",slug:"_3-1-自带函数源码",normalizedTitle:"3.1 自带函数源码",charIndex:1195},{level:3,title:"3.2 进阶—自定义比较规则",slug:"_3-2-进阶-自定义比较规则",normalizedTitle:"3.2 进阶—自定义比较规则",charIndex:2584}],headersStr:"1 二分搜索升天词 2 手写二分查找模板 2.1 版本1 2.2 版本2 3 利用C++自带的lowerbound和upperbound函数 3.1 自带函数源码 3.2 进阶—自定义比较规则",content:'# 1 二分搜索升天词\n\n转自：labuladong\n\n\n\n\n# 2 手写二分查找模板\n\n二分模板一共有两个，分别适用于不同情况。 算法思路：假设目标值在闭区间[l,r][l, r][l,r]中， 每次将区间长度缩小一半，当l=rl = rl=r时，我们就找到了目标值。\n\n\n# 2.1 版本1\n\n当我们将区间[l,r][l, r][l,r]划分成[l,mid][l, mid][l,mid]和[mid+1,r][mid + 1, r][mid+1,r]时，其更新操作是r=midr = midr=mid或者l=mid+1l = mid + 1l=mid+1;，计算midmidmid时不需要加111。\n\nbool check(int x) {\n    ...\n    ...\n}\nint binary_search_1(int l, int r) {\n    while (l < r) {\n        int mid = (l + r) >> 1;\n        if (check(mid)) {\n            r = mid;\n        } else {\n            l = mid + 1;\n        }\n    }\n    return l;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2.2 版本2\n\n当我们将区间[l,r][l, r][l,r]划分成[l,mid−1][l, mid-1][l,mid−1]和[mid,r][mid, r][mid,r]时，其更新操作是r=mid−1r = mid - 1r=mid−1或者l=midl = midl=mid;，此时为了防止死循环，计算midmidmid时需要加111。\n\nbool check(int x) {\n    ...\n    ...\n}\nint binary_search_2(int l, int r) {\n    while (l < r) {\n        int mid = (l + r + 1) >> 1;\n        if (check(mid)) { // check为判断函数，我们自己手写的规则\n            l = mid;\n        } else {\n            r = mid - 1;\n        }\n    }\n    return l;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 3 利用C++自带的lower_bound和upper_bound函数\n\n\n# 3.1 自带函数源码\n\nlower_bound：返回一个迭代器，迭代器指向[first, last)不小于val的第一个元素。如果范围内的所有元素比较小于val，则函数返回last。\n\ntemplate <class ForwardIterator, class T>\nForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T& val)\n{\n  ForwardIterator it;\n  iterator_traits<ForwardIterator>::difference_type count, step;\n  count = distance(first,last);\n  while (count>0)\n  {\n    it = first; step=count/2; advance (it,step);\n    if (*it<val) {                 // or: if (comp(*it,val)), for version (2)\n      first=++it;\n      count-=step+1;\n    }\n    else count=step;\n  }\n  return first;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nupper_bound：返回一个迭代器，迭代器指向[first, last)大于val的第一个元素。如果范围内的所有元素比较都不大于val，则函数返回last。\n\ntemplate <class ForwardIterator, class T>\nForwardIterator upper_bound (ForwardIterator first, ForwardIterator last, const T& val)\n{\n  ForwardIterator it;\n  iterator_traits<ForwardIterator>::difference_type count, step;\n  count = std::distance(first,last);\n  while (count>0)\n  {\n    it = first; step=count/2; std::advance (it,step);\n    if (!(val<*it))                 // or: if (!comp(val,*it)), for version (2)\n      { first=++it; count-=step+1;  }\n    else count=step;\n  }\n  return first;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n根据源码，我们很容易就可以使用它们，不用自己手写了，但如果需要自定义比较规则，实际上就是需要我们实现一个check函数即可。\n\n\n# 3.2 进阶—自定义比较规则\n\n在 C++ 中有很多情况下，我们需要自定义比较器，无非就是三种情况：\n\n 1. 对一个自定义的 struct 重写它的 operator < 方法\n 2. 定义一个``Comparator`函数\n 3. 定义一个Comparator结构体对象\n\n * 自定义结构体\n   \n   如果我们自定义了一个struct，然后想要对其排序又不想额外写一个比较器，那么最好实现它的 operaotr < 方法。\n   \n   struct node{\n       string s;\n       node(string s) {\n           this->s = s;\n       }\n       bool operator < (const node &a) const { // 注意这两个const，必须要加上，否则会报错，前者const是能接收非const和const的实参，后者const是表明该函数不会修改类成员变量。\n           return this->s.size() < a.s.size();\n       }\n   };\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   这样，我们就可以使用了。如下：\n   \n   vector<node> v(10, node("111"));\n   int pos = lower_bound(v.begin(), v.end(), node("111")) - v.begin();\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n * 函数比较器\n   \n   可以通过编写一个外部的比较器函数，实现 < 功能。\n   \n   struct node{\n       string s;\n       node(string s) {\n           this->s = s;\n       }\n   };\n   bool cmp(const string &s1, const string &s2) {\n       return s1.size() < s2.size();\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   这个通常用于自定义排序，其他的会报错，应该是不支持函数比较器，读者可自行尝试。\n   \n   vector<string> v(10, "111");\n   sort(v.begin(), v.end(), cmp);\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n * 函数对象比较器\n   \n   所谓函数对象是指实现了 operator () 的类或者结构体。可以用这样的一个对象来代替函数作为比较器。\n   \n   struct cmper {\n       bool operator() (const string &s1, const string &s2) const {\n           return s1.size() < s2.size();\n       }\n   };\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   这个通常用于自定义排序，其他的会报错，应该是不支持函数比较器，读者可自行尝试。\n   \n   vector<string> v(10, "111");\n   sort(v.begin(), v.end(), cmper());\n   \n   \n   1\n   2\n   \n   1\n   2\n   ',normalizedContent:'# 1 二分搜索升天词\n\n转自：labuladong\n\n\n\n\n# 2 手写二分查找模板\n\n二分模板一共有两个，分别适用于不同情况。 算法思路：假设目标值在闭区间[l,r][l, r][l,r]中， 每次将区间长度缩小一半，当l=rl = rl=r时，我们就找到了目标值。\n\n\n# 2.1 版本1\n\n当我们将区间[l,r][l, r][l,r]划分成[l,mid][l, mid][l,mid]和[mid+1,r][mid + 1, r][mid+1,r]时，其更新操作是r=midr = midr=mid或者l=mid+1l = mid + 1l=mid+1;，计算midmidmid时不需要加111。\n\nbool check(int x) {\n    ...\n    ...\n}\nint binary_search_1(int l, int r) {\n    while (l < r) {\n        int mid = (l + r) >> 1;\n        if (check(mid)) {\n            r = mid;\n        } else {\n            l = mid + 1;\n        }\n    }\n    return l;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2.2 版本2\n\n当我们将区间[l,r][l, r][l,r]划分成[l,mid−1][l, mid-1][l,mid−1]和[mid,r][mid, r][mid,r]时，其更新操作是r=mid−1r = mid - 1r=mid−1或者l=midl = midl=mid;，此时为了防止死循环，计算midmidmid时需要加111。\n\nbool check(int x) {\n    ...\n    ...\n}\nint binary_search_2(int l, int r) {\n    while (l < r) {\n        int mid = (l + r + 1) >> 1;\n        if (check(mid)) { // check为判断函数，我们自己手写的规则\n            l = mid;\n        } else {\n            r = mid - 1;\n        }\n    }\n    return l;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 3 利用c++自带的lower_bound和upper_bound函数\n\n\n# 3.1 自带函数源码\n\nlower_bound：返回一个迭代器，迭代器指向[first, last)不小于val的第一个元素。如果范围内的所有元素比较小于val，则函数返回last。\n\ntemplate <class forwarditerator, class t>\nforwarditerator lower_bound (forwarditerator first, forwarditerator last, const t& val)\n{\n  forwarditerator it;\n  iterator_traits<forwarditerator>::difference_type count, step;\n  count = distance(first,last);\n  while (count>0)\n  {\n    it = first; step=count/2; advance (it,step);\n    if (*it<val) {                 // or: if (comp(*it,val)), for version (2)\n      first=++it;\n      count-=step+1;\n    }\n    else count=step;\n  }\n  return first;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nupper_bound：返回一个迭代器，迭代器指向[first, last)大于val的第一个元素。如果范围内的所有元素比较都不大于val，则函数返回last。\n\ntemplate <class forwarditerator, class t>\nforwarditerator upper_bound (forwarditerator first, forwarditerator last, const t& val)\n{\n  forwarditerator it;\n  iterator_traits<forwarditerator>::difference_type count, step;\n  count = std::distance(first,last);\n  while (count>0)\n  {\n    it = first; step=count/2; std::advance (it,step);\n    if (!(val<*it))                 // or: if (!comp(val,*it)), for version (2)\n      { first=++it; count-=step+1;  }\n    else count=step;\n  }\n  return first;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n根据源码，我们很容易就可以使用它们，不用自己手写了，但如果需要自定义比较规则，实际上就是需要我们实现一个check函数即可。\n\n\n# 3.2 进阶—自定义比较规则\n\n在 c++ 中有很多情况下，我们需要自定义比较器，无非就是三种情况：\n\n 1. 对一个自定义的 struct 重写它的 operator < 方法\n 2. 定义一个``comparator`函数\n 3. 定义一个comparator结构体对象\n\n * 自定义结构体\n   \n   如果我们自定义了一个struct，然后想要对其排序又不想额外写一个比较器，那么最好实现它的 operaotr < 方法。\n   \n   struct node{\n       string s;\n       node(string s) {\n           this->s = s;\n       }\n       bool operator < (const node &a) const { // 注意这两个const，必须要加上，否则会报错，前者const是能接收非const和const的实参，后者const是表明该函数不会修改类成员变量。\n           return this->s.size() < a.s.size();\n       }\n   };\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   这样，我们就可以使用了。如下：\n   \n   vector<node> v(10, node("111"));\n   int pos = lower_bound(v.begin(), v.end(), node("111")) - v.begin();\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n * 函数比较器\n   \n   可以通过编写一个外部的比较器函数，实现 < 功能。\n   \n   struct node{\n       string s;\n       node(string s) {\n           this->s = s;\n       }\n   };\n   bool cmp(const string &s1, const string &s2) {\n       return s1.size() < s2.size();\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   这个通常用于自定义排序，其他的会报错，应该是不支持函数比较器，读者可自行尝试。\n   \n   vector<string> v(10, "111");\n   sort(v.begin(), v.end(), cmp);\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n * 函数对象比较器\n   \n   所谓函数对象是指实现了 operator () 的类或者结构体。可以用这样的一个对象来代替函数作为比较器。\n   \n   struct cmper {\n       bool operator() (const string &s1, const string &s2) const {\n           return s1.size() < s2.size();\n       }\n   };\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   这个通常用于自定义排序，其他的会报错，应该是不支持函数比较器，读者可自行尝试。\n   \n   vector<string> v(10, "111");\n   sort(v.begin(), v.end(), cmper());\n   \n   \n   1\n   2\n   \n   1\n   2\n   ',charsets:{cjk:!0},lastUpdated:"2023/11/25, 16:14:12",lastUpdatedTimestamp:1700900052e3},{title:"数位DP学习整理",frontmatter:{title:"数位DP学习整理",date:"2021-05-12T18:20:58.000Z",tags:["数位DP"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/243023/",categories:["开发","数据结构与算法","动态规划"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/03.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/07.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/01.%E6%95%B0%E4%BD%8DDP.html",relativePath:"01.开发/03.数据结构与算法/07.动态规划/01.数位DP.md",key:"v-66f28a6e",path:"/pages/243023/",headers:[{level:2,title:"1 数位DP介绍",slug:"_1-数位dp介绍",normalizedTitle:"1 数位dp介绍",charIndex:2},{level:2,title:"2 数位DP解法",slug:"_2-数位dp解法",normalizedTitle:"2 数位dp解法",charIndex:256},{level:2,title:"3 数位DP经典例题",slug:"_3-数位dp经典例题",normalizedTitle:"3 数位dp经典例题",charIndex:725},{level:3,title:"3.1 度的数量",slug:"_3-1-度的数量",normalizedTitle:"3.1 度的数量",charIndex:740},{level:3,title:"3.2 计数问题",slug:"_3-2-计数问题",normalizedTitle:"3.2 计数问题",charIndex:3886},{level:3,title:"3.3 数字游戏",slug:"_3-3-数字游戏",normalizedTitle:"3.3 数字游戏",charIndex:8248},{level:3,title:"3.4 windy数",slug:"_3-4-windy数",normalizedTitle:"3.4 windy数",charIndex:10401},{level:3,title:"3.5 数字游戏Ⅱ",slug:"_3-5-数字游戏ii",normalizedTitle:"3.5 数字游戏ⅱ",charIndex:13174},{level:3,title:"3.6 不要62",slug:"_3-6-不要62",normalizedTitle:"3.6 不要62",charIndex:15419},{level:3,title:"3.7 恨7不成妻",slug:"_3-7-恨7不成妻",normalizedTitle:"3.7 恨7不成妻",charIndex:17758},{level:2,title:"4 数位DP总结",slug:"_4-数位dp总结",normalizedTitle:"4 数位dp总结",charIndex:17800}],headersStr:"1 数位DP介绍 2 数位DP解法 3 数位DP经典例题 3.1 度的数量 3.2 计数问题 3.3 数字游戏 3.4 windy数 3.5 数字游戏Ⅱ 3.6 不要62 3.7 恨7不成妻 4 数位DP总结",content:'# 1 数位DP介绍\n\n数位DP往往都是这样的题型，给定一个闭区间[l,r][l,r][l,r]，让你求这个区间中满足某种条件的数的总数。而这个区间可能很大，简单的暴力代码如下：\n\nint ans=0;\nfor(int i=l;i<=r;i++){\n    if(check(i))ans++;\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n我们发现，若区间长度超过1e81e81e8，我们暴力枚举就会超时了，而数位DPDPDP则可以解决这样的题型。数位DPDPDP实际上就是在数位上进行DPDPDP。\n\n\n# 2 数位DP解法\n\n数位DPDPDP就是换一种暴力枚举的方式，使得新的枚举方式符合DPDPDP的性质，然后预处理好即可。我们来看：我们可以用f(n)f(n)f(n)表示[0,n][0,n][0,n]的所有满足条件的个数，那么对于[l,r][l,r][l,r]我们就可以用[l,r]  ⟺  f(r)−f(l−1)[l,r]\\iff f(r)-f(l-1)[l,r]⟺f(r)−f(l−1)，相当于前缀和思想。那么也就是说我们只要求出f(n)f(n)f(n)即可。那么数位DPDPDP关键的思想就是从树的角度来考虑。将数拆分成位，从高位到低位开始枚举。我们可以视NNN为nnn位数，那么我们拆分N:an、an−1...a1N:a_{n}、a_{n-1}...a_1N:an 、an−1 ...a1 。那么我们就可以开始分解建树，如下。之后我们就可以预处理再求解f(n)f(n)f(n)了，个人认为求解f(n)f(n)f(n)是最难的一步。\n\n\n\n听完是不是有点绕，我们可以来点题目练习一下，做完就会发现了数位DPDPDP的套路了。\n\n\n# 3 数位DP经典例题\n\n\n# 3.1 度的数量\n\n * 题面\n   \n   > 求给定区间$ [X,Y]$ 中满足下列条件的整数个数：这个数恰好等于 KKK 个互不相等的 BBB 的整数次幂之和。例如，设 X=15,Y=20,K=2,B=2X=15,Y=20,K=2,B=2X=15,Y=20,K=2,B=2，则有且仅有下列三个数满足题意： 17=24+2017=2^4+2^017=24+20 18=24+2118=2^4+2^118=24+21 20=24+2220=2^4+2^220=24+22 输入格式 第一行包含两个整数 X 和 Y，接下来两行包含整数 KKK 和 BBB。 输出格式 只包含一个整数，表示满足条件的数的个数。 数据范围 1≤X≤Y≤231−1,1≤X≤Y≤2^{31}−1,1≤X≤Y≤231−1, 1≤K≤20,1≤K≤20,1≤K≤20, 2≤B≤102≤B≤102≤B≤10 输入样例： 15 20 2 2 输出样例： 3\n\n * 解题思路\n   \n   此题实际上就是将十进制数转化为BBB进制数，判断位数上的值是否为111。那么我们可以视NNN为nnn位数，那么我们拆分N:an、an−1...a1N:a_{n}、a_{n-1}...a_1N:an 、an−1 ...a1 。从树的角度考虑：我们设N=76543210,B=10N=76543210,B=10N=76543210,B=10，那么我们从高位往最低位开始枚举如下；枚举ana_nan 时，我们有两种选择：\n   \n   1. 走右边分支，那么我们填7(an)7(a_n)7(an )，而题目要求每一位只能填111或者000,而an>1a_n>1an >1，所以不是合法方案，我们直接剔除。\n   2. 走左边分支，那么我们可以填000~666，即0−an−10-{a_n}-10−an −1，那么由于每一位只能填111或者000，所以我们累加这两种选择的方案。\n   \n   记住，走到了左边分支是可以直接累加的。\n   \n   所以我们实际上还是要做一个预处理的，我们用f[i][j]f[i][j]f[i][j]表示还剩下iii位没有填，且需要填写jjj个111的方案数。那么在(i,j)(i,j)(i,j)这个状态，我们可以选择填111，那么接下来的状态就是f[i−1][j−1]f[i-1][j-1]f[i−1][j−1]，而如果填000，那么接下来的状态就是f[i−1][j]f[i-1][j]f[i−1][j]，那么状态转移方程就是f[i][j]=f[i−1][j]+f[i][j−1]f[i][j]=f[i-1][j]+f[i][j-1]f[i][j]=f[i−1][j]+f[i][j−1]。而初始状态即是当j=0j=0j=0时，f[i][0]=1f[i][0]=1f[i][0]=1。这样我们就可以预处理fff数组了。\n   \n   处理完之后我们就可以直接模拟做了。\n\n * 代码\n\n/**\n  *@filename:度的数量\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 11:23\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 100000 + 5;\nconst int mod = 1e9+7;\n\nint l,r,k,b;\nint f[35][35];\n//首先我们先预处理f数组。其中f[i][j]表示剩下还有i个没填，需要填写j个1的方案数。\nvoid init(){\n    for(int i=0;i<35;i++){\n        for(int j=0;j<=i;j++){\n            if(!j)f[i][j]=1;\n            else{\n                f[i][j]=f[i-1][j]+f[i-1][j-1];\n            }\n        }\n    }\n}\nint dp(int n){\n    //求解f(n)。我们需要避免n为0的情况，这里需要特判。\n    if(!n)return 0;\n    vector<int> nums;//将n分割，存储位数。\n    while(n){\n        nums.push_back(n%b);\n        n/=b;\n    }\n    int ans=0;//答案。\n    int last=0;//前面的信息，这里代表的是前面分支选取了多少个1.\n    for(int i=nums.size()-1;i>=0;i--){\n        int x=nums[i];\n        if(x){\n            //说明x>0，我们可以选择左边分支填0.\n            ans+=f[i][k-last];\n            if(x>1){\n                //当x>1我们才可以枚举左边分支填1.\n                if(k-last-1>=0){\n                    //如果还可以填1的话。\n                    ans+=f[i][k-last-1];\n                }\n                break;//因为右边分支只能为0或1，所以不符合条件。break。\n            }\n            else{\n                //当x=1就可以进入右边的分支继续讨论。\n                last++;\n                if(last>k)break;\n            }\n        }\n        //考虑到最后一位，如果符合条件那么末位填0也算一种方案。\n        if(!i&&last==k)ans++;\n    }\n    return ans;\n}\nvoid solve(){\n}\nint main(){\n    cin>>l>>r>>k>>b;\n    init();\n    cout<<dp(r)-dp(l-1)<<endl;\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n\n# 3.2 计数问题\n\n * 题面\n   \n   > 给定两个整数 a 和 b，求 a 和 b 之间的所有数字中 0∼90∼9 的出现次数。\n   > \n   > 例如，a=1024，b=1032a=1024，b=1032a=1024，b=1032，则 a 和 b 之间共有 99 个数如下：\n   > \n   > 1024 1025 1026 1027 1028 1029 1030 1031 1032\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 其中 0 出现 10次，1 出现 10 次，2 出现 7 次，3 出现 3 次等等…\n   > \n   > 输入格式\n   > \n   > 输入包含多组测试数据。\n   > \n   > 每组测试数据占一行，包含两个整数 a 和 b。\n   > \n   > 当读入一行为 0 0 时，表示输入终止，且该行不作处理。\n   > \n   > 输出格式\n   > \n   > 每组数据输出一个结果，每个结果占一行。\n   > \n   > 每个结果包含十个用空格隔开的数字，第一个数字表示 0 出现的次数，第二个数字表示 1 出现的次数，以此类推。\n   > \n   > 数据范围\n   > \n   > 0<a,b<1000000000<a,b<1000000000<a,b<1000000000<a,b<1000000000<a,b<1000000000<a,b<100000000\n   > \n   > 输入样例：\n   > \n   > 1 10\n   > 44 497\n   > 346 542\n   > 1199 1748\n   > 1496 1403\n   > 1004 503\n   > 1714 190\n   > 1317 854\n   > 1976 494\n   > 1001 1960\n   > 0 0\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > \n   > \n   > 输出样例：\n   > \n   > 1 2 1 1 1 1 1 1 1 1\n   > 85 185 185 185 190 96 96 96 95 93\n   > 40 40 40 93 136 82 40 40 40 40\n   > 115 666 215 215 214 205 205 154 105 106\n   > 16 113 19 20 114 20 20 19 19 16\n   > 107 105 100 101 101 197 200 200 200 200\n   > 413 1133 503 503 503 502 502 417 402 412\n   > 196 512 186 104 87 93 97 97 142 196\n   > 398 1375 398 398 405 499 499 495 488 471\n   > 294 1256 296 296 296 296 287 286 286 247\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n\n * 解题思路\n   \n   \n   \n   我们需要预处理fff数组，那么我们可以用f[i,j,u]f[i,j,u]f[i,j,u]表示iii位，最高位为jjj的数拥有uuu的个数。那么如果jjj不等于uuu时，则f[i][j][u]+=f[i−1][k][u],0≤k≤9f[i][j][u]+=f[i-1][k][u],0\\leq k \\leq 9f[i][j][u]+=f[i−1][k][u],0≤k≤9。这个应该不难理解，因为这个状态就是由之前的状态得到的。 而当jjj等于uuu时，那么同样也可以由之前的999个状态得到。为f[i][j][u]+=f[i−1][k][u],0≤k≤9f[i][j][u]+=f[i-1][k][u],0\\leq k \\leq 9f[i][j][u]+=f[i−1][k][u],0≤k≤9。记住，我们是还没有计算最高位的uuu个数的，因为最高位本身就为uuu，也是一种可能，所以我们需要加上。那么总共有10i−110^{i-1}10i−1多的数，所以增加的u的数量为10i−110^{i-1}10i−1。初始状态就是f[1][i][i]=1f[1][i][i]=1f[1][i][i]=1，到这，我们的fff数组就初始化完了，那么接下来。就是拆位分支的数位DPDPDP套路讨论了，这里不在叙述，代码附详细注释。\n\n * 代码\n\n/**\n  *@filename:计数问题\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 13:12\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 100000 + 5;\nconst int mod = 1e9+7;\n\nint l,r;\nint f[11][10][10];//预处理f数组。其中f[i][j][u]表示i位最高位为j的数拥有u的个数。\nvoid init(){\n    for(int i=0;i<10;i++)f[1][i][i]=1;\n    for(int i=2;i<11;i++){\n        for(int j=0;j<10;j++){\n            for(int u=0;u<10;u++){\n                //判断j是否等于u。\n                if(j==u)f[i][j][u]+=pow(10,i-1);\n                for(int k=0;k<10;k++){\n                    f[i][j][u]+=f[i-1][k][u];\n                }\n            }\n        }\n    }\n}\nll dp(int n,int u){\n    //1~n,求x的出现次数。\n    if(!n)return u?0:1;//特判n是否为0.根据u的值确定返回值。\n    vector<int> nums;//存储分割后的位数。\n    while(n)nums.push_back(n%10),n/=10;\n    int last=0;//last记录前面u出现的次数。\n    ll ans=0;//答案。\n    for(int i=nums.size()-1;i>=0;i--){\n        int x=nums[i];\n        //左边分支，0~x。\n        for(int j=(i==nums.size()-1);j<x;j++){\n            //由于此题不能有前导0.\n            ans+=f[i+1][j][u];//注意这里i需要+1，因为我们i下标从0开始。而位数从1开始。\n        }\n        //走左边分支，那么我们需要加上前面的个数。注意这里需要乘上x，因为左边分支有x中选择。\n        ans+=x*last*pow(10,i);\n        if(x==u)last++;//记录last。\n        if(!i)ans+=last;//加上这个数本身含有的。\n    }\n    //由于我们前面都是枚举n位数的，我们还需要统计所有0~n-1位数的方案数量。\n    //例如000011是不合法的，但11是合法的。\n    //这一步确实很容易忽略，没办法，数位DP就是这么难。\n    for(int i=1;i<nums.size();i++){\n        for(int j=(i!=1);j<=9;j++){\n            ans+=f[i][j][u];\n        }\n    }\n    return ans;\n}\nvoid solve(){\n}\nint main(){\n    init();\n    while(cin>>l>>r&&(l||r)){\n        if(l>r)swap(l,r);\n        for(int i=0;i<=9;i++){\n            cout<<dp(r,i)-dp(l-1,i);\n            i==9?cout<<endl:cout<<" ";\n        }\n    }\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n\n# 3.3 数字游戏\n\n * 题面\n   \n   > 科协里最近很流行数字游戏。\n   > \n   > 某人命名了一种不降数，这种数字必须满足从左到右各位数字呈非下降关系，如 123，446。\n   > \n   > 现在大家决定玩一个游戏，指定一个整数闭区间 [a,b]，问这个区间内有多少个不降数。\n   > \n   > 输入格式 输入包含多组测试数据。\n   > \n   > 每组数据占一行，包含两个整数 a 和 b。\n   > \n   > 输出格式 每行给出一组测试数据的答案，即 [a,b] 之间有多少不降数。\n   > \n   > 数据范围 1≤a≤b≤231−11≤ a ≤ b ≤2^{31}−11≤a≤b≤231−1\n   > \n   > 样例输入 1 9 1 19 样例输出 9 18\n\n * 解题思路\n   \n   同样的套路， 先预处理fff数组，我们用f[i][j]f[i][j]f[i][j]表示iii位数，且最高位为jjj的不降数方案数。那么我们来列写一下状态转移方程，对于f[i][j]f[i][j]f[i][j]，要满足不降数的要求，则f[i−1][k]f[i-1][k]f[i−1][k]，kkk需满足j≤k≤9j \\leq k \\leq 9j≤k≤9，那么自然f[i][j]=∑k=j9f[i−1][k]f[i][j]=\\sum_{k=j}^9 f[i-1][k]f[i][j]=∑k=j9 f[i−1][k]。而初始状态自然是f[1][j]=1f[1][j]=1f[1][j]=1。预处理完之后，我们就好做了，直接按数位DPDPDP的思想处理即可。代码附详细注释。\n\n * 代码\n\n/**\n  *@filename:数字游戏\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 14:57\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 100000 + 5;\nconst int mod = 1e9+7;\n\nint l,r;\nint f[11][11];//预处理f数组。其中f[i][j]表示i位数，且最高位为j的不降数方案数。\nvoid init(){\n    for(int i=1;i<10;i++)f[1][i]=1;\n    for(int i=2;i<11;i++){\n        for(int j=0;j<10;j++){\n            for(int k=j;k<10;k++){\n                f[i][j]+=f[i-1][k];\n            }\n        }\n    }\n}\nint dp(int n){\n    //1~n，这里我们需要特判n=0。\n    if(!n)return 0;\n    vector<int> nums;//存储分割位数。\n    while(n)nums.push_back(n%10),n/=10;\n    int last=0;//last存储上一位的最大值。\n    int ans=0;//答案。\n    for(int i=nums.size()-1;i>=0;i--){\n        int x=nums[i];\n        //走左边的分支。因为要保持不降序，所以我们j>=last。\n        for(int j=last;j<x;j++){\n            ans+=f[i+1][j];//注意是i+1位。\n        }\n        if(last>x)break;//说明上一位比x大，不能构成降序了，直接退出。\n        last=x;//走右分支了，更新last。\n        if(!i)ans++;//全部枚举完了，自身也同样构成了一种方案。\n    }\n    return ans;\n}\nint main(){\n    init();\n    while(cin>>l>>r){\n        cout<<dp(r)-dp(l-1)<<endl;\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n# 3.4 windy数\n\n * 题面\n   \n   > windy 定义了一种 windy 数。\n   > \n   > 不含前导零且相邻两个数字之差至少为 2 的正整数被称为 windy 数。windy 想知道，在 a 和 b 之间，包括 a 和 b ，总共有多少个 windy 数？\n   > \n   > 输入格式\n   > \n   > 输入只有一行两个整数，分别表示 a 和 b。\n   > \n   > 输出格式\n   > \n   > 输出一行一个整数表示答案。\n   > \n   > 输入输出样例\n   > \n   > 输入 #1\n   > \n   > 1 10\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 输出 #1\n   > \n   > 9\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 输入 #2\n   > \n   > 25 50\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 输出 #2\n   > \n   > 20\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 说明/提示\n   > \n   > 数据规模与约定\n   > \n   > 对于全部的测试点，保证 1≤a≤b≤2×1091 \\leq a \\leq b \\leq 2 \\times 10^91≤a≤b≤2×109。\n\n * 解题思路\n   \n   同样，我们先进行预处理fff数组，其中f[i][j]f[i][j]f[i][j]表示iii位，其中最高位为jjj的方案数。那么根据题意，状态转移方程即为f[i][j]=∑f[i−1][k]f[i][j]=\\sum_{}f[i-1][k]f[i][j]=∑ f[i−1][k]，其中0≤k≤9 and abs(k−j)>=20 \\leq k \\leq 9 \\space and \\space abs(k-j)>=20≤k≤9 and abs(k−j)>=2。而初始状态即为dp[1][i]=1dp[1][i]=1dp[1][i]=1。预处理完之后就好处理了，这里不再提供思路，请大家自己画出树结构并完成此题。\n\n * 代码\n\n/**\n  *@filename:windy数\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 15:43\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 100000 + 5;\nconst int mod = 1e9+7;\n\nint l,r;\nint f[11][10];//f数组。其中f[i][j]表示i位，其中最高位为j的方案数。\nvoid init(){\n    for(int i=0;i<10;i++)f[1][i]=1;\n    for(int i=2;i<11;i++){\n        for(int j=0;j<10;j++){\n            for(int k=0;k<10;k++){\n                if(abs(k-j)>=2){\n                    f[i][j]+=f[i-1][k];\n                }\n            }\n        }\n    }\n}\nint dp(int n){\n    if(!n){\n        //特判n为0的情况，避免对之后操作造成影响。\n        return 0;\n    }\n    vector<int> nums;//存储分割位数。\n    int last=-2;//存储上一位的值。这里初值为-2,是因为我们需要确定1可以。\n    int ans=0;//答案。\n    while(n)nums.push_back(n%10),n/=10;\n    for(int i=nums.size()-1;i>=0;i--){\n        int x=nums[i];\n        //左分支。\n        for(int j=(i==nums.size()-1);j<x;j++){\n            if(abs(j-last)>=2){\n                //说明符合要求。\n                ans+=f[i+1][j];\n            }\n        }\n        if(abs(x-last)<2)break;//不满足要去。\n        last=x;\n        if(!i)ans++;//枚举到最后一位，自身也形成了一种方案。\n    }\n    //特殊枚举有前导0的数。\n    for(int i=1;i<nums.size();i++){\n        for(int j=1;j<=9;j++){\n            ans+=f[i][j];\n        }\n    }\n    return ans;\n}\nvoid solve(){\n}\nint main(){\n    init();\n    cin>>l>>r;\n    cout<<dp(r)-dp(l-1)<<endl;\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n\n# 3.5 数字游戏Ⅱ\n\n * 题面\n   \n   > 由于科协里最近真的很流行数字游戏。\n   > \n   > 某人又命名了一种取模数，这种数字必须满足各位数字之和modNmodNmodN为 0。\n   > \n   > 现在大家又要玩游戏了，指定一个整数闭区间 [a.b]，问这个区间内有多少个取模数。\n   > \n   > 数据范围 1≤a,b≤231−11≤a,b≤2^{31}−11≤a,b≤231−1, 1≤N<1001≤N<1001≤N<100 样例 输入 1 19 9\n   > \n   > 输出 2\n\n * 解题思路\n   \n   虽然这道题看起来很复杂，但是本质还是还是数位DP的套路，只不过现在性质是满足各位数字之和modNmod NmodN为0。那么此题实际上困难点在于预处理，我们发现预处理这其实就是一个dpdpdp，我们用闫式DPDPDP分析法分析如下：\n   \n   我们得到这个fff数组有什么用呢？我们发现，如果我现在已知前面的位数相加为lastlastlast，在左分支处，由于后面的数可以随便枚举，所以我们利用这个性质直接累加f[i+1][j][mod(−last,p)]f[i+1][j][mod(-last,p)]f[i+1][j][mod(−last,p)]即可得到种类数。故此按照数位DPDPDP步骤易解。\n\n * 代码\n\n/**\n  *@filename:数字游戏Ⅱ\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 18:23\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 100000 + 5;\n\nint l,r,p;\nint f[12][12][110];//f[i][j][k]表示i位数，最高位是j，其模n的余数是k的方案数。\n//预处理也是一个dp过程。\nint mod(int x,int y){\n    //由于c++中的%负数会得到负数，所以我们需要做一个偏移。\n    return (x%y+y)%y;\n}\nvoid init(){\n    memset(f,0,sizeof(f));\n    //预处理f数组。\n    for(int i=0;i<10;i++)f[1][i][i%p]++;\n    for(int i=2;i<12;i++){\n        for(int j=0;j<10;j++){\n            for(int k=0;k<p;k++){\n                for(int x=0;x<10;x++){\n                    f[i][j][k]+=f[i-1][x][mod(k-j,p)];\n                }\n            }\n        }\n    }\n}\nint dp(int n){\n    if(!n)return 1;\n    vector<int> a;//存储切出来的位数。\n    while(n)a.push_back(n%10),n/=10;\n    int last=0;//last存储前面数字之和。\n    int ans=0;\n    for(int i=a.size()-1;i>=0;i--){\n        int x=a[i];\n        for(int j=0;j<x;j++){\n            //走左边分支。为了凑成模n余0，则接下来的所有位数相加+last模n为0，所以我们来个-last即可。\n            ans+=f[i+1][j][mod(-last,p)];\n        }\n        last+=x;\n        if(!i&&last%p==0)ans++;//判断本身是否符合条件。\n    }\n    return ans;\n}\nvoid solve(){\n}\nint main(){\n    while(cin>>l>>r>>p){\n        init();\n        cout<<dp(r)-dp(l-1)<<endl;\n    }\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# 3.6 不要62\n\n * 题面\n   \n   > 杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。 杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。 不吉利的数字为所有含有4或62的号码。例如： 62315 73418 88914 都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。 你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。\n   > \n   > Input\n   > \n   > 输入的都是整数对n、m（0<n≤m<1000000），如果遇到都是0的整数对，则输入结束。\n   > \n   > Output\n   > \n   > 对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。\n   > \n   > Sample Input\n   > \n   > 1 100\n   > 0 0\n   > \n   > \n   > 1\n   > 2\n   > \n   > 1\n   > 2\n   > \n   > \n   > Sample Output\n   > \n   > 80\n   > \n   > \n   > 1\n   > \n   > 1\n\n * 解题思路\n   \n   这道题相对来说比较简单，因为预处理这一部分我们很容易想到。用f[i][j]f[i][j]f[i][j]表示iii位数字且最高位为jjj的方案数。那么我们排除掉特殊情况进行状态转移即可。代码附详细注释。\n\n * 代码\n\n/**\n  *@filename:不要62\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 19:56\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 100000 + 5;\nconst int mod = 1e9+7;\n\nint l,r;\nint f[11][11];//f[i][j]表示i位数且最高位为j的方案数。\n//那么我们来对这个进行分析，对于f[i][j]这个状态，我们根据题意我们转移的f[i-1][k]必须满足k!=4,j!=4.\n//并且jk!=62.\nvoid init(){\n    for(int i=0;i<10;i++)f[1][i]=1;\n    //排除4的情况。\n    f[1][4]=0;\n    for(int i=2;i<11;i++){\n        for(int j=0;j<10;j++){\n            if(j==4)continue;\n            for(int k=0;k<10;k++){\n                if((j==6&&k==2)||k==4)continue;\n                f[i][j]+=f[i-1][k];\n            }\n        }\n    }\n}\nint dp(int n){\n    if(!n)return 1;\n    vector<int> a;//存储分割位数。\n    int ans=0,last=0;//last保存上一位的值。\n    while(n)a.push_back(n%10),n/=10;\n    for(int i=a.size()-1;i>=0;i--){\n        int x=a[i];\n        for(int j=0;j<x;j++){\n            //走左边分支，我们需要判断。\n            if(j==4||(j==2&&last==6))continue;\n            ans+=f[i+1][j];\n        }\n        if(x==4||(last==6&&x==2))break;\n        last=x;\n        if(!i)ans++;\n    }\n    return ans;\n}\nvoid solve(){\n}\nint main(){\n    init();\n    while(cin>>l>>r&&(l||r)){\n        cout<<dp(r)-dp(l-1)<<endl;\n        solve();\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n# 3.7 恨7不成妻\n\n由于此题太过变态，已单开一篇blog讲解： 点这里。\n\n\n# 4 数位DP总结\n\n做了这么多的题，我们发现数位DPDPDP确实是有套路的，难点就在于预处理，通常就是要用DPDPDP来预处理，这里推荐大家学一下闫式DPDPDP分析法。预处理完之后，就可以套路做题了。当然，学DPDPDP一定要多刷题，所以请各位一定要多多刷题哦！',normalizedContent:'# 1 数位dp介绍\n\n数位dp往往都是这样的题型，给定一个闭区间[l,r][l,r][l,r]，让你求这个区间中满足某种条件的数的总数。而这个区间可能很大，简单的暴力代码如下：\n\nint ans=0;\nfor(int i=l;i<=r;i++){\n    if(check(i))ans++;\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n我们发现，若区间长度超过1e81e81e8，我们暴力枚举就会超时了，而数位dpdpdp则可以解决这样的题型。数位dpdpdp实际上就是在数位上进行dpdpdp。\n\n\n# 2 数位dp解法\n\n数位dpdpdp就是换一种暴力枚举的方式，使得新的枚举方式符合dpdpdp的性质，然后预处理好即可。我们来看：我们可以用f(n)f(n)f(n)表示[0,n][0,n][0,n]的所有满足条件的个数，那么对于[l,r][l,r][l,r]我们就可以用[l,r]  ⟺  f(r)−f(l−1)[l,r]\\iff f(r)-f(l-1)[l,r]⟺f(r)−f(l−1)，相当于前缀和思想。那么也就是说我们只要求出f(n)f(n)f(n)即可。那么数位dpdpdp关键的思想就是从树的角度来考虑。将数拆分成位，从高位到低位开始枚举。我们可以视nnn为nnn位数，那么我们拆分n:an、an−1...a1n:a_{n}、a_{n-1}...a_1n:an 、an−1 ...a1 。那么我们就可以开始分解建树，如下。之后我们就可以预处理再求解f(n)f(n)f(n)了，个人认为求解f(n)f(n)f(n)是最难的一步。\n\n\n\n听完是不是有点绕，我们可以来点题目练习一下，做完就会发现了数位dpdpdp的套路了。\n\n\n# 3 数位dp经典例题\n\n\n# 3.1 度的数量\n\n * 题面\n   \n   > 求给定区间$ [x,y]$ 中满足下列条件的整数个数：这个数恰好等于 kkk 个互不相等的 bbb 的整数次幂之和。例如，设 x=15,y=20,k=2,b=2x=15,y=20,k=2,b=2x=15,y=20,k=2,b=2，则有且仅有下列三个数满足题意： 17=24+2017=2^4+2^017=24+20 18=24+2118=2^4+2^118=24+21 20=24+2220=2^4+2^220=24+22 输入格式 第一行包含两个整数 x 和 y，接下来两行包含整数 kkk 和 bbb。 输出格式 只包含一个整数，表示满足条件的数的个数。 数据范围 1≤x≤y≤231−1,1≤x≤y≤2^{31}−1,1≤x≤y≤231−1, 1≤k≤20,1≤k≤20,1≤k≤20, 2≤b≤102≤b≤102≤b≤10 输入样例： 15 20 2 2 输出样例： 3\n\n * 解题思路\n   \n   此题实际上就是将十进制数转化为bbb进制数，判断位数上的值是否为111。那么我们可以视nnn为nnn位数，那么我们拆分n:an、an−1...a1n:a_{n}、a_{n-1}...a_1n:an 、an−1 ...a1 。从树的角度考虑：我们设n=76543210,b=10n=76543210,b=10n=76543210,b=10，那么我们从高位往最低位开始枚举如下；枚举ana_nan 时，我们有两种选择：\n   \n   1. 走右边分支，那么我们填7(an)7(a_n)7(an )，而题目要求每一位只能填111或者000,而an>1a_n>1an >1，所以不是合法方案，我们直接剔除。\n   2. 走左边分支，那么我们可以填000~666，即0−an−10-{a_n}-10−an −1，那么由于每一位只能填111或者000，所以我们累加这两种选择的方案。\n   \n   记住，走到了左边分支是可以直接累加的。\n   \n   所以我们实际上还是要做一个预处理的，我们用f[i][j]f[i][j]f[i][j]表示还剩下iii位没有填，且需要填写jjj个111的方案数。那么在(i,j)(i,j)(i,j)这个状态，我们可以选择填111，那么接下来的状态就是f[i−1][j−1]f[i-1][j-1]f[i−1][j−1]，而如果填000，那么接下来的状态就是f[i−1][j]f[i-1][j]f[i−1][j]，那么状态转移方程就是f[i][j]=f[i−1][j]+f[i][j−1]f[i][j]=f[i-1][j]+f[i][j-1]f[i][j]=f[i−1][j]+f[i][j−1]。而初始状态即是当j=0j=0j=0时，f[i][0]=1f[i][0]=1f[i][0]=1。这样我们就可以预处理fff数组了。\n   \n   处理完之后我们就可以直接模拟做了。\n\n * 代码\n\n/**\n  *@filename:度的数量\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 11:23\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 100000 + 5;\nconst int mod = 1e9+7;\n\nint l,r,k,b;\nint f[35][35];\n//首先我们先预处理f数组。其中f[i][j]表示剩下还有i个没填，需要填写j个1的方案数。\nvoid init(){\n    for(int i=0;i<35;i++){\n        for(int j=0;j<=i;j++){\n            if(!j)f[i][j]=1;\n            else{\n                f[i][j]=f[i-1][j]+f[i-1][j-1];\n            }\n        }\n    }\n}\nint dp(int n){\n    //求解f(n)。我们需要避免n为0的情况，这里需要特判。\n    if(!n)return 0;\n    vector<int> nums;//将n分割，存储位数。\n    while(n){\n        nums.push_back(n%b);\n        n/=b;\n    }\n    int ans=0;//答案。\n    int last=0;//前面的信息，这里代表的是前面分支选取了多少个1.\n    for(int i=nums.size()-1;i>=0;i--){\n        int x=nums[i];\n        if(x){\n            //说明x>0，我们可以选择左边分支填0.\n            ans+=f[i][k-last];\n            if(x>1){\n                //当x>1我们才可以枚举左边分支填1.\n                if(k-last-1>=0){\n                    //如果还可以填1的话。\n                    ans+=f[i][k-last-1];\n                }\n                break;//因为右边分支只能为0或1，所以不符合条件。break。\n            }\n            else{\n                //当x=1就可以进入右边的分支继续讨论。\n                last++;\n                if(last>k)break;\n            }\n        }\n        //考虑到最后一位，如果符合条件那么末位填0也算一种方案。\n        if(!i&&last==k)ans++;\n    }\n    return ans;\n}\nvoid solve(){\n}\nint main(){\n    cin>>l>>r>>k>>b;\n    init();\n    cout<<dp(r)-dp(l-1)<<endl;\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n\n# 3.2 计数问题\n\n * 题面\n   \n   > 给定两个整数 a 和 b，求 a 和 b 之间的所有数字中 0∼90∼9 的出现次数。\n   > \n   > 例如，a=1024，b=1032a=1024，b=1032a=1024，b=1032，则 a 和 b 之间共有 99 个数如下：\n   > \n   > 1024 1025 1026 1027 1028 1029 1030 1031 1032\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 其中 0 出现 10次，1 出现 10 次，2 出现 7 次，3 出现 3 次等等…\n   > \n   > 输入格式\n   > \n   > 输入包含多组测试数据。\n   > \n   > 每组测试数据占一行，包含两个整数 a 和 b。\n   > \n   > 当读入一行为 0 0 时，表示输入终止，且该行不作处理。\n   > \n   > 输出格式\n   > \n   > 每组数据输出一个结果，每个结果占一行。\n   > \n   > 每个结果包含十个用空格隔开的数字，第一个数字表示 0 出现的次数，第二个数字表示 1 出现的次数，以此类推。\n   > \n   > 数据范围\n   > \n   > 0<a,b<1000000000<a,b<1000000000<a,b<1000000000<a,b<1000000000<a,b<1000000000<a,b<100000000\n   > \n   > 输入样例：\n   > \n   > 1 10\n   > 44 497\n   > 346 542\n   > 1199 1748\n   > 1496 1403\n   > 1004 503\n   > 1714 190\n   > 1317 854\n   > 1976 494\n   > 1001 1960\n   > 0 0\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > \n   > \n   > 输出样例：\n   > \n   > 1 2 1 1 1 1 1 1 1 1\n   > 85 185 185 185 190 96 96 96 95 93\n   > 40 40 40 93 136 82 40 40 40 40\n   > 115 666 215 215 214 205 205 154 105 106\n   > 16 113 19 20 114 20 20 19 19 16\n   > 107 105 100 101 101 197 200 200 200 200\n   > 413 1133 503 503 503 502 502 417 402 412\n   > 196 512 186 104 87 93 97 97 142 196\n   > 398 1375 398 398 405 499 499 495 488 471\n   > 294 1256 296 296 296 296 287 286 286 247\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n\n * 解题思路\n   \n   \n   \n   我们需要预处理fff数组，那么我们可以用f[i,j,u]f[i,j,u]f[i,j,u]表示iii位，最高位为jjj的数拥有uuu的个数。那么如果jjj不等于uuu时，则f[i][j][u]+=f[i−1][k][u],0≤k≤9f[i][j][u]+=f[i-1][k][u],0\\leq k \\leq 9f[i][j][u]+=f[i−1][k][u],0≤k≤9。这个应该不难理解，因为这个状态就是由之前的状态得到的。 而当jjj等于uuu时，那么同样也可以由之前的999个状态得到。为f[i][j][u]+=f[i−1][k][u],0≤k≤9f[i][j][u]+=f[i-1][k][u],0\\leq k \\leq 9f[i][j][u]+=f[i−1][k][u],0≤k≤9。记住，我们是还没有计算最高位的uuu个数的，因为最高位本身就为uuu，也是一种可能，所以我们需要加上。那么总共有10i−110^{i-1}10i−1多的数，所以增加的u的数量为10i−110^{i-1}10i−1。初始状态就是f[1][i][i]=1f[1][i][i]=1f[1][i][i]=1，到这，我们的fff数组就初始化完了，那么接下来。就是拆位分支的数位dpdpdp套路讨论了，这里不在叙述，代码附详细注释。\n\n * 代码\n\n/**\n  *@filename:计数问题\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 13:12\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 100000 + 5;\nconst int mod = 1e9+7;\n\nint l,r;\nint f[11][10][10];//预处理f数组。其中f[i][j][u]表示i位最高位为j的数拥有u的个数。\nvoid init(){\n    for(int i=0;i<10;i++)f[1][i][i]=1;\n    for(int i=2;i<11;i++){\n        for(int j=0;j<10;j++){\n            for(int u=0;u<10;u++){\n                //判断j是否等于u。\n                if(j==u)f[i][j][u]+=pow(10,i-1);\n                for(int k=0;k<10;k++){\n                    f[i][j][u]+=f[i-1][k][u];\n                }\n            }\n        }\n    }\n}\nll dp(int n,int u){\n    //1~n,求x的出现次数。\n    if(!n)return u?0:1;//特判n是否为0.根据u的值确定返回值。\n    vector<int> nums;//存储分割后的位数。\n    while(n)nums.push_back(n%10),n/=10;\n    int last=0;//last记录前面u出现的次数。\n    ll ans=0;//答案。\n    for(int i=nums.size()-1;i>=0;i--){\n        int x=nums[i];\n        //左边分支，0~x。\n        for(int j=(i==nums.size()-1);j<x;j++){\n            //由于此题不能有前导0.\n            ans+=f[i+1][j][u];//注意这里i需要+1，因为我们i下标从0开始。而位数从1开始。\n        }\n        //走左边分支，那么我们需要加上前面的个数。注意这里需要乘上x，因为左边分支有x中选择。\n        ans+=x*last*pow(10,i);\n        if(x==u)last++;//记录last。\n        if(!i)ans+=last;//加上这个数本身含有的。\n    }\n    //由于我们前面都是枚举n位数的，我们还需要统计所有0~n-1位数的方案数量。\n    //例如000011是不合法的，但11是合法的。\n    //这一步确实很容易忽略，没办法，数位dp就是这么难。\n    for(int i=1;i<nums.size();i++){\n        for(int j=(i!=1);j<=9;j++){\n            ans+=f[i][j][u];\n        }\n    }\n    return ans;\n}\nvoid solve(){\n}\nint main(){\n    init();\n    while(cin>>l>>r&&(l||r)){\n        if(l>r)swap(l,r);\n        for(int i=0;i<=9;i++){\n            cout<<dp(r,i)-dp(l-1,i);\n            i==9?cout<<endl:cout<<" ";\n        }\n    }\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n\n# 3.3 数字游戏\n\n * 题面\n   \n   > 科协里最近很流行数字游戏。\n   > \n   > 某人命名了一种不降数，这种数字必须满足从左到右各位数字呈非下降关系，如 123，446。\n   > \n   > 现在大家决定玩一个游戏，指定一个整数闭区间 [a,b]，问这个区间内有多少个不降数。\n   > \n   > 输入格式 输入包含多组测试数据。\n   > \n   > 每组数据占一行，包含两个整数 a 和 b。\n   > \n   > 输出格式 每行给出一组测试数据的答案，即 [a,b] 之间有多少不降数。\n   > \n   > 数据范围 1≤a≤b≤231−11≤ a ≤ b ≤2^{31}−11≤a≤b≤231−1\n   > \n   > 样例输入 1 9 1 19 样例输出 9 18\n\n * 解题思路\n   \n   同样的套路， 先预处理fff数组，我们用f[i][j]f[i][j]f[i][j]表示iii位数，且最高位为jjj的不降数方案数。那么我们来列写一下状态转移方程，对于f[i][j]f[i][j]f[i][j]，要满足不降数的要求，则f[i−1][k]f[i-1][k]f[i−1][k]，kkk需满足j≤k≤9j \\leq k \\leq 9j≤k≤9，那么自然f[i][j]=∑k=j9f[i−1][k]f[i][j]=\\sum_{k=j}^9 f[i-1][k]f[i][j]=∑k=j9 f[i−1][k]。而初始状态自然是f[1][j]=1f[1][j]=1f[1][j]=1。预处理完之后，我们就好做了，直接按数位dpdpdp的思想处理即可。代码附详细注释。\n\n * 代码\n\n/**\n  *@filename:数字游戏\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 14:57\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 100000 + 5;\nconst int mod = 1e9+7;\n\nint l,r;\nint f[11][11];//预处理f数组。其中f[i][j]表示i位数，且最高位为j的不降数方案数。\nvoid init(){\n    for(int i=1;i<10;i++)f[1][i]=1;\n    for(int i=2;i<11;i++){\n        for(int j=0;j<10;j++){\n            for(int k=j;k<10;k++){\n                f[i][j]+=f[i-1][k];\n            }\n        }\n    }\n}\nint dp(int n){\n    //1~n，这里我们需要特判n=0。\n    if(!n)return 0;\n    vector<int> nums;//存储分割位数。\n    while(n)nums.push_back(n%10),n/=10;\n    int last=0;//last存储上一位的最大值。\n    int ans=0;//答案。\n    for(int i=nums.size()-1;i>=0;i--){\n        int x=nums[i];\n        //走左边的分支。因为要保持不降序，所以我们j>=last。\n        for(int j=last;j<x;j++){\n            ans+=f[i+1][j];//注意是i+1位。\n        }\n        if(last>x)break;//说明上一位比x大，不能构成降序了，直接退出。\n        last=x;//走右分支了，更新last。\n        if(!i)ans++;//全部枚举完了，自身也同样构成了一种方案。\n    }\n    return ans;\n}\nint main(){\n    init();\n    while(cin>>l>>r){\n        cout<<dp(r)-dp(l-1)<<endl;\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n# 3.4 windy数\n\n * 题面\n   \n   > windy 定义了一种 windy 数。\n   > \n   > 不含前导零且相邻两个数字之差至少为 2 的正整数被称为 windy 数。windy 想知道，在 a 和 b 之间，包括 a 和 b ，总共有多少个 windy 数？\n   > \n   > 输入格式\n   > \n   > 输入只有一行两个整数，分别表示 a 和 b。\n   > \n   > 输出格式\n   > \n   > 输出一行一个整数表示答案。\n   > \n   > 输入输出样例\n   > \n   > 输入 #1\n   > \n   > 1 10\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 输出 #1\n   > \n   > 9\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 输入 #2\n   > \n   > 25 50\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 输出 #2\n   > \n   > 20\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 说明/提示\n   > \n   > 数据规模与约定\n   > \n   > 对于全部的测试点，保证 1≤a≤b≤2×1091 \\leq a \\leq b \\leq 2 \\times 10^91≤a≤b≤2×109。\n\n * 解题思路\n   \n   同样，我们先进行预处理fff数组，其中f[i][j]f[i][j]f[i][j]表示iii位，其中最高位为jjj的方案数。那么根据题意，状态转移方程即为f[i][j]=∑f[i−1][k]f[i][j]=\\sum_{}f[i-1][k]f[i][j]=∑ f[i−1][k]，其中0≤k≤9 and abs(k−j)>=20 \\leq k \\leq 9 \\space and \\space abs(k-j)>=20≤k≤9 and abs(k−j)>=2。而初始状态即为dp[1][i]=1dp[1][i]=1dp[1][i]=1。预处理完之后就好处理了，这里不再提供思路，请大家自己画出树结构并完成此题。\n\n * 代码\n\n/**\n  *@filename:windy数\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 15:43\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 100000 + 5;\nconst int mod = 1e9+7;\n\nint l,r;\nint f[11][10];//f数组。其中f[i][j]表示i位，其中最高位为j的方案数。\nvoid init(){\n    for(int i=0;i<10;i++)f[1][i]=1;\n    for(int i=2;i<11;i++){\n        for(int j=0;j<10;j++){\n            for(int k=0;k<10;k++){\n                if(abs(k-j)>=2){\n                    f[i][j]+=f[i-1][k];\n                }\n            }\n        }\n    }\n}\nint dp(int n){\n    if(!n){\n        //特判n为0的情况，避免对之后操作造成影响。\n        return 0;\n    }\n    vector<int> nums;//存储分割位数。\n    int last=-2;//存储上一位的值。这里初值为-2,是因为我们需要确定1可以。\n    int ans=0;//答案。\n    while(n)nums.push_back(n%10),n/=10;\n    for(int i=nums.size()-1;i>=0;i--){\n        int x=nums[i];\n        //左分支。\n        for(int j=(i==nums.size()-1);j<x;j++){\n            if(abs(j-last)>=2){\n                //说明符合要求。\n                ans+=f[i+1][j];\n            }\n        }\n        if(abs(x-last)<2)break;//不满足要去。\n        last=x;\n        if(!i)ans++;//枚举到最后一位，自身也形成了一种方案。\n    }\n    //特殊枚举有前导0的数。\n    for(int i=1;i<nums.size();i++){\n        for(int j=1;j<=9;j++){\n            ans+=f[i][j];\n        }\n    }\n    return ans;\n}\nvoid solve(){\n}\nint main(){\n    init();\n    cin>>l>>r;\n    cout<<dp(r)-dp(l-1)<<endl;\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n\n# 3.5 数字游戏ⅱ\n\n * 题面\n   \n   > 由于科协里最近真的很流行数字游戏。\n   > \n   > 某人又命名了一种取模数，这种数字必须满足各位数字之和modnmodnmodn为 0。\n   > \n   > 现在大家又要玩游戏了，指定一个整数闭区间 [a.b]，问这个区间内有多少个取模数。\n   > \n   > 数据范围 1≤a,b≤231−11≤a,b≤2^{31}−11≤a,b≤231−1, 1≤n<1001≤n<1001≤n<100 样例 输入 1 19 9\n   > \n   > 输出 2\n\n * 解题思路\n   \n   虽然这道题看起来很复杂，但是本质还是还是数位dp的套路，只不过现在性质是满足各位数字之和modnmod nmodn为0。那么此题实际上困难点在于预处理，我们发现预处理这其实就是一个dpdpdp，我们用闫式dpdpdp分析法分析如下：\n   \n   我们得到这个fff数组有什么用呢？我们发现，如果我现在已知前面的位数相加为lastlastlast，在左分支处，由于后面的数可以随便枚举，所以我们利用这个性质直接累加f[i+1][j][mod(−last,p)]f[i+1][j][mod(-last,p)]f[i+1][j][mod(−last,p)]即可得到种类数。故此按照数位dpdpdp步骤易解。\n\n * 代码\n\n/**\n  *@filename:数字游戏ⅱ\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 18:23\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 100000 + 5;\n\nint l,r,p;\nint f[12][12][110];//f[i][j][k]表示i位数，最高位是j，其模n的余数是k的方案数。\n//预处理也是一个dp过程。\nint mod(int x,int y){\n    //由于c++中的%负数会得到负数，所以我们需要做一个偏移。\n    return (x%y+y)%y;\n}\nvoid init(){\n    memset(f,0,sizeof(f));\n    //预处理f数组。\n    for(int i=0;i<10;i++)f[1][i][i%p]++;\n    for(int i=2;i<12;i++){\n        for(int j=0;j<10;j++){\n            for(int k=0;k<p;k++){\n                for(int x=0;x<10;x++){\n                    f[i][j][k]+=f[i-1][x][mod(k-j,p)];\n                }\n            }\n        }\n    }\n}\nint dp(int n){\n    if(!n)return 1;\n    vector<int> a;//存储切出来的位数。\n    while(n)a.push_back(n%10),n/=10;\n    int last=0;//last存储前面数字之和。\n    int ans=0;\n    for(int i=a.size()-1;i>=0;i--){\n        int x=a[i];\n        for(int j=0;j<x;j++){\n            //走左边分支。为了凑成模n余0，则接下来的所有位数相加+last模n为0，所以我们来个-last即可。\n            ans+=f[i+1][j][mod(-last,p)];\n        }\n        last+=x;\n        if(!i&&last%p==0)ans++;//判断本身是否符合条件。\n    }\n    return ans;\n}\nvoid solve(){\n}\nint main(){\n    while(cin>>l>>r>>p){\n        init();\n        cout<<dp(r)-dp(l-1)<<endl;\n    }\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# 3.6 不要62\n\n * 题面\n   \n   > 杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。 杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。 不吉利的数字为所有含有4或62的号码。例如： 62315 73418 88914 都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。 你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。\n   > \n   > input\n   > \n   > 输入的都是整数对n、m（0<n≤m<1000000），如果遇到都是0的整数对，则输入结束。\n   > \n   > output\n   > \n   > 对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。\n   > \n   > sample input\n   > \n   > 1 100\n   > 0 0\n   > \n   > \n   > 1\n   > 2\n   > \n   > 1\n   > 2\n   > \n   > \n   > sample output\n   > \n   > 80\n   > \n   > \n   > 1\n   > \n   > 1\n\n * 解题思路\n   \n   这道题相对来说比较简单，因为预处理这一部分我们很容易想到。用f[i][j]f[i][j]f[i][j]表示iii位数字且最高位为jjj的方案数。那么我们排除掉特殊情况进行状态转移即可。代码附详细注释。\n\n * 代码\n\n/**\n  *@filename:不要62\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 19:56\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 100000 + 5;\nconst int mod = 1e9+7;\n\nint l,r;\nint f[11][11];//f[i][j]表示i位数且最高位为j的方案数。\n//那么我们来对这个进行分析，对于f[i][j]这个状态，我们根据题意我们转移的f[i-1][k]必须满足k!=4,j!=4.\n//并且jk!=62.\nvoid init(){\n    for(int i=0;i<10;i++)f[1][i]=1;\n    //排除4的情况。\n    f[1][4]=0;\n    for(int i=2;i<11;i++){\n        for(int j=0;j<10;j++){\n            if(j==4)continue;\n            for(int k=0;k<10;k++){\n                if((j==6&&k==2)||k==4)continue;\n                f[i][j]+=f[i-1][k];\n            }\n        }\n    }\n}\nint dp(int n){\n    if(!n)return 1;\n    vector<int> a;//存储分割位数。\n    int ans=0,last=0;//last保存上一位的值。\n    while(n)a.push_back(n%10),n/=10;\n    for(int i=a.size()-1;i>=0;i--){\n        int x=a[i];\n        for(int j=0;j<x;j++){\n            //走左边分支，我们需要判断。\n            if(j==4||(j==2&&last==6))continue;\n            ans+=f[i+1][j];\n        }\n        if(x==4||(last==6&&x==2))break;\n        last=x;\n        if(!i)ans++;\n    }\n    return ans;\n}\nvoid solve(){\n}\nint main(){\n    init();\n    while(cin>>l>>r&&(l||r)){\n        cout<<dp(r)-dp(l-1)<<endl;\n        solve();\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n# 3.7 恨7不成妻\n\n由于此题太过变态，已单开一篇blog讲解： 点这里。\n\n\n# 4 数位dp总结\n\n做了这么多的题，我们发现数位dpdpdp确实是有套路的，难点就在于预处理，通常就是要用dpdpdp来预处理，这里推荐大家学一下闫式dpdpdp分析法。预处理完之后，就可以套路做题了。当然，学dpdpdp一定要多刷题，所以请各位一定要多多刷题哦！',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"线段树入门",frontmatter:{title:"线段树入门",date:"2020-08-07T12:17:56.000Z",tags:["线段树"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/088910/",categories:["开发","数据结构与算法","数据结构"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/03.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/06.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8.html",relativePath:"01.开发/03.数据结构与算法/06.数据结构/01.线段树入门.md",key:"v-39ec134c",path:"/pages/088910/",headers:[{level:2,title:"1 什么是线段树？",slug:"_1-什么是线段树",normalizedTitle:"1 什么是线段树？",charIndex:244},{level:2,title:"2 线段树的基本内容",slug:"_2-线段树的基本内容",normalizedTitle:"2 线段树的基本内容",charIndex:1927},{level:2,title:"3 线段树的基本操作",slug:"_3-线段树的基本操作",normalizedTitle:"3 线段树的基本操作",charIndex:3400},{level:3,title:"3.1 点更新",slug:"_3-1-点更新",normalizedTitle:"3.1 点更新",charIndex:3440},{level:3,title:"3.2 区间查询",slug:"_3-2-区间查询",normalizedTitle:"3.2 区间查询",charIndex:3931}],headersStr:"1 什么是线段树？ 2 线段树的基本内容 3 线段树的基本操作 3.1 点更新 3.2 区间查询",content:'前言：理解线段树着实花了我很多时间，主要之前一直有个误区，就是对线段树中存储的信息，我认为只能是区间和，可万万没想到呀，它还可以是别的东西：区间最小值、区间最大值等等呀，我表示👤(已黑化)，好了，言归正传，博主是完全理解了线段树之后才有勇气写这篇文章的，所以我是根据一个完全初学者到理解线段树的过程来写下这篇文章的，不会像其他文章一下难以理解，当然，本文也只是我学习整理的，如果有错误的话，还请评论区留言或私信我，共同进步。\n\n线段树讲解共有两篇，这一篇为入门，另一篇为进阶。\n\n\n# 1 什么是线段树？\n\n * 线段树的基本概念\n   \n   在深入学习线段树之前，我们首先要了解线段树是什么？线段树本质也是一颗二叉搜索树，也被认为是区间树（即每个结点都有一段区间，我们也认为是线段）。那有小伙伴可能就要问了，什么是二叉搜索树？二叉搜索树顾名思义：前提是一颗二叉树，它的每个结点度都小于等于2，即每个结点最多有两个子树。其次就是搜索，这是关键，我们这个线段树在其中都有一个区间，那么搜索即是可以在这个区间上搜索你想要的值，这就是搜索，其中，每个结点存储的信息是由你来定的，如果你想求区间和，那么就可以存储区间和，如果你想求区间最大值，那么你可以存储区间最大值，只要可行，你都可以进行你想要的操作。\n   \n   ----------------------------------------\n\n * 线段树的注意事项\n   \n   1. 在给定了大小给定了叶子结点数目的时候这个线段树就已经确定了，我们不能进行添加和删除元素，不是说不能对已有叶子结点赋值，是不能对其进行扩大或者减小。因为在大多数情况中，对于线段树来说，区间本身都是固定的，不考虑新增和删除元素。所以用数组存储的话，直接用静态数组就好了，不用动态数组。\n   \n   2. 线段树的大小一定要开叶子结点数目（即原有点对点的数据数组大小）的四倍。例如叶子结点数目是maxn，那么我们通常会开线段树的大小为maxn<<2。因为线段树也是一颗完全二叉树，当最大的时候可能是满二叉树。我们来证明一下，我们这样想：最深一层的数目是n，则此线段树的高度为⌈\\lceil⌈log⁡2n⌉\\log_2n\\rceillog2 n⌉,我们可知⌈\\lceil⌈log⁡2n⌉\\log_2n\\rceillog2 n⌉ ≤\\leq≤ log2n+1log_2n+1log2 n+1。那么我们通过然后通过等比数列求和公式（a1(1−qx)1−q\\frac{a_1(1-q^x)}{1-q}1−qa1 (1−qx) ）求得二叉树的节点个数，具体公式为1∗(1−2x)1−2\\frac{1*(1-2^x)}{1-2}1−21∗(1−2x) ，（xxx为树的层数，为树的高度+1+1+1），化简可得2log2n+1+1−12^{log_2n+1+1}-12log2 n+1+1−1,整理之后即为4n4n4n（近似计算忽略掉-1)\n   \n   3. 我们进行乘除法运算的时候要使用位运算（<< >>一定要仔细理解这两个运算符），而避免使用基本的数学运算，因为我们会频繁使用结点坐标更新，用位运算会更快一点，而且还可以防WR。\n   \n   4. 在表示坐标的时候，若一个结点下标为i，那么它的父节点就是i>>1。如果这个结点是这个父节点的左孩子，那么右孩子下标就是i+1。如果这个结点是父节点的右孩子，那么左孩子的下标就是i-1。那个这个结点的左孩子下标就是i<<1，右孩子下标就是(i<<1)=1（==这里一定要使用括号改变运算符优先级，因为位运算的优先级属实低。==）\n   \n   5. 要根据你想解决的问题来设置结点的数据信息。区间求和和区间最值所进行的是不太一样的，所更改的信息也都要注意，但都是一个本质，就是从下往上更新，到达根节点就退出。\n   \n   6. 线段树不一定是满二叉树，也就是说线段树的叶子结点不一定是在最后一层。线段树也不一定是完全二叉树（切记！）。但我们可以把线段树看成是满二叉树，对于不存在的结点我们视为空就行。\n\n * 线段树能解决的问题\n   \n   线段树的适用范围很广，可以在线维护修改以及查询区间上的最值，求和。==使用一维线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN)==。线段树更可以扩充到二维线段树（矩阵树）和三维线段树（空间树），这里我们不作讲解。（其实博主也暂时不会😄）\n\n你问我线段树算什么东西？今天我就告诉你，单点、区间朴素查询处理做的我线段树能做！单点、区间朴素查询没有的速度我有！这就是线段树。（战术后仰）\n\n\n# 2 线段树的基本内容\n\n我们先看一颗线段树：\n\n\n\n不然发现线段树的特点，每个结点都有一个值和区间，每个结点的左右孩子都存储了父结点的一半的区间，且它们的序号是按照层次顺序编号的。在日常处理中，我们通常是使用结构体数组来作为线段树的存储结构，因为这样我们就可以利用下标的关系来找到父节点和孩子结点了。例如我们已知一个结点的下标为i，那么：\n\n * 对于父结点：i>>1（这个进行的操作其实就是i/2，前面提到，这样会快很多）\n   \n   具体证明也很简单，把线段树看成一个完全二叉树（空结点也当作使用）对于任意一个结点i来说，它所在此二叉树的log2ilog_2ilog2 i 层，则此层共有2log2(i)2^{log2(i)}2log2(i)个结点，同样对于k的左子树那层来说有2log2k+12^{log_2{k}+1}2log2 k+1个结点，则结点k和左子树间隔了2∗2log2(i)−i+2∗(i−2log2(k))2*2^{log_2(i)}-i + 2*(i-2^{log_2(k)})2∗2log2 (i)−i+2∗(i−2log2 (k))个结点，然后这就很简单就得到k+2∗2log2(k)−k+2∗(k−2log2(k))=2∗kk+2*2^{log_2(k)}-k + 2*(k-2^{log2(k)}) = 2*kk+2∗2log2 (k)−k+2∗(k−2log2(k))=2∗k的关系了吧，右子树也就等于左子树结点+1。\n\n * 对于左孩子结点：左孩子下标：i<<1（这些是同理的，即是由父结点推孩子结点。）\n\n * 对于右孩子结点：右孩子下标：i<<1|1\n\n了解了这些关系，我们是有能力去建立一颗线段树的，因为线段树也是树，所以我们自然可以利用递归的思想去建树，不会很难，我也写全了注释。\n\nconst int maxn = 1e5;//最大值。\nstruct Node{\n    int left;  //左端点\n    int right; //右端点\n    int value;//代表区间[left,right]的信息，可以是区间和，也可以是区间最值。\n}node[maxn<<2];//这里我们要开4倍大小，防止数据溢出\nint father[maxn];//存储原来数据在线段树中的下标，易于从下向上更新区间数据。例如father[i]表示原来的第i个数据在线段树中的下标，这些在线段树中都是叶子结点。\nvoid BuildTree(int i,int l,int r){\n    node[i].left=l;node[i].right=r;//存储各自结点的区间\n    node[i].value=0;                     //初始化为0.\n    if(l==r){                    //说明已经到了叶子结点。\n        father[l]=i;//存储下标。\n        return;\n    }\n    BuildTree(i<<1,l,(l+r)/2); //递归初始化左子树\n    BuildTree((i<<1)+1,(l+r)/2+1,r);//递归初始化右子树。\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n这样，我们的线段树就建好了。我们来看线段树有哪些基本操作吧。\n\n\n# 3 线段树的基本操作\n\n我们这里以结点的值value代表区间和来处理。\n\n\n# 3.1 点更新\n\n这很好办，有没有注意我们是使用了一个father数组，如果我在原数组中修改第i个元素的值，我们是直接可以node[father[i]].value=w，这就是我们使用father数组的好处，那你可能会问了，我们这样是不是要使用三个数组？大可不必，我们没必要给原有数据开一个数组存放，因为我们本身就已经把数据放在线段树中了，不管线段树中存放的是区间和还是区间最值，对于叶子结点来说，它就是本身。那么我们加入了点，自然也要更新整棵树，那有关这个叶子结点到根节点的路径自然全部都是要更新的，我们则是从下往上利用递归思想来更新的。\n\nvoid UpdateTree(int ri){\n    if(ri==1){\n        return;\n    }\n    int fi=ri>>1;//获得父结点下标。\n    node[fi].value=node[fi<<1].value+node[fi<<1|1].value;//两段区间总和。\n    UpdateTree(fi);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 3.2 区间查询\n\n我们有了线段树，可却不对它进行相关查询，那这颗线段树也只是精致的花瓶而已。我们最重要的就是进行区间查询，现在如果我想知道某个区间和的话，我们应该怎样来处理呢？我们知道根节点是存放了整个区间的信息，然后它的孩子结点则存放了它一半区间的信息，这样则显而易见，我们从根节点开始自上往下查询即可。我们本着下面的思想就一目了然了。\n\n1、如果这个区间被完全包括在目标区间里面，直接返回这个区间的值\n\n2、如果这个区间的左儿子和目标区间有交集，那么搜索左儿子\n\n3、如果这个区间的右儿子和目标区间有交集，那么搜索右儿子\n\nOK，整活。\n\n//区间查询，调用函数时为QueryTree(1,l,r)，即从根节点自上往下查询。\nint QueryTree(int i,int l,int r){\n    int sum=0;\n    if(l==node[i].left&&r==node[i].right){\n        //如果刚好就是这个区间，我们直接返回。\n        sum+=node[i].value;\n        return sum;\n    }\n    i=i<<1;\n    if(l<=node[i].right){\n        //说明部分包含左子树\n        if(r<=node[i].right){\n            //说明全包含在左子树。\n            sum+=QueryTree(i,l,r);\n        }\n        else{\n            sum+=QueryTree(i,l,node[i].right);\n        }\n    }\n    i+=1;\n    if(r>=node[i].left){\n        //说明部分包含右子树\n        if(l>=node[i].left){\n            //说明全包含在右子树。\n            sum+=QueryTree(i,l,r);\n        }\n        else{\n            sum+=QueryTree(i,node[i].left,r);\n        }\n    }\n    return sum; //返回求得的区间和。\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n区间查询不断二分，易知时间复杂度为O(log2nlog_2nlog2 n)。\n\n线段树的基本操作就是这些，当然，这只是入门，灵活使用线段树以及更深层次的利用线段树的道路还很长，我们一起加油！\n\n----------------------------------------\n\n主函数部分测试：\n\nint main(){\n    freopen("in.txt", "r", stdin);//提交的时候要注释掉\n    ios::sync_with_stdio(false);//打消iostream中输入输出缓存，节省时间。\n    cin.tie(0); cout.tie(0);//可以通过tie(0)（0表示NULL）来解除cin与cout的绑定，进一步加快执行效率。\n    int n,m,g;\n    while(cin>>n>>m){\n        BuildTree(1,1,n);\n        rep(i,1,n){\n            cin>>g;\n            node[father[i]].value=g;\n            UpdateTree(father[i]);\n        }\n        char ch;\n        int a,b;\n        while(m--){\n            cin>>ch>>a>>b;\n            if(ch==\'Q\'){\n                cout<<QueryTree(1,a,b)<<endl;;\n            }\n            else{\n                node[father[a]].value=b;\n                UpdateTree(father[a]);\n            }\n        }\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n测试数据：\n\n6 5 \n2 3 8 23 1 9\nQ 1 6\nS 2 3\nQ 1 6\nS 3 4\nQ 1 6\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n测试结果：',normalizedContent:'前言：理解线段树着实花了我很多时间，主要之前一直有个误区，就是对线段树中存储的信息，我认为只能是区间和，可万万没想到呀，它还可以是别的东西：区间最小值、区间最大值等等呀，我表示👤(已黑化)，好了，言归正传，博主是完全理解了线段树之后才有勇气写这篇文章的，所以我是根据一个完全初学者到理解线段树的过程来写下这篇文章的，不会像其他文章一下难以理解，当然，本文也只是我学习整理的，如果有错误的话，还请评论区留言或私信我，共同进步。\n\n线段树讲解共有两篇，这一篇为入门，另一篇为进阶。\n\n\n# 1 什么是线段树？\n\n * 线段树的基本概念\n   \n   在深入学习线段树之前，我们首先要了解线段树是什么？线段树本质也是一颗二叉搜索树，也被认为是区间树（即每个结点都有一段区间，我们也认为是线段）。那有小伙伴可能就要问了，什么是二叉搜索树？二叉搜索树顾名思义：前提是一颗二叉树，它的每个结点度都小于等于2，即每个结点最多有两个子树。其次就是搜索，这是关键，我们这个线段树在其中都有一个区间，那么搜索即是可以在这个区间上搜索你想要的值，这就是搜索，其中，每个结点存储的信息是由你来定的，如果你想求区间和，那么就可以存储区间和，如果你想求区间最大值，那么你可以存储区间最大值，只要可行，你都可以进行你想要的操作。\n   \n   ----------------------------------------\n\n * 线段树的注意事项\n   \n   1. 在给定了大小给定了叶子结点数目的时候这个线段树就已经确定了，我们不能进行添加和删除元素，不是说不能对已有叶子结点赋值，是不能对其进行扩大或者减小。因为在大多数情况中，对于线段树来说，区间本身都是固定的，不考虑新增和删除元素。所以用数组存储的话，直接用静态数组就好了，不用动态数组。\n   \n   2. 线段树的大小一定要开叶子结点数目（即原有点对点的数据数组大小）的四倍。例如叶子结点数目是maxn，那么我们通常会开线段树的大小为maxn<<2。因为线段树也是一颗完全二叉树，当最大的时候可能是满二叉树。我们来证明一下，我们这样想：最深一层的数目是n，则此线段树的高度为⌈\\lceil⌈log⁡2n⌉\\log_2n\\rceillog2 n⌉,我们可知⌈\\lceil⌈log⁡2n⌉\\log_2n\\rceillog2 n⌉ ≤\\leq≤ log2n+1log_2n+1log2 n+1。那么我们通过然后通过等比数列求和公式（a1(1−qx)1−q\\frac{a_1(1-q^x)}{1-q}1−qa1 (1−qx) ）求得二叉树的节点个数，具体公式为1∗(1−2x)1−2\\frac{1*(1-2^x)}{1-2}1−21∗(1−2x) ，（xxx为树的层数，为树的高度+1+1+1），化简可得2log2n+1+1−12^{log_2n+1+1}-12log2 n+1+1−1,整理之后即为4n4n4n（近似计算忽略掉-1)\n   \n   3. 我们进行乘除法运算的时候要使用位运算（<< >>一定要仔细理解这两个运算符），而避免使用基本的数学运算，因为我们会频繁使用结点坐标更新，用位运算会更快一点，而且还可以防wr。\n   \n   4. 在表示坐标的时候，若一个结点下标为i，那么它的父节点就是i>>1。如果这个结点是这个父节点的左孩子，那么右孩子下标就是i+1。如果这个结点是父节点的右孩子，那么左孩子的下标就是i-1。那个这个结点的左孩子下标就是i<<1，右孩子下标就是(i<<1)=1（==这里一定要使用括号改变运算符优先级，因为位运算的优先级属实低。==）\n   \n   5. 要根据你想解决的问题来设置结点的数据信息。区间求和和区间最值所进行的是不太一样的，所更改的信息也都要注意，但都是一个本质，就是从下往上更新，到达根节点就退出。\n   \n   6. 线段树不一定是满二叉树，也就是说线段树的叶子结点不一定是在最后一层。线段树也不一定是完全二叉树（切记！）。但我们可以把线段树看成是满二叉树，对于不存在的结点我们视为空就行。\n\n * 线段树能解决的问题\n   \n   线段树的适用范围很广，可以在线维护修改以及查询区间上的最值，求和。==使用一维线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为o(logn)==。线段树更可以扩充到二维线段树（矩阵树）和三维线段树（空间树），这里我们不作讲解。（其实博主也暂时不会😄）\n\n你问我线段树算什么东西？今天我就告诉你，单点、区间朴素查询处理做的我线段树能做！单点、区间朴素查询没有的速度我有！这就是线段树。（战术后仰）\n\n\n# 2 线段树的基本内容\n\n我们先看一颗线段树：\n\n\n\n不然发现线段树的特点，每个结点都有一个值和区间，每个结点的左右孩子都存储了父结点的一半的区间，且它们的序号是按照层次顺序编号的。在日常处理中，我们通常是使用结构体数组来作为线段树的存储结构，因为这样我们就可以利用下标的关系来找到父节点和孩子结点了。例如我们已知一个结点的下标为i，那么：\n\n * 对于父结点：i>>1（这个进行的操作其实就是i/2，前面提到，这样会快很多）\n   \n   具体证明也很简单，把线段树看成一个完全二叉树（空结点也当作使用）对于任意一个结点i来说，它所在此二叉树的log2ilog_2ilog2 i 层，则此层共有2log2(i)2^{log2(i)}2log2(i)个结点，同样对于k的左子树那层来说有2log2k+12^{log_2{k}+1}2log2 k+1个结点，则结点k和左子树间隔了2∗2log2(i)−i+2∗(i−2log2(k))2*2^{log_2(i)}-i + 2*(i-2^{log_2(k)})2∗2log2 (i)−i+2∗(i−2log2 (k))个结点，然后这就很简单就得到k+2∗2log2(k)−k+2∗(k−2log2(k))=2∗kk+2*2^{log_2(k)}-k + 2*(k-2^{log2(k)}) = 2*kk+2∗2log2 (k)−k+2∗(k−2log2(k))=2∗k的关系了吧，右子树也就等于左子树结点+1。\n\n * 对于左孩子结点：左孩子下标：i<<1（这些是同理的，即是由父结点推孩子结点。）\n\n * 对于右孩子结点：右孩子下标：i<<1|1\n\n了解了这些关系，我们是有能力去建立一颗线段树的，因为线段树也是树，所以我们自然可以利用递归的思想去建树，不会很难，我也写全了注释。\n\nconst int maxn = 1e5;//最大值。\nstruct node{\n    int left;  //左端点\n    int right; //右端点\n    int value;//代表区间[left,right]的信息，可以是区间和，也可以是区间最值。\n}node[maxn<<2];//这里我们要开4倍大小，防止数据溢出\nint father[maxn];//存储原来数据在线段树中的下标，易于从下向上更新区间数据。例如father[i]表示原来的第i个数据在线段树中的下标，这些在线段树中都是叶子结点。\nvoid buildtree(int i,int l,int r){\n    node[i].left=l;node[i].right=r;//存储各自结点的区间\n    node[i].value=0;                     //初始化为0.\n    if(l==r){                    //说明已经到了叶子结点。\n        father[l]=i;//存储下标。\n        return;\n    }\n    buildtree(i<<1,l,(l+r)/2); //递归初始化左子树\n    buildtree((i<<1)+1,(l+r)/2+1,r);//递归初始化右子树。\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n这样，我们的线段树就建好了。我们来看线段树有哪些基本操作吧。\n\n\n# 3 线段树的基本操作\n\n我们这里以结点的值value代表区间和来处理。\n\n\n# 3.1 点更新\n\n这很好办，有没有注意我们是使用了一个father数组，如果我在原数组中修改第i个元素的值，我们是直接可以node[father[i]].value=w，这就是我们使用father数组的好处，那你可能会问了，我们这样是不是要使用三个数组？大可不必，我们没必要给原有数据开一个数组存放，因为我们本身就已经把数据放在线段树中了，不管线段树中存放的是区间和还是区间最值，对于叶子结点来说，它就是本身。那么我们加入了点，自然也要更新整棵树，那有关这个叶子结点到根节点的路径自然全部都是要更新的，我们则是从下往上利用递归思想来更新的。\n\nvoid updatetree(int ri){\n    if(ri==1){\n        return;\n    }\n    int fi=ri>>1;//获得父结点下标。\n    node[fi].value=node[fi<<1].value+node[fi<<1|1].value;//两段区间总和。\n    updatetree(fi);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 3.2 区间查询\n\n我们有了线段树，可却不对它进行相关查询，那这颗线段树也只是精致的花瓶而已。我们最重要的就是进行区间查询，现在如果我想知道某个区间和的话，我们应该怎样来处理呢？我们知道根节点是存放了整个区间的信息，然后它的孩子结点则存放了它一半区间的信息，这样则显而易见，我们从根节点开始自上往下查询即可。我们本着下面的思想就一目了然了。\n\n1、如果这个区间被完全包括在目标区间里面，直接返回这个区间的值\n\n2、如果这个区间的左儿子和目标区间有交集，那么搜索左儿子\n\n3、如果这个区间的右儿子和目标区间有交集，那么搜索右儿子\n\nok，整活。\n\n//区间查询，调用函数时为querytree(1,l,r)，即从根节点自上往下查询。\nint querytree(int i,int l,int r){\n    int sum=0;\n    if(l==node[i].left&&r==node[i].right){\n        //如果刚好就是这个区间，我们直接返回。\n        sum+=node[i].value;\n        return sum;\n    }\n    i=i<<1;\n    if(l<=node[i].right){\n        //说明部分包含左子树\n        if(r<=node[i].right){\n            //说明全包含在左子树。\n            sum+=querytree(i,l,r);\n        }\n        else{\n            sum+=querytree(i,l,node[i].right);\n        }\n    }\n    i+=1;\n    if(r>=node[i].left){\n        //说明部分包含右子树\n        if(l>=node[i].left){\n            //说明全包含在右子树。\n            sum+=querytree(i,l,r);\n        }\n        else{\n            sum+=querytree(i,node[i].left,r);\n        }\n    }\n    return sum; //返回求得的区间和。\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n区间查询不断二分，易知时间复杂度为o(log2nlog_2nlog2 n)。\n\n线段树的基本操作就是这些，当然，这只是入门，灵活使用线段树以及更深层次的利用线段树的道路还很长，我们一起加油！\n\n----------------------------------------\n\n主函数部分测试：\n\nint main(){\n    freopen("in.txt", "r", stdin);//提交的时候要注释掉\n    ios::sync_with_stdio(false);//打消iostream中输入输出缓存，节省时间。\n    cin.tie(0); cout.tie(0);//可以通过tie(0)（0表示null）来解除cin与cout的绑定，进一步加快执行效率。\n    int n,m,g;\n    while(cin>>n>>m){\n        buildtree(1,1,n);\n        rep(i,1,n){\n            cin>>g;\n            node[father[i]].value=g;\n            updatetree(father[i]);\n        }\n        char ch;\n        int a,b;\n        while(m--){\n            cin>>ch>>a>>b;\n            if(ch==\'q\'){\n                cout<<querytree(1,a,b)<<endl;;\n            }\n            else{\n                node[father[a]].value=b;\n                updatetree(father[a]);\n            }\n        }\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n测试数据：\n\n6 5 \n2 3 8 23 1 9\nq 1 6\ns 2 3\nq 1 6\ns 3 4\nq 1 6\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n测试结果：',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"状压DP学习总结+经典例题精解",frontmatter:{title:"状压DP学习总结+经典例题精解",date:"2021-05-31T21:34:31.000Z",tags:["状压DP"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},categories:["开发","数据结构与算法","动态规划"],permalink:"/pages/671a5d/",readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/03.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/07.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/02.%E7%8A%B6%E5%8E%8BDP.html",relativePath:"01.开发/03.数据结构与算法/07.动态规划/02.状压DP.md",key:"v-1081ce44",path:"/pages/671a5d/",headers:[{level:2,title:"1 前言",slug:"_1-前言",normalizedTitle:"1 前言",charIndex:2},{level:2,title:"2 状态压缩",slug:"_2-状态压缩",normalizedTitle:"2 状态压缩",charIndex:197},{level:2,title:"3 使用场景",slug:"_3-使用场景",normalizedTitle:"3 使用场景",charIndex:595},{level:2,title:"4 常用模板",slug:"_4-常用模板",normalizedTitle:"4 常用模板",charIndex:985},{level:2,title:"5 经典例题",slug:"_5-经典例题",normalizedTitle:"5 经典例题",charIndex:1626},{level:3,title:"5.1 USACO06NOV Corn Fields G",slug:"_5-1-usaco06nov-corn-fields-g",normalizedTitle:"5.1 usaco06nov corn fields g",charIndex:1637},{level:3,title:"5.2 吃奶酪",slug:"_5-2-吃奶酪",normalizedTitle:"5.2 吃奶酪",charIndex:4998},{level:3,title:"5.3  USACO13NOV No Change G",slug:"_5-3-usaco13nov-no-change-g",normalizedTitle:"5.3  usaco13nov no change g",charIndex:null},{level:3,title:"5.4 SCOI2005互不侵犯",slug:"_5-4-scoi2005互不侵犯",normalizedTitle:"5.4 scoi2005互不侵犯",charIndex:12391}],headersStr:"1 前言 2 状态压缩 3 使用场景 4 常用模板 5 经典例题 5.1 USACO06NOV Corn Fields G 5.2 吃奶酪 5.3  USACO13NOV No Change G 5.4 SCOI2005互不侵犯",content:'# 1 前言\n\n> 学了这么久，说真的，动态规划是一个特别难的领域，而状压DPDPDP我感觉是其中一个比较难的分支，其中的状态定义、状态转移、状态计算都是难点。如果要完全搞懂状压DPDPDP是需要花很多时间去吸收去实践的，所以建议读者多刷DPDPDP题。同时，学习本文的先修知识为二进制位运算操作、基础动态规划和动态规划的分析。这里指路一篇二进制讲解blogblogblog:点这里。\n\n\n# 2 状态压缩\n\n我们知道状态压缩，顾名思义，就是需要考虑的状态非常多，我们如果用平常的思想去表示状态，那是非常不现实的，在时间和空间上都不允许，我们使用某种方法，以最小的代价表示某种状态。 那么，这通常是用进制来表示状态的，而选择几进制则根据要求使用的对象的点的状态有几种。一般来说，只有000和111，我们则是用二进制来表示，当然也有其他进制的题，在例题中会列举，需要我们灵活变通，主要谈二进制。\n\n那么如何用二进制表示状态呢？我们发现，二进制上是按位分的，那么我们每一位可以看成一个点，而点上的取值则为该点的状态或者选择。例如000010010000100100001001这个状态则表示第一个点和第四个点状态为111，其余的点状态为000。所以按照这种思想，我们能抽象的表示出一个很复杂的状态，实现了时间和空间的优化。\n\n知道了这个，我们就按照正常动态规划的思想去写这类题目即可。\n\n\n# 3 使用场景\n\n由上我们知道，状态压缩其实是有适用环境的：\n\n 1. 状态需要有一定的状态单元。 即一个状态应该是保存一个集合，其中的元素值对应着000或111，例如我们常见的棋盘，我们可以用000或111来表示棋子的放置状态。而整个集合即是一个010101串，即二进制数，我们通常用十进制表示。那么我们再进行状态转移或者判断的时候，需要先将十进制转化为二进制，再将二进制转化为十进制。\n 2. 题目中限制的集合大小不会超过202020。 这是最显著的特征，为什么呢？我们知道如果用二进制表示状态，那么集合大小为202020的二进制状态有220−12^{20} - 1220−1，已经达到1e71e71e7的数量级了。\n 3. 具有动态规划的特性。 对于动态规划，一般都是要求最优化某个值，具有最优子结构的性质。同时也需要满足状态转移的特性，而不是前一个状态毫无关系的。\n\n\n# 4 常用模板\n\n下面的模板适用于大多数题目，特殊题目需要灵活变动，总之，多刷题自然就都会了。\n\nint n;\nint maxn = 1 << n;//总状态数。\n    //枚举已有的集合数。按照状态转移的顺序，一般从小编号到大编号。\n    for(int i = 1; i <= m; ++ i){\n        //枚举当前集合中的状态。\n        for(int j = 0; j < maxn; ++ j){\n            //判断当前集合是否处于合法状态，通常我们需用一个数组提前处理好。如g数组;\n            if(当前状态是否合格){\n                for(int k = 0; k < maxn; ++ k){\n                    //枚举上一个集合的状态。\n                    if(上一个集合的状态是否合格 + 上一个集合的状态和当前状态的集合是否产生了冲突){\n                        列写状态转移方程。\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 5 经典例题\n\n\n# 5.1 USACO06NOV Corn Fields G\n\n * 题面\n   \n   > 农场主John新买了一块长方形的新牧场，这块牧场被划分成M行N列(1 ≤ M ≤ 12; 1 ≤ N ≤ 12)，每一格都是一块正方形的土地。John打算在牧场上的某几格里种上美味的草，供他的奶牛们享用。\n   > \n   > 遗憾的是，有些土地相当贫瘠，不能用来种草。并且，奶牛们喜欢独占一块草地的感觉，于是John不会选择两块相邻的土地，也就是说，没有哪两块草地有公共边。\n   > \n   > John想知道，如果不考虑草地的总块数，那么，一共有多少种种植方案可供他选择？（当然，把新牧场完全荒废也是一种方案）\n   > \n   > 输入格式\n   > \n   > 第一行：两个整数M和N，用空格隔开。\n   > \n   > 第2到第M+1行：每行包含N个用空格隔开的整数，描述了每块土地的状态。第i+1行描述了第i行的土地，所有整数均为0或1，是1的话，表示这块土地足够肥沃，0则表示这块土地不适合种草。\n   > \n   > 输出格式\n   > \n   > 一个整数，即牧场分配总方案数除以100,000,000的余数。\n   > \n   > 输入\n   > \n   > 2 3\n   > 1 1 1\n   > 0 1 0\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > \n   > 1\n   > 2\n   > 3\n   > \n   > \n   > 输出\n   > \n   > 9\n   > \n   > \n   > 1\n   > \n   > 1\n\n * 解题思路\n   \n   我们先作出规定，定义nnn代表的是行，mmm代表的是列。那么牧场大小就是n×mn\\times mn×m。我们看到数据范围,n,mn,mn,m都特别小，同时所求为方案数，这很符合状压DP的适用条件。那么对于每一行，我们就可以看成一个未知集合，而集合的大小自然就是列mmm。对于每一个单元，其取值范围为0,10,10,1，而111代表放置奶牛，000代表不放置奶牛，所以我们自然可以用二进制表示，那么状态总数就是(1<<m)−1(1 << m) - 1(1<<m)−1。 对于每一个状态，我们需要判断是否合格，而其中明确不能选择两块相邻的土地，在集合内，即相邻位不能全为111，所以我们可以预处理ggg数组，处理方式即为:g[i] = !(i & (i << 1))；同样，我们还应该知晓土地的状况，因为毕竟只有土地肥沃才可以放置奶牛，则我们可以通过一个ststst数组判断，集合与集合之间，我们也需要考虑相邻位不能全为111，所以在枚举上一个集合的状态也需要严格判断。对于状态定义，我们可以用f[i][j]f[i][j]f[i][j]表示第iii行且状态为jjj的方案数。对于状态转移，假设上一行状态为kkk，则状态转移方程为：\n   \n   f[i][j]+=f[i−1][k]f[i][j] += f[i - 1][k]f[i][j]+=f[i−1][k]\n   \n   具体见ACACAC代码。\n\n * AC代码\n\n/**\n  *@filename:Corn Field G\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-28 16:50\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 10 + 5,M = 10 + 5;\nconst int P = 1e8;\n\nint n,m;//n行m列的土地。\nint a[N][M],st[N];//a代表土地，st代表每一行的土地状况。\nbool g[1 << N];//g得到所有状态中的合法状态。\nint f[N][1 << N];//f[i][j]表示的则是第i行且状态为j的方案数，是由上一行转移过来的，所以我们定义上一行的状态为k。\n//则状态转移方程为f[i][j] += f[i - 1][k];//其中j和k必须满足条件。\nvoid solve(){\n}\nint main(){\n    scanf("%d%d", &n, &m);\n    for(int i = 1; i <= n; ++ i){\n        for(int j = 1; j <= m; ++ j){\n            scanf("%d", &a[i][j]);\n        }\n    }\n    //得到每一行的土地状况。\n    for(int i = 1; i <= n; ++ i){\n        for(int j = 1; j <= m; ++ j){\n            st[i] = (st[i] << 1) + a[i][j];\n        }\n    }\n    //得到所有状态中的合法状态。\n    int maxn = 1 << m;//总状态。\n    f[0][0] = 1;//初始化，这种也算一种。\n    for(int i = 0; i < maxn; ++ i){\n        g[i] = !( i & (i << 1));//由于不能相邻，所以我们左移判断是否符合条件。 \n    }\n    for(int i = 1; i <= n; ++ i){\n        //枚举每一行。\n        for(int j = 0; j < maxn; ++ j){\n            //枚举每一行的状态，判断此状态是否符合条件。1.不能相邻。2.是全部状态的子集。\n            if(g[j] && (j & st[i]) == j){\n                //如果符合条件。则我们去判断上一行是否符合。\n                for(int k = 0; k < maxn; ++ k){\n                    //枚举上一行状态。注意，这里我们无需判断上一行状态是否存在，因为不存在即为0.\n                    //只需要判断j和k是否存在相邻草地。\n                    if(!(j & k)){\n                        f[i][j] = (f[i][j] + f[i - 1][k]) % P;\n                    }\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for(int j = 0; j < maxn; ++ j){\n        ans = (ans + f[n][j]) % P;\n    }\n    printf("%d\\n", ans);\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n\n# 5.2 吃奶酪\n\n * 题面\n   \n   > 房间里放着nnn块奶酪。一只小老鼠要把它们都吃掉，问至少要跑多少距离？老鼠一开始在 (0,0)(0,0)(0,0)点处。\n   > \n   > 输入格式\n   > \n   > 第一行有一个整数，表示奶酪的数量 n。\n   > \n   > 第 22 到第 (n + 1)行，每行两个实数，第 (i+1)(i + 1)(i+1)行的实数分别表示第 iii 块奶酪的横纵坐标 xi,yix_i, y_ixi ,yi 。\n   > \n   > 输出格式\n   > \n   > 输出一行一个实数，表示要跑的最少距离，保留 2位小数。\n   > \n   > 输入 #1\n   > \n   > 4\n   > 1 1\n   > 1 -1\n   > -1 1\n   > -1 -1\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > \n   > \n   > 输出 #1\n   > \n   > 7.41\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 数据规模与约定\n   > \n   > 对于全部的测试点，保证 1≤n≤15，∣xi∣,∣yi∣≤2001\\leq n\\leq 15，|x_i|, |y_i| \\leq 2001≤n≤15，∣xi ∣,∣yi ∣≤200，小数点后最多有 3位数字。\n   > \n   > 提示\n   > \n   > 对于两个点$$ (x_1,y_1)，(x_2, y_2)$$，两点之间的距离公式为(x1−x2)2+(y1−y2)2\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}(x1 −x2 )2+(y1 −y2 )2 。\n\n * 解题思路\n   \n   同样，根据数据量等信息我们很容易发现这是一个状压DPDPDP。奶酪的状态无非两种0,10,10,1，而根据题意我们的集合数量只有111个，集合大小自然是奶酪的数量，而奶酪有nnn个，所以我们的集合情况也有(1<<n)−1(1 << n)-1(1<<n)−1种，同样在此题我们需要先初始化好奶酪的合法状态，用ggg数组表示，更严格的说，g[i]g[i]g[i]表示第iii个奶酪所在的二进制中的位置，用十进制数表示 。由于我们还需要计算距离，所以我们需要将每个点之间的距离也求出来，用distdistdist数组预处理奶酪之间的距离以及起点与各个奶酪的距离。 那么在状态定义上，我们可以用f[i][j]f[i][j]f[i][j]表示当前为iii状态，且处于第jjj个奶酪的最小距离，故状态转移方程易知为：\n   \n   f[i][j]=min(f[i][j],f[i−g[j]][k]+dist[k][j])f[i][j]=min(f[i][j],f[i-g[j]][k]+dist[k][j])f[i][j]=min(f[i][j],f[i−g[j]][k]+dist[k][j])\n   \n   据此，题目可解，具体看代码。\n\n * AC代码\n\n/**\n  *@filename:吃奶酪\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-30 14:20\n**/\n#include <bits/stdc++.h>\n#define x first \n#define y second\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<double,double> pdd;\nconst int N = 16;\nconst int P = 1e9+7;\n\nint n;\npdd a[N];\ndouble dist[N][N];//dist[i][j]表示第i个奶酪到第j个奶酪的距离。\nint g[1 << N];//奶酪的状态。\ndouble f[1 << N][N];//f[i][j]表示当前为i状态，且处于第j个奶酪的最小距离。\npdd st;\ndouble get(pdd a,pdd b){\n    return sqrt(pow(a.x - b.x,2) + pow(a.y - b.y,2));\n}\nvoid solve(){\n    //先计算距离。\n    st.x = 0,st.y = 0;\n    for(int i = 1; i <= n; ++ i){\n        dist[0][i] = get(st,a[i]);\n    }\n    for(int i = 1; i <= n; ++ i){\n        for(int j = 1; j <= n; ++ j){\n            dist[i][j] = get(a[i],a[j]);\n        }\n    }\n     int maxn = 1 << n;\n    //初始化奶酪的状态。\n    g[1] = 1;\n    for(int i = 2; i <= n; ++ i){\n        g[i] = g[i - 1] << 1;\n    }\n    //初始化最大值。\n    fill(f[0],f[0] + (1 << N) * N,0x3f3f3f3f);\n    //确定只吃了一个奶酪的距离。\n    for(int i = 1; i <= n; ++ i){\n        f[g[i]][i] = dist[0][i];\n    }\n    f[0][0] = 0;//最开始自然为0，0.\n    for(int i = 0; i < maxn ; ++ i){\n        //枚举所有状态。\n        for(int j = 1; j <= n; ++ j){\n            if(i & g[j]){\n                //该状态如果包含此奶酪就跳过。\n                for(int k = 1; k <= n; ++ k){\n                    if(k != j && i & g[k]){\n                        //说明符合条件。\n                        f[i][j] = min(f[i][j],f[i - g[j]][k] + dist[k][j]);//进行状态转移。\n                    }\n                }\n            }\n        }\n    }\n    double maxx = 0x3f3f3f3f;\n    for(int i = 1; i <= n; ++ i){\n        maxx = min(maxx,f[maxn - 1][i]);\n    }\n    printf("%.2lf\\n",maxx);\n}\nint main(){\n    scanf("%d", &n);\n    for(int i = 1; i <= n; ++ i){\n        scanf("%lf%lf", &a[i].x, &a[i].y);\n    }\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\n\n# 5.3 USACO13NOV No Change G\n\n * 题面\n   \n   > 约翰到商场购物，他的钱包里有K(1 <= K <= 16)个硬币，面值的范围是1..100,000,000。\n   > \n   > 约翰想按顺序买 N个物品(1 <= N <= 100,000)，第i个物品需要花费c(i)块钱，(1 <= c(i) <= 10,000)。\n   > \n   > 在依次进行的购买N个物品的过程中，约翰可以随时停下来付款，每次付款只用一个硬币，支付购买的内容是从上一次支付后开始到现在的这些所有物品（前提是该硬币足以支付这些物品的费用）。不幸的是，商场的收银机坏了，如果约翰支付的硬币面值大于所需的费用，他不会得到任何找零。\n   > \n   > 请计算出在购买完N个物品后，约翰最多剩下多少钱。如果无法完成购买，输出-1\n   > \n   > 输入格式\n   > \n   > *Line 1: Two integers, K and N.\n   > \n   > * Lines 2..1+K: Each line contains the amount of money of one of FJ\'s coins.\n   > \n   > * Lines 2+K..1+N+K: These N lines contain the costs of FJ\'s intended purchases.\n   > \n   > 输出格式\n   > \n   > * Line 1: The maximum amount of money FJ can end up with, or -1 if FJ cannot complete all of his purchases.\n   > \n   > 输入 #1\n   > \n   > 3 6 \n   > 12 \n   > 15 \n   > 10 \n   > 6 \n   > 3 \n   > 3 \n   > 2 \n   > 3 \n   > 7 \n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > \n   > \n   > 输出 #1\n   > \n   > 12 \n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 说明/提示\n   > \n   > FJ has 3 coins of values 12, 15, and 10. He must make purchases in sequence of value 6, 3, 3, 2, 3, and 7.\n   > \n   > FJ spends his 10-unit coin on the first two purchases, then the 15-unit coin on the remaining purchases. This leaves him with the 12-unit coin.\n\n * 解题思路\n   \n   此题状态定义比较简单，因为实际上我们只在乎了硬币的花费，这已经是一个集合了，花费为111不花费为000，而其他并不用在乎。所以我们完全可以用f[i]f[i]f[i]表示在iii状态下能够购买的最大物品数。此题难点在于状态转移。同样在此题我们需要先初始化好硬币的合法状态，用ggg数组表示，更严格的说，g[i]g[i]g[i]表示第iii个硬币所在的二进制中的位置。用十进制数表示。为了方便处理，我们需要用前缀和来优化本题，因为在处理过程中我们随时都要计算当前已有的总价值能够换取多少物品。 同样，在状态转移方面，我们需要根据前面的状态得到后者的状态，而由于我们是从小到大枚举状态的，故一定可以利用前面的状态而不会出现前面状态不是最优解，我们对于每一种状态，我们可以排除一个硬币获取前面的最优解，即枚举该状态已有的硬币，通过异或排除，最后利用二分查找所能购买的最大值得到最优解。 说起来有点乱，详情可见ACACAC代码。\n\n * AC代码\n\n/**\n  *@filename:No_Change_G\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-28 17:14\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 1000000 + 5,K = 20;\nconst int P = 1e9+7;\n\nint n,k;\nint g[K];//每个硬币的状态。\nint w[K];//硬币的价值\nint sum[N];//物品价值的前缀和。\nint ans;\nint f[1 << K];//f[i]表示在i状态下能够购买的最大物品数。\nvoid solve(){\n    //初始化硬币状态。\n    g[1] = 1;\n    for(int i = 2; i <= k; ++ i){\n        g[i] = g[i -1] << 1;\n    }\n    int maxn = 1 << k;//得到\n    for(int i = 0; i < maxn; ++ i){\n        //枚举每一种状态。\n        for(int j = 1; j <= k; ++ j){\n            //枚举所有的硬币。\n            if(i & g[j]){\n                //说明该硬币在当前状态使用过。\n                int te = f[i ^ g[j]];//获取该状态不使用j能获得的物品数。\n                te = upper_bound(sum + 1,sum + n + 1,sum[te] + w[j]) - sum;//这里需要减1.\n                f[i] = max(f[i],te - 1);\n            }\n        }\n    }\n    ll maxx = -2,temp;\n    for(int i = 0; i < maxn; ++ i){\n        if(f[i] == n){\n            //说明该状态能够将所有物品都买完。\n            temp = 0;\n            for(int j = 1; j <= k; ++ j){\n                if(i & g[j]){\n                    temp += w[j];\n                }\n            }\n            maxx = max(maxx,ans - temp);\n        }\n    }\n    if(maxx < 0)printf("%d\\n", -1);\n    else printf("%d\\n",maxx);\n}\nint main(){\n    scanf("%d%d", &k , &n);\n    for(int i = 1; i <= k; ++ i){\n        scanf("%d", &w[i]);\n        ans += w[i];//求硬币总价值。\n    }\n    for(int i = 1; i <= n; ++ i){\n        scanf("%d", &sum[i]);\n        sum[i] += sum[i - 1];\n    }\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n\n# 5.4 SCOI2005互不侵犯\n\n * 题面\n   \n   > 在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。\n   > \n   > 输入格式\n   > \n   > 只有一行，包含两个数N，K （ 1 <=N <=9, 0 <= K <= N * N）\n   > \n   > 输出格式\n   > \n   > 所得的方案数\n   > \n   > 输入 #1\n   > \n   > 3 2\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 输出 #1\n   > \n   > 16\n   > \n   > \n   > 1\n   > \n   > 1\n\n * 解题思路\n   \n   这道题跟5.15.15.1例题有点相似，只不过这里多了左上左下右上右下这几个点，处理方法一样，我们需要知道每个状态的放置国王数，所以这我们需要预处理。定义状态f[i][j][k]f[i][j][k]f[i][j][k]表示在第iii行且处于jjj状态时已经放置了kkk个国王。其他的处理方式和5.15.15.1相同，这里不作叙述，可见ACACAC代码。\n\n * AC代码\n\n/**\n  *@filename:互不侵犯\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-31 16:32\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 10;\nconst int P = 1e9+7;\n\nint n,m;\nint tot,num[1 << N];//num[i]表示第i种可行状态的国王所放数量。\nll f[N][1 << N][N * N];//f[i][j][k]表示前i行，当前处于j状态且已经放置了k个国王。\nint get(int x){\n    //获取该状态有多少国王。\n    int sum = 0;\n    for(int i = 0; i < n; ++ i){\n        sum += (x & 1);\n        x >>= 1;\n    }\n    return sum;\n}\nvoid init(){\n    int maxn = 1 << n;\n    for(int i = 0; i < maxn; ++ i){\n        if(i & (i << 1))continue;//说明存在相邻的。\n        num[i] = get(i);\n        f[1][i][num[i]] = 1;\n    }\n}\nvoid solve(){\n    init();\n    int maxn = 1 << n;\n    for(int i = 2; i <= n; ++ i){\n        for(int j = 0; j < maxn; ++ j){\n            //枚举所有状态。\n            if(j & (j << 1))continue;\n            for(int k = 0; k < maxn; ++ k){\n                //枚举上一行的所有状态。\n                if(((k & (k << 1)) || j & k || ((j << 1) & k) || (j & (k << 1)))){\n                    continue;\n                }\n                for(int cnt = num[j]; cnt <= m; ++ cnt){\n                    f[i][j][cnt] += f[i - 1][k][cnt - num[j]];\n                }\n            }\n        }\n    }\n    ll ans = 0;\n    for(int  i= 0; i < maxn; ++ i){\n        ans += f[n][i][m];\n    }\n    printf("%lld\\n",ans);\n}\nint main(){\n    scanf("%d %d", &n, &m);\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n',normalizedContent:'# 1 前言\n\n> 学了这么久，说真的，动态规划是一个特别难的领域，而状压dpdpdp我感觉是其中一个比较难的分支，其中的状态定义、状态转移、状态计算都是难点。如果要完全搞懂状压dpdpdp是需要花很多时间去吸收去实践的，所以建议读者多刷dpdpdp题。同时，学习本文的先修知识为二进制位运算操作、基础动态规划和动态规划的分析。这里指路一篇二进制讲解blogblogblog:点这里。\n\n\n# 2 状态压缩\n\n我们知道状态压缩，顾名思义，就是需要考虑的状态非常多，我们如果用平常的思想去表示状态，那是非常不现实的，在时间和空间上都不允许，我们使用某种方法，以最小的代价表示某种状态。 那么，这通常是用进制来表示状态的，而选择几进制则根据要求使用的对象的点的状态有几种。一般来说，只有000和111，我们则是用二进制来表示，当然也有其他进制的题，在例题中会列举，需要我们灵活变通，主要谈二进制。\n\n那么如何用二进制表示状态呢？我们发现，二进制上是按位分的，那么我们每一位可以看成一个点，而点上的取值则为该点的状态或者选择。例如000010010000100100001001这个状态则表示第一个点和第四个点状态为111，其余的点状态为000。所以按照这种思想，我们能抽象的表示出一个很复杂的状态，实现了时间和空间的优化。\n\n知道了这个，我们就按照正常动态规划的思想去写这类题目即可。\n\n\n# 3 使用场景\n\n由上我们知道，状态压缩其实是有适用环境的：\n\n 1. 状态需要有一定的状态单元。 即一个状态应该是保存一个集合，其中的元素值对应着000或111，例如我们常见的棋盘，我们可以用000或111来表示棋子的放置状态。而整个集合即是一个010101串，即二进制数，我们通常用十进制表示。那么我们再进行状态转移或者判断的时候，需要先将十进制转化为二进制，再将二进制转化为十进制。\n 2. 题目中限制的集合大小不会超过202020。 这是最显著的特征，为什么呢？我们知道如果用二进制表示状态，那么集合大小为202020的二进制状态有220−12^{20} - 1220−1，已经达到1e71e71e7的数量级了。\n 3. 具有动态规划的特性。 对于动态规划，一般都是要求最优化某个值，具有最优子结构的性质。同时也需要满足状态转移的特性，而不是前一个状态毫无关系的。\n\n\n# 4 常用模板\n\n下面的模板适用于大多数题目，特殊题目需要灵活变动，总之，多刷题自然就都会了。\n\nint n;\nint maxn = 1 << n;//总状态数。\n    //枚举已有的集合数。按照状态转移的顺序，一般从小编号到大编号。\n    for(int i = 1; i <= m; ++ i){\n        //枚举当前集合中的状态。\n        for(int j = 0; j < maxn; ++ j){\n            //判断当前集合是否处于合法状态，通常我们需用一个数组提前处理好。如g数组;\n            if(当前状态是否合格){\n                for(int k = 0; k < maxn; ++ k){\n                    //枚举上一个集合的状态。\n                    if(上一个集合的状态是否合格 + 上一个集合的状态和当前状态的集合是否产生了冲突){\n                        列写状态转移方程。\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 5 经典例题\n\n\n# 5.1 usaco06nov corn fields g\n\n * 题面\n   \n   > 农场主john新买了一块长方形的新牧场，这块牧场被划分成m行n列(1 ≤ m ≤ 12; 1 ≤ n ≤ 12)，每一格都是一块正方形的土地。john打算在牧场上的某几格里种上美味的草，供他的奶牛们享用。\n   > \n   > 遗憾的是，有些土地相当贫瘠，不能用来种草。并且，奶牛们喜欢独占一块草地的感觉，于是john不会选择两块相邻的土地，也就是说，没有哪两块草地有公共边。\n   > \n   > john想知道，如果不考虑草地的总块数，那么，一共有多少种种植方案可供他选择？（当然，把新牧场完全荒废也是一种方案）\n   > \n   > 输入格式\n   > \n   > 第一行：两个整数m和n，用空格隔开。\n   > \n   > 第2到第m+1行：每行包含n个用空格隔开的整数，描述了每块土地的状态。第i+1行描述了第i行的土地，所有整数均为0或1，是1的话，表示这块土地足够肥沃，0则表示这块土地不适合种草。\n   > \n   > 输出格式\n   > \n   > 一个整数，即牧场分配总方案数除以100,000,000的余数。\n   > \n   > 输入\n   > \n   > 2 3\n   > 1 1 1\n   > 0 1 0\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > \n   > 1\n   > 2\n   > 3\n   > \n   > \n   > 输出\n   > \n   > 9\n   > \n   > \n   > 1\n   > \n   > 1\n\n * 解题思路\n   \n   我们先作出规定，定义nnn代表的是行，mmm代表的是列。那么牧场大小就是n×mn\\times mn×m。我们看到数据范围,n,mn,mn,m都特别小，同时所求为方案数，这很符合状压dp的适用条件。那么对于每一行，我们就可以看成一个未知集合，而集合的大小自然就是列mmm。对于每一个单元，其取值范围为0,10,10,1，而111代表放置奶牛，000代表不放置奶牛，所以我们自然可以用二进制表示，那么状态总数就是(1<<m)−1(1 << m) - 1(1<<m)−1。 对于每一个状态，我们需要判断是否合格，而其中明确不能选择两块相邻的土地，在集合内，即相邻位不能全为111，所以我们可以预处理ggg数组，处理方式即为:g[i] = !(i & (i << 1))；同样，我们还应该知晓土地的状况，因为毕竟只有土地肥沃才可以放置奶牛，则我们可以通过一个ststst数组判断，集合与集合之间，我们也需要考虑相邻位不能全为111，所以在枚举上一个集合的状态也需要严格判断。对于状态定义，我们可以用f[i][j]f[i][j]f[i][j]表示第iii行且状态为jjj的方案数。对于状态转移，假设上一行状态为kkk，则状态转移方程为：\n   \n   f[i][j]+=f[i−1][k]f[i][j] += f[i - 1][k]f[i][j]+=f[i−1][k]\n   \n   具体见acacac代码。\n\n * ac代码\n\n/**\n  *@filename:corn field g\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-28 16:50\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int n = 10 + 5,m = 10 + 5;\nconst int p = 1e8;\n\nint n,m;//n行m列的土地。\nint a[n][m],st[n];//a代表土地，st代表每一行的土地状况。\nbool g[1 << n];//g得到所有状态中的合法状态。\nint f[n][1 << n];//f[i][j]表示的则是第i行且状态为j的方案数，是由上一行转移过来的，所以我们定义上一行的状态为k。\n//则状态转移方程为f[i][j] += f[i - 1][k];//其中j和k必须满足条件。\nvoid solve(){\n}\nint main(){\n    scanf("%d%d", &n, &m);\n    for(int i = 1; i <= n; ++ i){\n        for(int j = 1; j <= m; ++ j){\n            scanf("%d", &a[i][j]);\n        }\n    }\n    //得到每一行的土地状况。\n    for(int i = 1; i <= n; ++ i){\n        for(int j = 1; j <= m; ++ j){\n            st[i] = (st[i] << 1) + a[i][j];\n        }\n    }\n    //得到所有状态中的合法状态。\n    int maxn = 1 << m;//总状态。\n    f[0][0] = 1;//初始化，这种也算一种。\n    for(int i = 0; i < maxn; ++ i){\n        g[i] = !( i & (i << 1));//由于不能相邻，所以我们左移判断是否符合条件。 \n    }\n    for(int i = 1; i <= n; ++ i){\n        //枚举每一行。\n        for(int j = 0; j < maxn; ++ j){\n            //枚举每一行的状态，判断此状态是否符合条件。1.不能相邻。2.是全部状态的子集。\n            if(g[j] && (j & st[i]) == j){\n                //如果符合条件。则我们去判断上一行是否符合。\n                for(int k = 0; k < maxn; ++ k){\n                    //枚举上一行状态。注意，这里我们无需判断上一行状态是否存在，因为不存在即为0.\n                    //只需要判断j和k是否存在相邻草地。\n                    if(!(j & k)){\n                        f[i][j] = (f[i][j] + f[i - 1][k]) % p;\n                    }\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for(int j = 0; j < maxn; ++ j){\n        ans = (ans + f[n][j]) % p;\n    }\n    printf("%d\\n", ans);\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n\n# 5.2 吃奶酪\n\n * 题面\n   \n   > 房间里放着nnn块奶酪。一只小老鼠要把它们都吃掉，问至少要跑多少距离？老鼠一开始在 (0,0)(0,0)(0,0)点处。\n   > \n   > 输入格式\n   > \n   > 第一行有一个整数，表示奶酪的数量 n。\n   > \n   > 第 22 到第 (n + 1)行，每行两个实数，第 (i+1)(i + 1)(i+1)行的实数分别表示第 iii 块奶酪的横纵坐标 xi,yix_i, y_ixi ,yi 。\n   > \n   > 输出格式\n   > \n   > 输出一行一个实数，表示要跑的最少距离，保留 2位小数。\n   > \n   > 输入 #1\n   > \n   > 4\n   > 1 1\n   > 1 -1\n   > -1 1\n   > -1 -1\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > \n   > \n   > 输出 #1\n   > \n   > 7.41\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 数据规模与约定\n   > \n   > 对于全部的测试点，保证 1≤n≤15，∣xi∣,∣yi∣≤2001\\leq n\\leq 15，|x_i|, |y_i| \\leq 2001≤n≤15，∣xi ∣,∣yi ∣≤200，小数点后最多有 3位数字。\n   > \n   > 提示\n   > \n   > 对于两个点$$ (x_1,y_1)，(x_2, y_2)$$，两点之间的距离公式为(x1−x2)2+(y1−y2)2\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}(x1 −x2 )2+(y1 −y2 )2 。\n\n * 解题思路\n   \n   同样，根据数据量等信息我们很容易发现这是一个状压dpdpdp。奶酪的状态无非两种0,10,10,1，而根据题意我们的集合数量只有111个，集合大小自然是奶酪的数量，而奶酪有nnn个，所以我们的集合情况也有(1<<n)−1(1 << n)-1(1<<n)−1种，同样在此题我们需要先初始化好奶酪的合法状态，用ggg数组表示，更严格的说，g[i]g[i]g[i]表示第iii个奶酪所在的二进制中的位置，用十进制数表示 。由于我们还需要计算距离，所以我们需要将每个点之间的距离也求出来，用distdistdist数组预处理奶酪之间的距离以及起点与各个奶酪的距离。 那么在状态定义上，我们可以用f[i][j]f[i][j]f[i][j]表示当前为iii状态，且处于第jjj个奶酪的最小距离，故状态转移方程易知为：\n   \n   f[i][j]=min(f[i][j],f[i−g[j]][k]+dist[k][j])f[i][j]=min(f[i][j],f[i-g[j]][k]+dist[k][j])f[i][j]=min(f[i][j],f[i−g[j]][k]+dist[k][j])\n   \n   据此，题目可解，具体看代码。\n\n * ac代码\n\n/**\n  *@filename:吃奶酪\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-30 14:20\n**/\n#include <bits/stdc++.h>\n#define x first \n#define y second\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<double,double> pdd;\nconst int n = 16;\nconst int p = 1e9+7;\n\nint n;\npdd a[n];\ndouble dist[n][n];//dist[i][j]表示第i个奶酪到第j个奶酪的距离。\nint g[1 << n];//奶酪的状态。\ndouble f[1 << n][n];//f[i][j]表示当前为i状态，且处于第j个奶酪的最小距离。\npdd st;\ndouble get(pdd a,pdd b){\n    return sqrt(pow(a.x - b.x,2) + pow(a.y - b.y,2));\n}\nvoid solve(){\n    //先计算距离。\n    st.x = 0,st.y = 0;\n    for(int i = 1; i <= n; ++ i){\n        dist[0][i] = get(st,a[i]);\n    }\n    for(int i = 1; i <= n; ++ i){\n        for(int j = 1; j <= n; ++ j){\n            dist[i][j] = get(a[i],a[j]);\n        }\n    }\n     int maxn = 1 << n;\n    //初始化奶酪的状态。\n    g[1] = 1;\n    for(int i = 2; i <= n; ++ i){\n        g[i] = g[i - 1] << 1;\n    }\n    //初始化最大值。\n    fill(f[0],f[0] + (1 << n) * n,0x3f3f3f3f);\n    //确定只吃了一个奶酪的距离。\n    for(int i = 1; i <= n; ++ i){\n        f[g[i]][i] = dist[0][i];\n    }\n    f[0][0] = 0;//最开始自然为0，0.\n    for(int i = 0; i < maxn ; ++ i){\n        //枚举所有状态。\n        for(int j = 1; j <= n; ++ j){\n            if(i & g[j]){\n                //该状态如果包含此奶酪就跳过。\n                for(int k = 1; k <= n; ++ k){\n                    if(k != j && i & g[k]){\n                        //说明符合条件。\n                        f[i][j] = min(f[i][j],f[i - g[j]][k] + dist[k][j]);//进行状态转移。\n                    }\n                }\n            }\n        }\n    }\n    double maxx = 0x3f3f3f3f;\n    for(int i = 1; i <= n; ++ i){\n        maxx = min(maxx,f[maxn - 1][i]);\n    }\n    printf("%.2lf\\n",maxx);\n}\nint main(){\n    scanf("%d", &n);\n    for(int i = 1; i <= n; ++ i){\n        scanf("%lf%lf", &a[i].x, &a[i].y);\n    }\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\n\n# 5.3 usaco13nov no change g\n\n * 题面\n   \n   > 约翰到商场购物，他的钱包里有k(1 <= k <= 16)个硬币，面值的范围是1..100,000,000。\n   > \n   > 约翰想按顺序买 n个物品(1 <= n <= 100,000)，第i个物品需要花费c(i)块钱，(1 <= c(i) <= 10,000)。\n   > \n   > 在依次进行的购买n个物品的过程中，约翰可以随时停下来付款，每次付款只用一个硬币，支付购买的内容是从上一次支付后开始到现在的这些所有物品（前提是该硬币足以支付这些物品的费用）。不幸的是，商场的收银机坏了，如果约翰支付的硬币面值大于所需的费用，他不会得到任何找零。\n   > \n   > 请计算出在购买完n个物品后，约翰最多剩下多少钱。如果无法完成购买，输出-1\n   > \n   > 输入格式\n   > \n   > *line 1: two integers, k and n.\n   > \n   > * lines 2..1+k: each line contains the amount of money of one of fj\'s coins.\n   > \n   > * lines 2+k..1+n+k: these n lines contain the costs of fj\'s intended purchases.\n   > \n   > 输出格式\n   > \n   > * line 1: the maximum amount of money fj can end up with, or -1 if fj cannot complete all of his purchases.\n   > \n   > 输入 #1\n   > \n   > 3 6 \n   > 12 \n   > 15 \n   > 10 \n   > 6 \n   > 3 \n   > 3 \n   > 2 \n   > 3 \n   > 7 \n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > \n   > \n   > 输出 #1\n   > \n   > 12 \n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 说明/提示\n   > \n   > fj has 3 coins of values 12, 15, and 10. he must make purchases in sequence of value 6, 3, 3, 2, 3, and 7.\n   > \n   > fj spends his 10-unit coin on the first two purchases, then the 15-unit coin on the remaining purchases. this leaves him with the 12-unit coin.\n\n * 解题思路\n   \n   此题状态定义比较简单，因为实际上我们只在乎了硬币的花费，这已经是一个集合了，花费为111不花费为000，而其他并不用在乎。所以我们完全可以用f[i]f[i]f[i]表示在iii状态下能够购买的最大物品数。此题难点在于状态转移。同样在此题我们需要先初始化好硬币的合法状态，用ggg数组表示，更严格的说，g[i]g[i]g[i]表示第iii个硬币所在的二进制中的位置。用十进制数表示。为了方便处理，我们需要用前缀和来优化本题，因为在处理过程中我们随时都要计算当前已有的总价值能够换取多少物品。 同样，在状态转移方面，我们需要根据前面的状态得到后者的状态，而由于我们是从小到大枚举状态的，故一定可以利用前面的状态而不会出现前面状态不是最优解，我们对于每一种状态，我们可以排除一个硬币获取前面的最优解，即枚举该状态已有的硬币，通过异或排除，最后利用二分查找所能购买的最大值得到最优解。 说起来有点乱，详情可见acacac代码。\n\n * ac代码\n\n/**\n  *@filename:no_change_g\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-28 17:14\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int n = 1000000 + 5,k = 20;\nconst int p = 1e9+7;\n\nint n,k;\nint g[k];//每个硬币的状态。\nint w[k];//硬币的价值\nint sum[n];//物品价值的前缀和。\nint ans;\nint f[1 << k];//f[i]表示在i状态下能够购买的最大物品数。\nvoid solve(){\n    //初始化硬币状态。\n    g[1] = 1;\n    for(int i = 2; i <= k; ++ i){\n        g[i] = g[i -1] << 1;\n    }\n    int maxn = 1 << k;//得到\n    for(int i = 0; i < maxn; ++ i){\n        //枚举每一种状态。\n        for(int j = 1; j <= k; ++ j){\n            //枚举所有的硬币。\n            if(i & g[j]){\n                //说明该硬币在当前状态使用过。\n                int te = f[i ^ g[j]];//获取该状态不使用j能获得的物品数。\n                te = upper_bound(sum + 1,sum + n + 1,sum[te] + w[j]) - sum;//这里需要减1.\n                f[i] = max(f[i],te - 1);\n            }\n        }\n    }\n    ll maxx = -2,temp;\n    for(int i = 0; i < maxn; ++ i){\n        if(f[i] == n){\n            //说明该状态能够将所有物品都买完。\n            temp = 0;\n            for(int j = 1; j <= k; ++ j){\n                if(i & g[j]){\n                    temp += w[j];\n                }\n            }\n            maxx = max(maxx,ans - temp);\n        }\n    }\n    if(maxx < 0)printf("%d\\n", -1);\n    else printf("%d\\n",maxx);\n}\nint main(){\n    scanf("%d%d", &k , &n);\n    for(int i = 1; i <= k; ++ i){\n        scanf("%d", &w[i]);\n        ans += w[i];//求硬币总价值。\n    }\n    for(int i = 1; i <= n; ++ i){\n        scanf("%d", &sum[i]);\n        sum[i] += sum[i - 1];\n    }\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n\n# 5.4 scoi2005互不侵犯\n\n * 题面\n   \n   > 在n×n的棋盘里面放k个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。\n   > \n   > 输入格式\n   > \n   > 只有一行，包含两个数n，k （ 1 <=n <=9, 0 <= k <= n * n）\n   > \n   > 输出格式\n   > \n   > 所得的方案数\n   > \n   > 输入 #1\n   > \n   > 3 2\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 输出 #1\n   > \n   > 16\n   > \n   > \n   > 1\n   > \n   > 1\n\n * 解题思路\n   \n   这道题跟5.15.15.1例题有点相似，只不过这里多了左上左下右上右下这几个点，处理方法一样，我们需要知道每个状态的放置国王数，所以这我们需要预处理。定义状态f[i][j][k]f[i][j][k]f[i][j][k]表示在第iii行且处于jjj状态时已经放置了kkk个国王。其他的处理方式和5.15.15.1相同，这里不作叙述，可见acacac代码。\n\n * ac代码\n\n/**\n  *@filename:互不侵犯\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-31 16:32\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int n = 10;\nconst int p = 1e9+7;\n\nint n,m;\nint tot,num[1 << n];//num[i]表示第i种可行状态的国王所放数量。\nll f[n][1 << n][n * n];//f[i][j][k]表示前i行，当前处于j状态且已经放置了k个国王。\nint get(int x){\n    //获取该状态有多少国王。\n    int sum = 0;\n    for(int i = 0; i < n; ++ i){\n        sum += (x & 1);\n        x >>= 1;\n    }\n    return sum;\n}\nvoid init(){\n    int maxn = 1 << n;\n    for(int i = 0; i < maxn; ++ i){\n        if(i & (i << 1))continue;//说明存在相邻的。\n        num[i] = get(i);\n        f[1][i][num[i]] = 1;\n    }\n}\nvoid solve(){\n    init();\n    int maxn = 1 << n;\n    for(int i = 2; i <= n; ++ i){\n        for(int j = 0; j < maxn; ++ j){\n            //枚举所有状态。\n            if(j & (j << 1))continue;\n            for(int k = 0; k < maxn; ++ k){\n                //枚举上一行的所有状态。\n                if(((k & (k << 1)) || j & k || ((j << 1) & k) || (j & (k << 1)))){\n                    continue;\n                }\n                for(int cnt = num[j]; cnt <= m; ++ cnt){\n                    f[i][j][cnt] += f[i - 1][k][cnt - num[j]];\n                }\n            }\n        }\n    }\n    ll ans = 0;\n    for(int  i= 0; i < maxn; ++ i){\n        ans += f[n][i][m];\n    }\n    printf("%lld\\n",ans);\n}\nint main(){\n    scanf("%d %d", &n, &m);\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"位运算全面总结",frontmatter:{title:"位运算全面总结",date:"2021-05-28T13:12:04.000Z",tags:["位运算"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/41f1cd/",categories:["开发","数据结构与算法","位运算"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/03.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/05.%E4%BD%8D%E8%BF%90%E7%AE%97/01.%E4%BD%8D%E8%BF%90%E7%AE%97%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html",relativePath:"01.开发/03.数据结构与算法/05.位运算/01.位运算全面总结.md",key:"v-66f80783",path:"/pages/41f1cd/",headers:[{level:2,title:"1 位运算概述",slug:"_1-位运算概述",normalizedTitle:"1 位运算概述",charIndex:2},{level:2,title:"2 位运算的性质",slug:"_2-位运算的性质",normalizedTitle:"2 位运算的性质",charIndex:1187},{level:3,title:"2.1 运算符的优先级",slug:"_2-1-运算符的优先级",normalizedTitle:"2.1 运算符的优先级",charIndex:1200},{level:3,title:"2.2 位运算符的运算律",slug:"_2-2-位运算符的运算律",normalizedTitle:"2.2 位运算符的运算律",charIndex:2340},{level:2,title:"3 位运算高级操作",slug:"_3-位运算高级操作",normalizedTitle:"3 位运算高级操作",charIndex:2846},{level:2,title:"4 负数的位运算",slug:"_4-负数的位运算",normalizedTitle:"4 负数的位运算",charIndex:5898},{level:2,title:"5 位运算的一些应用",slug:"_5-位运算的一些应用",normalizedTitle:"5 位运算的一些应用",charIndex:6782},{level:2,title:"6 位运算例题",slug:"_6-位运算例题",normalizedTitle:"6 位运算例题",charIndex:8640},{level:3,title:"6.1 更新二进制位",slug:"_6-1-更新二进制位",normalizedTitle:"6.1 更新二进制位",charIndex:8652},{level:3,title:"6.2 A+B问题",slug:"_6-2-a-b问题",normalizedTitle:"6.2 a+b问题",charIndex:9616},{level:3,title:"6.3 O(1)时间检测2的幂次",slug:"_6-3-o-1-时间检测2的幂次",normalizedTitle:"6.3 o(1)时间检测2的幂次",charIndex:10825}],headersStr:"1 位运算概述 2 位运算的性质 2.1 运算符的优先级 2.2 位运算符的运算律 3 位运算高级操作 4 负数的位运算 5 位运算的一些应用 6 位运算例题 6.1 更新二进制位 6.2 A+B问题 6.3 O(1)时间检测2的幂次",content:"# 1 位运算概述\n\n我们知道，计算机中的数在内存中都是以二进制形式进行存储的 ，而位运算就是直接对整数在内存中的二进制位进行操作，因此其执行效率非常高，在程序中尽量使用位运算进行操作，这会大大提高程序的性能。\n\n那么，涉及位运算的运算符如下表所示：\n\n符号   描述   运算规则                                  实例（以四位二进制数为例）\n&    与    两个位都为1时，结果才为1。                        0001&0001=1,0001&0000=0,0000&0000=00000001\\&0001=1,0001\\&0000=0,0000\\&0000=00000001&0001=1,0001&0000=0,0000&0000=0000\n|    或    两个位都为0时，结果才为0。                        0001∥0001=0001,0001∥0000=0001,0000∥0000=00000001\\|0001=0001,0001\\|0000=0001,0000\\|0000=00000001∥0001=0001,0001∥0000=0001,0000∥0000=0000\n^    异或   两个位相同为0，相异为1。                         0001∧0001=0000,0001∧0000=1,0000∧0000=00001\n                                                \\wedge0001=0000,0001\\wedge0000=1,0000\\wedge\n                                                0000=00001∧0001=0000,0001∧0000=1,0000∧0000=0\n~    取反   0变1，1变0。                              ∼0=1,∼1=0\\sim0=1,\\sim 1 = 0∼0=1,∼1=0\n<<   左移   各二进位全部左移若干位，高位丢弃，低位补0。                0001<<k=0100，k=20001<<k=0100，k=20001<<k=0100，k=2，kkk是左移的位数，这里k=2k=2k=2\n>>   右移   各二进位全部右移若干位，对无符号数，高位补0，有符号数，右移补111。   0100>>k=0001，k=20100>>k=0001，k=20100>>k=0001，k=2，kkk是右移的位数，这里k=2k=2k=2\n\n看完，你可能会觉得挺简单的，但位运算的难点并不在这，而在于其性质、高级操作和它的应用。\n\n\n# 2 位运算的性质\n\n\n# 2.1 运算符的优先级\n\n优先级需要弄清楚，如果不太清楚可以加小括号确保是想要的运算顺序，这里只是相对优先级，即只是和一些常用的算术运算符做比较。\n\n优先级   运算符                                                                                       结合方向\n1     −（符号运算符）,∼（取反运算符），++（自增），−−（自减）-（符号运算符）,\\sim（取反运算符），                                      从右到左\n      ++（自增），--（自减）−（符号运算符）,∼（取反运算符），++（自增），−−（自减）\n2     ∗（乘）,/（除）,%（取余）*（乘）,/（除）,\\%（取余）∗（乘）,/（除）,%（取余）                                            从左到右\n3     +（加）,−（减）+（加）,-（减）+（加）,−（减）                                                               从左到右\n4     <<（左移），>>（右移）<<（左移），>>（右移）<<（左移），>>（右移）                                                   从左到右\n5     >（大于）,<(小于),>=(大于等于),<=(小于等于)>（大于）,<(小于),>=(大于等于),<=(小于等于)>（大于）,<(小于),>=(大于等于),<=(小于等于)   从左到右\n6     ==(等于),!=（不等于）==(等于),!=（不等于）==(等于),!=（不等于）                                                从左到右\n7     &（按位与）\\&（按位与）&（按位与）                                                                       从左到右\n8     ∧(按位异或)\\wedge (按位异或)∧(按位异或)                                                               从左到右\n9     ∥(按位或)\\|(按位或)∥(按位或)                                                                       从左到右\n\n\n# 2.2 位运算符的运算律\n\n公式名称                  运算规则\n交换律                   A&B=B&A,A∧B=B∧AA\\&B=B\\&A ,A\\wedge B=B\\wedge AA&B=B&A,A∧B=B∧A\n结合律（注意结合律只能在同符号下进行）   (A&B)&C=A&(B&C)(A\\&B)\\&C=A\\&(B\\&C)(A&B)&C=A&(B&C)\n等幂律                   A&A=A，A∥A=AA\\&A=A，A\\|A=AA&A=A，A∥A=A\n零律                    A&0=0A\\&0=0A&0=0\n互补律（注意，这不同于逻辑运算）      A&∼A=0,A∥∼A=−1A\\&\\sim A=0,A\\|\\sim A=-1A&∼A=0,A∥∼A=−1\n同一律                   A∥0=A，A∧0=AA\\|0=A，A\\wedge 0 =AA∥0=A，A∧0=A\n\n以上仅为已证明的运算律（可能存在遗漏），其余的博主均认为是不符合不成立的，注意：千万不要将逻辑运算的运算律或者其他的运算律与这混为一谈。\n\n\n# 3 位运算高级操作\n\n如下表，请读者认真阅读理解，在阅读的过程中可以对示例进行运算。\n\n功能               示例                                                                                                                位运算\n去掉最后一位           0100−>00100100->00100100−>0010                                                                                    x>>1x>>1x>>1\n在最后加一个000        0100−>10000100->10000100−>1000                                                                                    x<<1x<<1x<<1\n在最后加一个1          0100−>10010100->10010100−>1001                                                                                    (x<<1)+1(x<<1)+1(x<<1)+1\n将最后一位变为111       0100−>01010100->01010100−>0101                                                                                    x∥1x\\|1x∥1\n将最后一位变为000       0101−>01000101->01000101−>0100，这里实际上就是先确保最低位变为111，再减去111。                                                         (x∥1)−1(x\\|1)-1(x∥1)−1\n最后一位取反           0100−>01010100->01010100−>0101 ，利用异或性质，其中除最后一位其余不变。                                                               x∧1x\\wedge1x∧1\n把右数的第kkk位变为111   0001−>1001,k=40001->1001,k=40001−>1001,k=4                                                                        x∥(1<<(k−1))x\\|(1<<(k-1))x∥(1<<(k−1))\n把右数的第kkk位变为000   1001−>0001,k=41001->0001,k=41001−>0001,k=4，这个操作实际上就是先得到了100010001000，然后取反得到011101110111，最后利用按位与的性质其余位不变，最高位为000   x&(∼(1<<(k−1)))x\\&(\\sim(1<<(k-1)))x&(∼(1<<(k−1)))\n把右数的第kkk位取反      1000−>0000,k=41000->0000,k=41000−>0000,k=4，利用异或性质                                                                 x∧(1<<(k−1))x\\wedge (1<<(k-1))x∧(1<<(k−1))\n\n由于表长限制，这里接下表继续：\n\n功能                示例                                                                                          位运算\n取末kkk位            1011−>0011,k=21011->0011,k=21011−>0011,k=2                                                  x&((1<<k)−1)x\\&((1<<k)-1)x&((1<<k)−1)\n取右数的第kkk位         1011−>0001,k=41011->0001,k=41011−>0001,k=4，右移k−1k-1k−1位则是去掉了最后的k−1k-1k−1位，我们利用按位与即可将其提取出来   x>>(k−1)&1x>>(k-1)\\&1x>>(k−1)&1\n把末kkk位全变为111      1000−>1111,k=31000->1111,k=31000−>1111,k=3                                                  x∥((1<<k)−1)x\\|((1<<k)-1)x∥((1<<k)−1)\n把末kkk位取反          0101−>1010,k=40101->1010,k=40101−>1010,k=4                                                  x∧((1<<k)−1)x\\wedge ((1<<k)-1)x∧((1<<k)−1)\n把右边连续的111变为000    0111−>00000111->00000111−>0000 ，注意是右起连续的111                                                 x&(x+1)x\\&(x+1)x&(x+1)\n把右起的第一个000变为111   0011−>01110011->01110011−>0111                                                              x∥(x+1)x\\|(x+1)x∥(x+1)\n把右起连续的000变为111    1000−>11111000->11111000−>1111，注意是右起连续的000                                                  x∥(x−1)x\\|(x-1)x∥(x−1)\n取右边连续的111         1011−>00111011->00111011−>0011                                                              (x∧(x+1))>>1(x\\wedge (x+1))>>1(x∧(x+1))>>1\n去掉右起的第一个111的左边    1101−>00011101->00011101−>0001                                                              x&(x∧(x−1))x\\&(x\\wedge (x-1))x&(x∧(x−1))\n\n当然，这里只是一些常用的，并不是全部，位运算的神奇远不止于此。\n\n\n# 4 负数的位运算\n\n首先，我们要知道，在计算机中，运算是使用的二进制补码，而正数的补码是它本身，负数的补码则是符号位不变，其余按位取反，最后再+1+1+1得到的， 例如：\n\n151515,原码:00001111 00001111\\space00001111 补码:000011110000111100001111\n\n−15-15−15,原码:10001111 10001111\\space10001111 补码:111100011111000111110001\n\n那么对于负数的位运算而言，它们的操作都是建立在补码上的，得到的运算结果是补码，最后将补码结果转化成一个普通的十进制数结果。但需要注意的是，符号位是需要参与运算的，而在左移右移操作中，负数右移补111，左移右边补000。例如对于−15-15−15，其补码为11110001,11110001,11110001,右移一位(−15>>1)(-15>>1)(−15>>1)得到的是111110001111100011111000，即−8-8−8，其他的同理。\n\n这里我们介绍几个特殊的性质：\n\n * 快速判断是否为−1-1−1\n   \n   在链式前向星中，我们初始化headheadhead数组为−1-1−1，最后判断是否遍历完uuu的所有边时，即判断iii是否为−1-1−1，我们直接用∼i\\sim i∼i即可。原因就在于−1-1−1的补码是111111111111111111111111，按位取反就变为000000000000000000000000，这实际上就是000。\n\n * 取最低位的111，lowbit函数\n   \n   也就是x&(−x)x\\&(-x)x&(−x)，这在树状数组中起着巨大作用，这里指路一篇树状数组讲解blogblogblog:点这里，我们来证明一下，这里取x=15x=15x=15，对于15&(−15)15\\&(-15)15&(−15)，我们知道，在补码上进行运算得到的是000000010000000100000001，需要注意二元运算的符号位我们需要进行运算。\n\n\n# 5 位运算的一些应用\n\n * 位运算实现乘除法\n   \n   > 将xxx左移一位实现×2\\times 2×2，将xxx右移一位实现÷2\\div2÷2。\n   > \n   > a<<1≡a∗2a<<1 \\equiv a*2a<<1≡a∗2\n   > \n   > a>>1≡a/2a >>1 \\equiv a/2a>>1≡a/2\n\n * 位运算交换两整数\n\n void swap(int &a,int &b){\n      a ^= b;\n      b ^= a;\n      a ^= b;\n  }\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n这效率非常高，我们来剖析其原理，对于a=a∧ba=a\\wedge ba=a∧b，则b=b∧(a∧b)b = b\\wedge(a\\wedge b)b=b∧(a∧b)，根据交换律以及异或性质，得b=b∧b∧a=0∧a=ab=b\\wedge b\\wedge a=0\\wedge a=ab=b∧b∧a=0∧a=a，同理a=(a∧b)∧a=0∧b=ba=(a\\wedge b)\\wedge a=0\\wedge b=ba=(a∧b)∧a=0∧b=b。这样就实现了交换操作。\n\n * 位运算判断奇偶数\n   \n   > 我们知道，在二进制中，最低位决定了是奇数还是偶数，所以我们可以提取出最低位的值，即与111相与即可实现目的，为000则是偶数，为111则是奇数。\n\n * 位运算改变正负性和求绝对值\n\nint change(int a){\n    return ~ a + 1;\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n对于正数而言，补码就是原码，所以按位取反再+1+1+1则得到对应真值负数的补码，而对于负数，其补码进行按位取反再+1+1+1则得到对应真值正数的补码，变为原码。那么知道这个我们就可以特判是否为负数 （这里通过右移313131位，若为正数，则得到的是000，若为负数，则得到的是−1-1−1，而000的补码为000000000000,−1-1−1的补码为111111111111，根据异或性质即可判断感谢读者 （恢。）指出错误，这里应该是要进行按位取反操作，这样如果为负数判断结果才为0 。） ，利用条件表达式就可以根据判断结果求绝对值了。如下：\n\nint abs(int a){\n    return ~(a >> 31) ? a : ~a + 1;\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n * 位运算实现对ppp取余（p为2k2^k2k）\n\nint mod(int a,int p){\n    return a & (p - 1);\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n取余实际上就是舍去大于等于ppp的位数，所以我们只需要保留在ppp范围内的数。由于我们限定了ppp为2k2^k2k，所以(p−1)(p - 1)(p−1)一定是将小于ppp的最高位全部变为了111，这样再进行与操作即可得到余数。\n\n * 位运算统计二进制数111的个数\n\nint count(int x){\n    int cnt = 0;\n    while(x){\n        x = x & (x - 1);\n        cnt ++;\n    }\n    return cnt;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n对于任意的xxx，转换成二进制后，是形如这样的数字：aa...aa10...00aa...aa10...00aa...aa10...00，从右向左数有任意多个000，直到遇见第一个111，字母aaa用来占位，代表111左边的任意数字。x−1x-1x−1转换成二进制后，是形如这样的数字：aa...aa01...11aa...aa01...11aa...aa01...11，从右向左数，原来的任意多个000都变成111，原来的第一个111，变成000，字母aaa部分不变。对xxx 和 x−1x-1x−1 进行 按位与 计算，会得到：aa...aa00...00aa...aa00...00aa...aa00...00，从右向左数，原来的第一个111变成了000，字母a部分不变。所以 x&(x−1)x \\& (x-1)x&(x−1)相当于消除了 xxx 从右向左数遇到的第一个111。那么，xxx转换成二进制后包含多少个111，count函数里的循环就会进行多少次，直到xxx所有的111都被“消除”。\n\n\n# 6 位运算例题\n\n\n# 6.1 更新二进制位\n\n * 题面\n   \n   > 给出两个32位的整数N和M，以及两个二进制位的位置i和j。写一个方法来使得N中的第i到j位等于M（M会是N中从第i为开始到第j位的子串）\n   > \n   > 样例：\n   > \n   > 输入: N=(10000000000)2 M=(10101)2 i=2 j=6\n   > 输出: N=(10001010100)2\n   > 输入: N=(10000000000)2 M=(11111)2 i=2 j=6\n   > 输出: N=(10001111100)2\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n\n * 解题思路\n   \n   结合所学，我们的思路应该就是先将第iii位到第jjj位全部变为000，再将与左移iii位的MMM进行或操作。\n\n * AC代码\n\nclass Solution {\npublic:\n    int updateBits(int n, int m, int i, int j) {\n    \t// 循环遍历从第 i 位到第 j 位\n        for(int pos = i; pos <= j; pos ++ ){\n        \t// 将 n 的第 pos 位设为 0\n            // ~(1 << pos) 创建一个在第 pos 位为 0 其他位为 1 的掩码\n            // 然后使用按位与运算符（&）来将 n 的第 pos 位设置为 0\n        \tn &= ~(1 << pos);\n        }\n        // 将 m 左移 i 位，使 m 的低位对齐到 n 的第 i 位\n        // 然后使用按位或运算符（|）合并 n 和 m\n        // 这样 n 的第 i 到第 j 位就被 m 的相应位所替换\n        return n | (m << i);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 6.2 A+B问题\n\n * 题面\n   \n   > 给出两个整数 a 和 b , 求他们的和并以整数（int）的形式返回。不能使用 + 等数学运算符。\n   > \n   > 样例：\n   > \n   > 输入：\n   > \n   > a = 1\n   > b = 2\n   > \n   > \n   > 1\n   > 2\n   > \n   > 1\n   > 2\n   > \n   > \n   > 输出：\n   > \n   > 3\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 输入：\n   > \n   > a = -1\n   > b = 1\n   > \n   > \n   > 1\n   > 2\n   > \n   > 1\n   > 2\n   > \n   > \n   > 输出：\n   > \n   > 0\n   > \n   > \n   > 1\n   > \n   > 1\n\n * 解题思路\n   \n   这题我们可以利用异或操作来实现，因为异或操作有一个别名叫不进位加法。那么进位操作我们实际上就可以通过a&ba\\&ba&b来实现，因为a&ba\\&ba&b得到的都是aaa和bbb上都有的111，我们再左移即得到的是进位之后的结果，所以a+b=(a∧b)+(a&b<<1)a+b=(a\\wedge b)+(a\\&b<<1)a+b=(a∧b)+(a&b<<1)。通过这样模拟竖式加法操作即可。\n\n * AC代码\n\nclass Solution {\npublic:\n    int aplusb(int a, int b) {\n    \t// 当没有进位需要处理时循环结束\n        while(b != 0){\n        \t// temp_a 存储 a 和 b 的按位异或结果，这相当于不带进位的加法\n            int temp_a = a ^ b;\n            // temp_b 存储 a 和 b 的按位与结果并左移一位，这相当于计算进位\n            // 因为只有两个位都是1时才会产生进位\n            int temp_b = (a & b) << 1;\n\n\t\t\t// 更新 a 为不带进位的加法结果\n            a = temp_a;\n\t\n\t\t\t// 更新 b 为进位\n            b = temp_b;\n        }\n        // 当没有进位时，a 中存储了最终结果，返回 a\n        return a;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 6.3 O(1)时间检测2的幂次\n\n * 题面\n   \n   > 用 O(1) 时间检测整数 n 是否是 2 的幂次。\n   > \n   > 样例\n   > \n   > n=4，返回 true;\n   > \n   > n=5，返回 false.\n   > \n   > 挑战\n   > \n   > O(1) 时间复杂度\n\n * 解题思路\n   \n   首先我们知道2k2^k2k是大于000的，这里我们需要特判，同理，2k2^k2k的二进制表示中只有111个111，故我们可以利用x&(x−1)x\\&(x-1)x&(x−1)来消除唯一的111判断是否等于000即可。\n\n * AC代码\n\nclass Solution {\npublic:\n    bool checkPowerOf2(int n) {\n        // 检查 n 是否大于 0\n        // 2 的幂必须是正数，因为 0 和负数都不是 2 的幂\n        // 检查 n 和 n - 1 的按位与操作是否为 0\n        // 如果 n 是 2 的幂，则其二进制表示中只有一个 1\n        // 例如 2 (10), 4 (100), 8 (1000)\n        // 当 n 是 2 的幂时，n - 1 的二进制表示是 n 的最高位 1 变为 0，\n        // 其余位从 0 变为 1，例如 2 (10) - 1 = 1 (01), 4 (100) - 1 = 3 (011)\n        // 因此 n & (n - 1) 将得到 0\n        return n > 0 && (n & (n - 1)) == 0;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n",normalizedContent:"# 1 位运算概述\n\n我们知道，计算机中的数在内存中都是以二进制形式进行存储的 ，而位运算就是直接对整数在内存中的二进制位进行操作，因此其执行效率非常高，在程序中尽量使用位运算进行操作，这会大大提高程序的性能。\n\n那么，涉及位运算的运算符如下表所示：\n\n符号   描述   运算规则                                  实例（以四位二进制数为例）\n&    与    两个位都为1时，结果才为1。                        0001&0001=1,0001&0000=0,0000&0000=00000001\\&0001=1,0001\\&0000=0,0000\\&0000=00000001&0001=1,0001&0000=0,0000&0000=0000\n|    或    两个位都为0时，结果才为0。                        0001∥0001=0001,0001∥0000=0001,0000∥0000=00000001\\|0001=0001,0001\\|0000=0001,0000\\|0000=00000001∥0001=0001,0001∥0000=0001,0000∥0000=0000\n^    异或   两个位相同为0，相异为1。                         0001∧0001=0000,0001∧0000=1,0000∧0000=00001\n                                                \\wedge0001=0000,0001\\wedge0000=1,0000\\wedge\n                                                0000=00001∧0001=0000,0001∧0000=1,0000∧0000=0\n~    取反   0变1，1变0。                              ∼0=1,∼1=0\\sim0=1,\\sim 1 = 0∼0=1,∼1=0\n<<   左移   各二进位全部左移若干位，高位丢弃，低位补0。                0001<<k=0100，k=20001<<k=0100，k=20001<<k=0100，k=2，kkk是左移的位数，这里k=2k=2k=2\n>>   右移   各二进位全部右移若干位，对无符号数，高位补0，有符号数，右移补111。   0100>>k=0001，k=20100>>k=0001，k=20100>>k=0001，k=2，kkk是右移的位数，这里k=2k=2k=2\n\n看完，你可能会觉得挺简单的，但位运算的难点并不在这，而在于其性质、高级操作和它的应用。\n\n\n# 2 位运算的性质\n\n\n# 2.1 运算符的优先级\n\n优先级需要弄清楚，如果不太清楚可以加小括号确保是想要的运算顺序，这里只是相对优先级，即只是和一些常用的算术运算符做比较。\n\n优先级   运算符                                                                                       结合方向\n1     −（符号运算符）,∼（取反运算符），++（自增），−−（自减）-（符号运算符）,\\sim（取反运算符），                                      从右到左\n      ++（自增），--（自减）−（符号运算符）,∼（取反运算符），++（自增），−−（自减）\n2     ∗（乘）,/（除）,%（取余）*（乘）,/（除）,\\%（取余）∗（乘）,/（除）,%（取余）                                            从左到右\n3     +（加）,−（减）+（加）,-（减）+（加）,−（减）                                                               从左到右\n4     <<（左移），>>（右移）<<（左移），>>（右移）<<（左移），>>（右移）                                                   从左到右\n5     >（大于）,<(小于),>=(大于等于),<=(小于等于)>（大于）,<(小于),>=(大于等于),<=(小于等于)>（大于）,<(小于),>=(大于等于),<=(小于等于)   从左到右\n6     ==(等于),!=（不等于）==(等于),!=（不等于）==(等于),!=（不等于）                                                从左到右\n7     &（按位与）\\&（按位与）&（按位与）                                                                       从左到右\n8     ∧(按位异或)\\wedge (按位异或)∧(按位异或)                                                               从左到右\n9     ∥(按位或)\\|(按位或)∥(按位或)                                                                       从左到右\n\n\n# 2.2 位运算符的运算律\n\n公式名称                  运算规则\n交换律                   a&b=b&a,a∧b=b∧aa\\&b=b\\&a ,a\\wedge b=b\\wedge aa&b=b&a,a∧b=b∧a\n结合律（注意结合律只能在同符号下进行）   (a&b)&c=a&(b&c)(a\\&b)\\&c=a\\&(b\\&c)(a&b)&c=a&(b&c)\n等幂律                   a&a=a，a∥a=aa\\&a=a，a\\|a=aa&a=a，a∥a=a\n零律                    a&0=0a\\&0=0a&0=0\n互补律（注意，这不同于逻辑运算）      a&∼a=0,a∥∼a=−1a\\&\\sim a=0,a\\|\\sim a=-1a&∼a=0,a∥∼a=−1\n同一律                   a∥0=a，a∧0=aa\\|0=a，a\\wedge 0 =aa∥0=a，a∧0=a\n\n以上仅为已证明的运算律（可能存在遗漏），其余的博主均认为是不符合不成立的，注意：千万不要将逻辑运算的运算律或者其他的运算律与这混为一谈。\n\n\n# 3 位运算高级操作\n\n如下表，请读者认真阅读理解，在阅读的过程中可以对示例进行运算。\n\n功能               示例                                                                                                                位运算\n去掉最后一位           0100−>00100100->00100100−>0010                                                                                    x>>1x>>1x>>1\n在最后加一个000        0100−>10000100->10000100−>1000                                                                                    x<<1x<<1x<<1\n在最后加一个1          0100−>10010100->10010100−>1001                                                                                    (x<<1)+1(x<<1)+1(x<<1)+1\n将最后一位变为111       0100−>01010100->01010100−>0101                                                                                    x∥1x\\|1x∥1\n将最后一位变为000       0101−>01000101->01000101−>0100，这里实际上就是先确保最低位变为111，再减去111。                                                         (x∥1)−1(x\\|1)-1(x∥1)−1\n最后一位取反           0100−>01010100->01010100−>0101 ，利用异或性质，其中除最后一位其余不变。                                                               x∧1x\\wedge1x∧1\n把右数的第kkk位变为111   0001−>1001,k=40001->1001,k=40001−>1001,k=4                                                                        x∥(1<<(k−1))x\\|(1<<(k-1))x∥(1<<(k−1))\n把右数的第kkk位变为000   1001−>0001,k=41001->0001,k=41001−>0001,k=4，这个操作实际上就是先得到了100010001000，然后取反得到011101110111，最后利用按位与的性质其余位不变，最高位为000   x&(∼(1<<(k−1)))x\\&(\\sim(1<<(k-1)))x&(∼(1<<(k−1)))\n把右数的第kkk位取反      1000−>0000,k=41000->0000,k=41000−>0000,k=4，利用异或性质                                                                 x∧(1<<(k−1))x\\wedge (1<<(k-1))x∧(1<<(k−1))\n\n由于表长限制，这里接下表继续：\n\n功能                示例                                                                                          位运算\n取末kkk位            1011−>0011,k=21011->0011,k=21011−>0011,k=2                                                  x&((1<<k)−1)x\\&((1<<k)-1)x&((1<<k)−1)\n取右数的第kkk位         1011−>0001,k=41011->0001,k=41011−>0001,k=4，右移k−1k-1k−1位则是去掉了最后的k−1k-1k−1位，我们利用按位与即可将其提取出来   x>>(k−1)&1x>>(k-1)\\&1x>>(k−1)&1\n把末kkk位全变为111      1000−>1111,k=31000->1111,k=31000−>1111,k=3                                                  x∥((1<<k)−1)x\\|((1<<k)-1)x∥((1<<k)−1)\n把末kkk位取反          0101−>1010,k=40101->1010,k=40101−>1010,k=4                                                  x∧((1<<k)−1)x\\wedge ((1<<k)-1)x∧((1<<k)−1)\n把右边连续的111变为000    0111−>00000111->00000111−>0000 ，注意是右起连续的111                                                 x&(x+1)x\\&(x+1)x&(x+1)\n把右起的第一个000变为111   0011−>01110011->01110011−>0111                                                              x∥(x+1)x\\|(x+1)x∥(x+1)\n把右起连续的000变为111    1000−>11111000->11111000−>1111，注意是右起连续的000                                                  x∥(x−1)x\\|(x-1)x∥(x−1)\n取右边连续的111         1011−>00111011->00111011−>0011                                                              (x∧(x+1))>>1(x\\wedge (x+1))>>1(x∧(x+1))>>1\n去掉右起的第一个111的左边    1101−>00011101->00011101−>0001                                                              x&(x∧(x−1))x\\&(x\\wedge (x-1))x&(x∧(x−1))\n\n当然，这里只是一些常用的，并不是全部，位运算的神奇远不止于此。\n\n\n# 4 负数的位运算\n\n首先，我们要知道，在计算机中，运算是使用的二进制补码，而正数的补码是它本身，负数的补码则是符号位不变，其余按位取反，最后再+1+1+1得到的， 例如：\n\n151515,原码:00001111 00001111\\space00001111 补码:000011110000111100001111\n\n−15-15−15,原码:10001111 10001111\\space10001111 补码:111100011111000111110001\n\n那么对于负数的位运算而言，它们的操作都是建立在补码上的，得到的运算结果是补码，最后将补码结果转化成一个普通的十进制数结果。但需要注意的是，符号位是需要参与运算的，而在左移右移操作中，负数右移补111，左移右边补000。例如对于−15-15−15，其补码为11110001,11110001,11110001,右移一位(−15>>1)(-15>>1)(−15>>1)得到的是111110001111100011111000，即−8-8−8，其他的同理。\n\n这里我们介绍几个特殊的性质：\n\n * 快速判断是否为−1-1−1\n   \n   在链式前向星中，我们初始化headheadhead数组为−1-1−1，最后判断是否遍历完uuu的所有边时，即判断iii是否为−1-1−1，我们直接用∼i\\sim i∼i即可。原因就在于−1-1−1的补码是111111111111111111111111，按位取反就变为000000000000000000000000，这实际上就是000。\n\n * 取最低位的111，lowbit函数\n   \n   也就是x&(−x)x\\&(-x)x&(−x)，这在树状数组中起着巨大作用，这里指路一篇树状数组讲解blogblogblog:点这里，我们来证明一下，这里取x=15x=15x=15，对于15&(−15)15\\&(-15)15&(−15)，我们知道，在补码上进行运算得到的是000000010000000100000001，需要注意二元运算的符号位我们需要进行运算。\n\n\n# 5 位运算的一些应用\n\n * 位运算实现乘除法\n   \n   > 将xxx左移一位实现×2\\times 2×2，将xxx右移一位实现÷2\\div2÷2。\n   > \n   > a<<1≡a∗2a<<1 \\equiv a*2a<<1≡a∗2\n   > \n   > a>>1≡a/2a >>1 \\equiv a/2a>>1≡a/2\n\n * 位运算交换两整数\n\n void swap(int &a,int &b){\n      a ^= b;\n      b ^= a;\n      a ^= b;\n  }\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n这效率非常高，我们来剖析其原理，对于a=a∧ba=a\\wedge ba=a∧b，则b=b∧(a∧b)b = b\\wedge(a\\wedge b)b=b∧(a∧b)，根据交换律以及异或性质，得b=b∧b∧a=0∧a=ab=b\\wedge b\\wedge a=0\\wedge a=ab=b∧b∧a=0∧a=a，同理a=(a∧b)∧a=0∧b=ba=(a\\wedge b)\\wedge a=0\\wedge b=ba=(a∧b)∧a=0∧b=b。这样就实现了交换操作。\n\n * 位运算判断奇偶数\n   \n   > 我们知道，在二进制中，最低位决定了是奇数还是偶数，所以我们可以提取出最低位的值，即与111相与即可实现目的，为000则是偶数，为111则是奇数。\n\n * 位运算改变正负性和求绝对值\n\nint change(int a){\n    return ~ a + 1;\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n对于正数而言，补码就是原码，所以按位取反再+1+1+1则得到对应真值负数的补码，而对于负数，其补码进行按位取反再+1+1+1则得到对应真值正数的补码，变为原码。那么知道这个我们就可以特判是否为负数 （这里通过右移313131位，若为正数，则得到的是000，若为负数，则得到的是−1-1−1，而000的补码为000000000000,−1-1−1的补码为111111111111，根据异或性质即可判断感谢读者 （恢。）指出错误，这里应该是要进行按位取反操作，这样如果为负数判断结果才为0 。） ，利用条件表达式就可以根据判断结果求绝对值了。如下：\n\nint abs(int a){\n    return ~(a >> 31) ? a : ~a + 1;\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n * 位运算实现对ppp取余（p为2k2^k2k）\n\nint mod(int a,int p){\n    return a & (p - 1);\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n取余实际上就是舍去大于等于ppp的位数，所以我们只需要保留在ppp范围内的数。由于我们限定了ppp为2k2^k2k，所以(p−1)(p - 1)(p−1)一定是将小于ppp的最高位全部变为了111，这样再进行与操作即可得到余数。\n\n * 位运算统计二进制数111的个数\n\nint count(int x){\n    int cnt = 0;\n    while(x){\n        x = x & (x - 1);\n        cnt ++;\n    }\n    return cnt;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n对于任意的xxx，转换成二进制后，是形如这样的数字：aa...aa10...00aa...aa10...00aa...aa10...00，从右向左数有任意多个000，直到遇见第一个111，字母aaa用来占位，代表111左边的任意数字。x−1x-1x−1转换成二进制后，是形如这样的数字：aa...aa01...11aa...aa01...11aa...aa01...11，从右向左数，原来的任意多个000都变成111，原来的第一个111，变成000，字母aaa部分不变。对xxx 和 x−1x-1x−1 进行 按位与 计算，会得到：aa...aa00...00aa...aa00...00aa...aa00...00，从右向左数，原来的第一个111变成了000，字母a部分不变。所以 x&(x−1)x \\& (x-1)x&(x−1)相当于消除了 xxx 从右向左数遇到的第一个111。那么，xxx转换成二进制后包含多少个111，count函数里的循环就会进行多少次，直到xxx所有的111都被“消除”。\n\n\n# 6 位运算例题\n\n\n# 6.1 更新二进制位\n\n * 题面\n   \n   > 给出两个32位的整数n和m，以及两个二进制位的位置i和j。写一个方法来使得n中的第i到j位等于m（m会是n中从第i为开始到第j位的子串）\n   > \n   > 样例：\n   > \n   > 输入: n=(10000000000)2 m=(10101)2 i=2 j=6\n   > 输出: n=(10001010100)2\n   > 输入: n=(10000000000)2 m=(11111)2 i=2 j=6\n   > 输出: n=(10001111100)2\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n\n * 解题思路\n   \n   结合所学，我们的思路应该就是先将第iii位到第jjj位全部变为000，再将与左移iii位的mmm进行或操作。\n\n * ac代码\n\nclass solution {\npublic:\n    int updatebits(int n, int m, int i, int j) {\n    \t// 循环遍历从第 i 位到第 j 位\n        for(int pos = i; pos <= j; pos ++ ){\n        \t// 将 n 的第 pos 位设为 0\n            // ~(1 << pos) 创建一个在第 pos 位为 0 其他位为 1 的掩码\n            // 然后使用按位与运算符（&）来将 n 的第 pos 位设置为 0\n        \tn &= ~(1 << pos);\n        }\n        // 将 m 左移 i 位，使 m 的低位对齐到 n 的第 i 位\n        // 然后使用按位或运算符（|）合并 n 和 m\n        // 这样 n 的第 i 到第 j 位就被 m 的相应位所替换\n        return n | (m << i);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 6.2 a+b问题\n\n * 题面\n   \n   > 给出两个整数 a 和 b , 求他们的和并以整数（int）的形式返回。不能使用 + 等数学运算符。\n   > \n   > 样例：\n   > \n   > 输入：\n   > \n   > a = 1\n   > b = 2\n   > \n   > \n   > 1\n   > 2\n   > \n   > 1\n   > 2\n   > \n   > \n   > 输出：\n   > \n   > 3\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 输入：\n   > \n   > a = -1\n   > b = 1\n   > \n   > \n   > 1\n   > 2\n   > \n   > 1\n   > 2\n   > \n   > \n   > 输出：\n   > \n   > 0\n   > \n   > \n   > 1\n   > \n   > 1\n\n * 解题思路\n   \n   这题我们可以利用异或操作来实现，因为异或操作有一个别名叫不进位加法。那么进位操作我们实际上就可以通过a&ba\\&ba&b来实现，因为a&ba\\&ba&b得到的都是aaa和bbb上都有的111，我们再左移即得到的是进位之后的结果，所以a+b=(a∧b)+(a&b<<1)a+b=(a\\wedge b)+(a\\&b<<1)a+b=(a∧b)+(a&b<<1)。通过这样模拟竖式加法操作即可。\n\n * ac代码\n\nclass solution {\npublic:\n    int aplusb(int a, int b) {\n    \t// 当没有进位需要处理时循环结束\n        while(b != 0){\n        \t// temp_a 存储 a 和 b 的按位异或结果，这相当于不带进位的加法\n            int temp_a = a ^ b;\n            // temp_b 存储 a 和 b 的按位与结果并左移一位，这相当于计算进位\n            // 因为只有两个位都是1时才会产生进位\n            int temp_b = (a & b) << 1;\n\n\t\t\t// 更新 a 为不带进位的加法结果\n            a = temp_a;\n\t\n\t\t\t// 更新 b 为进位\n            b = temp_b;\n        }\n        // 当没有进位时，a 中存储了最终结果，返回 a\n        return a;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 6.3 o(1)时间检测2的幂次\n\n * 题面\n   \n   > 用 o(1) 时间检测整数 n 是否是 2 的幂次。\n   > \n   > 样例\n   > \n   > n=4，返回 true;\n   > \n   > n=5，返回 false.\n   > \n   > 挑战\n   > \n   > o(1) 时间复杂度\n\n * 解题思路\n   \n   首先我们知道2k2^k2k是大于000的，这里我们需要特判，同理，2k2^k2k的二进制表示中只有111个111，故我们可以利用x&(x−1)x\\&(x-1)x&(x−1)来消除唯一的111判断是否等于000即可。\n\n * ac代码\n\nclass solution {\npublic:\n    bool checkpowerof2(int n) {\n        // 检查 n 是否大于 0\n        // 2 的幂必须是正数，因为 0 和负数都不是 2 的幂\n        // 检查 n 和 n - 1 的按位与操作是否为 0\n        // 如果 n 是 2 的幂，则其二进制表示中只有一个 1\n        // 例如 2 (10), 4 (100), 8 (1000)\n        // 当 n 是 2 的幂时，n - 1 的二进制表示是 n 的最高位 1 变为 0，\n        // 其余位从 0 变为 1，例如 2 (10) - 1 = 1 (01), 4 (100) - 1 = 3 (011)\n        // 因此 n & (n - 1) 将得到 0\n        return n > 0 && (n & (n - 1)) == 0;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n",charsets:{cjk:!0},lastUpdated:"2023/11/25, 16:14:12",lastUpdatedTimestamp:1700900052e3},{title:"Prim算法详解",frontmatter:{title:"Prim算法详解",date:"2020-07-29T11:34:35.000Z",tags:["最小生成树"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/affd0f/",categories:["开发","数据结构与算法","图算法"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/03.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/08.%E5%9B%BE%E7%AE%97%E6%B3%95/04.Prim%E7%AE%97%E6%B3%95%E6%95%99%E7%A8%8B.html",relativePath:"01.开发/03.数据结构与算法/08.图算法/04.Prim算法教程.md",key:"v-4aec2599",path:"/pages/affd0f/",headers:[{level:2,title:"1 最小生成树（Minimum Spanning Tree,MST）",slug:"_1-最小生成树-minimum-spanning-tree-mst",normalizedTitle:"1 最小生成树（minimum spanning tree,mst）",charIndex:2},{level:2,title:"2 Prim算法",slug:"_2-prim算法",normalizedTitle:"2 prim算法",charIndex:659},{level:3,title:"2.1 简介",slug:"_2-1-简介",normalizedTitle:"2.1 简介",charIndex:672},{level:3,title:"2.2 具体步骤",slug:"_2-2-具体步骤",normalizedTitle:"2.2 具体步骤",charIndex:913},{level:3,title:"2.3 算法示例图",slug:"_2-3-算法示例图",normalizedTitle:"2.3 算法示例图",charIndex:1350},{level:3,title:"2.4 算法实现",slug:"_2-4-算法实现",normalizedTitle:"2.4 算法实现",charIndex:1366},{level:3,title:"2.5 算法分析",slug:"_2-5-算法分析",normalizedTitle:"2.5 算法分析",charIndex:4314},{level:3,title:"2.6 测试",slug:"_2-6-测试",normalizedTitle:"2.6 测试",charIndex:4523}],headersStr:"1 最小生成树（Minimum Spanning Tree,MST） 2 Prim算法 2.1 简介 2.2 具体步骤 2.3 算法示例图 2.4 算法实现 2.5 算法分析 2.6 测试",content:'# 1 最小生成树（Minimum Spanning Tree,MST）\n\n在一给定的无向图G=(V,E)G = (V, E)G=(V,E) 中，(u,v)(u, v)(u,v)代表连接顶点uuu 与顶点 vvv 的边，而 w(u,v)w(u, v)w(u,v) 代表此边的权重，若存在 TTT 为 EEE 的子集且为无循环图，使得 w(T)w(T)w(T) 最小，则此 TTT 为 GGG 的最小生成树，因为TTT是由图GGG产生的。\n\n\n\n最小生成树其实是最小权重生成树的简称。我们称求取该生成树的问题成为最小生成树问题。一个连通图可能有多个生成树。当图中的边具有权值时，总会有一个生成树的边的权值之和小于或者等于其它生成树的边的权值之和。广义上而言，对于非连通无向图来说，它的每一连通分量同样有最小生成树，它们的并被称为最小生成森林。以有线电视电缆的架设为例，若只能沿着街道布线，则以街道为边，而路口为顶点，其中必然有一最小生成树能使布线成本最低。\n\n\n\n如图，这个是一个平面图，图中黑色线描述的就是最小生成树，它的权值之和小于其他的生成树。\n\n那么，我们如何来求最小生成树呢，由最小生成树的定义我们可以知道构建最小生成树是可以利用贪心算法去实现的，我们接下来介绍的两种算法也都是利用贪心算法去求得MSTMSTMST的。因为贪心算法的策略就是在每一步尽可能多的选择中选择最优的，在当前看是最好的选择，这种策略虽然一般不能在全局中寻找到最优解，但是对于最小生成树问题来说，它的确可以找到一颗权重最小的树。\n\n\n# 2 Prim算法\n\n\n# 2.1 简介\n\n普里姆算法（Prim\'s algorithm），图论中的一种算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点，且其所有边的权值之和亦为最小。该算法于1930年由捷克数学家沃伊捷赫·亚尔尼克发现；并在1957年由美国计算机科学家罗伯特·普里姆独立发现；1959年，艾兹格·迪科斯彻再次发现了该算法。因此，在某些场合，普里姆算法又被称为DJP算法、亚尔尼克算法或普里姆－亚尔尼克算法。（来源于维基百科）\n\n\n# 2.2 具体步骤\n\nPrim算法是利用贪心算法实现的，我们确定根节点，从这个结点出发。普里姆算法按照以下步骤==逐步扩大树中所含顶点的数目，直到遍及连通图的所有顶点==。下面描述我们==假设N=(V,E)N=(V,E)N=(V,E)是连通网，TETETE是NNN上最小生成树中边的集合==。\n\n① U={u0}(u0∈V),TE={}U=\\{u_0\\}(u_0∈V) ,TE= \\{\\}U={u0 }(u0 ∈V),TE={}。\n\n② 在所有u∈U,v∈(V−U)u∈U,v∈(V-U)u∈U,v∈(V−U)的边(u,v)∈E(u,v)∈E(u,v)∈E找到一条权值最小的边(u0,v0)(u_0,v_0)(u0 ,v0 )并入集合TETETE，同时v0v_0v0 并入集合UUU。\n\n③ 重复②步骤，知道U=VU=VU=V为止。\n\n此时TETETE中必有n−1n-1n−1条边，则T=(V,TE)T=(V,TE)T=(V,TE)即为我们求得的NNN的最小生成树。\n\n\n# 2.3 算法示例图\n\n\n\n\n# 2.4 算法实现\n\n我们如果对Dijkstra算法很熟悉的话，Prim算法也很好实现了，它们都是利用了一样的思路，但却不相同。我们用利用lowcostlowcostlowcost数组来表示到集合中最近的距离，用closestclosestclosest数组来表示最小生成树的边。怎么来表示呢？我们用顶点来形容边，也就是说我们要求的就是closetclosetcloset数组。其中closest[i]closest[i]closest[i]表示的值就是与iii顶点相邻边的顶点序号。具体看代码（附带打印最小生成树代码）。\n\n#include<bits/stdc++.h> //POJ不支持\n\n#define rep(i,a,n) for (int i=a;i<=n;i++)//i为循环变量，a为初始值，n为界限值，递增\n#define per(i,a,n) for (int i=a;i>=n;i--)//i为循环变量， a为初始值，n为界限值，递减。\n#define pb push_back\n#define IOS ios::sync_with_stdio(false);cin.tie(0); cout.tie(0)\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\nconst int inf = 0x3f3f3f3f;//无穷大\nconst int maxn = 1e3;//最大值。\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll>  pll;\ntypedef pair<int, int> pii;\n//*******************************分割线，以上为自定义代码模板***************************************//\n\nint n,m;//图的大小和边数。\nint graph[maxn][maxn];//图\nint lowcost[maxn],closest[maxn];//lowcost[i]表示i到距离集合最近的距离，closest[i]表示i与之相连边的顶点序号。\nint sum;//计算最小生成树的权值总和。\nvoid Prim(int s){\n    //初始化操作，获取基本信息。\n    rep(i,1,n){\n        if(i==s)\n            lowcost[i]=0;\n        else\n            lowcost[i]=graph[s][i];\n        closest[i]=s;\n    }\n    int minn,pos;//距离集合最近的边，pos代表该点的终边下标。\n    sum=0;\n    rep(i,1,n){\n        minn=inf;\n        rep(j,1,n){\n            //找出距离点集合最近的边。\n            if(lowcost[j]!=0&&lowcost[j]<minn){\n                minn=lowcost[j];\n                pos=j;\n            }\n        }\n        if(minn==inf)break;//说明没有找到。\n        sum+=minn;//计算最小生成树的权值之和。\n        lowcost[pos]=0;//加入点集合。\n        rep(j,1,n){\n            //由于点集合中加入了新的点，我们要去更新。\n            if(lowcost[j]!=0&&graph[pos][j]<lowcost[j]){\n                lowcost[j]=graph[pos][j];\n                closest[j]=pos;//改变与顶点j相连的顶点序号。\n            }\n        }\n    }\n    cout<<sum<<endl;//closest数组就是我们要的最小生成树。它代表的就是边。\n}\nvoid print(int s){\n    //打印最小生成树。\n    int temp;\n    rep(i,1,n){\n        //等于s自然不算，故除去这个为n-1条边。\n        if(i!=s){\n            temp=closest[i];\n            cout<<temp<<"->"<<i<<"边权值为："<<graph[temp][i]<<endl;\n        }\n    }\n}\nint main(){\n    //freopen("in.txt", "r", stdin);//提交的时候要注释掉\n    IOS;\n    while(cin>>n>>m){\n        memset(graph,inf,sizeof(graph));//初始化。\n        int u,v,w;//临时变量。\n        rep(i,1,m){\n            cin>>u>>v>>w;\n            //视情况而论，我这里以无向图为例。\n            graph[u][v]=graph[v][u]=w;\n        }\n        //任取根结点，我这里默认取1.\n        Prim(1);\n        print(1);//打印最小生成树。\n    }\n    return 0;\n}\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n\n# 2.5 算法分析\n\n对于此算法，我们图中有nnn个顶点，则第一个进行初始化的循环语句的频度为nnn,第二个循环语句的频度为nnn，==但其中第二个循环中有两个内循环：第一个是在lowcostlowcostlowcost中求最小值，其频度为nnn，第二个是重新选择具有最小权值的边，频度为nnn==，由此我们可知Prim算法的时间复杂度为O(n2)O(n^2)O(n2)，与图中的边数无关，故十分适合于稠密图。\n\n\n# 2.6 测试\n\n我们用示例来测试：\n\n7 11\n1 2 7\n1 4 5\n2 4 9\n2 3 8\n2 5 7\n4 5 15\n4 6 6\n6 7 11\n5 6 8\n5 7 9\n3 5 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n测试结果如图：\n\n',normalizedContent:'# 1 最小生成树（minimum spanning tree,mst）\n\n在一给定的无向图g=(v,e)g = (v, e)g=(v,e) 中，(u,v)(u, v)(u,v)代表连接顶点uuu 与顶点 vvv 的边，而 w(u,v)w(u, v)w(u,v) 代表此边的权重，若存在 ttt 为 eee 的子集且为无循环图，使得 w(t)w(t)w(t) 最小，则此 ttt 为 ggg 的最小生成树，因为ttt是由图ggg产生的。\n\n\n\n最小生成树其实是最小权重生成树的简称。我们称求取该生成树的问题成为最小生成树问题。一个连通图可能有多个生成树。当图中的边具有权值时，总会有一个生成树的边的权值之和小于或者等于其它生成树的边的权值之和。广义上而言，对于非连通无向图来说，它的每一连通分量同样有最小生成树，它们的并被称为最小生成森林。以有线电视电缆的架设为例，若只能沿着街道布线，则以街道为边，而路口为顶点，其中必然有一最小生成树能使布线成本最低。\n\n\n\n如图，这个是一个平面图，图中黑色线描述的就是最小生成树，它的权值之和小于其他的生成树。\n\n那么，我们如何来求最小生成树呢，由最小生成树的定义我们可以知道构建最小生成树是可以利用贪心算法去实现的，我们接下来介绍的两种算法也都是利用贪心算法去求得mstmstmst的。因为贪心算法的策略就是在每一步尽可能多的选择中选择最优的，在当前看是最好的选择，这种策略虽然一般不能在全局中寻找到最优解，但是对于最小生成树问题来说，它的确可以找到一颗权重最小的树。\n\n\n# 2 prim算法\n\n\n# 2.1 简介\n\n普里姆算法（prim\'s algorithm），图论中的一种算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点，且其所有边的权值之和亦为最小。该算法于1930年由捷克数学家沃伊捷赫·亚尔尼克发现；并在1957年由美国计算机科学家罗伯特·普里姆独立发现；1959年，艾兹格·迪科斯彻再次发现了该算法。因此，在某些场合，普里姆算法又被称为djp算法、亚尔尼克算法或普里姆－亚尔尼克算法。（来源于维基百科）\n\n\n# 2.2 具体步骤\n\nprim算法是利用贪心算法实现的，我们确定根节点，从这个结点出发。普里姆算法按照以下步骤==逐步扩大树中所含顶点的数目，直到遍及连通图的所有顶点==。下面描述我们==假设n=(v,e)n=(v,e)n=(v,e)是连通网，tetete是nnn上最小生成树中边的集合==。\n\n① u={u0}(u0∈v),te={}u=\\{u_0\\}(u_0∈v) ,te= \\{\\}u={u0 }(u0 ∈v),te={}。\n\n② 在所有u∈u,v∈(v−u)u∈u,v∈(v-u)u∈u,v∈(v−u)的边(u,v)∈e(u,v)∈e(u,v)∈e找到一条权值最小的边(u0,v0)(u_0,v_0)(u0 ,v0 )并入集合tetete，同时v0v_0v0 并入集合uuu。\n\n③ 重复②步骤，知道u=vu=vu=v为止。\n\n此时tetete中必有n−1n-1n−1条边，则t=(v,te)t=(v,te)t=(v,te)即为我们求得的nnn的最小生成树。\n\n\n# 2.3 算法示例图\n\n\n\n\n# 2.4 算法实现\n\n我们如果对dijkstra算法很熟悉的话，prim算法也很好实现了，它们都是利用了一样的思路，但却不相同。我们用利用lowcostlowcostlowcost数组来表示到集合中最近的距离，用closestclosestclosest数组来表示最小生成树的边。怎么来表示呢？我们用顶点来形容边，也就是说我们要求的就是closetclosetcloset数组。其中closest[i]closest[i]closest[i]表示的值就是与iii顶点相邻边的顶点序号。具体看代码（附带打印最小生成树代码）。\n\n#include<bits/stdc++.h> //poj不支持\n\n#define rep(i,a,n) for (int i=a;i<=n;i++)//i为循环变量，a为初始值，n为界限值，递增\n#define per(i,a,n) for (int i=a;i>=n;i--)//i为循环变量， a为初始值，n为界限值，递减。\n#define pb push_back\n#define ios ios::sync_with_stdio(false);cin.tie(0); cout.tie(0)\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\nconst int inf = 0x3f3f3f3f;//无穷大\nconst int maxn = 1e3;//最大值。\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll>  pll;\ntypedef pair<int, int> pii;\n//*******************************分割线，以上为自定义代码模板***************************************//\n\nint n,m;//图的大小和边数。\nint graph[maxn][maxn];//图\nint lowcost[maxn],closest[maxn];//lowcost[i]表示i到距离集合最近的距离，closest[i]表示i与之相连边的顶点序号。\nint sum;//计算最小生成树的权值总和。\nvoid prim(int s){\n    //初始化操作，获取基本信息。\n    rep(i,1,n){\n        if(i==s)\n            lowcost[i]=0;\n        else\n            lowcost[i]=graph[s][i];\n        closest[i]=s;\n    }\n    int minn,pos;//距离集合最近的边，pos代表该点的终边下标。\n    sum=0;\n    rep(i,1,n){\n        minn=inf;\n        rep(j,1,n){\n            //找出距离点集合最近的边。\n            if(lowcost[j]!=0&&lowcost[j]<minn){\n                minn=lowcost[j];\n                pos=j;\n            }\n        }\n        if(minn==inf)break;//说明没有找到。\n        sum+=minn;//计算最小生成树的权值之和。\n        lowcost[pos]=0;//加入点集合。\n        rep(j,1,n){\n            //由于点集合中加入了新的点，我们要去更新。\n            if(lowcost[j]!=0&&graph[pos][j]<lowcost[j]){\n                lowcost[j]=graph[pos][j];\n                closest[j]=pos;//改变与顶点j相连的顶点序号。\n            }\n        }\n    }\n    cout<<sum<<endl;//closest数组就是我们要的最小生成树。它代表的就是边。\n}\nvoid print(int s){\n    //打印最小生成树。\n    int temp;\n    rep(i,1,n){\n        //等于s自然不算，故除去这个为n-1条边。\n        if(i!=s){\n            temp=closest[i];\n            cout<<temp<<"->"<<i<<"边权值为："<<graph[temp][i]<<endl;\n        }\n    }\n}\nint main(){\n    //freopen("in.txt", "r", stdin);//提交的时候要注释掉\n    ios;\n    while(cin>>n>>m){\n        memset(graph,inf,sizeof(graph));//初始化。\n        int u,v,w;//临时变量。\n        rep(i,1,m){\n            cin>>u>>v>>w;\n            //视情况而论，我这里以无向图为例。\n            graph[u][v]=graph[v][u]=w;\n        }\n        //任取根结点，我这里默认取1.\n        prim(1);\n        print(1);//打印最小生成树。\n    }\n    return 0;\n}\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n\n# 2.5 算法分析\n\n对于此算法，我们图中有nnn个顶点，则第一个进行初始化的循环语句的频度为nnn,第二个循环语句的频度为nnn，==但其中第二个循环中有两个内循环：第一个是在lowcostlowcostlowcost中求最小值，其频度为nnn，第二个是重新选择具有最小权值的边，频度为nnn==，由此我们可知prim算法的时间复杂度为o(n2)o(n^2)o(n2)，与图中的边数无关，故十分适合于稠密图。\n\n\n# 2.6 测试\n\n我们用示例来测试：\n\n7 11\n1 2 7\n1 4 5\n2 4 9\n2 3 8\n2 5 7\n4 5 15\n4 6 6\n6 7 11\n5 6 8\n5 7 9\n3 5 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n测试结果如图：\n\n',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"Kruskal算法详解",frontmatter:{title:"Kruskal算法详解",date:"2020-08-11T16:15:34.000Z",tags:["最小生成树"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/a97764/",categories:["开发","数据结构与算法","图算法"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/03.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/08.%E5%9B%BE%E7%AE%97%E6%B3%95/03.Kruskal%E7%AE%97%E6%B3%95%E6%95%99%E7%A8%8B.html",relativePath:"01.开发/03.数据结构与算法/08.图算法/03.Kruskal算法教程.md",key:"v-28760263",path:"/pages/a97764/",headers:[{level:2,title:"1、简介",slug:"_1、简介",normalizedTitle:"1、简介",charIndex:2},{level:2,title:"2、构造过程",slug:"_2、构造过程",normalizedTitle:"2、构造过程",charIndex:240},{level:2,title:"3、示例",slug:"_3、示例",normalizedTitle:"3、示例",charIndex:633},{level:2,title:"4、算法实现",slug:"_4、算法实现",normalizedTitle:"4、算法实现",charIndex:644},{level:2,title:"5、算法分析",slug:"_5、算法分析",normalizedTitle:"5、算法分析",charIndex:3325},{level:2,title:"6、测试",slug:"_6、测试",normalizedTitle:"6、测试",charIndex:3513}],headersStr:"1、简介 2、构造过程 3、示例 4、算法实现 5、算法分析 6、测试",content:'# 1、简介\n\nKruskal算法是一种用来查找最小生成树（MSTMSTMST）的算法，由Joseph Kruskal在1956年发表。求最小生成树的算法常用有两种：Kruskal算法和Prim算法。这里指路一篇Prim算法的详解blog：https://blog.csdn.net/hzf0701/article/details/107927858。与Prim算法不同的是，该算法的核心思想是归并边，而Prim算法的核心思想是归并点。这里我们会在后面的实现过程中看到。\n\n\n# 2、构造过程\n\n假设连通网N=(V,E)N=(V,E)N=(V,E)，将NNN中的边按权值从小到大的顺序排列。 ①初始状态为只有nnn个顶点而无边的非连通图T=(V,{})T=(V,\\{\\})T=(V,{})，图中每个顶点自成一个连通分量。 ②在EEE中选择权值最小的边，若该边依附的顶点落在TTT中不同的连通分量上（即不形成回路），则将此边将入到TTT中，否则舍去此边而选择下一条权值最小的边。 ③重复②，直到TTT中所有的顶点都在同一连通分量上为止。\n\n这个算法的构造过程十分简洁明了，那么为什么这样的构造过程能否形成最小生成树呢？我们来看第二个步骤，因为我们选取的边的顶点是不同的连通分量，且边权值是最小的，所以我们保证加入的边都不使得TTT有回路，且权值也最小。这样最后当所有的连通分量都相同时，即所有的顶点都在生成树中被连接成功了，我们构造成的树也就是最小生成树了。\n\n\n# 3、示例\n\n\n\n\n# 4、算法实现\n\n步骤： ①将存储边的数组temp按权值从小到大排序，注意进行运算符重载。 ②初始化连通分量数组verxverxverx。 ③依次查看数组temp的边，循环执行以下操作。\n\n * 依次从排好序的数组temp中选出一条边(u,v)(u,v)(u,v)；\n * 在verxverxverx中分别查找uuu和vvv所在的连通分量v1和v2v_1和v_2v1 和v2 ，进行判断。\n   * 如果v1v_1v1 和v2v_2v2 不等，说明所选的两个顶点分别属于不同的连通分量，则将此边存入最小生成树treetreetree，并合并v1v_1v1 和v2v_2v2 这个两个连通分量。\n   * 如果v1v_1v1 和v2v_2v2 相等，则说明所选的两个顶点属于同一个连通分量，舍去此边而选择下一条权值最小的边。\n\n#include<bits/stdc++.h> //POJ不支持\n\n#define rep(i,a,n) for (int i=a;i<=n;i++)//i为循环变量，a为初始值，n为界限值，递增\n#define per(i,a,n) for (int i=a;i>=n;i--)//i为循环变量， a为初始值，n为界限值，递减。\n#define pb push_back\n#define IOS ios::sync_with_stdio(false);cin.tie(0); cout.tie(0)\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\nconst int inf = 0x3f3f3f3f;//无穷大\nconst int maxn = 1e5;//最大值。\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll>  pll;\ntypedef pair<int, int> pii;\n//*******************************分割线，以上为自定义代码模板***************************************//\n\nstruct edge{\n    int s;//边的起始顶点。\n    int e;//边的终端顶点。\n    int w;//边权值。\n    bool operator < (const edge &a){\n        return w<a.w;\n    }\n};\nedge temp[maxn];//临时数组存储边。\nint verx[maxn];//辅助数组，判断是否连通。\nedge tree[maxn];//最小生成树。\nint n,m;//n*n的图，m条边。\nint cnt;//统计生成结点个数，若不满足n个，则生成失败。\nint sum;//最小生成树权值总和。\nvoid print(){\n    //打印最小生成树函数。\n    cout<<"最小生成树的权值总和为："<<sum<<endl;\n    rep(i,0,cnt-1){\n        cout<<tree[i].s<<" "<<tree[i].e<<"边权值为"<<tree[i].w<<endl;\n    }\n}\nvoid Kruskal(){\n    rep(i,1,n)\n        verx[i]=i;//这里表示各顶点自成一个连通分量。\n    cnt=0;sum=0;\n    sort(temp,temp+m);//将边按权值排列。\n    int v1,v2;\n    rep(i,0,m-1){\n        v1=verx[temp[i].s];\n        v2=verx[temp[i].e];\n        if(v1!=v2){\n            tree[cnt].s=temp[i].s;tree[cnt].e=temp[i].e;tree[cnt].w=temp[i].w;//并入最小生成树。\n            rep(j,1,n){\n                //合并v1和v2的两个分量，即两个集合统一编号。\n                if(verx[j]==v2)verx[j]=v1; //默认集合编号为v2的改为v1.\n            }\n            sum+=tree[cnt].w;\n            cnt++;\n        }\n    }\n    //结束双层for循环之后得到tree即是最小生成树。\n    print();\n}\nint main(){\n    //freopen("in.txt", "r", stdin);//提交的时候要注释掉\n    IOS;\n    while(cin>>n>>m){\n        int u,v,w;\n        rep(i,0,m-1){\n            cin>>u>>v>>w;\n            temp[i].s=u;temp[i].e=v;temp[i].w=w;\n        }\n        Kruskal();\n    }\n    return 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n\n\n\n# 5、算法分析\n\n对于有mmm条边和nnn个顶点的图。在forforfor循环中最耗时的操作就是合并两个不同的连通分量，第一个循环语句的频度为mmm，第二个循环由于存在ififif语句，所以平均频度是log2nlog_2nlog2 n，所以该算法的平均时间复杂度为O(mlog2n)O(mlog_2n)O(mlog2 n)，故和Prim算法相比 此算法适合用于稀疏图。\n\n\n# 6、测试\n\n以示例数据为测试样例：\n\n7 11\n1 2 7\n1 4 5\n2 4 9\n2 3 8\n2 5 7\n4 5 15\n4 6 6\n6 7 11\n5 6 8\n5 7 9\n3 5 5\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n测试结果如图：',normalizedContent:'# 1、简介\n\nkruskal算法是一种用来查找最小生成树（mstmstmst）的算法，由joseph kruskal在1956年发表。求最小生成树的算法常用有两种：kruskal算法和prim算法。这里指路一篇prim算法的详解blog：https://blog.csdn.net/hzf0701/article/details/107927858。与prim算法不同的是，该算法的核心思想是归并边，而prim算法的核心思想是归并点。这里我们会在后面的实现过程中看到。\n\n\n# 2、构造过程\n\n假设连通网n=(v,e)n=(v,e)n=(v,e)，将nnn中的边按权值从小到大的顺序排列。 ①初始状态为只有nnn个顶点而无边的非连通图t=(v,{})t=(v,\\{\\})t=(v,{})，图中每个顶点自成一个连通分量。 ②在eee中选择权值最小的边，若该边依附的顶点落在ttt中不同的连通分量上（即不形成回路），则将此边将入到ttt中，否则舍去此边而选择下一条权值最小的边。 ③重复②，直到ttt中所有的顶点都在同一连通分量上为止。\n\n这个算法的构造过程十分简洁明了，那么为什么这样的构造过程能否形成最小生成树呢？我们来看第二个步骤，因为我们选取的边的顶点是不同的连通分量，且边权值是最小的，所以我们保证加入的边都不使得ttt有回路，且权值也最小。这样最后当所有的连通分量都相同时，即所有的顶点都在生成树中被连接成功了，我们构造成的树也就是最小生成树了。\n\n\n# 3、示例\n\n\n\n\n# 4、算法实现\n\n步骤： ①将存储边的数组temp按权值从小到大排序，注意进行运算符重载。 ②初始化连通分量数组verxverxverx。 ③依次查看数组temp的边，循环执行以下操作。\n\n * 依次从排好序的数组temp中选出一条边(u,v)(u,v)(u,v)；\n * 在verxverxverx中分别查找uuu和vvv所在的连通分量v1和v2v_1和v_2v1 和v2 ，进行判断。\n   * 如果v1v_1v1 和v2v_2v2 不等，说明所选的两个顶点分别属于不同的连通分量，则将此边存入最小生成树treetreetree，并合并v1v_1v1 和v2v_2v2 这个两个连通分量。\n   * 如果v1v_1v1 和v2v_2v2 相等，则说明所选的两个顶点属于同一个连通分量，舍去此边而选择下一条权值最小的边。\n\n#include<bits/stdc++.h> //poj不支持\n\n#define rep(i,a,n) for (int i=a;i<=n;i++)//i为循环变量，a为初始值，n为界限值，递增\n#define per(i,a,n) for (int i=a;i>=n;i--)//i为循环变量， a为初始值，n为界限值，递减。\n#define pb push_back\n#define ios ios::sync_with_stdio(false);cin.tie(0); cout.tie(0)\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\nconst int inf = 0x3f3f3f3f;//无穷大\nconst int maxn = 1e5;//最大值。\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll>  pll;\ntypedef pair<int, int> pii;\n//*******************************分割线，以上为自定义代码模板***************************************//\n\nstruct edge{\n    int s;//边的起始顶点。\n    int e;//边的终端顶点。\n    int w;//边权值。\n    bool operator < (const edge &a){\n        return w<a.w;\n    }\n};\nedge temp[maxn];//临时数组存储边。\nint verx[maxn];//辅助数组，判断是否连通。\nedge tree[maxn];//最小生成树。\nint n,m;//n*n的图，m条边。\nint cnt;//统计生成结点个数，若不满足n个，则生成失败。\nint sum;//最小生成树权值总和。\nvoid print(){\n    //打印最小生成树函数。\n    cout<<"最小生成树的权值总和为："<<sum<<endl;\n    rep(i,0,cnt-1){\n        cout<<tree[i].s<<" "<<tree[i].e<<"边权值为"<<tree[i].w<<endl;\n    }\n}\nvoid kruskal(){\n    rep(i,1,n)\n        verx[i]=i;//这里表示各顶点自成一个连通分量。\n    cnt=0;sum=0;\n    sort(temp,temp+m);//将边按权值排列。\n    int v1,v2;\n    rep(i,0,m-1){\n        v1=verx[temp[i].s];\n        v2=verx[temp[i].e];\n        if(v1!=v2){\n            tree[cnt].s=temp[i].s;tree[cnt].e=temp[i].e;tree[cnt].w=temp[i].w;//并入最小生成树。\n            rep(j,1,n){\n                //合并v1和v2的两个分量，即两个集合统一编号。\n                if(verx[j]==v2)verx[j]=v1; //默认集合编号为v2的改为v1.\n            }\n            sum+=tree[cnt].w;\n            cnt++;\n        }\n    }\n    //结束双层for循环之后得到tree即是最小生成树。\n    print();\n}\nint main(){\n    //freopen("in.txt", "r", stdin);//提交的时候要注释掉\n    ios;\n    while(cin>>n>>m){\n        int u,v,w;\n        rep(i,0,m-1){\n            cin>>u>>v>>w;\n            temp[i].s=u;temp[i].e=v;temp[i].w=w;\n        }\n        kruskal();\n    }\n    return 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n\n\n\n# 5、算法分析\n\n对于有mmm条边和nnn个顶点的图。在forforfor循环中最耗时的操作就是合并两个不同的连通分量，第一个循环语句的频度为mmm，第二个循环由于存在ififif语句，所以平均频度是log2nlog_2nlog2 n，所以该算法的平均时间复杂度为o(mlog2n)o(mlog_2n)o(mlog2 n)，故和prim算法相比 此算法适合用于稀疏图。\n\n\n# 6、测试\n\n以示例数据为测试样例：\n\n7 11\n1 2 7\n1 4 5\n2 4 9\n2 3 8\n2 5 7\n4 5 15\n4 6 6\n6 7 11\n5 6 8\n5 7 9\n3 5 5\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n测试结果如图：',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"Floyd算法教程",frontmatter:{title:"Floyd算法教程",date:"2020-07-27T16:15:34.000Z",tags:["最短路"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/3610c3/",categories:["开发","数据结构与算法","图算法"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/03.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/08.%E5%9B%BE%E7%AE%97%E6%B3%95/01.Floyd%E7%AE%97%E6%B3%95%E6%95%99%E7%A8%8B.html",relativePath:"01.开发/03.数据结构与算法/08.图算法/01.Floyd算法教程.md",key:"v-857b513e",path:"/pages/3610c3/",headers:[{level:2,title:"1 简介",slug:"_1-简介",normalizedTitle:"1 简介",charIndex:2},{level:2,title:"2 算法原理",slug:"_2-算法原理",normalizedTitle:"2 算法原理",charIndex:161},{level:2,title:"3 邻接矩阵解题模板",slug:"_3-邻接矩阵解题模板",normalizedTitle:"3 邻接矩阵解题模板",charIndex:729},{level:2,title:"4 邻接表解题模板",slug:"_4-邻接表解题模板",normalizedTitle:"4 邻接表解题模板",charIndex:2702}],headersStr:"1 简介 2 算法原理 3 邻接矩阵解题模板 4 邻接表解题模板",content:'# 1 简介\n\nFloyd算法又称为插点法，是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法，可以正确处理有向图或无向图或负权（但不可存在负权回路)的最短路径问题，同时也被用于计算有向图的传递闭包。该算法名称以创始人之一、1978年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名。\n\n\n# 2 算法原理\n\n在给出的一张具有权值图中，我们已知每个顶点v与每个顶点u中的最短距离(即使无法到达，我们也认为是有距离的，但距离为无穷大）。对于最短距离表示，我们用dis[v][u]来表示顶点v到顶点u的最短距离，一开始没进行任何操作时，则表示他们的最短距离，就是顶点v到达顶点u的直接距离。\n\nOK，那么如果我现在有一个中转站（中转顶点temp），我先从顶点v到达顶点temp，再从顶点temp到达顶点u，则这段距离我们可以表示为dis[v][temp]+dis[temp][u]，如果这段距离比我们目前的直接到达方式更小的话，那么我们不就可以更新我们的最短距离dis[v][u]了吗？那么temp这个中转顶点可以是图中的所有顶点，如果我们不断把所有顶点插入作为中转顶点，再不断更新最短距离，最后，得到的dis[n][n]自然是多源点之间的最短路径了。我们由上述推导也可求得我们的状态转移方程dis[v][u]=min(dis[v][u],dis[v][temp]+dis[temp][u])，这就是Floyd算法的思想与原理，不断插入中转顶点，利用动态规划思想来实现。\n\n这里我们还要记录最短路径的方案，针对有些要求最短路径方案的题，我们用path[v][u]的值来记录顶点v到顶点u的中转顶点，若为-1则表示无中转顶点。\n\n\n# 3 邻接矩阵解题模板\n\n存储结构：\n\nconst int maxn=1000;//maxn表示图的最大顶点数\nint graph[maxn][maxn];\nint n;//图的实际顶点数\nint dis[maxn][maxn];//最短距离\nconst int inf=0x3f3f3f3f;//代表无穷大\nint path[maxn][maxn];//记录中转顶点\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n//Floyd算法核心\nvoid floyd(int n){\n    //顶点数目。\n    int i,j,k;//循环变量。\n    memset(dis,inf,sizeof(dis));//调用这个函数需包含memory.h头文件\n    memset(path,-1,sizeof(path));\n    for(i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            //初始化dis。\n            dis[i][j]=graph[i][j];\n        }\n    }\n    for(k=0;k<n;k++){\n    //不断插点\n        for(i=0;i<n;i++){\n            for(j=0;j<n;j++){\n            //对图中所有点之间的最短距离进行更新。\n                if(dis[i][j]>dis[i][k]+dis[k][j]){\n                    path[i][j]=k;//记录中转顶点。\n                    dis[i][j]=dis[i][k]+dis[k][j];//更新。\n                }\n            }\n   \t    }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n我们现在来输出最短路径，由于我们记录了中转顶点，那么我们可以借助我们求得的path数组来实现。如果path[i][j]的值不为-1的话，说明这个值就为中转顶点，可这样最短路径就求出来了吗？显然不是，我们还要继续判断i和k之间以及k和j之间有没有中转顶点。我们可以利用递归思想来实现这个方法输出最短路径。\n\nvoid print_path(int i,int j){\n    int k=path[i][j];\n    if(k==-1)\n        //说明没有中转顶点，直接返回.\n        return;\n    print_path(i,k);//寻找i和k之间\n    cout<<k<<",";\n    print_path(k,j);//寻找k和j之间\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n最后，再设置一个打印我们所求的结果的方法，比较简单，核心就是上面两个函数。\n\nvoid print_result(){\n    int i,j;\n    for(i=0;i<n;i++){\n        for(j=0;j<n;j++){\n              if(dis[i][j]==inf){\n                  //我们先前说过，无法到达我们设置距离为无穷大，则他们之前没有路径\n                  cout<<i<<"和"<<j<<"之间没有路径"<<endl;\n              }\n              else{\n                  cout<<i<<"和"<<j<<"的最短路径为"<<dis[i][j]<<endl;\n                  cout<<"路径方案为："<<i<<",";\n                  print_path(i,j);\n                  cout<<j<<endl;\n              }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n----------------------------------------\n\n\n# 4 邻接表解题模板\n\n存储结构：\n\nconst int maxn=1000;\ntypedef struct arc{\n    //边的信息\n    int adjust;//该边所指向的顶点。\n    int weight;//该边的权值。\n    struct arc *next;//指向一条边。\n}arc,*arclink;\n\ntypedef struct vex{\n    arclink firstarc;//该顶点的第一条边。\n}vex,vexs[maxn];\ntypedef struct graph{\n    vexs adj;\n    int arcnum;//边数\n    int vexnum;//顶点数\n}graph;\ngraph G;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n//初始化操作就不在这写了，最短距离还是用dis[maxn][maxn]表示，中转站顶点用path[maxn][maxn]毕竟我们的核心是解决Floyd算法。\n\nvoid floyd(){\n    int i,j,k;\n    //初始化dis\n    for(i=0;i<G.vexnum;i++){\n        for(j=0;j<G.vexnum;j++){\n            if(i==j)dis[i][j]=0;\n            else dis[i][j]=inf;\n        }\n    }\n    memset(path,-1,sizeof(path));//初始化path数组\n    arclink *p;//辅助作用\n    for(i=0;i<G.vexnum;i++){\n        p=G.adj[i].firstarc;\n        while(p){\n            //此操作是为了记录所有顶点之间的距离\n            dis[i][s->adjust]=s->wight;\n            s=s->next;\n        }\n    }\n    //到了这一步，就跟上面的是一样了，因为我们已经得到了dis数组和path数组的值了。下面利用dp并记录中转顶点，同种套路。\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n',normalizedContent:'# 1 简介\n\nfloyd算法又称为插点法，是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法，可以正确处理有向图或无向图或负权（但不可存在负权回路)的最短路径问题，同时也被用于计算有向图的传递闭包。该算法名称以创始人之一、1978年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名。\n\n\n# 2 算法原理\n\n在给出的一张具有权值图中，我们已知每个顶点v与每个顶点u中的最短距离(即使无法到达，我们也认为是有距离的，但距离为无穷大）。对于最短距离表示，我们用dis[v][u]来表示顶点v到顶点u的最短距离，一开始没进行任何操作时，则表示他们的最短距离，就是顶点v到达顶点u的直接距离。\n\nok，那么如果我现在有一个中转站（中转顶点temp），我先从顶点v到达顶点temp，再从顶点temp到达顶点u，则这段距离我们可以表示为dis[v][temp]+dis[temp][u]，如果这段距离比我们目前的直接到达方式更小的话，那么我们不就可以更新我们的最短距离dis[v][u]了吗？那么temp这个中转顶点可以是图中的所有顶点，如果我们不断把所有顶点插入作为中转顶点，再不断更新最短距离，最后，得到的dis[n][n]自然是多源点之间的最短路径了。我们由上述推导也可求得我们的状态转移方程dis[v][u]=min(dis[v][u],dis[v][temp]+dis[temp][u])，这就是floyd算法的思想与原理，不断插入中转顶点，利用动态规划思想来实现。\n\n这里我们还要记录最短路径的方案，针对有些要求最短路径方案的题，我们用path[v][u]的值来记录顶点v到顶点u的中转顶点，若为-1则表示无中转顶点。\n\n\n# 3 邻接矩阵解题模板\n\n存储结构：\n\nconst int maxn=1000;//maxn表示图的最大顶点数\nint graph[maxn][maxn];\nint n;//图的实际顶点数\nint dis[maxn][maxn];//最短距离\nconst int inf=0x3f3f3f3f;//代表无穷大\nint path[maxn][maxn];//记录中转顶点\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n//floyd算法核心\nvoid floyd(int n){\n    //顶点数目。\n    int i,j,k;//循环变量。\n    memset(dis,inf,sizeof(dis));//调用这个函数需包含memory.h头文件\n    memset(path,-1,sizeof(path));\n    for(i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            //初始化dis。\n            dis[i][j]=graph[i][j];\n        }\n    }\n    for(k=0;k<n;k++){\n    //不断插点\n        for(i=0;i<n;i++){\n            for(j=0;j<n;j++){\n            //对图中所有点之间的最短距离进行更新。\n                if(dis[i][j]>dis[i][k]+dis[k][j]){\n                    path[i][j]=k;//记录中转顶点。\n                    dis[i][j]=dis[i][k]+dis[k][j];//更新。\n                }\n            }\n   \t    }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n我们现在来输出最短路径，由于我们记录了中转顶点，那么我们可以借助我们求得的path数组来实现。如果path[i][j]的值不为-1的话，说明这个值就为中转顶点，可这样最短路径就求出来了吗？显然不是，我们还要继续判断i和k之间以及k和j之间有没有中转顶点。我们可以利用递归思想来实现这个方法输出最短路径。\n\nvoid print_path(int i,int j){\n    int k=path[i][j];\n    if(k==-1)\n        //说明没有中转顶点，直接返回.\n        return;\n    print_path(i,k);//寻找i和k之间\n    cout<<k<<",";\n    print_path(k,j);//寻找k和j之间\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n最后，再设置一个打印我们所求的结果的方法，比较简单，核心就是上面两个函数。\n\nvoid print_result(){\n    int i,j;\n    for(i=0;i<n;i++){\n        for(j=0;j<n;j++){\n              if(dis[i][j]==inf){\n                  //我们先前说过，无法到达我们设置距离为无穷大，则他们之前没有路径\n                  cout<<i<<"和"<<j<<"之间没有路径"<<endl;\n              }\n              else{\n                  cout<<i<<"和"<<j<<"的最短路径为"<<dis[i][j]<<endl;\n                  cout<<"路径方案为："<<i<<",";\n                  print_path(i,j);\n                  cout<<j<<endl;\n              }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n----------------------------------------\n\n\n# 4 邻接表解题模板\n\n存储结构：\n\nconst int maxn=1000;\ntypedef struct arc{\n    //边的信息\n    int adjust;//该边所指向的顶点。\n    int weight;//该边的权值。\n    struct arc *next;//指向一条边。\n}arc,*arclink;\n\ntypedef struct vex{\n    arclink firstarc;//该顶点的第一条边。\n}vex,vexs[maxn];\ntypedef struct graph{\n    vexs adj;\n    int arcnum;//边数\n    int vexnum;//顶点数\n}graph;\ngraph g;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n//初始化操作就不在这写了，最短距离还是用dis[maxn][maxn]表示，中转站顶点用path[maxn][maxn]毕竟我们的核心是解决floyd算法。\n\nvoid floyd(){\n    int i,j,k;\n    //初始化dis\n    for(i=0;i<g.vexnum;i++){\n        for(j=0;j<g.vexnum;j++){\n            if(i==j)dis[i][j]=0;\n            else dis[i][j]=inf;\n        }\n    }\n    memset(path,-1,sizeof(path));//初始化path数组\n    arclink *p;//辅助作用\n    for(i=0;i<g.vexnum;i++){\n        p=g.adj[i].firstarc;\n        while(p){\n            //此操作是为了记录所有顶点之间的距离\n            dis[i][s->adjust]=s->wight;\n            s=s->next;\n        }\n    }\n    //到了这一步，就跟上面的是一样了，因为我们已经得到了dis数组和path数组的值了。下面利用dp并记录中转顶点，同种套路。\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n',charsets:{cjk:!0},lastUpdated:"2023/11/25, 16:14:12",lastUpdatedTimestamp:1700900052e3},{title:"Linux常用命令、管道、环境变量",frontmatter:{title:"Linux常用命令、管道、环境变量",date:"2022-2-5",tags:["Linux"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/d66bf9/",categories:["开发","系统架构","Linux"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/01.Linux/01.Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E3%80%81%E7%AE%A1%E9%81%93%E3%80%81%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.html",relativePath:"01.开发/05.系统架构/01.Linux/01.Linux常用命令、管道、环境变量.md",key:"v-e792ddf8",path:"/pages/d66bf9/",headers:[{level:2,title:"1 Linux常用命令",slug:"_1-linux常用命令",normalizedTitle:"1 linux常用命令",charIndex:2},{level:3,title:"1.1 系统状况",slug:"_1-1-系统状况",normalizedTitle:"1.1 系统状况",charIndex:18},{level:3,title:"1.2 文件权限",slug:"_1-2-文件权限",normalizedTitle:"1.2 文件权限",charIndex:311},{level:3,title:"1.3 文件检索",slug:"_1-3-文件检索",normalizedTitle:"1.3 文件检索",charIndex:540},{level:3,title:"1.4 查看文件内容",slug:"_1-4-查看文件内容",normalizedTitle:"1.4 查看文件内容",charIndex:1251},{level:3,title:"1.5 用户相关",slug:"_1-5-用户相关",normalizedTitle:"1.5 用户相关",charIndex:1491},{level:3,title:"1.6 工具",slug:"_1-6-工具",normalizedTitle:"1.6 工具",charIndex:1547},{level:3,title:"1.7 安装软件",slug:"_1-7-安装软件",normalizedTitle:"1.7 安装软件",charIndex:1860},{level:2,title:"2 管道",slug:"_2-管道",normalizedTitle:"2 管道",charIndex:1980},{level:3,title:"2.1 管道命令",slug:"_2-1-管道命令",normalizedTitle:"2.1 管道命令",charIndex:1989},{level:3,title:"2.2 实例",slug:"_2-2-实例",normalizedTitle:"2.2 实例",charIndex:2381},{level:2,title:"3 环境变量",slug:"_3-环境变量",normalizedTitle:"3 环境变量",charIndex:2677},{level:3,title:"3.1 概念",slug:"_3-1-概念",normalizedTitle:"3.1 概念",charIndex:2688},{level:3,title:"3.2 查看环境变量",slug:"_3-2-查看环境变量",normalizedTitle:"3.2 查看环境变量",charIndex:2771},{level:3,title:"3.3 修改环境变量",slug:"_3-3-修改环境变量",normalizedTitle:"3.3 修改环境变量",charIndex:2925},{level:3,title:"3.4 常见环境变量",slug:"_3-4-常见环境变量",normalizedTitle:"3.4 常见环境变量",charIndex:3180}],headersStr:"1 Linux常用命令 1.1 系统状况 1.2 文件权限 1.3 文件检索 1.4 查看文件内容 1.5 用户相关 1.6 工具 1.7 安装软件 2 管道 2.1 管道命令 2.2 实例 3 环境变量 3.1 概念 3.2 查看环境变量 3.3 修改环境变量 3.4 常见环境变量",content:"# 1 Linux常用命令\n\n\n# 1.1 系统状况\n\ntop：查看所有进程的信息（Linux的任务管理器）。\n\n * 打开后输入M：按使用内存排序；\n * 打开后输入P：按使用CPU排序；\n * 打开后输入q：退出。\n\ndf -h：查看硬盘使用情况。 free -h：查看内存使用情况。 du -sh：查看当前目录占用的硬盘空间。 ps aux：查看所有进程。 kill -9 pid：杀死编号为pid的进程。 kill -s SIGTERM pid：传递某个具体的信号。 netstat -nt：查看所有网络连接。 w：列出当前登录的用户。 ping www.baidu.com：测试网络连接，检查是否联网。\n\n\n# 1.2 文件权限\n\nchmod：修改文件权限\n\n * chmod +x filename：给filename添加可执行权限；\n * chmod -x filename：去掉filename的可执行权限；\n * chmod abc filename:其中a，b，c各为一个数字，表示User、Group以及Other的权限。r=4，w=2，x=1，为读，写，可执行。 如设置所有人对该文件都可读可写可执行，则设置chmod 777 filename。\n\n\n# 1.3 文件检索\n\nfind <path>(文件路径) -name '*.py'：搜索path路径下的所有py文件。 grep xxx：从stdin中读入若干行数据，如果某行中包含xxx，则输出该行，否则忽略该行。 wc：统计行数、单词数、字节数。\n\n * 既可以从stdin中直接读取内容，也可以在命令行参数中传入文件名列表。\n * wc -l：统计行数。\n * wc -w：统计单词数。\n * wc -c：统计字节数。\n\ntree：展示当前目录的文件结构。\n\n * tree path：展示某个目录的文件结构。\n * tree -a：显示隐藏文件。\n\nag xxx：搜索当前目录下的所有文件，检索xxx字符串。 cut：分割一行内容。\n\n * 从stdin中读入多行数据。\n * echo $PATH | cut -d ':' -f 3, 5：输出PATH用:分割后的第3、5列数据。\n * echo $PATH | cut -d ':' -f 3-5：输出PATH用:分割后的第3-5列数据。\n * echo $PATH | cut -c 3, 5：输出PATH的第3、5个字符。\n * echo $PATH | cut -c 3-5：输出PATH的第3-5个字符。\n\nsort：将每行内容按字典序排序。\n\n * 可以从stdin中读取多行数据。\n * 可以从命令行参数中读取文件名列表。\n\nxargs：将stdin中的数据用空格或回车分割成命令行参数，作为其他命令使用。\n\n * find . -name '*.py' | xargs cat | wc -l：统计当前目录下所有python文件的总行数。\n\n\n# 1.4 查看文件内容\n\nmore：浏览文件内容。\n\n * 回车或空格：下一行。\n * b：上一页。\n * q：退出。\n\nless：和more类似，功能更全。\n\n * 回车：下一行。\n * y：上一行。\n * Page Down：下一页。\n * Page Up：上一页。\n * q：退出。\n\nhead -3 xxx：显示xxx的前3行内容。\n\n * 同时支持从stdin读入内容。\n\ntail -3 xxx：显示xxx末尾3行内容。\n\n * 同时支持从stdin读入内容。\n\n\n# 1.5 用户相关\n\nhistory：展示当前用户的历史操作。内容存放在~/bash_history中。\n\n\n# 1.6 工具\n\nmd5Sum：计算md5的哈希值。\n\n * 也可以从stdin中读入内容，也可以在命令行参数中传入文件名列表。\n\ntime command：统计command命令的执行时间。 ipython3：交互式python环境。可以当作计算器，或者批量管理文件。 i command：!表示执行shell脚本命令。 watch -n 0.1 command：每隔0.1s就执行一次command命令。 tar：压缩文件。\n\n * tar -zcvf xxx.tar.gz /path：压缩。\n * tar -zxvf xxx.tar.gz：解压缩。\n\ndiff xxx yyy：查看文件xxx和yyy的不同点。\n\n\n# 1.7 安装软件\n\nsudo command：以root身份运行command命令。 apt-get install xxx：安装xxx软件。 pip install xxx --user --upgrade：安装python包。\n\n\n# 2 管道\n\n\n# 2.1 管道命令\n\n管道命令操作符是|，,它只能处理经由前面一个指令传出的正确输出信息，对错误信息信息没有直接处理能力。然后传递给下一个命令，作为标准的输入。 下图为管道命令的输出说明： 【指令1】正确输出，作为【指令2】的输入，然后【指令2】的输出作为【指令3】的输入 ，【指令3】输出就会直接显示在屏幕上面了。 通过管道之后，我们发现【指令1】和【指令2】的正确输出不显示在屏幕上面，只显示指令3的输出。\n\n其类似于之前学习的文件重定向，可以将前面一个命令的stdout重定向下一个命令的stdin。但与文件重定向有很大区别：文件重定向左边为命令，右边为文件；管道左右两边均为命令，左边有stdout，右边有stdin。\n\n值得注意的点：\n\n * 管道命令仅能处理stdout，忽略stderr。\n * 管道右边的命令必须能接受stdin。\n * 多个管道命令可以串联。\n\n\n# 2.2 实例\n\n * 统计当前目录下所有python文件的总行数 统计总行数，在前面常用命令学习中，我们已经会了：wc -l，统计当前目录所有的python文件，也易得为：find . -name '*.py'。那么我们需要解决的问题则是将所有python文件选出来得到其内容再统计。我们则可能会这样：find . -name '*.py' | cat | wc -l。但find . -name '*.py'得到的是字符串，我们还需要利用xargs将字符串分割作为命令行参数，这样即可达到效果。 即：find . -name '*.py' | xargs cat | wc -l。\n\n\n# 3 环境变量\n\n\n# 3.1 概念\n\nLinux系统中会用很多环境变量来记录配置信息。环境变量类似于全局变量，可以被各个进程访问到。我们可以通过修改环境变量来方便地修改系统配置。\n\n\n# 3.2 查看环境变量\n\n * 列出当前环境下的所有环境变量：\n\nenv # 显示当前用户的变量；\nset # 显示当前shell的变量，包含当前用户的变量；\nexport # 显示当前导出成用户变量的shell变量。\n\n\n1\n2\n3\n\n1\n2\n3\n\n * 输出某个环境变量的值：echo $PATH\n\n\n# 3.3 修改环境变量\n\n修改环境变量我们可以先将修改命令放到~/.bashrc文件中。修改完之后需执行source ~/.bashrc，来将修改应用到当前的bash环境下。\n\n为何将修改命令放到~/.bashrc，就可以确保修改会影响未来所有的环境呢？\n\n * 每次启动bash，都会先执行~/.bashrc。\n * 每次ssh登录远程服务器，都会启动一个bash命令行给我们。\n * 每次tmux新开一个pane，都会启动一个bash命令行给我们。\n * 未来所有的新开环境都会加载我们修改的内容。\n\n\n# 3.4 常见环境变量\n\nHOME：用户的家目录 PATH：可执行文件（命令）的存储路径。路径与路径之间用:分隔。当某个可执行文件同时出现多个路径中时，会选择从左到右数第一个路径中的执行。下列所有存储路径的环境变量，均采用从左到右的优先顺序。 LD_LIBRARY_PATH：用于指定动态链接库(.so文件)的路径，其内容是以冒号分隔的路径列表。 C_INCLUDE_PATH：C语言的头文件路径，内容是以冒号分隔的路径列表。 CPLUS_INCLUDE_PATH：CPP的头文件路径，内容是以冒号分隔的路径列表。 PYTHONPATH：Python导入包的路径，内容是以冒号分隔的路径列表。 JAVA_HOME：jdk的安装目录。 CLASSPATH：存放Java导入类的路径，内容是以冒号分隔的路径列表。",normalizedContent:"# 1 linux常用命令\n\n\n# 1.1 系统状况\n\ntop：查看所有进程的信息（linux的任务管理器）。\n\n * 打开后输入m：按使用内存排序；\n * 打开后输入p：按使用cpu排序；\n * 打开后输入q：退出。\n\ndf -h：查看硬盘使用情况。 free -h：查看内存使用情况。 du -sh：查看当前目录占用的硬盘空间。 ps aux：查看所有进程。 kill -9 pid：杀死编号为pid的进程。 kill -s sigterm pid：传递某个具体的信号。 netstat -nt：查看所有网络连接。 w：列出当前登录的用户。 ping www.baidu.com：测试网络连接，检查是否联网。\n\n\n# 1.2 文件权限\n\nchmod：修改文件权限\n\n * chmod +x filename：给filename添加可执行权限；\n * chmod -x filename：去掉filename的可执行权限；\n * chmod abc filename:其中a，b，c各为一个数字，表示user、group以及other的权限。r=4，w=2，x=1，为读，写，可执行。 如设置所有人对该文件都可读可写可执行，则设置chmod 777 filename。\n\n\n# 1.3 文件检索\n\nfind <path>(文件路径) -name '*.py'：搜索path路径下的所有py文件。 grep xxx：从stdin中读入若干行数据，如果某行中包含xxx，则输出该行，否则忽略该行。 wc：统计行数、单词数、字节数。\n\n * 既可以从stdin中直接读取内容，也可以在命令行参数中传入文件名列表。\n * wc -l：统计行数。\n * wc -w：统计单词数。\n * wc -c：统计字节数。\n\ntree：展示当前目录的文件结构。\n\n * tree path：展示某个目录的文件结构。\n * tree -a：显示隐藏文件。\n\nag xxx：搜索当前目录下的所有文件，检索xxx字符串。 cut：分割一行内容。\n\n * 从stdin中读入多行数据。\n * echo $path | cut -d ':' -f 3, 5：输出path用:分割后的第3、5列数据。\n * echo $path | cut -d ':' -f 3-5：输出path用:分割后的第3-5列数据。\n * echo $path | cut -c 3, 5：输出path的第3、5个字符。\n * echo $path | cut -c 3-5：输出path的第3-5个字符。\n\nsort：将每行内容按字典序排序。\n\n * 可以从stdin中读取多行数据。\n * 可以从命令行参数中读取文件名列表。\n\nxargs：将stdin中的数据用空格或回车分割成命令行参数，作为其他命令使用。\n\n * find . -name '*.py' | xargs cat | wc -l：统计当前目录下所有python文件的总行数。\n\n\n# 1.4 查看文件内容\n\nmore：浏览文件内容。\n\n * 回车或空格：下一行。\n * b：上一页。\n * q：退出。\n\nless：和more类似，功能更全。\n\n * 回车：下一行。\n * y：上一行。\n * page down：下一页。\n * page up：上一页。\n * q：退出。\n\nhead -3 xxx：显示xxx的前3行内容。\n\n * 同时支持从stdin读入内容。\n\ntail -3 xxx：显示xxx末尾3行内容。\n\n * 同时支持从stdin读入内容。\n\n\n# 1.5 用户相关\n\nhistory：展示当前用户的历史操作。内容存放在~/bash_history中。\n\n\n# 1.6 工具\n\nmd5sum：计算md5的哈希值。\n\n * 也可以从stdin中读入内容，也可以在命令行参数中传入文件名列表。\n\ntime command：统计command命令的执行时间。 ipython3：交互式python环境。可以当作计算器，或者批量管理文件。 i command：!表示执行shell脚本命令。 watch -n 0.1 command：每隔0.1s就执行一次command命令。 tar：压缩文件。\n\n * tar -zcvf xxx.tar.gz /path：压缩。\n * tar -zxvf xxx.tar.gz：解压缩。\n\ndiff xxx yyy：查看文件xxx和yyy的不同点。\n\n\n# 1.7 安装软件\n\nsudo command：以root身份运行command命令。 apt-get install xxx：安装xxx软件。 pip install xxx --user --upgrade：安装python包。\n\n\n# 2 管道\n\n\n# 2.1 管道命令\n\n管道命令操作符是|，,它只能处理经由前面一个指令传出的正确输出信息，对错误信息信息没有直接处理能力。然后传递给下一个命令，作为标准的输入。 下图为管道命令的输出说明： 【指令1】正确输出，作为【指令2】的输入，然后【指令2】的输出作为【指令3】的输入 ，【指令3】输出就会直接显示在屏幕上面了。 通过管道之后，我们发现【指令1】和【指令2】的正确输出不显示在屏幕上面，只显示指令3的输出。\n\n其类似于之前学习的文件重定向，可以将前面一个命令的stdout重定向下一个命令的stdin。但与文件重定向有很大区别：文件重定向左边为命令，右边为文件；管道左右两边均为命令，左边有stdout，右边有stdin。\n\n值得注意的点：\n\n * 管道命令仅能处理stdout，忽略stderr。\n * 管道右边的命令必须能接受stdin。\n * 多个管道命令可以串联。\n\n\n# 2.2 实例\n\n * 统计当前目录下所有python文件的总行数 统计总行数，在前面常用命令学习中，我们已经会了：wc -l，统计当前目录所有的python文件，也易得为：find . -name '*.py'。那么我们需要解决的问题则是将所有python文件选出来得到其内容再统计。我们则可能会这样：find . -name '*.py' | cat | wc -l。但find . -name '*.py'得到的是字符串，我们还需要利用xargs将字符串分割作为命令行参数，这样即可达到效果。 即：find . -name '*.py' | xargs cat | wc -l。\n\n\n# 3 环境变量\n\n\n# 3.1 概念\n\nlinux系统中会用很多环境变量来记录配置信息。环境变量类似于全局变量，可以被各个进程访问到。我们可以通过修改环境变量来方便地修改系统配置。\n\n\n# 3.2 查看环境变量\n\n * 列出当前环境下的所有环境变量：\n\nenv # 显示当前用户的变量；\nset # 显示当前shell的变量，包含当前用户的变量；\nexport # 显示当前导出成用户变量的shell变量。\n\n\n1\n2\n3\n\n1\n2\n3\n\n * 输出某个环境变量的值：echo $path\n\n\n# 3.3 修改环境变量\n\n修改环境变量我们可以先将修改命令放到~/.bashrc文件中。修改完之后需执行source ~/.bashrc，来将修改应用到当前的bash环境下。\n\n为何将修改命令放到~/.bashrc，就可以确保修改会影响未来所有的环境呢？\n\n * 每次启动bash，都会先执行~/.bashrc。\n * 每次ssh登录远程服务器，都会启动一个bash命令行给我们。\n * 每次tmux新开一个pane，都会启动一个bash命令行给我们。\n * 未来所有的新开环境都会加载我们修改的内容。\n\n\n# 3.4 常见环境变量\n\nhome：用户的家目录 path：可执行文件（命令）的存储路径。路径与路径之间用:分隔。当某个可执行文件同时出现多个路径中时，会选择从左到右数第一个路径中的执行。下列所有存储路径的环境变量，均采用从左到右的优先顺序。 ld_library_path：用于指定动态链接库(.so文件)的路径，其内容是以冒号分隔的路径列表。 c_include_path：c语言的头文件路径，内容是以冒号分隔的路径列表。 cplus_include_path：cpp的头文件路径，内容是以冒号分隔的路径列表。 pythonpath：python导入包的路径，内容是以冒号分隔的路径列表。 java_home：jdk的安装目录。 classpath：存放java导入类的路径，内容是以冒号分隔的路径列表。",charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"Linux execve函数详解",frontmatter:{title:"Linux execve函数详解",tags:["Linux"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},categories:["开发","系统架构","Linux"],date:"2024-03-13T10:31:42.000Z",permalink:"/pages/d8622e/",readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/01.Linux/05.Linux%20execve%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3.html",relativePath:"01.开发/05.系统架构/01.Linux/05.Linux execve函数详解.md",key:"v-32c8611a",path:"/pages/d8622e/",headers:[{level:2,title:"1 基本介绍",slug:"_1-基本介绍",normalizedTitle:"1 基本介绍",charIndex:2},{level:2,title:"2 execve实例",slug:"_2-execve实例",normalizedTitle:"2 execve实例",charIndex:1581},{level:3,title:"2.1 自定义argv和envp",slug:"_2-1-自定义argv和envp",normalizedTitle:"2.1 自定义argv和envp",charIndex:1596},{level:3,title:"2.2 fork后再通过子进程执行execve",slug:"_2-2-fork后再通过子进程执行execve",normalizedTitle:"2.2 fork后再通过子进程执行execve",charIndex:2351}],headersStr:"1 基本介绍 2 execve实例 2.1 自定义argv和envp 2.2 fork后再通过子进程执行execve",content:'# 1 基本介绍\n\n#include <unistd.h>\nint execve(const char *pathname, char *const argv[], char *const envp[]);\n\n\n1\n2\n\n1\n2\n\n\n * 描述\n   \n   > execve()执行由pathname引用的程序。这会导致当前由调用进程运行的程序被一个新程序替换，该新程序具有新初始化的堆栈、堆和（已初始化和未初始化）数据段。\n   > \n   > pathname必须是二进制可执行文件或以形式为#!interpreter [optional-arg]开头的脚本。\n   > \n   > argv是传递给新程序作为其命令行参数的字符串指针数组。按照惯例，这些字符串中第一个（即argv[0]）应包含与正在执行文件相关联的文件名。argv数组必须以NULL指针结尾。（因此，在新程序中，argv[argc]将为NULL）。\n   > \n   > envp是传递给新程序环境变量的字符串指针数组。该数组包含了环境变量。每个环境变量都是一个 char* 指针，格式为 "name=value"。envp数组同样必须以NULL指针结尾。\n   > \n   > char *envp[] = {\n   >  "PATH=/bin",\n   >  "HOME=/home/user",\n   >  "USER=user",\n   >  NULL // 终止环境变量数组\n   > };\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > \n   > \n   > argv和envp可以从新程序的主函数访问。例如我们编写的C程序，实际上是由操作系统通过execve()系统调用执行（这里是操作系统先执行fork系统调用，创建一个新的子进程，然后在新的子进程中，操作系统执行execve()系统调用），它会传递这些参数给新程序的主函数，即 main 函数。这些参数定义了新程序执行时的环境和命令行参数，在程序启动时由操作系统设置，并在整个程序执行期间保持不变。这使得程序能够根据传递给它的参数和环境变量来执行不同的任务或调整其行为。\n\n * 返回值\n   \n   > 成功时，execve() 不返回任何值，当 execve 成功替换当前进程的映像并开始执行新的程序时，原来的进程（即调用 execve 的进程）已经不再存在，因此无法返回任何值。\n   > \n   > 在出错时返回 -1，并设置适当的 errno。\n\n * 重点\n   \n   >  1. execve实际上就是将当前运行的状态机重置成另一个程序的初始状态\n   >  2. 允许对新状态机设置参数 argv (v) 和环境变量 envp (e)\n   >  3. 在程序启动时，操作系统首先执行 fork 系统调用，创建一个新的子进程。然后，操作系统在子进程中执行 execve 系统调用，以替换子进程的程序映像并开始执行新的程序。原来的父进程继续执行 fork 之后的代码。\n   >  4. 在调用 execve 之前，确保释放所有不再需要的资源，如打开的文件描述符、锁等。\n   >  5. 在调用 execve 之前，确保子进程已经处理了所有待处理的信号，除非你希望信号处理程序在新程序中执行。\n   >  6. 如果 execve 失败，子进程通常应该终止。\n   >  7. 在父进程中，通常会在 fork 之后立即调用 wait 或 waitpid 来等待子进程结束，以确保父进程不会过早退出，从而导致子进程的僵尸进程。\n\n\n# 2 execve实例\n\n\n# 2.1 自定义argv和envp\n\n#include <unistd.h>\n#include <stdio.h>\n\nint main() {\n  char * const argv[] = {\n    "/bin/bash", "-c", "env", NULL,\n  };\n  char * const envp[] = {\n    "HELLO=WORLD", NULL,\n  };\n  execve(argv[0], argv, envp);\n  printf("Hello, World!\\n");\n  return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n在这段代码中，我们显式的设置了argv和envp，其中参数 "/bin/bash", "-c", "env", NULL，这里的参数实际上是在告诉 bash 执行一个命令（由 -c 后面的字符串指定），在这个例子中是 env，它打印当前的环境变量。\n\n我们运行代码，得到如下输出：\n\n\n\n如果我们不传 -c 参数和随后的命令，即只传入 "/bin/bash", NULL 作为参数，bash 会默认进入交互式模式。在这种模式下，它不会执行任何命令并立即退出，而是会等待用户输入，表现为进入了 shell 环境。\n\n我们发现，打印的当前环境变量除了自定的envp，还有一些其他的输出。这是因为除了我们设定的环境变量外，还有一些系统或者 shell 默认的环境变量会被添加到新进程中，例如 PWD 表示当前工作目录，SHLVL 表示 shell 层级，_ 是上一个执行的命令。这就是为什么我们会看到额外的环境变量出现在输出中。\n\n\n# 2.2 fork后再通过子进程执行execve\n\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n\nint main() {\n    pid_t pid = fork();\n\n    if (pid == 0) {\n        // 子进程\n        char * const argv[] = {"/bin/echo", "Hello, World!", NULL};\n        char * const envp[] = {NULL};\n        execve("/bin/echo", argv, envp);\n    } else if (pid > 0) {\n        // 父进程\n        wait(NULL); // 等待子进程结束\n        printf("Child process finished.\\n");\n    } else {\n        // fork失败\n        perror("fork");\n        return 1;\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n这段代码演示了如何使用 fork() 系统调用创建一个新的子进程，然后在子进程中执行 execve() 系统调用。这是在 Unix-like 系统中常见的操作模式，因为 execve() 系统调用有一些关键的限制：\n\n * 一次机会：execve() 系统调用只能用于替换当前进程的映像一次。如果一个进程已经调用了 execve()，它就不能再调用 fork() 或再次执行 execve()。\n * 无返回值：execve() 成功执行时，原来的进程映像被新程序映像替换，原来的进程不再存在，因此无法返回任何值。如果在 execve() 执行之前有任何返回值，那么这个返回值是在 fork() 调用之后，由父进程获得的。\n\n因此，在实际应用中，我们通常会先使用 fork() 创建一个子进程，然后在子进程中调用 execve() 执行新的程序。父进程在 fork() 之后会继续执行，并通过调用 wait(NULL) 来等待子进程结束。这样，父进程可以知道子进程已经成功执行了 execve()，并且可以继续执行其他任务或退出。\n\n在多线程程序中，如果一个线程执行了 fork() 并尝试在子进程中执行 execve()，那么其他线程将继续执行，不受 fork() 和 execve() 的影响。只有调用 fork() 的线程会进入子进程，而其他线程则继续在父进程中运行。\n\n得到的运行结果：\n\n',normalizedContent:'# 1 基本介绍\n\n#include <unistd.h>\nint execve(const char *pathname, char *const argv[], char *const envp[]);\n\n\n1\n2\n\n1\n2\n\n\n * 描述\n   \n   > execve()执行由pathname引用的程序。这会导致当前由调用进程运行的程序被一个新程序替换，该新程序具有新初始化的堆栈、堆和（已初始化和未初始化）数据段。\n   > \n   > pathname必须是二进制可执行文件或以形式为#!interpreter [optional-arg]开头的脚本。\n   > \n   > argv是传递给新程序作为其命令行参数的字符串指针数组。按照惯例，这些字符串中第一个（即argv[0]）应包含与正在执行文件相关联的文件名。argv数组必须以null指针结尾。（因此，在新程序中，argv[argc]将为null）。\n   > \n   > envp是传递给新程序环境变量的字符串指针数组。该数组包含了环境变量。每个环境变量都是一个 char* 指针，格式为 "name=value"。envp数组同样必须以null指针结尾。\n   > \n   > char *envp[] = {\n   >  "path=/bin",\n   >  "home=/home/user",\n   >  "user=user",\n   >  null // 终止环境变量数组\n   > };\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > \n   > \n   > argv和envp可以从新程序的主函数访问。例如我们编写的c程序，实际上是由操作系统通过execve()系统调用执行（这里是操作系统先执行fork系统调用，创建一个新的子进程，然后在新的子进程中，操作系统执行execve()系统调用），它会传递这些参数给新程序的主函数，即 main 函数。这些参数定义了新程序执行时的环境和命令行参数，在程序启动时由操作系统设置，并在整个程序执行期间保持不变。这使得程序能够根据传递给它的参数和环境变量来执行不同的任务或调整其行为。\n\n * 返回值\n   \n   > 成功时，execve() 不返回任何值，当 execve 成功替换当前进程的映像并开始执行新的程序时，原来的进程（即调用 execve 的进程）已经不再存在，因此无法返回任何值。\n   > \n   > 在出错时返回 -1，并设置适当的 errno。\n\n * 重点\n   \n   >  1. execve实际上就是将当前运行的状态机重置成另一个程序的初始状态\n   >  2. 允许对新状态机设置参数 argv (v) 和环境变量 envp (e)\n   >  3. 在程序启动时，操作系统首先执行 fork 系统调用，创建一个新的子进程。然后，操作系统在子进程中执行 execve 系统调用，以替换子进程的程序映像并开始执行新的程序。原来的父进程继续执行 fork 之后的代码。\n   >  4. 在调用 execve 之前，确保释放所有不再需要的资源，如打开的文件描述符、锁等。\n   >  5. 在调用 execve 之前，确保子进程已经处理了所有待处理的信号，除非你希望信号处理程序在新程序中执行。\n   >  6. 如果 execve 失败，子进程通常应该终止。\n   >  7. 在父进程中，通常会在 fork 之后立即调用 wait 或 waitpid 来等待子进程结束，以确保父进程不会过早退出，从而导致子进程的僵尸进程。\n\n\n# 2 execve实例\n\n\n# 2.1 自定义argv和envp\n\n#include <unistd.h>\n#include <stdio.h>\n\nint main() {\n  char * const argv[] = {\n    "/bin/bash", "-c", "env", null,\n  };\n  char * const envp[] = {\n    "hello=world", null,\n  };\n  execve(argv[0], argv, envp);\n  printf("hello, world!\\n");\n  return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n在这段代码中，我们显式的设置了argv和envp，其中参数 "/bin/bash", "-c", "env", null，这里的参数实际上是在告诉 bash 执行一个命令（由 -c 后面的字符串指定），在这个例子中是 env，它打印当前的环境变量。\n\n我们运行代码，得到如下输出：\n\n\n\n如果我们不传 -c 参数和随后的命令，即只传入 "/bin/bash", null 作为参数，bash 会默认进入交互式模式。在这种模式下，它不会执行任何命令并立即退出，而是会等待用户输入，表现为进入了 shell 环境。\n\n我们发现，打印的当前环境变量除了自定的envp，还有一些其他的输出。这是因为除了我们设定的环境变量外，还有一些系统或者 shell 默认的环境变量会被添加到新进程中，例如 pwd 表示当前工作目录，shlvl 表示 shell 层级，_ 是上一个执行的命令。这就是为什么我们会看到额外的环境变量出现在输出中。\n\n\n# 2.2 fork后再通过子进程执行execve\n\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n\nint main() {\n    pid_t pid = fork();\n\n    if (pid == 0) {\n        // 子进程\n        char * const argv[] = {"/bin/echo", "hello, world!", null};\n        char * const envp[] = {null};\n        execve("/bin/echo", argv, envp);\n    } else if (pid > 0) {\n        // 父进程\n        wait(null); // 等待子进程结束\n        printf("child process finished.\\n");\n    } else {\n        // fork失败\n        perror("fork");\n        return 1;\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n这段代码演示了如何使用 fork() 系统调用创建一个新的子进程，然后在子进程中执行 execve() 系统调用。这是在 unix-like 系统中常见的操作模式，因为 execve() 系统调用有一些关键的限制：\n\n * 一次机会：execve() 系统调用只能用于替换当前进程的映像一次。如果一个进程已经调用了 execve()，它就不能再调用 fork() 或再次执行 execve()。\n * 无返回值：execve() 成功执行时，原来的进程映像被新程序映像替换，原来的进程不再存在，因此无法返回任何值。如果在 execve() 执行之前有任何返回值，那么这个返回值是在 fork() 调用之后，由父进程获得的。\n\n因此，在实际应用中，我们通常会先使用 fork() 创建一个子进程，然后在子进程中调用 execve() 执行新的程序。父进程在 fork() 之后会继续执行，并通过调用 wait(null) 来等待子进程结束。这样，父进程可以知道子进程已经成功执行了 execve()，并且可以继续执行其他任务或退出。\n\n在多线程程序中，如果一个线程执行了 fork() 并尝试在子进程中执行 execve()，那么其他线程将继续执行，不受 fork() 和 execve() 的影响。只有调用 fork() 的线程会进入子进程，而其他线程则继续在父进程中运行。\n\n得到的运行结果：\n\n',charsets:{cjk:!0},lastUpdated:"2024/03/13, 21:31:54",lastUpdatedTimestamp:1710336714e3},{title:"Dijkstra算法教程",frontmatter:{title:"Dijkstra算法教程",date:"2020-07-29T16:15:34.000Z",tags:["最短路"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/180ec0/",categories:["开发","数据结构与算法","图算法"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/03.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/08.%E5%9B%BE%E7%AE%97%E6%B3%95/02.Dijkstra%E7%AE%97%E6%B3%95%E6%95%99%E7%A8%8B.html",relativePath:"01.开发/03.数据结构与算法/08.图算法/02.Dijkstra算法教程.md",key:"v-7f5cbb59",path:"/pages/180ec0/",headers:[{level:2,title:"1 简介（百度百科）",slug:"_1-简介-百度百科",normalizedTitle:"1 简介（百度百科）",charIndex:76},{level:2,title:"2 算法思想与原理",slug:"_2-算法思想与原理",normalizedTitle:"2 算法思想与原理",charIndex:292},{level:2,title:"3 具体步骤",slug:"_3-具体步骤",normalizedTitle:"3 具体步骤",charIndex:920},{level:2,title:"4 动态展示",slug:"_4-动态展示",normalizedTitle:"4 动态展示",charIndex:1479},{level:2,title:"5 一般代码实现（以邻接矩阵为例）",slug:"_5-一般代码实现-以邻接矩阵为例",normalizedTitle:"5 一般代码实现（以邻接矩阵为例）",charIndex:1492},{level:3,title:"5.1 基本数据",slug:"_5-1-基本数据",normalizedTitle:"5.1 基本数据",charIndex:1514},{level:3,title:"5.2 初始化",slug:"_5-2-初始化",normalizedTitle:"5.2 初始化",charIndex:1762},{level:3,title:"5.3 dijkstra算法核心",slug:"_5-3-dijkstra算法核心",normalizedTitle:"5.3 dijkstra算法核心",charIndex:1922},{level:3,title:"5.4 主函数与头文件等",slug:"_5-4-主函数与头文件等",normalizedTitle:"5.4 主函数与头文件等",charIndex:2697},{level:2,title:"6 拓展",slug:"_6-拓展",normalizedTitle:"6 拓展",charIndex:3116}],headersStr:"1 简介（百度百科） 2 算法思想与原理 3 具体步骤 4 动态展示 5 一般代码实现（以邻接矩阵为例） 5.1 基本数据 5.2 初始化 5.3 dijkstra算法核心 5.4 主函数与头文件等 6 拓展",content:"PS：此算法不能用于求负权图，要求所有边的权重都为非负值。\n\n----------------------------------------\n\n\n# 1 简介（百度百科）\n\n> 迪杰斯特拉算法(Dijkstra)是由荷兰计算机科学家狄克斯特拉于1959 年提出的，因此又叫狄克斯特拉算法。这是从一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。迪杰斯特拉算法主要特点是从起始点开始，采用贪心算法的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。\n\n----------------------------------------\n\n\n# 2 算法思想与原理\n\n> dijkstra算法思想是基于贪心算法思想的。所谓贪心算法即始终保持当前迭代解为当前最优解。意思就是在已知的条件下或是当前拥有的全部条件下保证最优解，若在此后的迭代中由于加入了新的条件使得产生了更优解则替代此前的最优解。通过不断的迭代不断保证每次迭代的结果都是当前最优解，那么当迭代到最后一轮时得到的就会是全局最优解。 由于下一轮迭代会参考上一轮的最优解，因此每一轮的迭代的工作量基本一致，降低了整体工作的复杂性。\n\n在最短路径的问题中，局部最优解即当前的最短路径或者说是在当前的已知条件下起点到其余各点的最短距离。关键就在于已知条件，这也是Dijkstra算法最精妙的地方。我们来解释一下。\n\n对于Dijkstra算法，我们假设初始集合（也就是初始条件）不存在任何顶点的，即所有顶点之间是不存在任何路径的，即我们认为所有顶点之间的距离都是无穷大。那么开始加入新的条件，因为我们已知源点距源点距离最小，所以加入进去，并加入它的边，在该条件下，更新该源点到其余顶点的最短距离，选出没有加入到已知集合的距源点距离最小的点，此点最短距离也被确定了（因为其他路径都比这条路径大，无法通过其他路径间接到达这个顶点使得路径更小），然后加入该点与其余还未加入已知条件顶点的边，并以该点迭代刷新最短距离。再重复以上操作，直至所有顶点都加入已知条件集合。\n\n----------------------------------------\n\n\n# 3 具体步骤\n\n 1. 选择起点startstartstart与终点endendend；\n 2. 所有点除起点外加入未知集合，并将起点加入已知集合，即至标志位为真，意为已确定该点到源点的最短路径；\n 3. 初始化计算，更新起点与其他各点的耗费dis(start,n)dis(start,n)dis(start,n);\n 4. 在未知集合中，选择dis(start,n)中值最小的点x，将x加入已知集合。\n 5. 对于剩余顶点中，计算dis(start,n)>dis(start,x)+dis(x,n)dis(start,n)>dis(start,x)+dis(x,n)dis(start,n)>dis(start,x)+dis(x,n) 若真则dis(start,n)=dis(start,x)+dis(x,n)dis(start,n)=dis(start,x)+dis(x,n)dis(start,n)=dis(start,x)+dis(x,n)，此时start与n点路径经过x点。循环直至goal点加入已知列表，取得dis(start,goal)dis(start,goal)dis(start,goal)即为最短距离。\n\n----------------------------------------\n\n\n# 4 动态展示\n\n\n\n\n# 5 一般代码实现（以邻接矩阵为例）\n\n\n# 5.1 基本数据\n\nconst int inf=0x3f3f3f3f; //代表无穷大。\nconst int maxn=100;//最大顶点数\nint n,m;//n个顶点，m条边。\nbool visited[maxn];//判断是否确定到源点的最终最短距离。\nint graph[maxn][maxn];//带权图\nint dis[maxn];//顶点到源点的最短距离。\nint start,goal;//起点与目标点。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 5.2 初始化\n\nvoid init(){\n\tmemset(visited,false,sizeof(visited));\n\tfor(int i=1;i<=n;i++){\n\t\tdis[i]=graph[start][i];//初始化dis数组。\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5.3 dijkstra算法核心\n\nvoid dijkstra(){\n\t//源点为源点start。\n\tint minn;//记录每趟最短路径中最小的路径值。 \n\tint pos;//记录得到的minn所对应的下标。\n\tinit();//调用初始化函数。\n\tvisited[start]=true;\n\tfor(int i=1;i<=n;i++){\n\t\t//将n个顶点依次加入判断。\n\t\tminn=inf;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(!visited[j]&&dis[j]<minn){\n\t\t\t\tminn=dis[j];\n\t\t\t\tpos=j;\n\t\t\t}\n\t\t}\n\t\t//经过这趟for循环后我们找到的就是我们想要的点，可以确定这点到源点的最终最短距离了。\n\t\tvisited[pos]=true;//我们将此点并入已知集合。\n\t\t//接下来就是更新dis数组了，也就是当前最短距离，这都是针对还没有并入已知集合的点。\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(!visited[j]&&dis[j]>dis[pos]+graph[pos][j])\n\t\t\t\tdis[j]=dis[pos]+graph[pos][j];\n\t\t}\n\t}\n\t//退出循环后，所有的点都已并入已知集合中，得到的dis数组也就是最终最短距离了。\n\tcout<<dis[goal]<<endl;//输出目标点到源点的最短路径长度。\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 5.4 主函数与头文件等\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    while(cin>>n>>m){\n\t\tmemset(graph,inf,sizeof(graph));\n\t\tint u,v,w;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>u>>v>>w;\n//\t\t\tgraph[u][v]=w;//有向图\n\t\t\tgraph[u][v]=graph[v][u]=w;//无向图\n\t\t}\n\t\tcin>>start>>goal;//输入起点与终点。\n\t\tdijkstra();\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 6 拓展\n\n如果你学会了dijkstra，那恭喜你成功突破了一关。但是，没有优化的dijkstra算法时间复杂度为O(n2)O(n^2)O(n2)，如果顶点很多边很少呢等等卡邻接矩阵的题，那么建议你还是要学一下dijkstra的优化版了。详情点击：Dijkstra算法优化~~你一定可以看懂的四种进阶优化",normalizedContent:"ps：此算法不能用于求负权图，要求所有边的权重都为非负值。\n\n----------------------------------------\n\n\n# 1 简介（百度百科）\n\n> 迪杰斯特拉算法(dijkstra)是由荷兰计算机科学家狄克斯特拉于1959 年提出的，因此又叫狄克斯特拉算法。这是从一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。迪杰斯特拉算法主要特点是从起始点开始，采用贪心算法的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。\n\n----------------------------------------\n\n\n# 2 算法思想与原理\n\n> dijkstra算法思想是基于贪心算法思想的。所谓贪心算法即始终保持当前迭代解为当前最优解。意思就是在已知的条件下或是当前拥有的全部条件下保证最优解，若在此后的迭代中由于加入了新的条件使得产生了更优解则替代此前的最优解。通过不断的迭代不断保证每次迭代的结果都是当前最优解，那么当迭代到最后一轮时得到的就会是全局最优解。 由于下一轮迭代会参考上一轮的最优解，因此每一轮的迭代的工作量基本一致，降低了整体工作的复杂性。\n\n在最短路径的问题中，局部最优解即当前的最短路径或者说是在当前的已知条件下起点到其余各点的最短距离。关键就在于已知条件，这也是dijkstra算法最精妙的地方。我们来解释一下。\n\n对于dijkstra算法，我们假设初始集合（也就是初始条件）不存在任何顶点的，即所有顶点之间是不存在任何路径的，即我们认为所有顶点之间的距离都是无穷大。那么开始加入新的条件，因为我们已知源点距源点距离最小，所以加入进去，并加入它的边，在该条件下，更新该源点到其余顶点的最短距离，选出没有加入到已知集合的距源点距离最小的点，此点最短距离也被确定了（因为其他路径都比这条路径大，无法通过其他路径间接到达这个顶点使得路径更小），然后加入该点与其余还未加入已知条件顶点的边，并以该点迭代刷新最短距离。再重复以上操作，直至所有顶点都加入已知条件集合。\n\n----------------------------------------\n\n\n# 3 具体步骤\n\n 1. 选择起点startstartstart与终点endendend；\n 2. 所有点除起点外加入未知集合，并将起点加入已知集合，即至标志位为真，意为已确定该点到源点的最短路径；\n 3. 初始化计算，更新起点与其他各点的耗费dis(start,n)dis(start,n)dis(start,n);\n 4. 在未知集合中，选择dis(start,n)中值最小的点x，将x加入已知集合。\n 5. 对于剩余顶点中，计算dis(start,n)>dis(start,x)+dis(x,n)dis(start,n)>dis(start,x)+dis(x,n)dis(start,n)>dis(start,x)+dis(x,n) 若真则dis(start,n)=dis(start,x)+dis(x,n)dis(start,n)=dis(start,x)+dis(x,n)dis(start,n)=dis(start,x)+dis(x,n)，此时start与n点路径经过x点。循环直至goal点加入已知列表，取得dis(start,goal)dis(start,goal)dis(start,goal)即为最短距离。\n\n----------------------------------------\n\n\n# 4 动态展示\n\n\n\n\n# 5 一般代码实现（以邻接矩阵为例）\n\n\n# 5.1 基本数据\n\nconst int inf=0x3f3f3f3f; //代表无穷大。\nconst int maxn=100;//最大顶点数\nint n,m;//n个顶点，m条边。\nbool visited[maxn];//判断是否确定到源点的最终最短距离。\nint graph[maxn][maxn];//带权图\nint dis[maxn];//顶点到源点的最短距离。\nint start,goal;//起点与目标点。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 5.2 初始化\n\nvoid init(){\n\tmemset(visited,false,sizeof(visited));\n\tfor(int i=1;i<=n;i++){\n\t\tdis[i]=graph[start][i];//初始化dis数组。\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5.3 dijkstra算法核心\n\nvoid dijkstra(){\n\t//源点为源点start。\n\tint minn;//记录每趟最短路径中最小的路径值。 \n\tint pos;//记录得到的minn所对应的下标。\n\tinit();//调用初始化函数。\n\tvisited[start]=true;\n\tfor(int i=1;i<=n;i++){\n\t\t//将n个顶点依次加入判断。\n\t\tminn=inf;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(!visited[j]&&dis[j]<minn){\n\t\t\t\tminn=dis[j];\n\t\t\t\tpos=j;\n\t\t\t}\n\t\t}\n\t\t//经过这趟for循环后我们找到的就是我们想要的点，可以确定这点到源点的最终最短距离了。\n\t\tvisited[pos]=true;//我们将此点并入已知集合。\n\t\t//接下来就是更新dis数组了，也就是当前最短距离，这都是针对还没有并入已知集合的点。\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(!visited[j]&&dis[j]>dis[pos]+graph[pos][j])\n\t\t\t\tdis[j]=dis[pos]+graph[pos][j];\n\t\t}\n\t}\n\t//退出循环后，所有的点都已并入已知集合中，得到的dis数组也就是最终最短距离了。\n\tcout<<dis[goal]<<endl;//输出目标点到源点的最短路径长度。\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 5.4 主函数与头文件等\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    while(cin>>n>>m){\n\t\tmemset(graph,inf,sizeof(graph));\n\t\tint u,v,w;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>u>>v>>w;\n//\t\t\tgraph[u][v]=w;//有向图\n\t\t\tgraph[u][v]=graph[v][u]=w;//无向图\n\t\t}\n\t\tcin>>start>>goal;//输入起点与终点。\n\t\tdijkstra();\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 6 拓展\n\n如果你学会了dijkstra，那恭喜你成功突破了一关。但是，没有优化的dijkstra算法时间复杂度为o(n2)o(n^2)o(n2)，如果顶点很多边很少呢等等卡邻接矩阵的题，那么建议你还是要学一下dijkstra的优化版了。详情点击：dijkstra算法优化~~你一定可以看懂的四种进阶优化",charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"Linux 系统调用函数fork、vfork、clone详解",frontmatter:{title:"Linux 系统调用函数fork、vfork、clone详解",tags:["Linux"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},categories:["开发","系统架构","Linux"],date:"2024-03-12T21:24:42.000Z",permalink:"/pages/64b48d/",readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/01.Linux/04.Linux_fork%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3.html",relativePath:"01.开发/05.系统架构/01.Linux/04.Linux_fork函数详解.md",key:"v-5c9edb39",path:"/pages/64b48d/",headers:[{level:2,title:"1 fork",slug:"_1-fork",normalizedTitle:"1 fork",charIndex:2},{level:3,title:"1.1 基本介绍",slug:"_1-1-基本介绍",normalizedTitle:"1.1 基本介绍",charIndex:13},{level:3,title:"1.2 fork实例",slug:"_1-2-fork实例",normalizedTitle:"1.2 fork实例",charIndex:861},{level:4,title:"1.2.1多个fork返回值",slug:"_1-2-1多个fork返回值",normalizedTitle:"1.2.1多个fork返回值",charIndex:875},{level:4,title:"1.2.2 C语言 fork与输出",slug:"_1-2-2-c语言-fork与输出",normalizedTitle:"1.2.2 c语言 fork与输出",charIndex:1442},{level:4,title:"1.2.3 fork 💣",slug:"_1-2-3-fork-💣",normalizedTitle:"1.2.3 fork 💣",charIndex:2600},{level:2,title:"2 vfork",slug:"_2-vfork",normalizedTitle:"2 vfork",charIndex:2967},{level:3,title:"2.1 基本介绍",slug:"_2-1-基本介绍",normalizedTitle:"2.1 基本介绍",charIndex:2979},{level:3,title:"2.2 验证vfork共享内存",slug:"_2-2-验证vfork共享内存",normalizedTitle:"2.2 验证vfork共享内存",charIndex:3826},{level:2,title:"3 clone",slug:"_3-clone",normalizedTitle:"3 clone",charIndex:5378},{level:3,title:"3.1 基本介绍",slug:"_3-1-基本介绍",normalizedTitle:"3.1 基本介绍",charIndex:5390},{level:3,title:"3.2 clone使用",slug:"_3-2-clone使用",normalizedTitle:"3.2 clone使用",charIndex:7304}],headersStr:"1 fork 1.1 基本介绍 1.2 fork实例 1.2.1多个fork返回值 1.2.2 C语言 fork与输出 1.2.3 fork 💣 2 vfork 2.1 基本介绍 2.2 验证vfork共享内存 3 clone 3.1 基本介绍 3.2 clone使用",content:'# 1 fork\n\n\n# 1.1 基本介绍\n\n#include <sys/types.h>\n#include <unistd.h>\n\npid_t fork(void)\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n * 描述\n   \n   > fork用于创建一个子进程，它与父进程的唯一区别在于其PID和PPID，以及资源利用设置为0。文件锁和挂起信号（指已经被内核发送给一个进程，但尚未被该进程处理的信号）不会被继承，其他和父进程几乎完全相同：会获得父进程的内存空间、栈、数据段、堆、打开的文件描述符、信号处理函数、进程优先级、环境变量等资源的副本。\n\n * 返回值\n   \n   > 成功时，在父进程中返回子进程的 PID，在子进程中返回 000。失败时，父进程返回 −1-1−1，不创建子进程，并适当设置 errno。\n   > \n   > 其中errno是一个全局变量，它用于表示最近一次系统调用或库函数调用产生的错误代码。当系统调用或库函数失败时，它们通常会设置 errno 以指示错误的原因。\n   > \n   > 以下是一些常见的 errno 错误代码及其含义：\n   > \n   >  * EAGAIN：资源暂时不可用，通常是因为达到了系统限制，如文件描述符或内存限制。\n   >  * ENOMEM：内存不足，无法分配请求的资源。\n   >  * EACCES：权限不足，无法访问某个资源。\n   >  * EINTR：系统调用被信号中断。\n   >  * EINVAL：无效的参数。\n\n * 重点\n   \n   > fork() 函数创建的子进程会从父进程复制执行顺序。具体来说，子进程会从父进程复制当前的执行上下文，包括指令指针（instruction pointer）和寄存器的状态。这意味着子进程将从 fork() 系统调用之后的指令开始执行，与父进程在 fork() 之后应该执行的指令完全相同。因此，fork() 之后通常会有一个基于返回值的分支结构，以区分父进程和子进程的执行路径。\n\n\n# 1.2 fork实例\n\n# 1.2.1多个fork返回值\n\n#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    pid_t pid1 = fork();\n    pid_t pid2 = fork();\n    pid_t pid3 = fork();\n    pid_t pid  = getpid();\n    printf("The PID of the current process is %d\\n Hello World from (%d, %d, %d)\\n", pid, pid1, pid2, pid3);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这段程序包含了三个 fork() 调用，每个 fork() 都会创建一个新的子进程。由于每次 fork() 调用都会导致进程数翻倍，所以总共会有23=82^3=823=8个进程 （包括最初的父进程）。每个进程都会打印出它的进程 ID (pid) 以及三个 fork() 调用的返回值 (pid1, pid2, pid3)。\n\n得到的输出结果如下：\n\n\n\n我们画个状态机来理解它们的输出，假设最初的父进程PID为291871：\n\n\n\n# 1.2.2 C语言 fork与输出\n\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main(int argc, char *argv[]) {\n  int n = 2;\n  for (int i = 0; i < n; i++) {\n    fork();\n    printf("Hello\\n");\n  }\n  for (int i = 0; i < n; i++) {\n    wait(NULL);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这段代码中，按我们的理解，第一次fork后有2个进程，然后一起执行printf输出，得到两个Hello，然后第二次fork后有4个进程，然后执行printf，得到四个Hello，则会有6个``Hello`，如下：\n\n\n\n但是当我们将输出通过管道传给cat等命令时，会看到8个Hello：\n\n\n\n这是因为标准输出一般是行缓冲的，碰到\\n，缓冲区中的内容会被刷新，即输出到终端或文件中。这种缓冲方式的目的是为了提高效率，因为这样可以减少对磁盘 I/O 的调用次数。\n\n如果标准输出被重定向到管道，它可能不再是行缓冲的，而是变为全缓冲的。这意味着缓冲区可能会在填满时刷新，而不是在每次遇到换行符时刷新。如果缓冲区足够大，以至于可以容纳所有的 Hello 输出，那么fork的时候子进程也会复制缓冲区，导致最后每个进程中的缓冲区都有2个Hello，最后输出为8个。\n\n如果为了确保缓冲区在需要的时候被刷新，可以在 printf 调用之后显式地调用 fflush(stdout) 来刷新标准输出缓冲区。这样可以确保所有的输出都被立即写入，而不会受到缓冲行为的影响。\n\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main(int argc, char *argv[]) {\n  int n = 2;\n  for (int i = 0; i < n; i++) {\n    fork();\n    printf("Hello\\n");\n    fflush(stdout);\n  }\n  for (int i = 0; i < n; i++) {\n    wait(NULL);\n  }\n  return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n\n# 1.2.3 fork 💣\n\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main(int argc, char *argv[]) {\n  while(1) {\n      fork();\n  }\n  return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这段代码会无限循环地调用 fork() 函数，每次循环都会创建一个新进程。由于每次 fork() 调用都会成功创建一个新进程，而且这个新进程又会立即进入下一次循环并再次调用 fork()，因此进程的数量会以指数速度增长，很快就会耗尽系统的可用资源。\n\n绝对不要在任何生产环境或您没有权限的任何系统上运行fork炸弹。\n\n\n# 2 vfork\n\n\n# 2.1 基本介绍\n\n * 描述\n   \n   #include <sys/types.h>\n   #include <unistd.h>\n   \n   pid_t vfork(void);\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n   \n   vfork() 系统调用用于创建一个子进程，与 fork() 类似，但它使用父进程的地址空间，而不是复制父进程的地址空间。vfork() 调用后，父进程会阻塞，直到子进程调用 exec 函数或执行了 exit 函数。这是因为子进程需要独占父进程的地址空间，以确保数据一致性。一。在子进程调用 exec 函数或执行了 exit 函数之后，子进程将获得自己的内存空间。\n\n * 返回值\n   \n   和fork一致\n\n * 重点\n   \n   >  1. vfork() 创建的子进程会继承父进程的环境，但不会继承父进程的堆栈。\n   >  2. 在子进程执行这些exec或exit操作之前，父进程和子进程可能会访问相同的内存地址，这可能导致数据竞争和不一致。\n   >  3. 在 vfork() 调用成功后，子进程应该立即调用 exec 函数或执行 exit 函数。如果在子进程中修改除了用于存储从 vfork() 返回值的 pid_t 类型变量之外的任何数据，或者从调用 vfork() 的函数返回，或在成功调用 _exit() 或 exec() 函数族中的一个函数之前调用其他任何函数，则行为是未定义的。这可能会导致程序崩溃或表现出不可预测的行为。 因此，使用 vfork() 时，必须确保子进程在调用 exec 函数或执行 exit 函数之前不执行任何可能影响共享内存的操作。\n   >  4. vfork() 系统调用会阻塞父进程，直到子进程完成 exec 调用或 exit 调用。父进程不需要显式调用 wait() 或 waitpid() 来等待子进程结束。\n\n\n# 2.2 验证vfork共享内存\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    // 在父进程中分配内存并初始化\n    char *buffer = malloc(1024);\n    assert(buffer != NULL);\n    memset(buffer, \'A\', 1024);\n\n    // 使用vfork创建子进程\n    pid_t pid = vfork();\n    if (pid < 0) {\n        perror("vfork error");\n        exit(EXIT_FAILURE);\n    } else if (pid == 0) {\n        // 子进程\n        printf("Child process: PID = %d\\n", getpid());\n\n        // 修改内容\n        memset(buffer, \'B\', 1024);\n        // 子进程\n        char * const argv[] = {"/bin/echo", "Hello, Linux!", NULL};\n        char * const envp[] = {NULL};\n        // 执行exec函数\n        execve(argv[0], argv, envp);\n    } else {\n        // 父进程\n        printf("Parent process: PID = %d, child\'s PID = %d\\n", getpid(), pid);\n        // 验证内存内容是否被子进程修改\n        for (int i = 0; i < 1024; i++) {\n            if (buffer[i] != \'B\') {\n                printf("Memory corruption detected at index %d\\n", i);\n                exit(EXIT_FAILURE);\n            }\n        }\n        printf("Memory is consistent\\n");\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n这个程序的目的是验证在 vfork() 之后，子进程和父进程是否共享内存。首先在父进程中分配一块内存 ，并将其初始化为字符‘A’。然后，父进程调用 vfork() 创建一个子进程。在子进程中，程序试图将内容修改为字符 ‘B’，并执行 execve()。在父进程中，程序检查缓冲区的内容是否被修改为字符 ‘B’，以验证内存是否被正确共享。\n\n程序运行结果如下：\n\n\n\n\n# 3 clone\n\n\n# 3.1 基本介绍\n\n * 描述\n   \n   #define _GNU_SOURCE\n   #include <sched.h>\n   int clone(int (*fn)(void *), void *child_stack, int flags, void *arg, ...\n                    /* pid_t *parent_tid, void *tls, pid_t *child_tid */ );\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n   \n   clone与fork类似，是用于创建新进程的系统调用，但clone提供了更精确的控制，可以确定在调用进程（父进程）和子进程之间共享哪些执行上下文的部分。例如，调用者可以控制两个进程是否共享虚拟地址空间、文件描述符表和信号处理程序表。这些系统调用还允许将新的子进程放置在单独的命名空间中。\n\n * 参数\n   \n   >  * fn是指向新进程要执行的函数的指针，这个函数接受一个 void* 参数，并返回一个 int 类型的值，这个返回值将被 clone 系统调用捕获，并作为子进程的退出状态；\n   > \n   >  * child_stack是新进程的堆栈地址，由于子进程和调用进程可能共享内存，因此子进程不可能与调用进程在同一堆栈中执行。调用进程必须为子堆栈设置内存空间，并将指向该空间的指针传递给clone()。\n   > \n   >  * flags可以设置新进程的属性（通过二进制位设置），包括是否与原进程共享地址空间（CLONE_VM）、是否共享文件描述符表（CLONE_FILES）、是否共享信号处理器（CLONE_SIGHAND）等等；\n   >    \n   >    int flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS;\n   >    \n   >    标志              含义\n   >    CLONE_PARENT    创建的子进程的父进程是调用者的父进程，新进程与创建它的进程成了“兄弟”而不是“父子”\n   >    CLONE_FS        子进程与父进程共享相同的文件系统，包括root、当前目录、umask\n   >    CLONE_FILES     子进程与父进程共享相同的文件描述符（file descriptor）表\n   >    CLONE_NEWNS     在新的namespace启动子进程，namespace描述了进程的文件hierarchy\n   >    CLONE_SIGHAND   子进程与父进程共享相同的信号处理（signal handler）表\n   >    CLONE_PTRACE    若父进程被trace，子进程也被trace\n   >    CLONE_VFORK     父进程被挂起，直至子进程释放虚拟内存资源\n   >    CLONE_VM        子进程与父进程运行于相同的内存空间\n   >    CLONE_PID       子进程在创建时PID与父进程一致\n   >    CLONE_THREAD    Linux 2.4中增加以支持POSIX线程标准，子进程与父进程共享相同的线程群\n   > \n   >  * arg是传递给新进程的参数；\n   > \n   >  * 可选参数，包括 pid_t *parent_tid等。\n\n * 返回值\n   \n   > 成功时，在父进程中返回子进程的 PID。失败时，父进程返回 −1-1−1，不创建子进程，并适当设置 errno。\n\n * 重点\n   \n   >  1. clone 可以创建新的进程或线程，Linux创建线程使用的系统调用就是clone。而 fork 和vfork只能创建进程。这意味着 clone 可以在单个进程中创建多个线程，而 fork 则总是创建一个新的进程。\n   >  2. clone 提供比 fork 和 vfork 更多的选项，可以指定子进程或线程的堆栈、信号处理、权限等。\n   >  3. clone 的使用比 fork 和 vfork 更复杂，需要正确设置 flags、child_stack、parent_pidptr、ptr、stack_size 和 tls 等参数。\n\n\n# 3.2 clone使用\n\n#define _GNU_SOURCE\n#include <sched.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#define STACK_SIZE (1024 * 1024) /* Stack size for cloned child */\n// 宏，简化错误处理\n#define ERREXIT(msg) { perror(msg); exit(EXIT_FAILURE); }\n// 安全分配内存函数，分配失败报告错误\n#define CHECKALLOC(ptr, msg)  ({ void *p = ptr; if (p == NULL) {ERREXIT(msg);} p;})\n\n/*\n * 子进程函数\n * params: 接受一个void *类型参数，但是没有被使用过，后面的声明是用于告诉编译器这个参数是未被使用的\n */\nstatic int childFunc(void *arg __attribute__((unused))) {\n    puts("child: start");\n    sleep(2);\n    puts("child: terminate");\n    return 0; /* Child terminates now */\n\n}\n\nint main(int argc, char *argv[]) {\n    /* Start of stack buffer */\n    char **stacks;\n    /* Child process\'s pids */\n    pid_t *pids;\n    size_t nproc, i;\n\n    // 接受两个参数\n    if (argc != 2) {\n        puts("Wrong way to execute the program:\\n"\n                "\\t\\t./waitpid nProcesses\\n"\n                "example:\\t./waitpid 2");\n\n        return EXIT_FAILURE;\n\n    }\n    // 初始化nproc，表示要创建的子进程数\n    nproc = atol(argv[1]);  /* Process count */\n\n    // 分配内存空间\n    stacks = CHECKALLOC(malloc(nproc * sizeof(void *)), "malloc");\n    pids = CHECKALLOC(malloc(nproc * sizeof(pid_t)), "malloc");\n\n    for (i = 0; i < nproc; i++) {\n        char *stackTop; /* End of stack buffer */\n        stacks[i] = CHECKALLOC(malloc(STACK_SIZE), "stack malloc");\n        // 得到栈顶位置\n        stackTop = stacks[i] + STACK_SIZE;\n\n        /*\n         * 创建子进程\n         * 第一个标志表示在子进程清除线程组ID（TID），目的是为了避免子进程与父进程或其他子进程的线程组ID冲突\n         * 第二个表示告诉在子进程中设置线程ID，目的是为了允许父进程在子进程中追踪线程\n         * 告诉 clone 系统调用在子进程中重新安装信号处理程序，目的是为了允许子进程捕获和处理信号，而不是传递给父进程。\n         */\n        pids[i] = clone(childFunc, stackTop, CLONE_CHILD_CLEARTID | CLONE_CHILD_SETTID | SIGCHLD, NULL);\n        if (pids[i] == -1)\n            ERREXIT("clone");\n        printf("clone() returned %ld\\n", (long)pids[i]);\n\n    }\n\n    sleep(1);\n\n    // 等待所有子进程\n    for (i = 0; i < nproc; i++) {\n        // 第一个参数为子进程id，第二个参数表示不关心子进程的退出状态，第三个参数表示等待任何子进程\n        if (waitpid(pids[i], NULL, 0) == -1)\n            ERREXIT("waitpid");\n        printf("child %ld has terminated\\n", (long)pids[i]);\n\n    }\n\n    // 回收内存空间\n    for (i = 0; i < nproc; i++)\n        free(stacks[i]);\n    free(stacks);\n    free(pids);\n    return EXIT_SUCCESS;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n\n\n运行：gcc clone-example.c && ./a.out 5，其中5为nproc，表示要创建的进程数。\n\n运行结果如下：\n\n',normalizedContent:'# 1 fork\n\n\n# 1.1 基本介绍\n\n#include <sys/types.h>\n#include <unistd.h>\n\npid_t fork(void)\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n * 描述\n   \n   > fork用于创建一个子进程，它与父进程的唯一区别在于其pid和ppid，以及资源利用设置为0。文件锁和挂起信号（指已经被内核发送给一个进程，但尚未被该进程处理的信号）不会被继承，其他和父进程几乎完全相同：会获得父进程的内存空间、栈、数据段、堆、打开的文件描述符、信号处理函数、进程优先级、环境变量等资源的副本。\n\n * 返回值\n   \n   > 成功时，在父进程中返回子进程的 pid，在子进程中返回 000。失败时，父进程返回 −1-1−1，不创建子进程，并适当设置 errno。\n   > \n   > 其中errno是一个全局变量，它用于表示最近一次系统调用或库函数调用产生的错误代码。当系统调用或库函数失败时，它们通常会设置 errno 以指示错误的原因。\n   > \n   > 以下是一些常见的 errno 错误代码及其含义：\n   > \n   >  * eagain：资源暂时不可用，通常是因为达到了系统限制，如文件描述符或内存限制。\n   >  * enomem：内存不足，无法分配请求的资源。\n   >  * eacces：权限不足，无法访问某个资源。\n   >  * eintr：系统调用被信号中断。\n   >  * einval：无效的参数。\n\n * 重点\n   \n   > fork() 函数创建的子进程会从父进程复制执行顺序。具体来说，子进程会从父进程复制当前的执行上下文，包括指令指针（instruction pointer）和寄存器的状态。这意味着子进程将从 fork() 系统调用之后的指令开始执行，与父进程在 fork() 之后应该执行的指令完全相同。因此，fork() 之后通常会有一个基于返回值的分支结构，以区分父进程和子进程的执行路径。\n\n\n# 1.2 fork实例\n\n# 1.2.1多个fork返回值\n\n#include <stdio.h>\n#include <unistd.h>\n\nint main() {\n    pid_t pid1 = fork();\n    pid_t pid2 = fork();\n    pid_t pid3 = fork();\n    pid_t pid  = getpid();\n    printf("the pid of the current process is %d\\n hello world from (%d, %d, %d)\\n", pid, pid1, pid2, pid3);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这段程序包含了三个 fork() 调用，每个 fork() 都会创建一个新的子进程。由于每次 fork() 调用都会导致进程数翻倍，所以总共会有23=82^3=823=8个进程 （包括最初的父进程）。每个进程都会打印出它的进程 id (pid) 以及三个 fork() 调用的返回值 (pid1, pid2, pid3)。\n\n得到的输出结果如下：\n\n\n\n我们画个状态机来理解它们的输出，假设最初的父进程pid为291871：\n\n\n\n# 1.2.2 c语言 fork与输出\n\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main(int argc, char *argv[]) {\n  int n = 2;\n  for (int i = 0; i < n; i++) {\n    fork();\n    printf("hello\\n");\n  }\n  for (int i = 0; i < n; i++) {\n    wait(null);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这段代码中，按我们的理解，第一次fork后有2个进程，然后一起执行printf输出，得到两个hello，然后第二次fork后有4个进程，然后执行printf，得到四个hello，则会有6个``hello`，如下：\n\n\n\n但是当我们将输出通过管道传给cat等命令时，会看到8个hello：\n\n\n\n这是因为标准输出一般是行缓冲的，碰到\\n，缓冲区中的内容会被刷新，即输出到终端或文件中。这种缓冲方式的目的是为了提高效率，因为这样可以减少对磁盘 i/o 的调用次数。\n\n如果标准输出被重定向到管道，它可能不再是行缓冲的，而是变为全缓冲的。这意味着缓冲区可能会在填满时刷新，而不是在每次遇到换行符时刷新。如果缓冲区足够大，以至于可以容纳所有的 hello 输出，那么fork的时候子进程也会复制缓冲区，导致最后每个进程中的缓冲区都有2个hello，最后输出为8个。\n\n如果为了确保缓冲区在需要的时候被刷新，可以在 printf 调用之后显式地调用 fflush(stdout) 来刷新标准输出缓冲区。这样可以确保所有的输出都被立即写入，而不会受到缓冲行为的影响。\n\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main(int argc, char *argv[]) {\n  int n = 2;\n  for (int i = 0; i < n; i++) {\n    fork();\n    printf("hello\\n");\n    fflush(stdout);\n  }\n  for (int i = 0; i < n; i++) {\n    wait(null);\n  }\n  return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n\n# 1.2.3 fork 💣\n\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main(int argc, char *argv[]) {\n  while(1) {\n      fork();\n  }\n  return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这段代码会无限循环地调用 fork() 函数，每次循环都会创建一个新进程。由于每次 fork() 调用都会成功创建一个新进程，而且这个新进程又会立即进入下一次循环并再次调用 fork()，因此进程的数量会以指数速度增长，很快就会耗尽系统的可用资源。\n\n绝对不要在任何生产环境或您没有权限的任何系统上运行fork炸弹。\n\n\n# 2 vfork\n\n\n# 2.1 基本介绍\n\n * 描述\n   \n   #include <sys/types.h>\n   #include <unistd.h>\n   \n   pid_t vfork(void);\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n   \n   vfork() 系统调用用于创建一个子进程，与 fork() 类似，但它使用父进程的地址空间，而不是复制父进程的地址空间。vfork() 调用后，父进程会阻塞，直到子进程调用 exec 函数或执行了 exit 函数。这是因为子进程需要独占父进程的地址空间，以确保数据一致性。一。在子进程调用 exec 函数或执行了 exit 函数之后，子进程将获得自己的内存空间。\n\n * 返回值\n   \n   和fork一致\n\n * 重点\n   \n   >  1. vfork() 创建的子进程会继承父进程的环境，但不会继承父进程的堆栈。\n   >  2. 在子进程执行这些exec或exit操作之前，父进程和子进程可能会访问相同的内存地址，这可能导致数据竞争和不一致。\n   >  3. 在 vfork() 调用成功后，子进程应该立即调用 exec 函数或执行 exit 函数。如果在子进程中修改除了用于存储从 vfork() 返回值的 pid_t 类型变量之外的任何数据，或者从调用 vfork() 的函数返回，或在成功调用 _exit() 或 exec() 函数族中的一个函数之前调用其他任何函数，则行为是未定义的。这可能会导致程序崩溃或表现出不可预测的行为。 因此，使用 vfork() 时，必须确保子进程在调用 exec 函数或执行 exit 函数之前不执行任何可能影响共享内存的操作。\n   >  4. vfork() 系统调用会阻塞父进程，直到子进程完成 exec 调用或 exit 调用。父进程不需要显式调用 wait() 或 waitpid() 来等待子进程结束。\n\n\n# 2.2 验证vfork共享内存\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    // 在父进程中分配内存并初始化\n    char *buffer = malloc(1024);\n    assert(buffer != null);\n    memset(buffer, \'a\', 1024);\n\n    // 使用vfork创建子进程\n    pid_t pid = vfork();\n    if (pid < 0) {\n        perror("vfork error");\n        exit(exit_failure);\n    } else if (pid == 0) {\n        // 子进程\n        printf("child process: pid = %d\\n", getpid());\n\n        // 修改内容\n        memset(buffer, \'b\', 1024);\n        // 子进程\n        char * const argv[] = {"/bin/echo", "hello, linux!", null};\n        char * const envp[] = {null};\n        // 执行exec函数\n        execve(argv[0], argv, envp);\n    } else {\n        // 父进程\n        printf("parent process: pid = %d, child\'s pid = %d\\n", getpid(), pid);\n        // 验证内存内容是否被子进程修改\n        for (int i = 0; i < 1024; i++) {\n            if (buffer[i] != \'b\') {\n                printf("memory corruption detected at index %d\\n", i);\n                exit(exit_failure);\n            }\n        }\n        printf("memory is consistent\\n");\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n这个程序的目的是验证在 vfork() 之后，子进程和父进程是否共享内存。首先在父进程中分配一块内存 ，并将其初始化为字符‘a’。然后，父进程调用 vfork() 创建一个子进程。在子进程中，程序试图将内容修改为字符 ‘b’，并执行 execve()。在父进程中，程序检查缓冲区的内容是否被修改为字符 ‘b’，以验证内存是否被正确共享。\n\n程序运行结果如下：\n\n\n\n\n# 3 clone\n\n\n# 3.1 基本介绍\n\n * 描述\n   \n   #define _gnu_source\n   #include <sched.h>\n   int clone(int (*fn)(void *), void *child_stack, int flags, void *arg, ...\n                    /* pid_t *parent_tid, void *tls, pid_t *child_tid */ );\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n   \n   clone与fork类似，是用于创建新进程的系统调用，但clone提供了更精确的控制，可以确定在调用进程（父进程）和子进程之间共享哪些执行上下文的部分。例如，调用者可以控制两个进程是否共享虚拟地址空间、文件描述符表和信号处理程序表。这些系统调用还允许将新的子进程放置在单独的命名空间中。\n\n * 参数\n   \n   >  * fn是指向新进程要执行的函数的指针，这个函数接受一个 void* 参数，并返回一个 int 类型的值，这个返回值将被 clone 系统调用捕获，并作为子进程的退出状态；\n   > \n   >  * child_stack是新进程的堆栈地址，由于子进程和调用进程可能共享内存，因此子进程不可能与调用进程在同一堆栈中执行。调用进程必须为子堆栈设置内存空间，并将指向该空间的指针传递给clone()。\n   > \n   >  * flags可以设置新进程的属性（通过二进制位设置），包括是否与原进程共享地址空间（clone_vm）、是否共享文件描述符表（clone_files）、是否共享信号处理器（clone_sighand）等等；\n   >    \n   >    int flags = clone_vm | clone_fs | clone_files | clone_sighand | clone_thread | clone_sysvsem | clone_settls;\n   >    \n   >    标志              含义\n   >    clone_parent    创建的子进程的父进程是调用者的父进程，新进程与创建它的进程成了“兄弟”而不是“父子”\n   >    clone_fs        子进程与父进程共享相同的文件系统，包括root、当前目录、umask\n   >    clone_files     子进程与父进程共享相同的文件描述符（file descriptor）表\n   >    clone_newns     在新的namespace启动子进程，namespace描述了进程的文件hierarchy\n   >    clone_sighand   子进程与父进程共享相同的信号处理（signal handler）表\n   >    clone_ptrace    若父进程被trace，子进程也被trace\n   >    clone_vfork     父进程被挂起，直至子进程释放虚拟内存资源\n   >    clone_vm        子进程与父进程运行于相同的内存空间\n   >    clone_pid       子进程在创建时pid与父进程一致\n   >    clone_thread    linux 2.4中增加以支持posix线程标准，子进程与父进程共享相同的线程群\n   > \n   >  * arg是传递给新进程的参数；\n   > \n   >  * 可选参数，包括 pid_t *parent_tid等。\n\n * 返回值\n   \n   > 成功时，在父进程中返回子进程的 pid。失败时，父进程返回 −1-1−1，不创建子进程，并适当设置 errno。\n\n * 重点\n   \n   >  1. clone 可以创建新的进程或线程，linux创建线程使用的系统调用就是clone。而 fork 和vfork只能创建进程。这意味着 clone 可以在单个进程中创建多个线程，而 fork 则总是创建一个新的进程。\n   >  2. clone 提供比 fork 和 vfork 更多的选项，可以指定子进程或线程的堆栈、信号处理、权限等。\n   >  3. clone 的使用比 fork 和 vfork 更复杂，需要正确设置 flags、child_stack、parent_pidptr、ptr、stack_size 和 tls 等参数。\n\n\n# 3.2 clone使用\n\n#define _gnu_source\n#include <sched.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#define stack_size (1024 * 1024) /* stack size for cloned child */\n// 宏，简化错误处理\n#define errexit(msg) { perror(msg); exit(exit_failure); }\n// 安全分配内存函数，分配失败报告错误\n#define checkalloc(ptr, msg)  ({ void *p = ptr; if (p == null) {errexit(msg);} p;})\n\n/*\n * 子进程函数\n * params: 接受一个void *类型参数，但是没有被使用过，后面的声明是用于告诉编译器这个参数是未被使用的\n */\nstatic int childfunc(void *arg __attribute__((unused))) {\n    puts("child: start");\n    sleep(2);\n    puts("child: terminate");\n    return 0; /* child terminates now */\n\n}\n\nint main(int argc, char *argv[]) {\n    /* start of stack buffer */\n    char **stacks;\n    /* child process\'s pids */\n    pid_t *pids;\n    size_t nproc, i;\n\n    // 接受两个参数\n    if (argc != 2) {\n        puts("wrong way to execute the program:\\n"\n                "\\t\\t./waitpid nprocesses\\n"\n                "example:\\t./waitpid 2");\n\n        return exit_failure;\n\n    }\n    // 初始化nproc，表示要创建的子进程数\n    nproc = atol(argv[1]);  /* process count */\n\n    // 分配内存空间\n    stacks = checkalloc(malloc(nproc * sizeof(void *)), "malloc");\n    pids = checkalloc(malloc(nproc * sizeof(pid_t)), "malloc");\n\n    for (i = 0; i < nproc; i++) {\n        char *stacktop; /* end of stack buffer */\n        stacks[i] = checkalloc(malloc(stack_size), "stack malloc");\n        // 得到栈顶位置\n        stacktop = stacks[i] + stack_size;\n\n        /*\n         * 创建子进程\n         * 第一个标志表示在子进程清除线程组id（tid），目的是为了避免子进程与父进程或其他子进程的线程组id冲突\n         * 第二个表示告诉在子进程中设置线程id，目的是为了允许父进程在子进程中追踪线程\n         * 告诉 clone 系统调用在子进程中重新安装信号处理程序，目的是为了允许子进程捕获和处理信号，而不是传递给父进程。\n         */\n        pids[i] = clone(childfunc, stacktop, clone_child_cleartid | clone_child_settid | sigchld, null);\n        if (pids[i] == -1)\n            errexit("clone");\n        printf("clone() returned %ld\\n", (long)pids[i]);\n\n    }\n\n    sleep(1);\n\n    // 等待所有子进程\n    for (i = 0; i < nproc; i++) {\n        // 第一个参数为子进程id，第二个参数表示不关心子进程的退出状态，第三个参数表示等待任何子进程\n        if (waitpid(pids[i], null, 0) == -1)\n            errexit("waitpid");\n        printf("child %ld has terminated\\n", (long)pids[i]);\n\n    }\n\n    // 回收内存空间\n    for (i = 0; i < nproc; i++)\n        free(stacks[i]);\n    free(stacks);\n    free(pids);\n    return exit_success;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n\n\n运行：gcc clone-example.c && ./a.out 5，其中5为nproc，表示要创建的进程数。\n\n运行结果如下：\n\n',charsets:{cjk:!0},lastUpdated:"2024/04/26, 08:43:57",lastUpdatedTimestamp:1714092237e3},{title:"03.HDU 4507 恨7不成妻 （数位DP套路题）",frontmatter:{title:"03.HDU 4507 恨7不成妻 （数位DP套路题）",date:"2021-05-13T22:02:01.000Z",tags:["数位DP"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/243024/",categories:["开发","数据结构与算法","动态规划"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/03.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/07.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/03.HDU%204507%20%E6%81%A87%E4%B8%8D%E6%88%90%E5%A6%BB%20%EF%BC%88%E6%95%B0%E4%BD%8DDP%E5%A5%97%E8%B7%AF%E9%A2%98%EF%BC%8C%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90%EF%BC%89.html",relativePath:"01.开发/03.数据结构与算法/07.动态规划/03.HDU 4507 恨7不成妻 （数位DP套路题，详细解析）.md",key:"v-49401e23",path:"/pages/243024/",headersStr:null,content:'不会数位DPDPDP的这里指路一篇介绍非常详细的数位DPDPDP的blogblogblog:点这里。\n\n * 链接 恨7不成妻\n\n * 题面\n   \n   > 单身! 依然单身！ 吉哥依然单身！ DS级码农吉哥依然单身！ 所以，他生平最恨情人节，不管是214还是77，他都讨厌！ 吉哥观察了214和77这两个数，发现： 2+1+4=72+1+4=72+1+4=7　 7+7=7∗27+7=7*27+7=7∗2 77=7∗1177=7*1177=7∗11 最终，他发现原来这一切归根到底都是因为和7有关！所以，他现在甚至讨厌一切和7有关的数！什么样的数和7有关呢？如果一个整数符合下面3个条件之一，那么我们就说这个整数和7有关—— 　　　1、整数中某一位是7； 　　　2、整数的每一位加起来的和是7的整数倍； 　　　3、这个整数是7的整数倍；\n   > \n   > 现在问题来了：吉哥想知道在一定区间内和7无关的数字的平方和。 　Input 　输入数据的第一行是case数T(1 <= T <= 50)，然后接下来的T行表示T个case;每个case在一行内包含两个正整数L, R(1 <= L <= R <= 10^18)。 　Output 　请计算[L,R]中和7无关的数字的平方和，并将结果对10^9 + 7 求模后输出。 　Sample Input\n   > \n   > 3\n   > 1 9\n   > 10 11\n   > 17 17\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > \n   > \n   > Sample Output\n   > \n   > 236\n   > 221\n   > 0\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > \n   > 1\n   > 2\n   > 3\n\n * 解题思路\n   \n   根据题意我们做出预处理，利用闫式DPDPDP分析法分析如下：\n\n\n\n以上只是简单分析，我们还并没有真正的进行状态转移和计算，那么根据题意，首先是需要知道整数的每一位加起来的和是777的整数倍以及该整数是777的整数倍，这个好处理，在我们的前面的题中有类似的题型，这已经在我们的fff数组的第三维和第四维了。所以难点就在于怎么处理整数的平方和。我们看下面的公式推导：\n\n我们用jAjAjA来表示iii位数，而其中的AAA为i−1i-1i−1位数。设这个状态有ttt个符合要求的数，分别是A1A_1A1 ~AtA_tAt 。 那么，平方和易得为：\n\n(jA1)2+(jA2)2+(jA3)2+...+(jAt−1)2+(jAt)2(jA_1)^2+(jA_2)^2+(jA_3)^2+...+(jA_{t-1})^2+(jA_t)^2(jA1 )2+(jA2 )2+(jA3 )2+...+(jAt−1 )2+(jAt )2\n\n（我们分割表示将AAA提取出来。）\n\n=(j∗10i−1+A1)2+(j∗10i−1+A2)2+(j∗10i−1+A3)2+...+(j∗10i−1+At−1)2+(j∗10i−1+At)2=(j*10^{i-1}+A_1)^2+(j*10^{i-1}+A_2)^2+(j*10^{i-1}+A_3)^2+...+(j*10^{i-1}+A_{t-1})^2+(j*10^{i-1}+A_t)^2=(j∗10i−1+A1 )2+(j∗10i−1+A2 )2+(j∗10i−1+A3 )2+...+(j∗10i−1+At−1 )2+(j∗10i−1+At )2\n\n（平方和公式）\n\n=t∗(j∗10i−1)2+2∗(j∗10i−1)∗(A1+...+At)+(A12+...+A2)=t*(j*10^{i-1})^2+2*(j*10^{i-1})*(A_1+...+A_t)+(A_1^2+...+A^2)=t∗(j∗10i−1)2+2∗(j∗10i−1)∗(A1 +...+At )+(A12 +...+A2)\n\n这样，在这个式子中，由于jjj已知，所以我们发现fff数组需要保存三个值。AAA的000次方之和，也就是符合要求的数，AAA的111次方之和，也就是符合要求的除去jjj的i−1i-1i−1位数相加，AAA的222次方之和，也就是符合要求的除去jjj的i−1i-1i−1位数平方相加。我们分别用s0,s1,s2s_0,s_1,s_2s0 ,s1 ,s2\n\n分别代表上述的三个值。\n\n那么这里我们需要怎么求s1s_1s1 ，如下：\n\n注：这里的s1s_1s1 为i+1i+1i+1位的s1s_1s1 ，而它存储的就是iii位的AAA。\n\njA1+...+jAtjA_1+...+jA_tjA1 +...+jAt\n\n=j∗10i−1+(A1+...+At)=j*10^{i-1}+(A_1+...+A_t)=j∗10i−1+(A1 +...+At )\n\n所以我们的fff应该是一个结构体数组，它需要存取s0,s1,s2s_0,s_1,s_2s0 ,s1 ,s2 。那么预处理根据上述分析其实就简单了。那么就按照数位DPDPDP的套路解决这道题即可。需要注意这道题好多坑点，多取模，足够细心才可以解决。（调BugBugBug调了好久。快绝望了。）\n\n * 代码\n\n/**\n  *@filename:恨7不成妻\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 21:19\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 20;\nconst ll P = 1e9+7;\n\n//需要满足三个性质。\n//1.不含7.\n//2.各位数字之和模7不为0.an-1+...+a0%7!=0. \n//3.该数模7不为0.an-1*pow(10,n-1)+...+a0+pow(10,0)%7!=0\n\nstruct F{\n    ll s0,s1,s2;//s0为符合要求的数。s1为符合要求的数1次方之和，s2为符合要求的数的2次方之和。\n}f[N][10][7][7];//f[i][j][k][u]表示总共有i位数且最高位是j，该数值模7为k，各位数数字之和模7为u的所有数的s0,s1,s2.\n//进行初始化。\nint t;//测试数。\nll l,r;\nll power7[N],power9[N];//power7[i]存储10^i余7的余数，power9[i]存储10^i余P的余数。\nll mod(ll x,ll y){\n    return (x%y+y)%y;\n}\nvoid init(){\n    //确定初始值，位数为1的情况。\n    for(int j=0;j<10;j++){\n        if(j==7)continue;\n        //根据性质排除不符合要求的。\n        F &v=f[1][j][j%7][j%7];//这里用引用减少代码量。\n        v.s0++;\n        v.s1+=j;\n        v.s2+=j*j;\n    }\n    ll power = 10;//辅助作用，表示10的i-1次方。\n    for(int i=2;i<N;i++,power*=10){\n        for(int j=0;j<10;j++){\n            if(j==7)continue;//排除不符合要求的数。\n            for(int k=0;k<7;k++){\n                for(int u=0;u<7;u++){\n                    for(int q=0;q<10;q++){\n                        //枚举i-1的最高位。\n                        if(q==7)continue;\n                        F &x=f[i][j][k][u],y=f[i-1][q][mod(k-j*(power%7),7)][mod(u-j,7)];\n                        //s0,s1,s2都是通过公式就算得到。\n                        x.s0=mod(x.s0+y.s0,P);\n                        x.s1=mod(x.s1+1LL*j%P*(power%P)%P*y.s0%P+y.s1,P);\n                        x.s2=mod(x.s2+\n                            1LL*j%P*y.s0%P*(power%P)%P*j%P*(power%P)%P+\n                            1LL*y.s1%P*2%P*j%P*(power%P)%P+y.s2,P);\n                    }\n                }\n            }\n        }\n    }\n    //这里处理为了方便以及降低时间复杂度。\n    power7[0]=1,power9[0]=1;\n    for(int i=1;i<N;i++){\n        power7[i]=power7[i-1]*10%7;\n        power9[i]=power9[i-1]*10%P;\n    }\n}\nF get(int i,int j,int k,int u){\n    //因为f[i][j][k][u]是本身模7等于k，且各位数之和模7等于u的，所以我们需要找出符合条件的集合。\n    ll s0=0,s1=0,s2=0;\n    for(int x=0;x<7;x++){\n        for(int y=0;y<7;y++){\n            if(x==k||y==u)continue;\n            F v=f[i][j][x][y];\n            s0=mod(s0+v.s0,P);\n            s1=mod(s1+v.s1,P);\n            s2=mod(s2+v.s2,P);\n        }\n    }\n    return {s0,s1,s2};\n}\nll dp(ll n){\n    if(!n)return 0;//0的平方和为0.\n    vector<int> a;\n    ll temp=n%P;//备份一个n，供后面判断n使用。\n    while(n)a.push_back(n%10),n/=10;\n    ll last_a=0,last_b=0;//这里我们需要存储前缀的本身值和前缀的个位数之和。\n    ll ans=0;//答案。\n    for(int i=a.size()-1;i>=0;i--){\n        int x=a[i];\n        for(int j=0;j<x;j++){\n            //走左分支。\n            if(j==7)continue;\n            //我们需要将符合条件的数筛出来，这里要用到一个get函数。\n            //求得本身模7不等于a，并且各位数之和模7不等b的集合，此时就可以使用预处理出来的结构体\n            int k=mod(-last_a*power7[i+1],7),u=mod(-last_b,7);\n            F v=get(i+1,j,k,u);\n            //cout<<v.s0<<" "<<v.s1<<" "<<v.s2<<endl;\n            //根据公式求解s2.\n            //j就是last_a.\n            ans=mod(ans+\n                1LL*(last_a%P)*(last_a%P)%P*(power9[i+1]%P)%P*(power9[i+1]%P)%P*v.s0%P+\n                1LL*2*last_a%P*(power9[i+1]%P)%P*v.s1%P+\n                v.s2,P);\n            //cout<<ans<<endl;\n        }\n        //判断x。\n        if(x==7)break;\n        //走右分支更新。\n        last_a=last_a*10+x;\n        last_b+=x;\n        //判断自己本身是否符合要求。\n        if(!i&&last_a%7&&last_b%7){\n            ans=mod(ans+temp*temp%P,P);\n        }\n    }\n    return ans;\n}\nint main(){\n    init();\n    cin>>t;\n    while(t--){\n        cin>>l>>r;\n        cout<<mod(dp(r)-dp(l-1),P)<<endl;\n    }\n    return 0;\n}\n/*\n1\n1 1000000000000000000\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n',normalizedContent:'不会数位dpdpdp的这里指路一篇介绍非常详细的数位dpdpdp的blogblogblog:点这里。\n\n * 链接 恨7不成妻\n\n * 题面\n   \n   > 单身! 依然单身！ 吉哥依然单身！ ds级码农吉哥依然单身！ 所以，他生平最恨情人节，不管是214还是77，他都讨厌！ 吉哥观察了214和77这两个数，发现： 2+1+4=72+1+4=72+1+4=7　 7+7=7∗27+7=7*27+7=7∗2 77=7∗1177=7*1177=7∗11 最终，他发现原来这一切归根到底都是因为和7有关！所以，他现在甚至讨厌一切和7有关的数！什么样的数和7有关呢？如果一个整数符合下面3个条件之一，那么我们就说这个整数和7有关—— 　　　1、整数中某一位是7； 　　　2、整数的每一位加起来的和是7的整数倍； 　　　3、这个整数是7的整数倍；\n   > \n   > 现在问题来了：吉哥想知道在一定区间内和7无关的数字的平方和。 　input 　输入数据的第一行是case数t(1 <= t <= 50)，然后接下来的t行表示t个case;每个case在一行内包含两个正整数l, r(1 <= l <= r <= 10^18)。 　output 　请计算[l,r]中和7无关的数字的平方和，并将结果对10^9 + 7 求模后输出。 　sample input\n   > \n   > 3\n   > 1 9\n   > 10 11\n   > 17 17\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > \n   > \n   > sample output\n   > \n   > 236\n   > 221\n   > 0\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > \n   > 1\n   > 2\n   > 3\n\n * 解题思路\n   \n   根据题意我们做出预处理，利用闫式dpdpdp分析法分析如下：\n\n\n\n以上只是简单分析，我们还并没有真正的进行状态转移和计算，那么根据题意，首先是需要知道整数的每一位加起来的和是777的整数倍以及该整数是777的整数倍，这个好处理，在我们的前面的题中有类似的题型，这已经在我们的fff数组的第三维和第四维了。所以难点就在于怎么处理整数的平方和。我们看下面的公式推导：\n\n我们用jajaja来表示iii位数，而其中的aaa为i−1i-1i−1位数。设这个状态有ttt个符合要求的数，分别是a1a_1a1 ~ata_tat 。 那么，平方和易得为：\n\n(ja1)2+(ja2)2+(ja3)2+...+(jat−1)2+(jat)2(ja_1)^2+(ja_2)^2+(ja_3)^2+...+(ja_{t-1})^2+(ja_t)^2(ja1 )2+(ja2 )2+(ja3 )2+...+(jat−1 )2+(jat )2\n\n（我们分割表示将aaa提取出来。）\n\n=(j∗10i−1+a1)2+(j∗10i−1+a2)2+(j∗10i−1+a3)2+...+(j∗10i−1+at−1)2+(j∗10i−1+at)2=(j*10^{i-1}+a_1)^2+(j*10^{i-1}+a_2)^2+(j*10^{i-1}+a_3)^2+...+(j*10^{i-1}+a_{t-1})^2+(j*10^{i-1}+a_t)^2=(j∗10i−1+a1 )2+(j∗10i−1+a2 )2+(j∗10i−1+a3 )2+...+(j∗10i−1+at−1 )2+(j∗10i−1+at )2\n\n（平方和公式）\n\n=t∗(j∗10i−1)2+2∗(j∗10i−1)∗(a1+...+at)+(a12+...+a2)=t*(j*10^{i-1})^2+2*(j*10^{i-1})*(a_1+...+a_t)+(a_1^2+...+a^2)=t∗(j∗10i−1)2+2∗(j∗10i−1)∗(a1 +...+at )+(a12 +...+a2)\n\n这样，在这个式子中，由于jjj已知，所以我们发现fff数组需要保存三个值。aaa的000次方之和，也就是符合要求的数，aaa的111次方之和，也就是符合要求的除去jjj的i−1i-1i−1位数相加，aaa的222次方之和，也就是符合要求的除去jjj的i−1i-1i−1位数平方相加。我们分别用s0,s1,s2s_0,s_1,s_2s0 ,s1 ,s2\n\n分别代表上述的三个值。\n\n那么这里我们需要怎么求s1s_1s1 ，如下：\n\n注：这里的s1s_1s1 为i+1i+1i+1位的s1s_1s1 ，而它存储的就是iii位的aaa。\n\nja1+...+jatja_1+...+ja_tja1 +...+jat\n\n=j∗10i−1+(a1+...+at)=j*10^{i-1}+(a_1+...+a_t)=j∗10i−1+(a1 +...+at )\n\n所以我们的fff应该是一个结构体数组，它需要存取s0,s1,s2s_0,s_1,s_2s0 ,s1 ,s2 。那么预处理根据上述分析其实就简单了。那么就按照数位dpdpdp的套路解决这道题即可。需要注意这道题好多坑点，多取模，足够细心才可以解决。（调bugbugbug调了好久。快绝望了。）\n\n * 代码\n\n/**\n  *@filename:恨7不成妻\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 21:19\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int n = 20;\nconst ll p = 1e9+7;\n\n//需要满足三个性质。\n//1.不含7.\n//2.各位数字之和模7不为0.an-1+...+a0%7!=0. \n//3.该数模7不为0.an-1*pow(10,n-1)+...+a0+pow(10,0)%7!=0\n\nstruct f{\n    ll s0,s1,s2;//s0为符合要求的数。s1为符合要求的数1次方之和，s2为符合要求的数的2次方之和。\n}f[n][10][7][7];//f[i][j][k][u]表示总共有i位数且最高位是j，该数值模7为k，各位数数字之和模7为u的所有数的s0,s1,s2.\n//进行初始化。\nint t;//测试数。\nll l,r;\nll power7[n],power9[n];//power7[i]存储10^i余7的余数，power9[i]存储10^i余p的余数。\nll mod(ll x,ll y){\n    return (x%y+y)%y;\n}\nvoid init(){\n    //确定初始值，位数为1的情况。\n    for(int j=0;j<10;j++){\n        if(j==7)continue;\n        //根据性质排除不符合要求的。\n        f &v=f[1][j][j%7][j%7];//这里用引用减少代码量。\n        v.s0++;\n        v.s1+=j;\n        v.s2+=j*j;\n    }\n    ll power = 10;//辅助作用，表示10的i-1次方。\n    for(int i=2;i<n;i++,power*=10){\n        for(int j=0;j<10;j++){\n            if(j==7)continue;//排除不符合要求的数。\n            for(int k=0;k<7;k++){\n                for(int u=0;u<7;u++){\n                    for(int q=0;q<10;q++){\n                        //枚举i-1的最高位。\n                        if(q==7)continue;\n                        f &x=f[i][j][k][u],y=f[i-1][q][mod(k-j*(power%7),7)][mod(u-j,7)];\n                        //s0,s1,s2都是通过公式就算得到。\n                        x.s0=mod(x.s0+y.s0,p);\n                        x.s1=mod(x.s1+1ll*j%p*(power%p)%p*y.s0%p+y.s1,p);\n                        x.s2=mod(x.s2+\n                            1ll*j%p*y.s0%p*(power%p)%p*j%p*(power%p)%p+\n                            1ll*y.s1%p*2%p*j%p*(power%p)%p+y.s2,p);\n                    }\n                }\n            }\n        }\n    }\n    //这里处理为了方便以及降低时间复杂度。\n    power7[0]=1,power9[0]=1;\n    for(int i=1;i<n;i++){\n        power7[i]=power7[i-1]*10%7;\n        power9[i]=power9[i-1]*10%p;\n    }\n}\nf get(int i,int j,int k,int u){\n    //因为f[i][j][k][u]是本身模7等于k，且各位数之和模7等于u的，所以我们需要找出符合条件的集合。\n    ll s0=0,s1=0,s2=0;\n    for(int x=0;x<7;x++){\n        for(int y=0;y<7;y++){\n            if(x==k||y==u)continue;\n            f v=f[i][j][x][y];\n            s0=mod(s0+v.s0,p);\n            s1=mod(s1+v.s1,p);\n            s2=mod(s2+v.s2,p);\n        }\n    }\n    return {s0,s1,s2};\n}\nll dp(ll n){\n    if(!n)return 0;//0的平方和为0.\n    vector<int> a;\n    ll temp=n%p;//备份一个n，供后面判断n使用。\n    while(n)a.push_back(n%10),n/=10;\n    ll last_a=0,last_b=0;//这里我们需要存储前缀的本身值和前缀的个位数之和。\n    ll ans=0;//答案。\n    for(int i=a.size()-1;i>=0;i--){\n        int x=a[i];\n        for(int j=0;j<x;j++){\n            //走左分支。\n            if(j==7)continue;\n            //我们需要将符合条件的数筛出来，这里要用到一个get函数。\n            //求得本身模7不等于a，并且各位数之和模7不等b的集合，此时就可以使用预处理出来的结构体\n            int k=mod(-last_a*power7[i+1],7),u=mod(-last_b,7);\n            f v=get(i+1,j,k,u);\n            //cout<<v.s0<<" "<<v.s1<<" "<<v.s2<<endl;\n            //根据公式求解s2.\n            //j就是last_a.\n            ans=mod(ans+\n                1ll*(last_a%p)*(last_a%p)%p*(power9[i+1]%p)%p*(power9[i+1]%p)%p*v.s0%p+\n                1ll*2*last_a%p*(power9[i+1]%p)%p*v.s1%p+\n                v.s2,p);\n            //cout<<ans<<endl;\n        }\n        //判断x。\n        if(x==7)break;\n        //走右分支更新。\n        last_a=last_a*10+x;\n        last_b+=x;\n        //判断自己本身是否符合要求。\n        if(!i&&last_a%7&&last_b%7){\n            ans=mod(ans+temp*temp%p,p);\n        }\n    }\n    return ans;\n}\nint main(){\n    init();\n    cin>>t;\n    while(t--){\n        cin>>l>>r;\n        cout<<mod(dp(r)-dp(l-1),p)<<endl;\n    }\n    return 0;\n}\n/*\n1\n1 1000000000000000000\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"有限直接执行",frontmatter:{title:"有限直接执行",tags:["OS"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},date:"2024-04-25T22:31:02.000Z",permalink:"/pages/4b8a3a/",categories:["开发","系统架构","操作系统","虚拟化"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/02.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/03.%E6%9C%89%E9%99%90%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C.html",relativePath:"01.开发/05.系统架构/02.操作系统/03.有限直接执行.md",key:"v-31a7810b",path:"/pages/4b8a3a/",headersStr:null,content:'github代码 在本作业中，您将测量系统调用和上下文切换的成本。测量系统调用的成本相对容易。例如，您可以反复调用一个简单的系统调用（如执行 0 字节读取），并计算所需时间；将时间除以迭代次数，就能估算出系统调用的成本。 您必须考虑的一件事是计时器的精度和准确性。可以使用的典型计时器是 gettimeofday()；阅读手册页了解详细信息。您将看到 gettimeofday() 返回 1970 年以来的时间（以微秒为单位）；然而，这并不意味着计时器精确到微秒。测量对 gettimeofday() 的连续调用，以了解计时器的精确度；这将告诉您必须运行多少次空系统调用测试迭代才能获得良好的测量结果。如果 gettimeofday() 对您来说不够精确，您可以考虑使用 x86 机器上可用的 rdtsc 指令。 测量上下文切换的成本比较麻烦。lmbench 基准测试的方法是在单个 CPU 上运行两个进程，并在它们之间设置两个 UNIX 管道；管道只是 UNIX 系统中进程相互通信的众多方式之一。第一个进程向第一个管道发出写操作，并等待第二个管道的读操作；当看到第一个进程在等待从第二个管道读取数据时，操作系统会将第一个进程置于阻塞状态，并切换到另一个进程，后者从第一个管道读取数据，然后向第二个管道写操作。当第二个进程再次尝试从第一个管道读取数据时，它就会阻塞，这样来回循环的通信就继续进行。通过测量这样反复通信的成本，lmbench 可以很好地估算出上下文切换的成本。您可以尝试使用管道或其他通信机制（如 UNIX 套接字）在这里重新创建类似的功能。 在拥有多个 CPU 的系统中，测量上下文切换成本是个难题；在这样的系统中，你需要做的是确保上下文切换进程位于同一个处理器上。幸运的是，大多数操作系统都有将进程绑定到特定处理器的调用；例如，在 Linux 系统中，调用 sched_setaffinity() 就是你要找的。通过确保两个进程位于同一处理器上，就能确保衡量操作系统在同一 CPU 上停止一个进程并恢复另一个进程的成本。\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/time.h>\n\n#define ITERATIONS 1000\n\n// Measure the cost of a system call\nvoid measure_system_call() {\n    struct timeval start, end;\n    gettimeofday(&start, NULL);\n    for (int i = 0; i < ITERATIONS; i++) {\n        read(0, NULL, 0);  // Example of a simple system call\n    }\n    gettimeofday(&end, NULL);\n    double time_per_call = ((double)(end.tv_sec - start.tv_sec) * 1000000 + (end.tv_usec - start.tv_usec)) / ITERATIONS;\n    printf("Estimated cost of a system call: %f microseconds\\n", time_per_call);\n}\n\n// Measure the precision of gettimeofday()\nvoid measure_gettimeofday_precision() {\n    struct timeval start, end;\n    gettimeofday(&start, NULL);\n    for (int i = 0; i < ITERATIONS; i++) {\n        gettimeofday(&end, NULL);\n    }\n    double precision = ((double)(end.tv_sec - start.tv_sec) * 1000000 + (end.tv_usec - start.tv_usec)) / ITERATIONS;\n    printf("Precision of gettimeofday(): %f microseconds\\n", precision);\n}\n\n// Measure the cost of a context switch\nvoid measure_context_switch() {\n    int pipefd[2];\n    if (pipe(pipefd) == -1) {\n        perror("pipe");\n        exit(EXIT_FAILURE);\n    }\n\n    pid_t pid = fork();\n    if (pid == -1) {\n        perror("fork");\n        exit(EXIT_FAILURE);\n    }\n\n    if (pid == 0) {\n        // Child process\n        close(pipefd[1]);\n        struct timeval start, end;\n        gettimeofday(&start, NULL);\n        read(pipefd[0], NULL, 0);\n        gettimeofday(&end, NULL);\n        double time_diff = (end.tv_sec - start.tv_sec) * 1000000 + (end.tv_usec - start.tv_usec);\n        printf("Child process context switch time: %f microseconds\\n", time_diff);\n        exit(EXIT_SUCCESS);\n    } else {\n        // Parent process\n        close(pipefd[0]);\n        struct timeval start, end;\n        gettimeofday(&start, NULL);\n        write(pipefd[1], "", 1);\n        wait(NULL);\n        gettimeofday(&end, NULL);\n        double time_diff = (end.tv_sec - start.tv_sec) * 1000000 + (end.tv_usec - start.tv_usec);\n        printf("Parent process context switch time: %f microseconds\\n", time_diff);\n    }\n}\n\nint main() {\n    measure_system_call();\n    measure_gettimeofday_precision();\n    measure_context_switch();\n    return 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n> 输出结果如下： Estimated cost of a system call: 0.333000 microseconds Precision of gettimeofday(): 0.014000 microseconds Child process context switch time: 1.000000 microseconds Parent process context switch time: 160.000000 microseconds',normalizedContent:'github代码 在本作业中，您将测量系统调用和上下文切换的成本。测量系统调用的成本相对容易。例如，您可以反复调用一个简单的系统调用（如执行 0 字节读取），并计算所需时间；将时间除以迭代次数，就能估算出系统调用的成本。 您必须考虑的一件事是计时器的精度和准确性。可以使用的典型计时器是 gettimeofday()；阅读手册页了解详细信息。您将看到 gettimeofday() 返回 1970 年以来的时间（以微秒为单位）；然而，这并不意味着计时器精确到微秒。测量对 gettimeofday() 的连续调用，以了解计时器的精确度；这将告诉您必须运行多少次空系统调用测试迭代才能获得良好的测量结果。如果 gettimeofday() 对您来说不够精确，您可以考虑使用 x86 机器上可用的 rdtsc 指令。 测量上下文切换的成本比较麻烦。lmbench 基准测试的方法是在单个 cpu 上运行两个进程，并在它们之间设置两个 unix 管道；管道只是 unix 系统中进程相互通信的众多方式之一。第一个进程向第一个管道发出写操作，并等待第二个管道的读操作；当看到第一个进程在等待从第二个管道读取数据时，操作系统会将第一个进程置于阻塞状态，并切换到另一个进程，后者从第一个管道读取数据，然后向第二个管道写操作。当第二个进程再次尝试从第一个管道读取数据时，它就会阻塞，这样来回循环的通信就继续进行。通过测量这样反复通信的成本，lmbench 可以很好地估算出上下文切换的成本。您可以尝试使用管道或其他通信机制（如 unix 套接字）在这里重新创建类似的功能。 在拥有多个 cpu 的系统中，测量上下文切换成本是个难题；在这样的系统中，你需要做的是确保上下文切换进程位于同一个处理器上。幸运的是，大多数操作系统都有将进程绑定到特定处理器的调用；例如，在 linux 系统中，调用 sched_setaffinity() 就是你要找的。通过确保两个进程位于同一处理器上，就能确保衡量操作系统在同一 cpu 上停止一个进程并恢复另一个进程的成本。\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/time.h>\n\n#define iterations 1000\n\n// measure the cost of a system call\nvoid measure_system_call() {\n    struct timeval start, end;\n    gettimeofday(&start, null);\n    for (int i = 0; i < iterations; i++) {\n        read(0, null, 0);  // example of a simple system call\n    }\n    gettimeofday(&end, null);\n    double time_per_call = ((double)(end.tv_sec - start.tv_sec) * 1000000 + (end.tv_usec - start.tv_usec)) / iterations;\n    printf("estimated cost of a system call: %f microseconds\\n", time_per_call);\n}\n\n// measure the precision of gettimeofday()\nvoid measure_gettimeofday_precision() {\n    struct timeval start, end;\n    gettimeofday(&start, null);\n    for (int i = 0; i < iterations; i++) {\n        gettimeofday(&end, null);\n    }\n    double precision = ((double)(end.tv_sec - start.tv_sec) * 1000000 + (end.tv_usec - start.tv_usec)) / iterations;\n    printf("precision of gettimeofday(): %f microseconds\\n", precision);\n}\n\n// measure the cost of a context switch\nvoid measure_context_switch() {\n    int pipefd[2];\n    if (pipe(pipefd) == -1) {\n        perror("pipe");\n        exit(exit_failure);\n    }\n\n    pid_t pid = fork();\n    if (pid == -1) {\n        perror("fork");\n        exit(exit_failure);\n    }\n\n    if (pid == 0) {\n        // child process\n        close(pipefd[1]);\n        struct timeval start, end;\n        gettimeofday(&start, null);\n        read(pipefd[0], null, 0);\n        gettimeofday(&end, null);\n        double time_diff = (end.tv_sec - start.tv_sec) * 1000000 + (end.tv_usec - start.tv_usec);\n        printf("child process context switch time: %f microseconds\\n", time_diff);\n        exit(exit_success);\n    } else {\n        // parent process\n        close(pipefd[0]);\n        struct timeval start, end;\n        gettimeofday(&start, null);\n        write(pipefd[1], "", 1);\n        wait(null);\n        gettimeofday(&end, null);\n        double time_diff = (end.tv_sec - start.tv_sec) * 1000000 + (end.tv_usec - start.tv_usec);\n        printf("parent process context switch time: %f microseconds\\n", time_diff);\n    }\n}\n\nint main() {\n    measure_system_call();\n    measure_gettimeofday_precision();\n    measure_context_switch();\n    return 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n> 输出结果如下： estimated cost of a system call: 0.333000 microseconds precision of gettimeofday(): 0.014000 microseconds child process context switch time: 1.000000 microseconds parent process context switch time: 160.000000 microseconds',charsets:{cjk:!0},lastUpdated:"2024/05/11, 20:33:38",lastUpdatedTimestamp:1715430818e3},{title:"进程介绍",frontmatter:{title:"进程介绍",tags:["OS"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},date:"2024-04-25T22:16:51.000Z",permalink:"/pages/77a74b/",categories:["开发","系统架构","操作系统","虚拟化"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/02.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/01.%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D.html",relativePath:"01.开发/05.系统架构/02.操作系统/01.进程介绍.md",key:"v-65dcdf76",path:"/pages/77a74b/",headers:[{level:2,title:"1 Program Explanation",slug:"_1-program-explanation",normalizedTitle:"1 program explanation",charIndex:13},{level:2,title:"2 QA",slug:"_2-qa",normalizedTitle:"2 qa",charIndex:7167}],headersStr:"1 Program Explanation 2 QA",content:"github代码\n\n\n# 1 Program Explanation\n\nprocess-run.py：可以查看进程状态在CPU上运行时如何变化。 进程可以处于以下几种不同的状态：\n\n * RUNNING：进程正在使用CPU\n * READY：进程现在可以使用CPU但其他进程正在使用\n * BLOCKED：进程正在等待I/O（例如，它向磁盘发送请求）\n * DONE：进程已经执行完成\n\n要运行该程序获取其选项，可执行以下操作 ./process-run.py -h 或者 python process-run.py -h 得到：\n\nUsage: process-run.py [options]\n\nOptions:\n  -h, --help            show this help message and exit\n  -s SEED, --seed=SEED  the random seed\n  -l PROCESS_LIST, --processlist=PROCESS_LIST\n                        a comma-separated list of processes to run, in the\n                        form X1:Y1,X2:Y2,... where X is the number of\n                        instructions that process should run, and Y the\n                        chances (from 0 to 100) that an instruction will use\n                        the CPU or issue an IO\n  -L IO_LENGTH, --iolength=IO_LENGTH\n                        how long an IO takes\n  -S PROCESS_SWITCH_BEHAVIOR, --switch=PROCESS_SWITCH_BEHAVIOR\n                        when to switch between processes: SWITCH_ON_IO,\n                        SWITCH_ON_END\n  -I IO_DONE_BEHAVIOR, --iodone=IO_DONE_BEHAVIOR\n                        type of behavior when IO ends: IO_RUN_LATER,\n                        IO_RUN_IMMEDIATE\n  -c                    compute answers for me\n  -p, --printstats      print statistics at end; only useful with -c flag\n                        (otherwise stats are not printed)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n要理解的最重要的选项是 PROCESS_LIST（由 -l 或 --processlist 参数指定），它准确指定每个正在运行的程序（或“进程”）将执行的操作。一个进程由指令组成，每条指令只能执行以下两件事之一：\n\n>  * 使用CPU 请求IO（并等待其完成）\n\n当进程使用 CPU（不执行 IO）时，它应该简单地在 CPU 上运行或准备运行之间交替。例如，这是一个简单的运行，仅运行一个程序，并且该程序仅使用 CPU（不执行 IO）。\n\n❯ python process-run.py -l 5:100\nProduce a trace of what would happen when you run these processes:\nProcess 0\n  cpu\n  cpu\n  cpu\n  cpu\n  cpu\n\nImportant behaviors:\n  System will switch when the current process is FINISHED or ISSUES AN IO\n  After IOs, the process issuing the IO will run LATER (when it is its turn)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这里，我们指定的进程是“5:100”，这意味着它应该由5条指令组成，并且每条指令是CPU指令的机会是100%。 我们可以使用-c参数来查看进程发生了什么：\n\n❯ python process-run.py -l 5:100 -c\nTime        PID: 0           CPU           IOs\n  1        RUN:cpu             1          \n  2        RUN:cpu             1          \n  3        RUN:cpu             1          \n  4        RUN:cpu             1          \n  5        RUN:cpu             1 \n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这个结果并不是太有趣：该过程在 RUNNING 状态下很简单，然后完成，始终使用 CPU，从而使 CPU 在整个运行过程中保持忙碌，并且不执行任何 I/O。 我们可以运行三个进程看看结果：\n\n❯ python process-run.py -l 5:100,5:100,5:100 -c\nTime        PID: 0        PID: 1        PID: 2           CPU           IOs\n  1        RUN:cpu         READY         READY             1          \n  2        RUN:cpu         READY         READY             1          \n  3        RUN:cpu         READY         READY             1          \n  4        RUN:cpu         READY         READY             1          \n  5        RUN:cpu         READY         READY             1          \n  6           DONE       RUN:cpu         READY             1          \n  7           DONE       RUN:cpu         READY             1          \n  8           DONE       RUN:cpu         READY             1          \n  9           DONE       RUN:cpu         READY             1          \n 10           DONE       RUN:cpu         READY             1          \n 11           DONE          DONE       RUN:cpu             1          \n 12           DONE          DONE       RUN:cpu             1          \n 13           DONE          DONE       RUN:cpu             1          \n 14           DONE          DONE       RUN:cpu             1          \n 15           DONE          DONE       RUN:cpu             1  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n首先首先“进程 ID”（或“PID”）为 0 的进程运行，而进程 1 和进程2已准备好运行，但只是等待 0 完成。当0完成时，它进入DONE状态，而1则运行，2继续等待。当 1 完成时，则2才开始运行。\n\n我们继续看一个例子，在此示例中，进程仅发出I/O请求。我们使用-L参数指定I/O需要5个时间单位才能完成。\n\n❯ python process-run.py -l 3:0 -L 5\nProduce a trace of what would happen when you run these processes:\nProcess 0\n  io\n  io_done\n  io\n  io_done\n  io\n  io_done\n\nImportant behaviors:\n  System will switch when the current process is FINISHED or ISSUES AN IO\n  After IOs, the process issuing the IO will run LATER (when it is its turn)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n我们设置跟踪参数看看会是什么样子：\n\n❯ python process-run.py -l 3:0 -L 5 -c\nTime        PID: 0           CPU           IOs\n  1         RUN:io             1          \n  2        BLOCKED                           1\n  3        BLOCKED                           1\n  4        BLOCKED                           1\n  5        BLOCKED                           1\n  6        BLOCKED                           1\n  7*   RUN:io_done             1          \n  8         RUN:io             1          \n  9        BLOCKED                           1\n 10        BLOCKED                           1\n 11        BLOCKED                           1\n 12        BLOCKED                           1\n 13        BLOCKED                           1\n 14*   RUN:io_done             1          \n 15         RUN:io             1          \n 16        BLOCKED                           1\n 17        BLOCKED                           1\n 18        BLOCKED                           1\n 19        BLOCKED                           1\n 20        BLOCKED                           1\n 21*   RUN:io_done             1          \n❯ python process-run.py -l 3:0 -L 5 -c\nTime        PID: 0           CPU           IOs\n  1         RUN:io             1          \n  2        BLOCKED                           1\n  3        BLOCKED                           1\n  4        BLOCKED                           1\n  5        BLOCKED                           1\n  6        BLOCKED                           1\n  7*   RUN:io_done             1          \n  8         RUN:io             1          \n  9        BLOCKED                           1\n 10        BLOCKED                           1\n 11        BLOCKED                           1\n 12        BLOCKED                           1\n 13        BLOCKED                           1\n 14*   RUN:io_done             1          \n 15         RUN:io             1          \n 16        BLOCKED                           1\n 17        BLOCKED                           1\n 18        BLOCKED                           1\n 19        BLOCKED                           1\n 20        BLOCKED                           1\n 21*   RUN:io_done             1 \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n如上所示，该程序仅发出三个 I/O。当发出每个 I/O 时，进程将进入 BLOCKED 状态，当设备忙于为 I/O 提供服务时，CPU 处于空闲状态。 为了处理 I/O 的完成，还会发生一项 CPU 操作。请注意，处理 I/O 启动和完成的单个指令并不是特别现实，但这里只是为了简单起见而使用。让我们打印一些统计信息（运行与上面相同的命令，但使用 -p 参数）来查看一些总体行为：\n\nStats: Total Time 21\nStats: CPU Busy 6 (28.57%)\nStats: IO Busy  15 (71.43%)\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n如上所示，跟踪运行需要 21 个时钟周期，但 CPU 忙碌的时间不到 30%。另一方面，I/O 设备却相当忙碌。一般来说，我们希望让所有设备保持忙碌，因为这样可以更好地利用资源。\n\n\n# 2 QA\n\n 1. 运行 process-run.py，指定参数：-l 5:100。CPU 利用率应该是多少（例如，CPU 使用时间的百分比）？使用 -c 和 -p 参数来查看你是否正确。\n    \n    > CPU利用率为100%，因为有5条指令，使用CPU的指令机会为100%。\n    \n    ❯ python process-run.py  -l 5:100 -c -p\n     Time        PID: 0           CPU           IOs\n     1        RUN:cpu             1          \n     2        RUN:cpu             1          \n     3        RUN:cpu             1          \n     4        RUN:cpu             1          \n     5        RUN:cpu             1          \n    \n     Stats: Total Time 5\n     Stats: CPU Busy 5 (100.00%)\n     Stats: IO Busy  0 (0.00%)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n 2. 运行：./process-run.py -l 4:100,1:0。这些参数指定一个具有 4 条指令的进程（全部使用 CPU），以及一个仅发出 I/O 并等待其完成的进程。完成这两个过程需要多长时间？使用 -c 和 -p 来看看你是否正确。\n    \n    > PID为0的进程运行四条指令需要4，PID为1的进程完成IO需要5，但是发出IO指令以及完成IO指令需要CPU，所以为4+5+2=11。\n    \n     ❯ python process-run.py  -l 4:100,1:0 -c -p\n     Time        PID: 0        PID: 1           CPU           IOs\n       1        RUN:cpu         READY             1          \n       2        RUN:cpu         READY             1          \n       3        RUN:cpu         READY             1          \n       4        RUN:cpu         READY             1          \n       5           DONE        RUN:io             1          \n       6           DONE       BLOCKED                           1\n       7           DONE       BLOCKED                           1\n       8           DONE       BLOCKED                           1\n       9           DONE       BLOCKED                           1\n     10           DONE       BLOCKED                           1\n     11*          DONE   RUN:io_done             1          \n    \n     Stats: Total Time 11\n     Stats: CPU Busy 6 (54.55%)\n     Stats: IO Busy  5 (45.45%)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n 3. 改变进程的顺序： ./process-run.py -l 1:0,4:100。现在会发生什么？切换顺序重要吗？为什么？（像往常一样，使用 -c 和 -p 查看你是否正确） 这样进程0就可以先获得CPU发起IO请求，然后进行I/O。此时CPU空闲，进程1则可以获得CPU。在2中，进程0则需要等到进程1运行完成才可以获得。这节省了时间。\n    \n    ❯ python process-run.py  -l 1:0,4:100 -c -p\n     Time        PID: 0        PID: 1           CPU           IOs\n       1         RUN:io         READY             1          \n       2        BLOCKED       RUN:cpu             1             1\n       3        BLOCKED       RUN:cpu             1             1\n       4        BLOCKED       RUN:cpu             1             1\n       5        BLOCKED       RUN:cpu             1             1\n       6        BLOCKED          DONE                           1\n       7*   RUN:io_done          DONE             1          \n    \n     Stats: Total Time 7\n     Stats: CPU Busy 6 (85.71%)\n     Stats: IO Busy  5 (71.43%)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n 4. 现在我们来看看其他一些参数。其中一个重要的参数是 -S，它决定了当一个进程发出 I/O 时系统的反应。将该标志设置为 SWITCH ON END 时，当一个进程正在进行 I/O 时，系统不会切换到另一个进程，而是等待该进程完全结束。如果运行以下两个进程（-l 1:0,4:100 -c -S SWITCH_ON_END），其中一个正在执行 I/O 操作，另一个正在执行 CPU 操作，会发生什么情况？\n    \n    > 此时进程0会一直占用CPU，直到I/O操作完成。用时也是11。\n    \n    ❯ python process-run.py  -l 1:0,4:100 -c -S SWITCH_ON_END -p\n     Time        PID: 0        PID: 1           CPU           IOs\n       1         RUN:io         READY             1          \n       2        BLOCKED         READY                           1\n       3        BLOCKED         READY                           1\n       4        BLOCKED         READY                           1\n       5        BLOCKED         READY                           1\n       6        BLOCKED         READY                           1\n       7*   RUN:io_done         READY             1          \n       8           DONE       RUN:cpu             1          \n       9           DONE       RUN:cpu             1          \n       10           DONE       RUN:cpu             1          \n       11           DONE       RUN:cpu             1          \n    \n       Stats: Total Time 11\n       Stats: CPU Busy 6 (54.55%)\n       Stats: IO Busy  5 (45.45%)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n 5. 现在，运行相同的进程，但将切换行为设置为每当一个进程等待 I/O 时就切换到另一个进程（-l 1:0,4:100 -c -S SWITCH_ON_IO）。现在会发生什么？使用 -c 和 -p 来确认是否正确。\n    \n    > 此时进程0发起I/O请求后，操作系统就会切换进程，总用时为7\n    \n    ❯ python process-run.py  -l 1:0,4:100 -c -S SWITCH_ON_IO -p\n     Time        PID: 0        PID: 1           CPU           IOs\n       1         RUN:io         READY             1          \n       2        BLOCKED       RUN:cpu             1             1\n       3        BLOCKED       RUN:cpu             1             1\n       4        BLOCKED       RUN:cpu             1             1\n       5        BLOCKED       RUN:cpu             1             1\n       6        BLOCKED          DONE                           1\n       7*   RUN:io_done          DONE             1          \n    \n     Stats: Total Time 7\n     Stats: CPU Busy 6 (85.71%)\n     Stats: IO Busy  5 (71.43%)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n 6. 另一个重要的行为是在 I/O 完成时该做什么。使用 -I IO RUN LATER 选项时，当 I/O 完成时，发出它的进程不一定会立即运行；相反，正在运行的内容将继续运行。当您运行这组进程组合时会发生什么？（运行 python process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_LATER -c -p）系统资源是否得到有效利用？\n    \n    > 此时系统资源没有得到有效利用。因为CPU处理I/O完成越早，进程就可以继续处理I/O，它可以在不占用CPU的时候进行。\n    \n    ❯ python process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_LATER -c -p\n     Time        PID: 0        PID: 1        PID: 2        PID: 3           CPU           IOs\n       1         RUN:io         READY         READY         READY             1          \n       2        BLOCKED       RUN:cpu         READY         READY             1             1\n       3        BLOCKED       RUN:cpu         READY         READY             1             1\n       4        BLOCKED       RUN:cpu         READY         READY             1             1\n       5        BLOCKED       RUN:cpu         READY         READY             1             1\n       6        BLOCKED       RUN:cpu         READY         READY             1             1\n       7*         READY          DONE       RUN:cpu         READY             1          \n       8          READY          DONE       RUN:cpu         READY             1          \n       9          READY          DONE       RUN:cpu         READY             1          \n     10          READY          DONE       RUN:cpu         READY             1          \n     11          READY          DONE       RUN:cpu         READY             1          \n     12          READY          DONE          DONE       RUN:cpu             1          \n     13          READY          DONE          DONE       RUN:cpu             1          \n     14          READY          DONE          DONE       RUN:cpu             1          \n     15          READY          DONE          DONE       RUN:cpu             1          \n     16          READY          DONE          DONE       RUN:cpu             1          \n     17    RUN:io_done          DONE          DONE          DONE             1          \n     18         RUN:io          DONE          DONE          DONE             1          \n     19        BLOCKED          DONE          DONE          DONE                           1\n     20        BLOCKED          DONE          DONE          DONE                           1\n     21        BLOCKED          DONE          DONE          DONE                           1\n     22        BLOCKED          DONE          DONE          DONE                           1\n     23        BLOCKED          DONE          DONE          DONE                           1\n     24*   RUN:io_done          DONE          DONE          DONE             1          \n     25         RUN:io          DONE          DONE          DONE             1          \n     26        BLOCKED          DONE          DONE          DONE                           1\n     27        BLOCKED          DONE          DONE          DONE                           1\n     28        BLOCKED          DONE          DONE          DONE                           1\n     29        BLOCKED          DONE          DONE          DONE                           1\n     30        BLOCKED          DONE          DONE          DONE                           1\n     31*   RUN:io_done          DONE          DONE          DONE             1          \n    \n     Stats: Total Time 31\n     Stats: CPU Busy 21 (67.74%)\n     Stats: IO Busy  15 (48.39%)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    \n 7. 现在运行相同的进程，但使用 -I IO_RUN_IMMEDIATE 设置，该设置会立即运行发出 I/O 的进程。这种行为有何不同？为什么再次运行刚完成 I/O 的进程可能是个好主意？\n    \n    > 这种行为会让进程处理I/O请求的时候还给其他CPU，但完成后立即获得CPU，能让I/O处理和CPU处理一起进行，节省总时间，有效提高CPU利用率。\n    \n    ❯ python process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_IMMEDIATE -c -p\n     Time        PID: 0        PID: 1        PID: 2        PID: 3           CPU           IOs\n       1         RUN:io         READY         READY         READY             1          \n       2        BLOCKED       RUN:cpu         READY         READY             1             1\n       3        BLOCKED       RUN:cpu         READY         READY             1             1\n       4        BLOCKED       RUN:cpu         READY         READY             1             1\n       5        BLOCKED       RUN:cpu         READY         READY             1             1\n       6        BLOCKED       RUN:cpu         READY         READY             1             1\n       7*   RUN:io_done          DONE         READY         READY             1          \n       8         RUN:io          DONE         READY         READY             1          \n       9        BLOCKED          DONE       RUN:cpu         READY             1             1\n     10        BLOCKED          DONE       RUN:cpu         READY             1             1\n     11        BLOCKED          DONE       RUN:cpu         READY             1             1\n     12        BLOCKED          DONE       RUN:cpu         READY             1             1\n     13        BLOCKED          DONE       RUN:cpu         READY             1             1\n     14*   RUN:io_done          DONE          DONE         READY             1          \n     15         RUN:io          DONE          DONE         READY             1          \n     16        BLOCKED          DONE          DONE       RUN:cpu             1             1\n     17        BLOCKED          DONE          DONE       RUN:cpu             1             1\n     18        BLOCKED          DONE          DONE       RUN:cpu             1             1\n     19        BLOCKED          DONE          DONE       RUN:cpu             1             1\n     20        BLOCKED          DONE          DONE       RUN:cpu             1             1\n     21*   RUN:io_done          DONE          DONE          DONE             1          \n    \n     Stats: Total Time 21\n     Stats: CPU Busy 21 (100.00%)\n     Stats: IO Busy  15 (71.43%)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    \n 8. 现在运行一些随机生成的进程：-s 1 -l 3:50,3:50 或 -s 2 -l 3:50,3:50 或 -s 3 -l 3:50,3:50。看看你是否可以预测跟踪结果如何。当您使用参数 -I IO_RUN_IMMEDIATE 与 -I IO_RUN_LATER 时会发生什么？当您使用 -S SWITCH_ON_IO 与 -S SWITCH_ON_END 时会发生什么？\n\n> 设置随机种子，可以保证相同的种子生成的随机数都一样，会得到相同的随机数序列。针对问题中的50，则是有50%的机会进行CPU操作或者I/O操作。如果没有使用任何参数，则是正常的切换。\n\n❯ python process-run.py -s 1 -l 3:50,3:50 -c -p\nTime        PID: 0        PID: 1           CPU           IOs\n  1        RUN:cpu         READY             1          \n  2         RUN:io         READY             1          \n  3        BLOCKED       RUN:cpu             1             1\n  4        BLOCKED       RUN:cpu             1             1\n  5        BLOCKED       RUN:cpu             1             1\n  6        BLOCKED          DONE                           1\n  7        BLOCKED          DONE                           1\n  8*   RUN:io_done          DONE             1          \n  9         RUN:io          DONE             1          \n10        BLOCKED          DONE                           1\n11        BLOCKED          DONE                           1\n12        BLOCKED          DONE                           1\n13        BLOCKED          DONE                           1\n14        BLOCKED          DONE                           1\n15*   RUN:io_done          DONE             1          \n\nStats: Total Time 15\nStats: CPU Busy 8 (53.33%)\nStats: IO Busy  10 (66.67%)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",normalizedContent:"github代码\n\n\n# 1 program explanation\n\nprocess-run.py：可以查看进程状态在cpu上运行时如何变化。 进程可以处于以下几种不同的状态：\n\n * running：进程正在使用cpu\n * ready：进程现在可以使用cpu但其他进程正在使用\n * blocked：进程正在等待i/o（例如，它向磁盘发送请求）\n * done：进程已经执行完成\n\n要运行该程序获取其选项，可执行以下操作 ./process-run.py -h 或者 python process-run.py -h 得到：\n\nusage: process-run.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -s seed, --seed=seed  the random seed\n  -l process_list, --processlist=process_list\n                        a comma-separated list of processes to run, in the\n                        form x1:y1,x2:y2,... where x is the number of\n                        instructions that process should run, and y the\n                        chances (from 0 to 100) that an instruction will use\n                        the cpu or issue an io\n  -l io_length, --iolength=io_length\n                        how long an io takes\n  -s process_switch_behavior, --switch=process_switch_behavior\n                        when to switch between processes: switch_on_io,\n                        switch_on_end\n  -i io_done_behavior, --iodone=io_done_behavior\n                        type of behavior when io ends: io_run_later,\n                        io_run_immediate\n  -c                    compute answers for me\n  -p, --printstats      print statistics at end; only useful with -c flag\n                        (otherwise stats are not printed)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n要理解的最重要的选项是 process_list（由 -l 或 --processlist 参数指定），它准确指定每个正在运行的程序（或“进程”）将执行的操作。一个进程由指令组成，每条指令只能执行以下两件事之一：\n\n>  * 使用cpu 请求io（并等待其完成）\n\n当进程使用 cpu（不执行 io）时，它应该简单地在 cpu 上运行或准备运行之间交替。例如，这是一个简单的运行，仅运行一个程序，并且该程序仅使用 cpu（不执行 io）。\n\n❯ python process-run.py -l 5:100\nproduce a trace of what would happen when you run these processes:\nprocess 0\n  cpu\n  cpu\n  cpu\n  cpu\n  cpu\n\nimportant behaviors:\n  system will switch when the current process is finished or issues an io\n  after ios, the process issuing the io will run later (when it is its turn)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这里，我们指定的进程是“5:100”，这意味着它应该由5条指令组成，并且每条指令是cpu指令的机会是100%。 我们可以使用-c参数来查看进程发生了什么：\n\n❯ python process-run.py -l 5:100 -c\ntime        pid: 0           cpu           ios\n  1        run:cpu             1          \n  2        run:cpu             1          \n  3        run:cpu             1          \n  4        run:cpu             1          \n  5        run:cpu             1 \n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这个结果并不是太有趣：该过程在 running 状态下很简单，然后完成，始终使用 cpu，从而使 cpu 在整个运行过程中保持忙碌，并且不执行任何 i/o。 我们可以运行三个进程看看结果：\n\n❯ python process-run.py -l 5:100,5:100,5:100 -c\ntime        pid: 0        pid: 1        pid: 2           cpu           ios\n  1        run:cpu         ready         ready             1          \n  2        run:cpu         ready         ready             1          \n  3        run:cpu         ready         ready             1          \n  4        run:cpu         ready         ready             1          \n  5        run:cpu         ready         ready             1          \n  6           done       run:cpu         ready             1          \n  7           done       run:cpu         ready             1          \n  8           done       run:cpu         ready             1          \n  9           done       run:cpu         ready             1          \n 10           done       run:cpu         ready             1          \n 11           done          done       run:cpu             1          \n 12           done          done       run:cpu             1          \n 13           done          done       run:cpu             1          \n 14           done          done       run:cpu             1          \n 15           done          done       run:cpu             1  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n首先首先“进程 id”（或“pid”）为 0 的进程运行，而进程 1 和进程2已准备好运行，但只是等待 0 完成。当0完成时，它进入done状态，而1则运行，2继续等待。当 1 完成时，则2才开始运行。\n\n我们继续看一个例子，在此示例中，进程仅发出i/o请求。我们使用-l参数指定i/o需要5个时间单位才能完成。\n\n❯ python process-run.py -l 3:0 -l 5\nproduce a trace of what would happen when you run these processes:\nprocess 0\n  io\n  io_done\n  io\n  io_done\n  io\n  io_done\n\nimportant behaviors:\n  system will switch when the current process is finished or issues an io\n  after ios, the process issuing the io will run later (when it is its turn)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n我们设置跟踪参数看看会是什么样子：\n\n❯ python process-run.py -l 3:0 -l 5 -c\ntime        pid: 0           cpu           ios\n  1         run:io             1          \n  2        blocked                           1\n  3        blocked                           1\n  4        blocked                           1\n  5        blocked                           1\n  6        blocked                           1\n  7*   run:io_done             1          \n  8         run:io             1          \n  9        blocked                           1\n 10        blocked                           1\n 11        blocked                           1\n 12        blocked                           1\n 13        blocked                           1\n 14*   run:io_done             1          \n 15         run:io             1          \n 16        blocked                           1\n 17        blocked                           1\n 18        blocked                           1\n 19        blocked                           1\n 20        blocked                           1\n 21*   run:io_done             1          \n❯ python process-run.py -l 3:0 -l 5 -c\ntime        pid: 0           cpu           ios\n  1         run:io             1          \n  2        blocked                           1\n  3        blocked                           1\n  4        blocked                           1\n  5        blocked                           1\n  6        blocked                           1\n  7*   run:io_done             1          \n  8         run:io             1          \n  9        blocked                           1\n 10        blocked                           1\n 11        blocked                           1\n 12        blocked                           1\n 13        blocked                           1\n 14*   run:io_done             1          \n 15         run:io             1          \n 16        blocked                           1\n 17        blocked                           1\n 18        blocked                           1\n 19        blocked                           1\n 20        blocked                           1\n 21*   run:io_done             1 \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n如上所示，该程序仅发出三个 i/o。当发出每个 i/o 时，进程将进入 blocked 状态，当设备忙于为 i/o 提供服务时，cpu 处于空闲状态。 为了处理 i/o 的完成，还会发生一项 cpu 操作。请注意，处理 i/o 启动和完成的单个指令并不是特别现实，但这里只是为了简单起见而使用。让我们打印一些统计信息（运行与上面相同的命令，但使用 -p 参数）来查看一些总体行为：\n\nstats: total time 21\nstats: cpu busy 6 (28.57%)\nstats: io busy  15 (71.43%)\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n如上所示，跟踪运行需要 21 个时钟周期，但 cpu 忙碌的时间不到 30%。另一方面，i/o 设备却相当忙碌。一般来说，我们希望让所有设备保持忙碌，因为这样可以更好地利用资源。\n\n\n# 2 qa\n\n 1. 运行 process-run.py，指定参数：-l 5:100。cpu 利用率应该是多少（例如，cpu 使用时间的百分比）？使用 -c 和 -p 参数来查看你是否正确。\n    \n    > cpu利用率为100%，因为有5条指令，使用cpu的指令机会为100%。\n    \n    ❯ python process-run.py  -l 5:100 -c -p\n     time        pid: 0           cpu           ios\n     1        run:cpu             1          \n     2        run:cpu             1          \n     3        run:cpu             1          \n     4        run:cpu             1          \n     5        run:cpu             1          \n    \n     stats: total time 5\n     stats: cpu busy 5 (100.00%)\n     stats: io busy  0 (0.00%)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n 2. 运行：./process-run.py -l 4:100,1:0。这些参数指定一个具有 4 条指令的进程（全部使用 cpu），以及一个仅发出 i/o 并等待其完成的进程。完成这两个过程需要多长时间？使用 -c 和 -p 来看看你是否正确。\n    \n    > pid为0的进程运行四条指令需要4，pid为1的进程完成io需要5，但是发出io指令以及完成io指令需要cpu，所以为4+5+2=11。\n    \n     ❯ python process-run.py  -l 4:100,1:0 -c -p\n     time        pid: 0        pid: 1           cpu           ios\n       1        run:cpu         ready             1          \n       2        run:cpu         ready             1          \n       3        run:cpu         ready             1          \n       4        run:cpu         ready             1          \n       5           done        run:io             1          \n       6           done       blocked                           1\n       7           done       blocked                           1\n       8           done       blocked                           1\n       9           done       blocked                           1\n     10           done       blocked                           1\n     11*          done   run:io_done             1          \n    \n     stats: total time 11\n     stats: cpu busy 6 (54.55%)\n     stats: io busy  5 (45.45%)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n 3. 改变进程的顺序： ./process-run.py -l 1:0,4:100。现在会发生什么？切换顺序重要吗？为什么？（像往常一样，使用 -c 和 -p 查看你是否正确） 这样进程0就可以先获得cpu发起io请求，然后进行i/o。此时cpu空闲，进程1则可以获得cpu。在2中，进程0则需要等到进程1运行完成才可以获得。这节省了时间。\n    \n    ❯ python process-run.py  -l 1:0,4:100 -c -p\n     time        pid: 0        pid: 1           cpu           ios\n       1         run:io         ready             1          \n       2        blocked       run:cpu             1             1\n       3        blocked       run:cpu             1             1\n       4        blocked       run:cpu             1             1\n       5        blocked       run:cpu             1             1\n       6        blocked          done                           1\n       7*   run:io_done          done             1          \n    \n     stats: total time 7\n     stats: cpu busy 6 (85.71%)\n     stats: io busy  5 (71.43%)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n 4. 现在我们来看看其他一些参数。其中一个重要的参数是 -s，它决定了当一个进程发出 i/o 时系统的反应。将该标志设置为 switch on end 时，当一个进程正在进行 i/o 时，系统不会切换到另一个进程，而是等待该进程完全结束。如果运行以下两个进程（-l 1:0,4:100 -c -s switch_on_end），其中一个正在执行 i/o 操作，另一个正在执行 cpu 操作，会发生什么情况？\n    \n    > 此时进程0会一直占用cpu，直到i/o操作完成。用时也是11。\n    \n    ❯ python process-run.py  -l 1:0,4:100 -c -s switch_on_end -p\n     time        pid: 0        pid: 1           cpu           ios\n       1         run:io         ready             1          \n       2        blocked         ready                           1\n       3        blocked         ready                           1\n       4        blocked         ready                           1\n       5        blocked         ready                           1\n       6        blocked         ready                           1\n       7*   run:io_done         ready             1          \n       8           done       run:cpu             1          \n       9           done       run:cpu             1          \n       10           done       run:cpu             1          \n       11           done       run:cpu             1          \n    \n       stats: total time 11\n       stats: cpu busy 6 (54.55%)\n       stats: io busy  5 (45.45%)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n 5. 现在，运行相同的进程，但将切换行为设置为每当一个进程等待 i/o 时就切换到另一个进程（-l 1:0,4:100 -c -s switch_on_io）。现在会发生什么？使用 -c 和 -p 来确认是否正确。\n    \n    > 此时进程0发起i/o请求后，操作系统就会切换进程，总用时为7\n    \n    ❯ python process-run.py  -l 1:0,4:100 -c -s switch_on_io -p\n     time        pid: 0        pid: 1           cpu           ios\n       1         run:io         ready             1          \n       2        blocked       run:cpu             1             1\n       3        blocked       run:cpu             1             1\n       4        blocked       run:cpu             1             1\n       5        blocked       run:cpu             1             1\n       6        blocked          done                           1\n       7*   run:io_done          done             1          \n    \n     stats: total time 7\n     stats: cpu busy 6 (85.71%)\n     stats: io busy  5 (71.43%)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n 6. 另一个重要的行为是在 i/o 完成时该做什么。使用 -i io run later 选项时，当 i/o 完成时，发出它的进程不一定会立即运行；相反，正在运行的内容将继续运行。当您运行这组进程组合时会发生什么？（运行 python process-run.py -l 3:0,5:100,5:100,5:100 -s switch_on_io -i io_run_later -c -p）系统资源是否得到有效利用？\n    \n    > 此时系统资源没有得到有效利用。因为cpu处理i/o完成越早，进程就可以继续处理i/o，它可以在不占用cpu的时候进行。\n    \n    ❯ python process-run.py -l 3:0,5:100,5:100,5:100 -s switch_on_io -i io_run_later -c -p\n     time        pid: 0        pid: 1        pid: 2        pid: 3           cpu           ios\n       1         run:io         ready         ready         ready             1          \n       2        blocked       run:cpu         ready         ready             1             1\n       3        blocked       run:cpu         ready         ready             1             1\n       4        blocked       run:cpu         ready         ready             1             1\n       5        blocked       run:cpu         ready         ready             1             1\n       6        blocked       run:cpu         ready         ready             1             1\n       7*         ready          done       run:cpu         ready             1          \n       8          ready          done       run:cpu         ready             1          \n       9          ready          done       run:cpu         ready             1          \n     10          ready          done       run:cpu         ready             1          \n     11          ready          done       run:cpu         ready             1          \n     12          ready          done          done       run:cpu             1          \n     13          ready          done          done       run:cpu             1          \n     14          ready          done          done       run:cpu             1          \n     15          ready          done          done       run:cpu             1          \n     16          ready          done          done       run:cpu             1          \n     17    run:io_done          done          done          done             1          \n     18         run:io          done          done          done             1          \n     19        blocked          done          done          done                           1\n     20        blocked          done          done          done                           1\n     21        blocked          done          done          done                           1\n     22        blocked          done          done          done                           1\n     23        blocked          done          done          done                           1\n     24*   run:io_done          done          done          done             1          \n     25         run:io          done          done          done             1          \n     26        blocked          done          done          done                           1\n     27        blocked          done          done          done                           1\n     28        blocked          done          done          done                           1\n     29        blocked          done          done          done                           1\n     30        blocked          done          done          done                           1\n     31*   run:io_done          done          done          done             1          \n    \n     stats: total time 31\n     stats: cpu busy 21 (67.74%)\n     stats: io busy  15 (48.39%)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    \n 7. 现在运行相同的进程，但使用 -i io_run_immediate 设置，该设置会立即运行发出 i/o 的进程。这种行为有何不同？为什么再次运行刚完成 i/o 的进程可能是个好主意？\n    \n    > 这种行为会让进程处理i/o请求的时候还给其他cpu，但完成后立即获得cpu，能让i/o处理和cpu处理一起进行，节省总时间，有效提高cpu利用率。\n    \n    ❯ python process-run.py -l 3:0,5:100,5:100,5:100 -s switch_on_io -i io_run_immediate -c -p\n     time        pid: 0        pid: 1        pid: 2        pid: 3           cpu           ios\n       1         run:io         ready         ready         ready             1          \n       2        blocked       run:cpu         ready         ready             1             1\n       3        blocked       run:cpu         ready         ready             1             1\n       4        blocked       run:cpu         ready         ready             1             1\n       5        blocked       run:cpu         ready         ready             1             1\n       6        blocked       run:cpu         ready         ready             1             1\n       7*   run:io_done          done         ready         ready             1          \n       8         run:io          done         ready         ready             1          \n       9        blocked          done       run:cpu         ready             1             1\n     10        blocked          done       run:cpu         ready             1             1\n     11        blocked          done       run:cpu         ready             1             1\n     12        blocked          done       run:cpu         ready             1             1\n     13        blocked          done       run:cpu         ready             1             1\n     14*   run:io_done          done          done         ready             1          \n     15         run:io          done          done         ready             1          \n     16        blocked          done          done       run:cpu             1             1\n     17        blocked          done          done       run:cpu             1             1\n     18        blocked          done          done       run:cpu             1             1\n     19        blocked          done          done       run:cpu             1             1\n     20        blocked          done          done       run:cpu             1             1\n     21*   run:io_done          done          done          done             1          \n    \n     stats: total time 21\n     stats: cpu busy 21 (100.00%)\n     stats: io busy  15 (71.43%)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    \n 8. 现在运行一些随机生成的进程：-s 1 -l 3:50,3:50 或 -s 2 -l 3:50,3:50 或 -s 3 -l 3:50,3:50。看看你是否可以预测跟踪结果如何。当您使用参数 -i io_run_immediate 与 -i io_run_later 时会发生什么？当您使用 -s switch_on_io 与 -s switch_on_end 时会发生什么？\n\n> 设置随机种子，可以保证相同的种子生成的随机数都一样，会得到相同的随机数序列。针对问题中的50，则是有50%的机会进行cpu操作或者i/o操作。如果没有使用任何参数，则是正常的切换。\n\n❯ python process-run.py -s 1 -l 3:50,3:50 -c -p\ntime        pid: 0        pid: 1           cpu           ios\n  1        run:cpu         ready             1          \n  2         run:io         ready             1          \n  3        blocked       run:cpu             1             1\n  4        blocked       run:cpu             1             1\n  5        blocked       run:cpu             1             1\n  6        blocked          done                           1\n  7        blocked          done                           1\n  8*   run:io_done          done             1          \n  9         run:io          done             1          \n10        blocked          done                           1\n11        blocked          done                           1\n12        blocked          done                           1\n13        blocked          done                           1\n14        blocked          done                           1\n15*   run:io_done          done             1          \n\nstats: total time 15\nstats: cpu busy 8 (53.33%)\nstats: io busy  10 (66.67%)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",charsets:{cjk:!0},lastUpdated:"2024/05/11, 20:33:38",lastUpdatedTimestamp:1715430818e3},{title:"Linux用户和用户组教程",frontmatter:{title:"Linux用户和用户组教程",date:"2022-05-24T10:27:01.000Z",tags:["Linux"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},categories:["开发","系统架构","Linux"],permalink:"/pages/419777/",readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/01.Linux/03.Linux%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E6%95%99%E7%A8%8B.html",relativePath:"01.开发/05.系统架构/01.Linux/03.Linux用户和用户组教程.md",key:"v-38c4edfa",path:"/pages/419777/",headers:[{level:2,title:"1 用户和用户组介绍",slug:"_1-用户和用户组介绍",normalizedTitle:"1 用户和用户组介绍",charIndex:2},{level:3,title:"1.1 用户",slug:"_1-1-用户",normalizedTitle:"1.1 用户",charIndex:17},{level:3,title:"1.2 用户组",slug:"_1-2-用户组",normalizedTitle:"1.2 用户组",charIndex:1130},{level:3,title:"1.3 文件权限",slug:"_1-3-文件权限",normalizedTitle:"1.3 文件权限",charIndex:1987},{level:4,title:"1.3.1 文件所有者（User）",slug:"_1-3-1-文件所有者-user",normalizedTitle:"1.3.1 文件所有者（user）",charIndex:2311},{level:4,title:"1.3.2 用户组成员（Group）",slug:"_1-3-2-用户组成员-group",normalizedTitle:"1.3.2 用户组成员（group）",charIndex:2614},{level:4,title:"1.3.3 其他人（Others）",slug:"_1-3-3-其他人-others",normalizedTitle:"1.3.3 其他人（others）",charIndex:2903},{level:3,title:"1.3.4 超级管理员（root）",slug:"_1-3-4-超级管理员-root",normalizedTitle:"1.3.4 超级管理员（root）",charIndex:2971},{level:3,title:"1.4 AAA基础",slug:"_1-4-aaa基础",normalizedTitle:"1.4 aaa基础",charIndex:3153},{level:2,title:"2 用户和用户组文件",slug:"_2-用户和用户组文件",normalizedTitle:"2 用户和用户组文件",charIndex:3445},{level:3,title:"2.1 用户账号文件— /etc/passwd",slug:"_2-1-用户账号文件-etc-passwd",normalizedTitle:"2.1 用户账号文件— /etc/passwd",charIndex:3460},{level:3,title:"2.2 用户影子文件—/etc/shadow",slug:"_2-2-用户影子文件-etc-shadow",normalizedTitle:"2.2 用户影子文件—/etc/shadow",charIndex:4430},{level:3,title:"2.3 创建用户的默认设置文件—/etc/login.defs",slug:"_2-3-创建用户的默认设置文件-etc-login-defs",normalizedTitle:"2.3 创建用户的默认设置文件—/etc/login.defs",charIndex:5141},{level:3,title:"2.4 用户组账号文件—/etc/group",slug:"_2-4-用户组账号文件-etc-group",normalizedTitle:"2.4 用户组账号文件—/etc/group",charIndex:6557},{level:3,title:"2.5 用户组影子文件—/etc/gshadow",slug:"_2-5-用户组影子文件-etc-gshadow",normalizedTitle:"2.5 用户组影子文件—/etc/gshadow",charIndex:7119},{level:2,title:"3 用户和用户组管理",slug:"_3-用户和用户组管理",normalizedTitle:"3 用户和用户组管理",charIndex:7405},{level:3,title:"3.1 用户管理",slug:"_3-1-用户管理",normalizedTitle:"3.1 用户管理",charIndex:7420},{level:4,title:"3.1.1 使用useradd命令添加用户",slug:"_3-1-1-使用useradd命令添加用户",normalizedTitle:"3.1.1 使用useradd命令添加用户",charIndex:7432},{level:4,title:"3.1.2 使用usermod命令修改用户信息",slug:"_3-1-2-使用usermod命令修改用户信息",normalizedTitle:"3.1.2 使用usermod命令修改用户信息",charIndex:8460},{level:4,title:"3.1.3 使用userdel命令删除用户",slug:"_3-1-3-使用userdel命令删除用户",normalizedTitle:"3.1.3 使用userdel命令删除用户",charIndex:8896},{level:4,title:"3.1.4 使用passwd命令管理用户口令",slug:"_3-1-4-使用passwd命令管理用户口令",normalizedTitle:"3.1.4 使用passwd命令管理用户口令",charIndex:9022},{level:3,title:"3.2 用户组管理",slug:"_3-2-用户组管理",normalizedTitle:"3.2 用户组管理",charIndex:9349},{level:4,title:"3.2.1 使用groupadd命令创建用户组",slug:"_3-2-1-使用groupadd命令创建用户组",normalizedTitle:"3.2.1 使用groupadd命令创建用户组",charIndex:9362},{level:4,title:"3.2.2 使用groupmod修改",slug:"_3-2-2-使用groupmod修改",normalizedTitle:"3.2.2 使用groupmod修改",charIndex:9653},{level:4,title:"3.2.3 使用groupdel命令删除用户组",slug:"_3-2-3-使用groupdel命令删除用户组",normalizedTitle:"3.2.3 使用groupdel命令删除用户组",charIndex:9853},{level:4,title:"3.2.4 使用gpasswd命令管理用户组",slug:"_3-2-4-使用gpasswd命令管理用户组",normalizedTitle:"3.2.4 使用gpasswd命令管理用户组",charIndex:10007},{level:4,title:"3.2.5 使用newgrp命令切换用户的有效组",slug:"_3-2-5-使用newgrp命令切换用户的有效组",normalizedTitle:"3.2.5 使用newgrp命令切换用户的有效组",charIndex:10533},{level:2,title:"4 其他相关命令",slug:"_4-其他相关命令",normalizedTitle:"4 其他相关命令",charIndex:10850},{level:3,title:"4.1 id命令查看用户的UID和GID",slug:"_4-1-id命令查看用户的uid和gid",normalizedTitle:"4.1 id命令查看用户的uid和gid",charIndex:10863},{level:3,title:"4.2 su命令临时切换用户身份",slug:"_4-2-su命令临时切换用户身份",normalizedTitle:"4.2 su命令临时切换用户身份",charIndex:10960},{level:3,title:"4.3 whoami和who am i命令",slug:"_4-3-whoami和who-am-i命令",normalizedTitle:"4.3 whoami和who am i命令",charIndex:11473},{level:3,title:"4.4 users和groups命令",slug:"_4-4-users和groups命令",normalizedTitle:"4.4 users和groups命令",charIndex:11710},{level:2,title:"5 高级操作示例",slug:"_5-高级操作示例",normalizedTitle:"5 高级操作示例",charIndex:12045},{level:3,title:"5.1 通过更改用户和组的配置文件，直接添加或修改用户和组",slug:"_5-1-通过更改用户和组的配置文件-直接添加或修改用户和组",normalizedTitle:"5.1 通过更改用户和组的配置文件，直接添加或修改用户和组",charIndex:12058},{level:3,title:"5.2 Linux批量添加用户",slug:"_5-2-linux批量添加用户",normalizedTitle:"5.2 linux批量添加用户",charIndex:12928}],headersStr:"1 用户和用户组介绍 1.1 用户 1.2 用户组 1.3 文件权限 1.3.1 文件所有者（User） 1.3.2 用户组成员（Group） 1.3.3 其他人（Others） 1.3.4 超级管理员（root） 1.4 AAA基础 2 用户和用户组文件 2.1 用户账号文件— /etc/passwd 2.2 用户影子文件—/etc/shadow 2.3 创建用户的默认设置文件—/etc/login.defs 2.4 用户组账号文件—/etc/group 2.5 用户组影子文件—/etc/gshadow 3 用户和用户组管理 3.1 用户管理 3.1.1 使用useradd命令添加用户 3.1.2 使用usermod命令修改用户信息 3.1.3 使用userdel命令删除用户 3.1.4 使用passwd命令管理用户口令 3.2 用户组管理 3.2.1 使用groupadd命令创建用户组 3.2.2 使用groupmod修改 3.2.3 使用groupdel命令删除用户组 3.2.4 使用gpasswd命令管理用户组 3.2.5 使用newgrp命令切换用户的有效组 4 其他相关命令 4.1 id命令查看用户的UID和GID 4.2 su命令临时切换用户身份 4.3 whoami和who am i命令 4.4 users和groups命令 5 高级操作示例 5.1 通过更改用户和组的配置文件，直接添加或修改用户和组 5.2 Linux批量添加用户",content:'# 1 用户和用户组介绍\n\n\n# 1.1 用户\n\n任何操作系统都存在“用户”的概念，Linux也不例外。Linux系统是一个多用户多任务的分时操作系统，即Linux系统支持多个用户在同一时间内登录，不同用户可以执行不同的任务，并且互不影响。每个用户账号都拥有一个用户名和各自的口令（即密码）。在登录系统时，只有正确输入用户名和密码，才能进入系统和自己的主目录。\n\n在Linux中，用户分为两大类、三小类：分别为系统管理员（一般为root）和普通用户 。普通用户中，又划分为两类，分别为系统用户和登录用户。\n\n * 系统管理员：即超级管理员，可以操作系统中任意文件和命令，拥有最高的管理权限。\n * 普通用户\n   * 登录用户：为管理员手动添加的用户，默认仅拥有操作自身家目录中文件及目录的权限，以及进入与浏览相关目录文件的权限（如/etc、/var/log等），但没有创建、修改、删除等权限。\n   * 系统用户：一般为系统安装后默认存在的，且默认情况下不能登录系统，它们的存在主要是为了满足系统进程对文件属主的需求。 Tips：在部署某些服务是，也可以手动添加某些系统用户。\n\nLinux系统使用UID（User ID）来标识不同用户，说白了，其实Linux并不认识你的用户名称，它只认识用户名对应的UID。其中UID是16bit的二进制数字，所以换算成十进制，UID的范围是0~65535，Linux根据用户类别，对UID划分做了规定：\n\n * 0（系统管理员）：，当UID是0时，代表这个用户为超级管理员，所以当你想要其他的用户也有root权限时，将该用户的UID改为0即可。但一般来说，用户的UID应当是独一无二的，其他用户不应当有相同的UID数值，只有UID等于0时可以例外。\n * 1~499（系统账号）：该范围内的UID是保留给系统使用的 ID，其实 1~65534 之间的账号并没有不同， 也就是除了 0 之外，其它的 UID 并没有不一样，预设 500 以下给系统作为保留账号只是一个习惯。这样的好处是，以有名的 DNS 服务器的启动服务『 named 』为例，这个程序的预设所有人 named 的账号 UID 是 25 ，当你自定义的账号也是 25 时，会造成系统冲突！为了杜绝这样的问题，养成好习惯，保留 500 以前的 UID 给系统使用！ 一般来说， 1到99 会保留给系统预设的账号，另外 100~499 则保留给一些服务来使用。\n * 500~65535（登录用户）：给一般使用者用的。事实上，目前的 linux 核心 (2.6.x 版)已经可以支持到 4294967295 (2^32-1) 这么大的 UID 号码。\n\n\n# 1.2 用户组\n\n用户组是具有相同特征用户的逻辑集合。简单的理解，有时我们需要让多个用户具有相同的权限，比如查看、修改某一个文件的权限，一种方法是分别对多个用户进行文件访问授权，如果有 10 个用户的话，就需要授权 10 次，那如果有 100、1000 甚至更多的用户呢？\n\n显然，这种方法不太合理。最好的方式是建立一个组，让这个组具有查看、修改此文件的权限，然后将所有需要访问此文件的用户放入这个组中。那么，所有用户就具有了和组一样的权限，这就是用户组。将用户分组是 Linux 系统中对用户进行管理及控制访问权限的一种手段，通过定义用户组，很多程序上简化了对用户的管理工作。\n\nLinux对用户组也有三种划分方式：\n\n * 第一种组类别\n   \n   * 管理员组\n   * 普通用户组（包括系统用户组和登录用户组）\n\n * 第二种组类别\n   \n   * 用户的基本组（主组）：用户必须有且只能有一个基本组。\n   * 用户的附加组 （附属组）：用户可以有0个、1个或多个附加组。\n   \n   基本组和附加组就比如，每个人有一个用来安家的房子（基本组），还可以有N个用于投资的房子（附属组）。\n\n * 第三种组类别\n   \n   * 私有组：每新建一个用户，如果不指定-g参数，都会自动创建一个和用户名同名的组，且组内只包含用户本身。\n   * 公共组：组内可包含多个用户。\n\nLinux系统也是使用GID（Group ID）来标识不同组。用户和用户组的对应关系有以下 4 种：\n\n 1. 一对一：一个用户可以存在一个组中，是组中的唯一成员；\n 2. 一对多：一个用户可以存在多个用户组中，此用户具有这多个组的共同权限；\n 3. 多对一：多个用户可以存在一个组中，这些用户具有和组相同的权限；\n 4. 多对多：多个用户可以存在多个组中，也就是以上 3 种关系的扩展。\n\n下图形象的表示了用户和用户组的4种对应关系。\n\n注意：每一个用户组也有一个口令，当我们将用户添加到指定组时需要该用户组的密码。\n\n\n# 1.3 文件权限\n\n在Linux操作系统中，任何文件都归属于某一特定的用户，其作为多用户系统，如何区分不同用户对文件的权限成了不可避免的问题。例如，小 A 希望个人文件不被其他用户读取，而如果不对文件进行权限设置，共享了主机资源的小 B 也可以读取小 A 的个人文件，这是不合理的，不同用户对不同文件所拥有的权限应该不尽相同。\n\n因此，Linux 以 “用户与用户组” 的概念，建立用户与文件权限之间的联系，保证系统能够充分考虑每个用户的隐私保护，很大程度上保障了 Linux 作为多用户系统的可行性。从文件权限的角度出发，“用户与用户组” 引申为三个具体的对象——文件所有者、用户组成员、其他人。每一个对象对某一个文件的持有权限是不同的。\n\n# 1.3.1 文件所有者（User）\n\n当一个用户创建了一个文件，这个用户就是这个文件的文件所有者。文件所有者对文件拥有最高权限，除非文件所有者开放权限，否则其他人无法对文件执行查看、修改等操作。**这也是 Linux 系统能够保护用户隐私的最关键的原因。**在文件所有者占有文件之后，需要文件所有者对其他用户开放权限，其他用户才能查看、修改文件。\n\n如果仅区分 “文件所有者” 和 “其他用户”，那么文件所有者对其他用户开放权限后，所有其他用户均能查看、修改文件。但是，若文件所有者希望仅对部分用户开放，那么仅仅区分 “用户所有者” 和 “其他用户” 显然不满足需求。这就引入了 “用户组的概念”。\n\n# 1.3.2 用户组成员（Group）\n\n将 “其他用户” 区分为用户组成员和其他人后，若文件所有者希望对部分用户开放权限，而对其他人继续保持私有，则只需要将这部分用户与文件所有者划入一个用户组。这样，这部分用户就成了与文件所有者同组的用户组成员。用户可以对用户组成员开放文件权限，用户组成员则具备了查看、修改文件的权限，而对其他无关用户保持私有。\n\n用户组成员在团队开发中非常有帮助。例如，团队成员之间保持文件资源共享，但对非团队成员保持私有，这就需要将文件所有者与团队成员用户划分为同一个用户组，再对用户组成员开放权限即可。\n\n需要注意的是，一个用户可在多个用户组中。\n\n# 1.3.3 其他人（Others）\n\n顾名思义，就是与文件所有者没有任何联系的用户，即不是文件所有者也不是所在文件所属用户组。\n\n\n# 1.3.4 超级管理员（root）\n\n由于Linux系统中，root具有最高权限，可以执行任何想要执行的操作，也正因为如此，处于安全考虑，一般情况下不推荐使用 root 用户进行日常使用。root 用户所在的用户组称为 “root组”，处于 root 组的普通用户，能够通过 sudo 命令获取 root 权限，即我们是可以通过sudo权限来操作文件的。\n\n\n# 1.4 AAA基础\n\nAAA指的是Authentication、Authorization、Accounting，即认证、授权和审计。\n\n * 认证：验证用户是否可以获得权限，是AAA的第一步，即验证身份；\n * 授权：授权用户可以使用那些服务或资源，即身份验证成功后，赋予这个身份相应的权限；\n * 审计：记录用户的操作情况，在Linux中，日志就是审计的一种手段。\n\nLinux的用户和组管理可以说是基于AAA进行的，首先用户登录输入用户名密码，就是认证的过程；其次，在用户登录成功后，所拥有的权限各不相同，这就是\n\n授权；最后，用户的操作历史会记录在日志中，这是审计。\n\n\n# 2 用户和用户组文件\n\n\n# 2.1 用户账号文件— /etc/passwd\n\n/etc/passwd文件是Linux系统安全的关键文件之一，只有系统管理员才可以修改此文件。该文件用于用户登录等操作时校验用户的登录名、加密的口令数据项、用户ID（UID）、默认的用户组ID（GID）、用户信息、用户主目录及登录后使用的shell。该文件种每一行保存一个用户的资料，而用户数据按域以冒号\':\'分割。格式如下。\n\nusername:password:uid:gid:userinfo:home:shell\n\n\n1\n\n1\n\n\n具体含义如表所示。\n\n域          含义\nusername   登录名\npassword   加密的用户口令\nuid        用户ID\ngid        用户组ID\nuserinfo   用户信息\nhome       分配给用户的主目录\nshell      用户登录后将执行的shell（若为空格泽默认为“/bin/sh”）\n\n其中关于用户主目录，每个用户都需要保存专属于自己的配置文件及其他文档，这是以免用户间相互干扰。除root账户外（root账户的主目录为"/root"），大多数Linux默认将用户主目录安置在"/home"目录下，并把每个用户的主目录命名为其上机使用的登录名。\n\n\n\n如图，acs的登录主目录为"/home/acs"。通常，“~”被指向当前用户的登录子目录。\n\n注意：用户主目录被安排在“/home”下完全是认为决定的。系统并不关心我们到底把用户主目录安排在什么地方，因为每个用户的位置是在账号文件中定义说明的。所以，用户可以自行调整，灵活使用\n\n关于shell，Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。当用户登录进入系统时，会启动一个Shell程序，默认是bash。系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用bash为默认的登录Shell，即这个字段的值为/bin/bash。用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。\n\n我们通过查看/etc/passwd文件，可以得到如下完整的系统账号文件。\n\n\n\n我们发现，第二列都为x。我们可以继续往下看。\n\n\n# 2.2 用户影子文件—/etc/shadow\n\n实际上，Linxu使用不可逆的加密算法（如MD5）来加密口令，由于加密算法是不可逆的，所以黑客从密文是得不到明文的。但/etc/passwd文件时全局可读的，且加密的算法是公开的，如果在passwd中显示密文，黑客据此可以破解口令。Linux系统目前广泛采用了“shadow（影子）文件”机制。将加密的口令转移到“/etc/shadow”文件中。/etc/shadow文件只为root超级用户可读，而相应的etc/passwd文件的密文域泽显示为一个x，从而最大限度地减少了密文泄露的机会。x表示该账户需要密码才能登录，为空时，账户无须密码即可登录。\n\n和/etc/passwd类似，/etc/shadow文件中每条记录用冒号“：”分隔，形成9个域，格式如下。\n\nusername:password:lastchg:min:max:warn:inactive:expire:flag\n\n\n1\n\n1\n\n\n域          含义\nusername   用户登陆名\npassword   加密的用户口令\nlastchg    表示从1970年1月1日起到上次修改口令所经过的天数\nmin        表示两次修改口令之间至少经过的天数\nmax        表示口令还会有效的最大天数，如果是99999则表示永不过期\nwarn       表示口令失效前多少天内系统向用户发出警告\ninactive   表示禁止登录前用户名还有效的天数\nexpire     表示用户被禁止登录的时间\nflag       保留域，暂未使用\n\n下图为系统中实际影子文件的例子。\n\n\n\n\n# 2.3 创建用户的默认设置文件—/etc/login.defs\n\n/etc/login.defs 文件用于在创建用户时，对用户的一些基本属性做默认设置，例如指定用户 UID 和 GID 的范围，用户的过期时间，密码的最大长度，等等。\n\n需要注意的是，该文件的用户默认配置对 root 用户无效。并且，当此文件中的配置与 /etc/passwd 和 /etc/shadow 文件中的用户信息有冲突时，系统会以/etc/passwd 和 /etc/shadow 为准。\n\n其中设置项含义如下表所示。\n\n设置项                        含义\nMAIL_DIR /var/spool/mail   创建用户时，系统会在目录 /var/spool/mail 中创建一个用户邮箱，比如 lamp 用户的邮箱是\n                           /var/spool/mail/lamp。\nPASS_MAX_DAYS 99999        密码有效期，99999 是自 1970 年 1 月 1 日起密码有效的天数，相当于 273 年，可理解为密码始终有效。\nPASS_MIN_DAYS 0            表示自上次修改密码以来，最少隔多少天后用户才能再次修改密码，默认值是 0。\nPASS_MIN_LEN 5             指定密码的最小长度，默认不小于 5 位，但是现在用户登录时验证已经被 PAM 模块取代，所以这个选项并不生效。\nPASS_WARN_AGE 7            指定在密码到期前多少天，系统就开始通过用户密码即将到期，默认为 7 天。\nUID_MIN 500                指定最小 UID 为 500，也就是说，添加用户时，默认 UID 从 500 开始。注意，如果手工指定了一个用户的\n                           UID 是 550，那么下一个创建的用户的 UID 就会从 551 开始，哪怕 500~549 之间的 UID\n                           没有使用。\nUID_MAX 60000              指定用户最大的 UID 为 60000。\nGID_MIN 500                指定最小 GID 为 500，也就是在添加组时，组的 GID 从 500 开始。\nGID_MAX 60000              用户 GID 最大为 60000。\nCREATE_HOME yes            指定在创建用户时，是否同时创建用户主目录，yes 表示创建，no 则不创建，默认是 yes。\nUMASK 077                  用户主目录的权限默认设置为 077。\nUSERGROUPS_ENAB yes        指定删除用户的时候是否同时删除用户组，准备地说，这里指的是删除用户的初始组，此项的默认值为 yes。\nENCRYPT_METHOD SHA512      指定用户密码采用的加密规则，默认采用 SHA512，这是新的密码加密模式，原先的 Linux 只能用 DES 或 MD5\n                           加密。\n\n如果我们想修改默认配置即可修改配置项的值即可。\n\n\n# 2.4 用户组账号文件—/etc/group\n\n我们知道，/etc/passwd文件中包含着每个用户的用户组ID（GID），但如果我们需要找一个用户组中的所有用户，通过/etc/passwd难免有些复杂，需要从头到尾寻找同组用户。而/etc/group文件包含关于用户组信息，GID被映射到用户分组的名称及同一分组中的其他成员，这样找同组用户以及配置用户组就方便了许多。/etc/group文件对用户组的许可权限的控制并不是必要的，这是因为Linux系统用来自于/etc/passwd文件的UID、GID来决定文件存取权限。即使/etc/group文件不存在于系统中，具有相同的GID用户也能以用户组的许可权限共享文件。\n\n/etc/group文件记录格式如下。\n\ngroup_name:group_password:group_id:group_members\n\n\n1\n\n1\n\n\n其中，各个域的含义如下表。\n\n域                含义\ngroup_name       用户组名\ngroup_password   加密后的用户组口令\ngroup_id         用户组ID（GID）\ngroup_members    以逗号分隔的成员用户清单\n\n以下是一个/etc/group文件的实例。\n\n\n\n\n# 2.5 用户组影子文件—/etc/gshadow\n\n和用户账号文件passwd一样，为了应对黑客对其进行的暴力攻击，用户组文件也采用一种将组口令与组的其他信息相分离的安全机制——gshadow。/etc/shadow文件记录格式如下。\n\ngroup_name:group_password:group_members\n\n\n1\n\n1\n\n\n其中，各个域的含义如下表。\n\n域                含义\ngroup_name       用户组名\ngroup_password   加密后的用户组口令\ngroup_members    以逗号分隔的成员用户清单\n\n\n# 3 用户和用户组管理\n\n\n# 3.1 用户管理\n\n# 3.1.1 使用useradd命令添加用户\n\nLinux使用useradd命令添加用户或更新新创建用户的默认信息。其命令格式如下。\n\nuseradd [option] username\n\n\n1\n\n1\n\n\n可使用的选项如下：\n\n * -c comment：描述新用户账号，通常为用户全名。\n * -d home_dir：设置用户主目录。默认值为用户的登录名，并放在"/home"目录下。\n * -g group：指定用户所属的基本组。\n * -G group：指定用户所属的附加组。\n * -u uid：设置用户的ID。\n * -s shell类型：设定用户使用的登录shell类型。\n * -k dir：设置框架目录，创建用户时该目录下的文件都被复制到主目录。\n * -e expire_date：设置账号过期时间。\n * -f inactivity：设置口令失效时间。\n * -n：不为用户创建私有用户组。\n * -p password：为新建用户指定登录密码。此处的 password 是对应登录密码经 MD5 加密后所得到的密码值，不是真实密码原文，因此在实际应用中，该参数选项使用较少，通常单独使用 passwd 命令来为用户设置登录密码。\n * -r：创建一个用户 ID 小于 500 的系统账户，默认不创建对应的主目录。\n * -m：若主目录不存在，则创建它。通常与-r结合，可为系统用户主目录。\n * -M：不创建主目录。\n\n实例1：创建一个普通用户，名为hzf，其中uid为6666，用户主目录指定在/hzf/。\n\nuseradd -u 6666 -d /hzf/ hzf\n\n\n1\n\n1\n\n\n实例2：创建一个系统账户，名为mysystem，其中为系统用户创建主目录，指定密码为12345678\n\n> 首先需要加密密码串，这里使用md5sum工具。\n> \n> 利用md5sum加密字符串的方法\n> \n> # md5sum //然后回车\n> \n> 12345678 //输入12345678，然后按两次ctrl+d。\n> \n> 这个时候就会得到一串密文。\n> \n> 使用以下命令即可创建该系统用户\n> \n> useradd -r -m -p 1234567825d55ad283aa400af464c76d713c07ad mysystem\n> \n> \n> 1\n> \n> 1\n\n查看/etc/passwd即可看到我们创建得用户信息。\n\n\n\n# 3.1.2 使用usermod命令修改用户信息\n\n对于已创建好的用户，可使用 usermod 命令来修改和设置账户的各项属性，包括登录名，主目录，用户组，登录 shell 等，该命令格式如下。\n\nusermod [option] username\n\n\n1\n\n1\n\n\n常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。\n\n另外，有些系统还可以使用-l修改用户名。用法为：usermod -l newusername\n\n使用-L可以锁定用户账号，临时禁止用户登录。用法为：usermod -L username，Linux锁定用户，是通过在密码文件 shadow 的密码字段前加 “！” 来标识该用户被锁定。\n\n但如果我们是用root用户登录，再用su命令切换到被锁定的账号是可以进去的。\n\n使用-U可以解锁用户账号。用法为：usermod -U username。\n\n# 3.1.3 使用userdel命令删除用户\n\n要删除用户，可以使用userdel命令删除，命令格式如下。\n\nuserdel [-r] username\n\n\n1\n\n1\n\n\n其中-r参数可选，若带上参数，表示在删除账户的同时，一并删除用户的主目录。\n\n# 3.1.4 使用passwd命令管理用户口令\n\n用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。\n\n指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式如下。\n\npasswd [option] username\n\n\n1\n\n1\n\n\n可使用的选项如下：\n\n * -l：锁定口令，即禁用账号。\n * -u：口令解锁。\n * -d：使账号无口令。这样，下次登录的时候，系统就不再允许该用户登录了。\n * -f：强迫用户下次登陆时修改口令。\n\n如果不指定用户名，则表示修改自己的口令。\n\n\n# 3.2 用户组管理\n\n# 3.2.1 使用groupadd命令创建用户组\n\n增加一个新的用户组使用groupadd命令。命令格式如下。\n\ngroupadd [option] groupname\n\n\n1\n\n1\n\n\n可使用的选项如下：\n\n * -r：表示创建系统用户组，该类用户组的 GID 值小于 500；若没有 - r 参数，则创建普通用户组，其 GID 值大于或等于 500。\n * -g gid：指定新用户组的标识号GID。\n * -o：一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。\n\n如果没有指定选择参数，新组的组标识号是在当前已有的最大组标识号的基础上加1。\n\n# 3.2.2 使用groupmod修改\n\n修改用户组的属性使用groupmod命令。命令格式如下。\n\ngroupmod [option] groupname\n\n\n1\n\n1\n\n\n可使用的选项如下：\n\n * -g gid：为用户组指定新的组标识号。\n * -o：与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。\n * -n newgroupname： 将用户组的名字改为新名字\n\n# 3.2.3 使用groupdel命令删除用户组\n\n使用groupdel命令可以删除用户组。命令格式如下。\n\ngroupdel groupname\n\n\n1\n\n1\n\n\n在删除用户组时，被删除的用户组不能是某个账户的私有用户组，否则将无法删除，若要删除，则应先删除引用该私有用户组的账户，然后再删除用户组。\n\n# 3.2.4 使用gpasswd命令管理用户组\n\n为了避免系统管理员（root）太忙碌，无法及时管理群组，我们可以使用 gpasswd 命令给群组设置一个群组管理员，代替 root 完成将用户加入或移出群组的操作。gpasswd命令格式如下。\n\ngpasswd [option] groupname\n\n\n1\n\n1\n\n\n可选择的选项如下：\n\n选项             功能\n               选项为空时，表示给群组设置密码，仅 root 用户可用。\n-A user1,...   将群组的控制权交给 user1,... 等用户管理，也就是说，设置 user1,... 等用户为群组的管理员，仅\n               root 用户可用。\n-M user1,...   将 user1,... 加入到此群组中，仅 root 用户可用。\n-r             移除群组的密码，仅 root 用户可用。\n-R             让群组的密码失效，仅 root 用户可用。\n-a user        将 user 用户加入到群组中。\n-d user        将 user 用户从群组中移除。\n\n实例如下。\n\n\n\n# 3.2.5 使用newgrp命令切换用户的有效组\n\n我们知道，每个用户可以属于一个初始组（用户是这个组的初始用户），也可以属于多个附加组（用户是这个组的附加用户）。既然用户可以属于这么多用户组，那么用户在创建文件后，默认生效的组身份是哪个呢？\n\n当然是初始用户组的组身份生效，因为初始组是用户一旦登陆就获得的组身份。也就是说，用户的有效组默认是初始组，因此所创建文件的属组是用户的初始组。那么，既然用户属于多个用户组，能不能改变用户的初始组呢？使用命令 newgrp 就可以。此命令基本格式如下。\n\nnewgrp groupname\n\n\n1\n\n1\n\n\nnewgrp 命令可以从用户的附加组中选择一个群组，作为用户新的初始组。\n\n\n# 4 其他相关命令\n\n\n# 4.1 id命令查看用户的UID和GID\n\nid 命令可以查询用户的UID、GID 和附加组的信息。命令比较简单，格式如下。\n\nid username\n\n\n1\n\n1\n\n\n实例如下：\n\n\n\n\n# 4.2 su命令临时切换用户身份\n\nsu 是最简单的用户切换命令，通过该命令可以实现任何身份的切换，包括从普通用户切换为 root 用户、从 root 用户切换为普通用户以及普通用户之间的切换。\n\n普通用户之间切换以及普通用户切换至 root 用户，都需要知晓对方的密码，只有正确输入密码，才能实现切换；从 root 用户切换至其他用户，无需知晓对方密码，直接可切换成功。\n\nsu命令格式如下。\n\nsu [option] username\n\n\n1\n\n1\n\n\n可使用的选项如下：\n\n * -l或-：带这个参数就好像是重新 login 为该使用者一样，大部份环境参数都是以该使用者为主，并且工作目录也会改变，如果没有指定 USER ，内定是 root。\n * -c <command> ：仅切换用户执行一次命令，执行后自动切换回来，该选项后通常会带有要执行的命令。\n * -s <shell>： 指定要执行的 shell （bash csh tcsh 等），预设值为 /etc/passwd 内的该使用者shell\n * -h：显示说明文件。\n * -V：显示版本资讯。\n * -m或-p：执行su时不改变工作环境。\n\n\n\n\n# 4.3 whoami和who am i命令\n\nwhoami 命令和 who am i 命令是不同的 2 个命令，前者用来打印当前执行操作的用户名，后者则用来打印登陆当前 Linux 系统的用户名。\n\n我们可以看一下操作实例来感受区别：\n\n\n\n在未切换用户身份之前，whoami 和 who am i 命令的输出是一样的，但使用 su 命令切换用户身份后，使用 whoami 命令打印的是切换后的用户名，而 who am i 命令打印的仍旧是登陆系统时所用的用户名。\n\n\n# 4.4 users和groups命令\n\nusers命令格式如下。\n\nusers [option]\n\n\n1\n\n1\n\n * 如果没有参数，则显示当前登录系统的所有用户的用户列表。每个显示的用户名对应一个登录会话。如果一个用户有不止一个登录会话，那他的用户名将显示相同的次数。\n * --help：显示命令的帮助信息。\n * --version：显示命令的版本信息。\n\ngroups命令格式如下。\n\ngroups [option] [groupname]\n\n\n1\n\n1\n\n * 如果没有参数，查看当前登录用户的组内成员。如果指定了groupname，则显示该group的成员。\n * --help：显示命令的帮助信息。\n * --version：显示命令的版本信息。\n\n\n# 5 高级操作示例\n\n\n# 5.1 通过更改用户和组的配置文件，直接添加或修改用户和组\n\n为了更深入了解用户和组的相关配置文件，可以手动更改配置文件以达到命令的执行效果。\n\n首先我们需要了解Linux中的/etc/skel目录。skel是skeleton的缩写，意为骨骼、框架。故此目录的作用是在建立新用户时，用于初始化用户根目录。系统会将此目录下的所有文件、目录都复制到新建用户的主目录，并且将用户属主与用户组调整为与此主目录相同。所以可将用户配置文件预置到/etc/skel目录下，比如说.bashrc、.profile与.vimrc等。\n\n注意：\n\n * 如果在新建用户时，没有自动建立用户根目录，则无法调用到此框架目录。\n * 如果不想以默认的/etc/skel目录作为框架目录，可以在运行useradd命令时使用-k指定新的框架目录。\n * 如果不想在每次新建用户时，都重新指定新的框架目录，可以通过修改/etc/default/useradd配置文件来改变默认的框架目录。修改SKEL变量的值即可。原来为SKEL=/etc/skel。\n\n实际操作步骤如下：\n\n 1. 编辑/etc/group文件，添加组test，其中GID为1500。\n    \n    echo \'test:x:1500\' >> /etc/group\n\n 2. 创建用户的主目录。\n    \n    我们需要将框架目录中的文件放到主目录中。同时还需要修改好主目录对其他用户都没有任何访问权限。\n    \n    \n\n 3. 编辑/etc/passwd文件，添加用户test，UID为1500，其中基本组ID为test组的GID，其家目录为/home/test。\n    \n    echo \'test:x:1500:1500::/home/test:/bin/bash\' >> /etc/passwd\n\n 4. 修改/home/test目录及其内部所有文件的属主为test，属组为test。\n    \n    \n\n 5. 修改test用户的密码并尝试登录。\n    \n    \n\n\n# 5.2 Linux批量添加用户\n\n我们可以使用useradd+passwd命令配合shell脚本来实现该功能。\n\n首先我们将需要创建的用户名写入一个文本文件，其中每行代表一个用户名：\n\n\n\n然后实际上我们的思路就是提取出文件中的用户名然后自动执行useradd命令，再执行passwd自动填入初始密码。编写的shell脚本文件如下：\n\n#! /bin/bash\n\nfor username in $(more username.txt)\ndo\nif [ -n $username ]\nthen\n        useradd -m $username # 执行useradd命令\n        echo $username"123456" | passwd --stdin $username\n        echo "User $username\'s password is changed!"\nelse\n        echo "The username is null!"\nfi\ndone\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n测试登录，登录成功！\n\n',normalizedContent:'# 1 用户和用户组介绍\n\n\n# 1.1 用户\n\n任何操作系统都存在“用户”的概念，linux也不例外。linux系统是一个多用户多任务的分时操作系统，即linux系统支持多个用户在同一时间内登录，不同用户可以执行不同的任务，并且互不影响。每个用户账号都拥有一个用户名和各自的口令（即密码）。在登录系统时，只有正确输入用户名和密码，才能进入系统和自己的主目录。\n\n在linux中，用户分为两大类、三小类：分别为系统管理员（一般为root）和普通用户 。普通用户中，又划分为两类，分别为系统用户和登录用户。\n\n * 系统管理员：即超级管理员，可以操作系统中任意文件和命令，拥有最高的管理权限。\n * 普通用户\n   * 登录用户：为管理员手动添加的用户，默认仅拥有操作自身家目录中文件及目录的权限，以及进入与浏览相关目录文件的权限（如/etc、/var/log等），但没有创建、修改、删除等权限。\n   * 系统用户：一般为系统安装后默认存在的，且默认情况下不能登录系统，它们的存在主要是为了满足系统进程对文件属主的需求。 tips：在部署某些服务是，也可以手动添加某些系统用户。\n\nlinux系统使用uid（user id）来标识不同用户，说白了，其实linux并不认识你的用户名称，它只认识用户名对应的uid。其中uid是16bit的二进制数字，所以换算成十进制，uid的范围是0~65535，linux根据用户类别，对uid划分做了规定：\n\n * 0（系统管理员）：，当uid是0时，代表这个用户为超级管理员，所以当你想要其他的用户也有root权限时，将该用户的uid改为0即可。但一般来说，用户的uid应当是独一无二的，其他用户不应当有相同的uid数值，只有uid等于0时可以例外。\n * 1~499（系统账号）：该范围内的uid是保留给系统使用的 id，其实 1~65534 之间的账号并没有不同， 也就是除了 0 之外，其它的 uid 并没有不一样，预设 500 以下给系统作为保留账号只是一个习惯。这样的好处是，以有名的 dns 服务器的启动服务『 named 』为例，这个程序的预设所有人 named 的账号 uid 是 25 ，当你自定义的账号也是 25 时，会造成系统冲突！为了杜绝这样的问题，养成好习惯，保留 500 以前的 uid 给系统使用！ 一般来说， 1到99 会保留给系统预设的账号，另外 100~499 则保留给一些服务来使用。\n * 500~65535（登录用户）：给一般使用者用的。事实上，目前的 linux 核心 (2.6.x 版)已经可以支持到 4294967295 (2^32-1) 这么大的 uid 号码。\n\n\n# 1.2 用户组\n\n用户组是具有相同特征用户的逻辑集合。简单的理解，有时我们需要让多个用户具有相同的权限，比如查看、修改某一个文件的权限，一种方法是分别对多个用户进行文件访问授权，如果有 10 个用户的话，就需要授权 10 次，那如果有 100、1000 甚至更多的用户呢？\n\n显然，这种方法不太合理。最好的方式是建立一个组，让这个组具有查看、修改此文件的权限，然后将所有需要访问此文件的用户放入这个组中。那么，所有用户就具有了和组一样的权限，这就是用户组。将用户分组是 linux 系统中对用户进行管理及控制访问权限的一种手段，通过定义用户组，很多程序上简化了对用户的管理工作。\n\nlinux对用户组也有三种划分方式：\n\n * 第一种组类别\n   \n   * 管理员组\n   * 普通用户组（包括系统用户组和登录用户组）\n\n * 第二种组类别\n   \n   * 用户的基本组（主组）：用户必须有且只能有一个基本组。\n   * 用户的附加组 （附属组）：用户可以有0个、1个或多个附加组。\n   \n   基本组和附加组就比如，每个人有一个用来安家的房子（基本组），还可以有n个用于投资的房子（附属组）。\n\n * 第三种组类别\n   \n   * 私有组：每新建一个用户，如果不指定-g参数，都会自动创建一个和用户名同名的组，且组内只包含用户本身。\n   * 公共组：组内可包含多个用户。\n\nlinux系统也是使用gid（group id）来标识不同组。用户和用户组的对应关系有以下 4 种：\n\n 1. 一对一：一个用户可以存在一个组中，是组中的唯一成员；\n 2. 一对多：一个用户可以存在多个用户组中，此用户具有这多个组的共同权限；\n 3. 多对一：多个用户可以存在一个组中，这些用户具有和组相同的权限；\n 4. 多对多：多个用户可以存在多个组中，也就是以上 3 种关系的扩展。\n\n下图形象的表示了用户和用户组的4种对应关系。\n\n注意：每一个用户组也有一个口令，当我们将用户添加到指定组时需要该用户组的密码。\n\n\n# 1.3 文件权限\n\n在linux操作系统中，任何文件都归属于某一特定的用户，其作为多用户系统，如何区分不同用户对文件的权限成了不可避免的问题。例如，小 a 希望个人文件不被其他用户读取，而如果不对文件进行权限设置，共享了主机资源的小 b 也可以读取小 a 的个人文件，这是不合理的，不同用户对不同文件所拥有的权限应该不尽相同。\n\n因此，linux 以 “用户与用户组” 的概念，建立用户与文件权限之间的联系，保证系统能够充分考虑每个用户的隐私保护，很大程度上保障了 linux 作为多用户系统的可行性。从文件权限的角度出发，“用户与用户组” 引申为三个具体的对象——文件所有者、用户组成员、其他人。每一个对象对某一个文件的持有权限是不同的。\n\n# 1.3.1 文件所有者（user）\n\n当一个用户创建了一个文件，这个用户就是这个文件的文件所有者。文件所有者对文件拥有最高权限，除非文件所有者开放权限，否则其他人无法对文件执行查看、修改等操作。**这也是 linux 系统能够保护用户隐私的最关键的原因。**在文件所有者占有文件之后，需要文件所有者对其他用户开放权限，其他用户才能查看、修改文件。\n\n如果仅区分 “文件所有者” 和 “其他用户”，那么文件所有者对其他用户开放权限后，所有其他用户均能查看、修改文件。但是，若文件所有者希望仅对部分用户开放，那么仅仅区分 “用户所有者” 和 “其他用户” 显然不满足需求。这就引入了 “用户组的概念”。\n\n# 1.3.2 用户组成员（group）\n\n将 “其他用户” 区分为用户组成员和其他人后，若文件所有者希望对部分用户开放权限，而对其他人继续保持私有，则只需要将这部分用户与文件所有者划入一个用户组。这样，这部分用户就成了与文件所有者同组的用户组成员。用户可以对用户组成员开放文件权限，用户组成员则具备了查看、修改文件的权限，而对其他无关用户保持私有。\n\n用户组成员在团队开发中非常有帮助。例如，团队成员之间保持文件资源共享，但对非团队成员保持私有，这就需要将文件所有者与团队成员用户划分为同一个用户组，再对用户组成员开放权限即可。\n\n需要注意的是，一个用户可在多个用户组中。\n\n# 1.3.3 其他人（others）\n\n顾名思义，就是与文件所有者没有任何联系的用户，即不是文件所有者也不是所在文件所属用户组。\n\n\n# 1.3.4 超级管理员（root）\n\n由于linux系统中，root具有最高权限，可以执行任何想要执行的操作，也正因为如此，处于安全考虑，一般情况下不推荐使用 root 用户进行日常使用。root 用户所在的用户组称为 “root组”，处于 root 组的普通用户，能够通过 sudo 命令获取 root 权限，即我们是可以通过sudo权限来操作文件的。\n\n\n# 1.4 aaa基础\n\naaa指的是authentication、authorization、accounting，即认证、授权和审计。\n\n * 认证：验证用户是否可以获得权限，是aaa的第一步，即验证身份；\n * 授权：授权用户可以使用那些服务或资源，即身份验证成功后，赋予这个身份相应的权限；\n * 审计：记录用户的操作情况，在linux中，日志就是审计的一种手段。\n\nlinux的用户和组管理可以说是基于aaa进行的，首先用户登录输入用户名密码，就是认证的过程；其次，在用户登录成功后，所拥有的权限各不相同，这就是\n\n授权；最后，用户的操作历史会记录在日志中，这是审计。\n\n\n# 2 用户和用户组文件\n\n\n# 2.1 用户账号文件— /etc/passwd\n\n/etc/passwd文件是linux系统安全的关键文件之一，只有系统管理员才可以修改此文件。该文件用于用户登录等操作时校验用户的登录名、加密的口令数据项、用户id（uid）、默认的用户组id（gid）、用户信息、用户主目录及登录后使用的shell。该文件种每一行保存一个用户的资料，而用户数据按域以冒号\':\'分割。格式如下。\n\nusername:password:uid:gid:userinfo:home:shell\n\n\n1\n\n1\n\n\n具体含义如表所示。\n\n域          含义\nusername   登录名\npassword   加密的用户口令\nuid        用户id\ngid        用户组id\nuserinfo   用户信息\nhome       分配给用户的主目录\nshell      用户登录后将执行的shell（若为空格泽默认为“/bin/sh”）\n\n其中关于用户主目录，每个用户都需要保存专属于自己的配置文件及其他文档，这是以免用户间相互干扰。除root账户外（root账户的主目录为"/root"），大多数linux默认将用户主目录安置在"/home"目录下，并把每个用户的主目录命名为其上机使用的登录名。\n\n\n\n如图，acs的登录主目录为"/home/acs"。通常，“~”被指向当前用户的登录子目录。\n\n注意：用户主目录被安排在“/home”下完全是认为决定的。系统并不关心我们到底把用户主目录安排在什么地方，因为每个用户的位置是在账号文件中定义说明的。所以，用户可以自行调整，灵活使用\n\n关于shell，shell是用户与linux系统之间的接口。linux的shell有许多种，每种都有不同的特点。当用户登录进入系统时，会启动一个shell程序，默认是bash。系统管理员可以根据系统情况和用户习惯为用户指定某个shell。如果不指定shell，那么系统使用bash为默认的登录shell，即这个字段的值为/bin/bash。用户的登录shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。\n\n我们通过查看/etc/passwd文件，可以得到如下完整的系统账号文件。\n\n\n\n我们发现，第二列都为x。我们可以继续往下看。\n\n\n# 2.2 用户影子文件—/etc/shadow\n\n实际上，linxu使用不可逆的加密算法（如md5）来加密口令，由于加密算法是不可逆的，所以黑客从密文是得不到明文的。但/etc/passwd文件时全局可读的，且加密的算法是公开的，如果在passwd中显示密文，黑客据此可以破解口令。linux系统目前广泛采用了“shadow（影子）文件”机制。将加密的口令转移到“/etc/shadow”文件中。/etc/shadow文件只为root超级用户可读，而相应的etc/passwd文件的密文域泽显示为一个x，从而最大限度地减少了密文泄露的机会。x表示该账户需要密码才能登录，为空时，账户无须密码即可登录。\n\n和/etc/passwd类似，/etc/shadow文件中每条记录用冒号“：”分隔，形成9个域，格式如下。\n\nusername:password:lastchg:min:max:warn:inactive:expire:flag\n\n\n1\n\n1\n\n\n域          含义\nusername   用户登陆名\npassword   加密的用户口令\nlastchg    表示从1970年1月1日起到上次修改口令所经过的天数\nmin        表示两次修改口令之间至少经过的天数\nmax        表示口令还会有效的最大天数，如果是99999则表示永不过期\nwarn       表示口令失效前多少天内系统向用户发出警告\ninactive   表示禁止登录前用户名还有效的天数\nexpire     表示用户被禁止登录的时间\nflag       保留域，暂未使用\n\n下图为系统中实际影子文件的例子。\n\n\n\n\n# 2.3 创建用户的默认设置文件—/etc/login.defs\n\n/etc/login.defs 文件用于在创建用户时，对用户的一些基本属性做默认设置，例如指定用户 uid 和 gid 的范围，用户的过期时间，密码的最大长度，等等。\n\n需要注意的是，该文件的用户默认配置对 root 用户无效。并且，当此文件中的配置与 /etc/passwd 和 /etc/shadow 文件中的用户信息有冲突时，系统会以/etc/passwd 和 /etc/shadow 为准。\n\n其中设置项含义如下表所示。\n\n设置项                        含义\nmail_dir /var/spool/mail   创建用户时，系统会在目录 /var/spool/mail 中创建一个用户邮箱，比如 lamp 用户的邮箱是\n                           /var/spool/mail/lamp。\npass_max_days 99999        密码有效期，99999 是自 1970 年 1 月 1 日起密码有效的天数，相当于 273 年，可理解为密码始终有效。\npass_min_days 0            表示自上次修改密码以来，最少隔多少天后用户才能再次修改密码，默认值是 0。\npass_min_len 5             指定密码的最小长度，默认不小于 5 位，但是现在用户登录时验证已经被 pam 模块取代，所以这个选项并不生效。\npass_warn_age 7            指定在密码到期前多少天，系统就开始通过用户密码即将到期，默认为 7 天。\nuid_min 500                指定最小 uid 为 500，也就是说，添加用户时，默认 uid 从 500 开始。注意，如果手工指定了一个用户的\n                           uid 是 550，那么下一个创建的用户的 uid 就会从 551 开始，哪怕 500~549 之间的 uid\n                           没有使用。\nuid_max 60000              指定用户最大的 uid 为 60000。\ngid_min 500                指定最小 gid 为 500，也就是在添加组时，组的 gid 从 500 开始。\ngid_max 60000              用户 gid 最大为 60000。\ncreate_home yes            指定在创建用户时，是否同时创建用户主目录，yes 表示创建，no 则不创建，默认是 yes。\numask 077                  用户主目录的权限默认设置为 077。\nusergroups_enab yes        指定删除用户的时候是否同时删除用户组，准备地说，这里指的是删除用户的初始组，此项的默认值为 yes。\nencrypt_method sha512      指定用户密码采用的加密规则，默认采用 sha512，这是新的密码加密模式，原先的 linux 只能用 des 或 md5\n                           加密。\n\n如果我们想修改默认配置即可修改配置项的值即可。\n\n\n# 2.4 用户组账号文件—/etc/group\n\n我们知道，/etc/passwd文件中包含着每个用户的用户组id（gid），但如果我们需要找一个用户组中的所有用户，通过/etc/passwd难免有些复杂，需要从头到尾寻找同组用户。而/etc/group文件包含关于用户组信息，gid被映射到用户分组的名称及同一分组中的其他成员，这样找同组用户以及配置用户组就方便了许多。/etc/group文件对用户组的许可权限的控制并不是必要的，这是因为linux系统用来自于/etc/passwd文件的uid、gid来决定文件存取权限。即使/etc/group文件不存在于系统中，具有相同的gid用户也能以用户组的许可权限共享文件。\n\n/etc/group文件记录格式如下。\n\ngroup_name:group_password:group_id:group_members\n\n\n1\n\n1\n\n\n其中，各个域的含义如下表。\n\n域                含义\ngroup_name       用户组名\ngroup_password   加密后的用户组口令\ngroup_id         用户组id（gid）\ngroup_members    以逗号分隔的成员用户清单\n\n以下是一个/etc/group文件的实例。\n\n\n\n\n# 2.5 用户组影子文件—/etc/gshadow\n\n和用户账号文件passwd一样，为了应对黑客对其进行的暴力攻击，用户组文件也采用一种将组口令与组的其他信息相分离的安全机制——gshadow。/etc/shadow文件记录格式如下。\n\ngroup_name:group_password:group_members\n\n\n1\n\n1\n\n\n其中，各个域的含义如下表。\n\n域                含义\ngroup_name       用户组名\ngroup_password   加密后的用户组口令\ngroup_members    以逗号分隔的成员用户清单\n\n\n# 3 用户和用户组管理\n\n\n# 3.1 用户管理\n\n# 3.1.1 使用useradd命令添加用户\n\nlinux使用useradd命令添加用户或更新新创建用户的默认信息。其命令格式如下。\n\nuseradd [option] username\n\n\n1\n\n1\n\n\n可使用的选项如下：\n\n * -c comment：描述新用户账号，通常为用户全名。\n * -d home_dir：设置用户主目录。默认值为用户的登录名，并放在"/home"目录下。\n * -g group：指定用户所属的基本组。\n * -g group：指定用户所属的附加组。\n * -u uid：设置用户的id。\n * -s shell类型：设定用户使用的登录shell类型。\n * -k dir：设置框架目录，创建用户时该目录下的文件都被复制到主目录。\n * -e expire_date：设置账号过期时间。\n * -f inactivity：设置口令失效时间。\n * -n：不为用户创建私有用户组。\n * -p password：为新建用户指定登录密码。此处的 password 是对应登录密码经 md5 加密后所得到的密码值，不是真实密码原文，因此在实际应用中，该参数选项使用较少，通常单独使用 passwd 命令来为用户设置登录密码。\n * -r：创建一个用户 id 小于 500 的系统账户，默认不创建对应的主目录。\n * -m：若主目录不存在，则创建它。通常与-r结合，可为系统用户主目录。\n * -m：不创建主目录。\n\n实例1：创建一个普通用户，名为hzf，其中uid为6666，用户主目录指定在/hzf/。\n\nuseradd -u 6666 -d /hzf/ hzf\n\n\n1\n\n1\n\n\n实例2：创建一个系统账户，名为mysystem，其中为系统用户创建主目录，指定密码为12345678\n\n> 首先需要加密密码串，这里使用md5sum工具。\n> \n> 利用md5sum加密字符串的方法\n> \n> # md5sum //然后回车\n> \n> 12345678 //输入12345678，然后按两次ctrl+d。\n> \n> 这个时候就会得到一串密文。\n> \n> 使用以下命令即可创建该系统用户\n> \n> useradd -r -m -p 1234567825d55ad283aa400af464c76d713c07ad mysystem\n> \n> \n> 1\n> \n> 1\n\n查看/etc/passwd即可看到我们创建得用户信息。\n\n\n\n# 3.1.2 使用usermod命令修改用户信息\n\n对于已创建好的用户，可使用 usermod 命令来修改和设置账户的各项属性，包括登录名，主目录，用户组，登录 shell 等，该命令格式如下。\n\nusermod [option] username\n\n\n1\n\n1\n\n\n常用的选项包括-c, -d, -m, -g, -g, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。\n\n另外，有些系统还可以使用-l修改用户名。用法为：usermod -l newusername\n\n使用-l可以锁定用户账号，临时禁止用户登录。用法为：usermod -l username，linux锁定用户，是通过在密码文件 shadow 的密码字段前加 “！” 来标识该用户被锁定。\n\n但如果我们是用root用户登录，再用su命令切换到被锁定的账号是可以进去的。\n\n使用-u可以解锁用户账号。用法为：usermod -u username。\n\n# 3.1.3 使用userdel命令删除用户\n\n要删除用户，可以使用userdel命令删除，命令格式如下。\n\nuserdel [-r] username\n\n\n1\n\n1\n\n\n其中-r参数可选，若带上参数，表示在删除账户的同时，一并删除用户的主目录。\n\n# 3.1.4 使用passwd命令管理用户口令\n\n用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。\n\n指定和修改用户口令的shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式如下。\n\npasswd [option] username\n\n\n1\n\n1\n\n\n可使用的选项如下：\n\n * -l：锁定口令，即禁用账号。\n * -u：口令解锁。\n * -d：使账号无口令。这样，下次登录的时候，系统就不再允许该用户登录了。\n * -f：强迫用户下次登陆时修改口令。\n\n如果不指定用户名，则表示修改自己的口令。\n\n\n# 3.2 用户组管理\n\n# 3.2.1 使用groupadd命令创建用户组\n\n增加一个新的用户组使用groupadd命令。命令格式如下。\n\ngroupadd [option] groupname\n\n\n1\n\n1\n\n\n可使用的选项如下：\n\n * -r：表示创建系统用户组，该类用户组的 gid 值小于 500；若没有 - r 参数，则创建普通用户组，其 gid 值大于或等于 500。\n * -g gid：指定新用户组的标识号gid。\n * -o：一般与-g选项同时使用，表示新用户组的gid可以与系统已有用户组的gid相同。\n\n如果没有指定选择参数，新组的组标识号是在当前已有的最大组标识号的基础上加1。\n\n# 3.2.2 使用groupmod修改\n\n修改用户组的属性使用groupmod命令。命令格式如下。\n\ngroupmod [option] groupname\n\n\n1\n\n1\n\n\n可使用的选项如下：\n\n * -g gid：为用户组指定新的组标识号。\n * -o：与-g选项同时使用，用户组的新gid可以与系统已有用户组的gid相同。\n * -n newgroupname： 将用户组的名字改为新名字\n\n# 3.2.3 使用groupdel命令删除用户组\n\n使用groupdel命令可以删除用户组。命令格式如下。\n\ngroupdel groupname\n\n\n1\n\n1\n\n\n在删除用户组时，被删除的用户组不能是某个账户的私有用户组，否则将无法删除，若要删除，则应先删除引用该私有用户组的账户，然后再删除用户组。\n\n# 3.2.4 使用gpasswd命令管理用户组\n\n为了避免系统管理员（root）太忙碌，无法及时管理群组，我们可以使用 gpasswd 命令给群组设置一个群组管理员，代替 root 完成将用户加入或移出群组的操作。gpasswd命令格式如下。\n\ngpasswd [option] groupname\n\n\n1\n\n1\n\n\n可选择的选项如下：\n\n选项             功能\n               选项为空时，表示给群组设置密码，仅 root 用户可用。\n-a user1,...   将群组的控制权交给 user1,... 等用户管理，也就是说，设置 user1,... 等用户为群组的管理员，仅\n               root 用户可用。\n-m user1,...   将 user1,... 加入到此群组中，仅 root 用户可用。\n-r             移除群组的密码，仅 root 用户可用。\n-r             让群组的密码失效，仅 root 用户可用。\n-a user        将 user 用户加入到群组中。\n-d user        将 user 用户从群组中移除。\n\n实例如下。\n\n\n\n# 3.2.5 使用newgrp命令切换用户的有效组\n\n我们知道，每个用户可以属于一个初始组（用户是这个组的初始用户），也可以属于多个附加组（用户是这个组的附加用户）。既然用户可以属于这么多用户组，那么用户在创建文件后，默认生效的组身份是哪个呢？\n\n当然是初始用户组的组身份生效，因为初始组是用户一旦登陆就获得的组身份。也就是说，用户的有效组默认是初始组，因此所创建文件的属组是用户的初始组。那么，既然用户属于多个用户组，能不能改变用户的初始组呢？使用命令 newgrp 就可以。此命令基本格式如下。\n\nnewgrp groupname\n\n\n1\n\n1\n\n\nnewgrp 命令可以从用户的附加组中选择一个群组，作为用户新的初始组。\n\n\n# 4 其他相关命令\n\n\n# 4.1 id命令查看用户的uid和gid\n\nid 命令可以查询用户的uid、gid 和附加组的信息。命令比较简单，格式如下。\n\nid username\n\n\n1\n\n1\n\n\n实例如下：\n\n\n\n\n# 4.2 su命令临时切换用户身份\n\nsu 是最简单的用户切换命令，通过该命令可以实现任何身份的切换，包括从普通用户切换为 root 用户、从 root 用户切换为普通用户以及普通用户之间的切换。\n\n普通用户之间切换以及普通用户切换至 root 用户，都需要知晓对方的密码，只有正确输入密码，才能实现切换；从 root 用户切换至其他用户，无需知晓对方密码，直接可切换成功。\n\nsu命令格式如下。\n\nsu [option] username\n\n\n1\n\n1\n\n\n可使用的选项如下：\n\n * -l或-：带这个参数就好像是重新 login 为该使用者一样，大部份环境参数都是以该使用者为主，并且工作目录也会改变，如果没有指定 user ，内定是 root。\n * -c <command> ：仅切换用户执行一次命令，执行后自动切换回来，该选项后通常会带有要执行的命令。\n * -s <shell>： 指定要执行的 shell （bash csh tcsh 等），预设值为 /etc/passwd 内的该使用者shell\n * -h：显示说明文件。\n * -v：显示版本资讯。\n * -m或-p：执行su时不改变工作环境。\n\n\n\n\n# 4.3 whoami和who am i命令\n\nwhoami 命令和 who am i 命令是不同的 2 个命令，前者用来打印当前执行操作的用户名，后者则用来打印登陆当前 linux 系统的用户名。\n\n我们可以看一下操作实例来感受区别：\n\n\n\n在未切换用户身份之前，whoami 和 who am i 命令的输出是一样的，但使用 su 命令切换用户身份后，使用 whoami 命令打印的是切换后的用户名，而 who am i 命令打印的仍旧是登陆系统时所用的用户名。\n\n\n# 4.4 users和groups命令\n\nusers命令格式如下。\n\nusers [option]\n\n\n1\n\n1\n\n * 如果没有参数，则显示当前登录系统的所有用户的用户列表。每个显示的用户名对应一个登录会话。如果一个用户有不止一个登录会话，那他的用户名将显示相同的次数。\n * --help：显示命令的帮助信息。\n * --version：显示命令的版本信息。\n\ngroups命令格式如下。\n\ngroups [option] [groupname]\n\n\n1\n\n1\n\n * 如果没有参数，查看当前登录用户的组内成员。如果指定了groupname，则显示该group的成员。\n * --help：显示命令的帮助信息。\n * --version：显示命令的版本信息。\n\n\n# 5 高级操作示例\n\n\n# 5.1 通过更改用户和组的配置文件，直接添加或修改用户和组\n\n为了更深入了解用户和组的相关配置文件，可以手动更改配置文件以达到命令的执行效果。\n\n首先我们需要了解linux中的/etc/skel目录。skel是skeleton的缩写，意为骨骼、框架。故此目录的作用是在建立新用户时，用于初始化用户根目录。系统会将此目录下的所有文件、目录都复制到新建用户的主目录，并且将用户属主与用户组调整为与此主目录相同。所以可将用户配置文件预置到/etc/skel目录下，比如说.bashrc、.profile与.vimrc等。\n\n注意：\n\n * 如果在新建用户时，没有自动建立用户根目录，则无法调用到此框架目录。\n * 如果不想以默认的/etc/skel目录作为框架目录，可以在运行useradd命令时使用-k指定新的框架目录。\n * 如果不想在每次新建用户时，都重新指定新的框架目录，可以通过修改/etc/default/useradd配置文件来改变默认的框架目录。修改skel变量的值即可。原来为skel=/etc/skel。\n\n实际操作步骤如下：\n\n 1. 编辑/etc/group文件，添加组test，其中gid为1500。\n    \n    echo \'test:x:1500\' >> /etc/group\n\n 2. 创建用户的主目录。\n    \n    我们需要将框架目录中的文件放到主目录中。同时还需要修改好主目录对其他用户都没有任何访问权限。\n    \n    \n\n 3. 编辑/etc/passwd文件，添加用户test，uid为1500，其中基本组id为test组的gid，其家目录为/home/test。\n    \n    echo \'test:x:1500:1500::/home/test:/bin/bash\' >> /etc/passwd\n\n 4. 修改/home/test目录及其内部所有文件的属主为test，属组为test。\n    \n    \n\n 5. 修改test用户的密码并尝试登录。\n    \n    \n\n\n# 5.2 linux批量添加用户\n\n我们可以使用useradd+passwd命令配合shell脚本来实现该功能。\n\n首先我们将需要创建的用户名写入一个文本文件，其中每行代表一个用户名：\n\n\n\n然后实际上我们的思路就是提取出文件中的用户名然后自动执行useradd命令，再执行passwd自动填入初始密码。编写的shell脚本文件如下：\n\n#! /bin/bash\n\nfor username in $(more username.txt)\ndo\nif [ -n $username ]\nthen\n        useradd -m $username # 执行useradd命令\n        echo $username"123456" | passwd --stdin $username\n        echo "user $username\'s password is changed!"\nelse\n        echo "the username is null!"\nfi\ndone\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n测试登录，登录成功！\n\n',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"进程API",frontmatter:{title:"进程API",tags:["OS"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},date:"2024-04-25T22:29:38.000Z",permalink:"/pages/1d4493/",categories:["开发","系统架构","操作系统","虚拟化"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/02.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02.%E8%BF%9B%E7%A8%8BAPI.html",relativePath:"01.开发/05.系统架构/02.操作系统/02.进程API.md",key:"v-78dda423",path:"/pages/1d4493/",headersStr:null,content:"github代码\n\n 1. 编写一个调用 fork() 的程序。在调用 fork() 之前，让主进程访问一个变量（如 x）并将其值设为某个值（如 100）。子进程中的变量值是多少？当子进程和父进程都改变 x 的值时，变量会发生什么变化？\n    \n    > 调用fork会创建一个与父进程几乎完全一样的副本，且会复制当前执行的上下文，所以子进程中的变量值是100，它们改变x的值都是互不影响的。执行python q1.py可得到结果如下：\n    \n     Parent process - x: 100\n     Parent process - x after modification: 150\n     Child process - x: 100\n     Child process - x after modification: 50\n    \n    \n    1\n    2\n    3\n    4\n    \n    1\n    2\n    3\n    4\n    \n 2. 编写一个程序，打开一个文件（使用 open() 系统调用），然后调用 fork() 创建一个新进程。子进程和父进程都能访问 open() 返回的文件描述符吗？当它们同时（即同时）向文件写入时会发生什么情况？\n    \n    > 父进程的文件描述符也会继承，所以子进程也可以往 test.txt写入消息，虽然父进程和子进程的文件描述符是相同的，但是它们各自的文件描述符指向的是相同文件的不同偏移位置。在写入文件时，操作系统会维护两个进程的文件偏移，确保它们互不干扰。执行python q2.py可验证。\n\n 3. 使用fork()编写另一个程序。子进程应打印“hello”，父进程应打印“goodbye”。您应尽量确保子进程始终先打印；您能在不在父进程中调用wait()的情况下实现吗？\n    \n    > 如果不使用wait，则可以使用time.sleep()通过短暂的休眠来实现。执行python q3.py可验证结果。\n\n 4. 编写一个调用fork()然后调用某种形式的exec()来运行程序/bin/ls的程序。看看你能否尝试所有的exec()变体，包括（在Linux上）execl()、execle()、execlp()、execv()、execvp()和execvpe(). 为什么你认为同一基本调用有这么多变体？ q4.py尝试了所有的变体。这些变体的存在主要是为了提供不同的参数传递方式和环境设置，以满足不同的编程需求和场景。具体如下：\n    1. execl()和execlp()：\n       * execl()接受一个可变数量的参数，用于指定执行文件的路径以及命令行参数，参数列表以NULL结尾。\n       * execlp()函数接受与execl()相同的参数列表，但它还会在系统的PATH环境变量中搜索可执行文件。\n    2. execv()和execvp()：\n       * execv()接受两个参数，第一个参数是要执行的文件的路径，第二个参数是一个字符串数组，表示命令行参数，数组的第一个元素通常是执行文件的名称。\n       * execvp()函数与execv()类似，但它会在系统的PATH环境变量中搜索可执行文件。\n    3. execle()和execvpe()：\n       * execle()函数允许指定新程序的环境变量，它接受一个额外的参数environ，用于传递环境变量数组。\n       * execvpe()函数允许指定新程序的环境变量，并且会在系统的PATH环境变量中搜索可执行文件。\n 5. 现在编写一个程序，在父进程中使用wait()等待子进程完成。wait()返回什么？如果在子进程中使用wait()会发生什么？\n    \n    > wait()返回的状态信息通常是一个16位的整数，其中高8位存储了子进程的退出状态码，低8位存储了终止信号的编号（如果子进程是由信号终止的话）。如果在子进程中调用wait()函数，由于子进程没有子进程，wait()函数会立即返回-1，并设置 errno 为 ECHILD。实验见q5.py\n\n 6. 对之前的程序稍作修改，这次使用 waitpid() 而不是 wait()。 waitpid() 什么时候有用？\n    \n    > 当您想要等待特定子进程完成而不是像 wait() 那样等待任何子进程完成时，waitpid() 非常有用。它允许您指定您有兴趣等待的子进程的 PID。这在父进程生成多个子进程并需要单独处理它们的情况下非常有用。\n\n 7. 编写一个程序，创建一个子进程，然后在子进程中关闭标准输出（STDOUT FILENO）。如果子进程在关闭描述符后调用 printf() 来打印一些输出，会发生什么？\n    \n    > 如果我们关闭 stdout 文件描述符，我们将无法使用 printf() 在屏幕上写入内容。但不会发生任何错误。\n\n 8. 编写一个程序，创建两个子进程，并使用pipe()系统调用将一个子进程的标准输出连接到另一个子进程的标准输入。\n    \n    > 我们使用 pipe() 系统调用创建一个管道，如果不成功则退出。我们通过 fork() 调用创建第一个子进程（我们称之为 A），然后，在为父进程运行的代码部分中，我们进行第二个 fork() 调用来创建第二个子进程（我们称之为 B）。 A 使用 dup2 使 stdout 指向管道的写入端，并向管道的写入端传递一个字符串。B使用dup2使stdin指向管道的读取端，并从管道的读取端读取。这将 A 的标准输出连接到 B 的标准输入。",normalizedContent:"github代码\n\n 1. 编写一个调用 fork() 的程序。在调用 fork() 之前，让主进程访问一个变量（如 x）并将其值设为某个值（如 100）。子进程中的变量值是多少？当子进程和父进程都改变 x 的值时，变量会发生什么变化？\n    \n    > 调用fork会创建一个与父进程几乎完全一样的副本，且会复制当前执行的上下文，所以子进程中的变量值是100，它们改变x的值都是互不影响的。执行python q1.py可得到结果如下：\n    \n     parent process - x: 100\n     parent process - x after modification: 150\n     child process - x: 100\n     child process - x after modification: 50\n    \n    \n    1\n    2\n    3\n    4\n    \n    1\n    2\n    3\n    4\n    \n 2. 编写一个程序，打开一个文件（使用 open() 系统调用），然后调用 fork() 创建一个新进程。子进程和父进程都能访问 open() 返回的文件描述符吗？当它们同时（即同时）向文件写入时会发生什么情况？\n    \n    > 父进程的文件描述符也会继承，所以子进程也可以往 test.txt写入消息，虽然父进程和子进程的文件描述符是相同的，但是它们各自的文件描述符指向的是相同文件的不同偏移位置。在写入文件时，操作系统会维护两个进程的文件偏移，确保它们互不干扰。执行python q2.py可验证。\n\n 3. 使用fork()编写另一个程序。子进程应打印“hello”，父进程应打印“goodbye”。您应尽量确保子进程始终先打印；您能在不在父进程中调用wait()的情况下实现吗？\n    \n    > 如果不使用wait，则可以使用time.sleep()通过短暂的休眠来实现。执行python q3.py可验证结果。\n\n 4. 编写一个调用fork()然后调用某种形式的exec()来运行程序/bin/ls的程序。看看你能否尝试所有的exec()变体，包括（在linux上）execl()、execle()、execlp()、execv()、execvp()和execvpe(). 为什么你认为同一基本调用有这么多变体？ q4.py尝试了所有的变体。这些变体的存在主要是为了提供不同的参数传递方式和环境设置，以满足不同的编程需求和场景。具体如下：\n    1. execl()和execlp()：\n       * execl()接受一个可变数量的参数，用于指定执行文件的路径以及命令行参数，参数列表以null结尾。\n       * execlp()函数接受与execl()相同的参数列表，但它还会在系统的path环境变量中搜索可执行文件。\n    2. execv()和execvp()：\n       * execv()接受两个参数，第一个参数是要执行的文件的路径，第二个参数是一个字符串数组，表示命令行参数，数组的第一个元素通常是执行文件的名称。\n       * execvp()函数与execv()类似，但它会在系统的path环境变量中搜索可执行文件。\n    3. execle()和execvpe()：\n       * execle()函数允许指定新程序的环境变量，它接受一个额外的参数environ，用于传递环境变量数组。\n       * execvpe()函数允许指定新程序的环境变量，并且会在系统的path环境变量中搜索可执行文件。\n 5. 现在编写一个程序，在父进程中使用wait()等待子进程完成。wait()返回什么？如果在子进程中使用wait()会发生什么？\n    \n    > wait()返回的状态信息通常是一个16位的整数，其中高8位存储了子进程的退出状态码，低8位存储了终止信号的编号（如果子进程是由信号终止的话）。如果在子进程中调用wait()函数，由于子进程没有子进程，wait()函数会立即返回-1，并设置 errno 为 echild。实验见q5.py\n\n 6. 对之前的程序稍作修改，这次使用 waitpid() 而不是 wait()。 waitpid() 什么时候有用？\n    \n    > 当您想要等待特定子进程完成而不是像 wait() 那样等待任何子进程完成时，waitpid() 非常有用。它允许您指定您有兴趣等待的子进程的 pid。这在父进程生成多个子进程并需要单独处理它们的情况下非常有用。\n\n 7. 编写一个程序，创建一个子进程，然后在子进程中关闭标准输出（stdout fileno）。如果子进程在关闭描述符后调用 printf() 来打印一些输出，会发生什么？\n    \n    > 如果我们关闭 stdout 文件描述符，我们将无法使用 printf() 在屏幕上写入内容。但不会发生任何错误。\n\n 8. 编写一个程序，创建两个子进程，并使用pipe()系统调用将一个子进程的标准输出连接到另一个子进程的标准输入。\n    \n    > 我们使用 pipe() 系统调用创建一个管道，如果不成功则退出。我们通过 fork() 调用创建第一个子进程（我们称之为 a），然后，在为父进程运行的代码部分中，我们进行第二个 fork() 调用来创建第二个子进程（我们称之为 b）。 a 使用 dup2 使 stdout 指向管道的写入端，并向管道的写入端传递一个字符串。b使用dup2使stdin指向管道的读取端，并从管道的读取端读取。这将 a 的标准输出连接到 b 的标准输入。",charsets:{cjk:!0},lastUpdated:"2024/05/11, 20:33:38",lastUpdatedTimestamp:1715430818e3},{title:"多级反馈队列",frontmatter:{title:"多级反馈队列",tags:["OS"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},date:"2024-04-25T22:33:29.000Z",permalink:"/pages/a1ad96/",categories:["开发","系统架构","操作系统","虚拟化"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/02.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/05.%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97.html",relativePath:"01.开发/05.系统架构/02.操作系统/05.多级反馈队列.md",key:"v-1bc85996",path:"/pages/a1ad96/",headers:[{level:2,title:"1 Note/Translation",slug:"_1-note-translation",normalizedTitle:"1 note/translation",charIndex:13},{level:2,title:"2 Program Explanation",slug:"_2-program-explanation",normalizedTitle:"2 program explanation",charIndex:8394},{level:2,title:"3 QA",slug:"_3-qa",normalizedTitle:"3 qa",charIndex:14983}],headersStr:"1 Note/Translation 2 Program Explanation 3 QA",content:'github地址\n\n\n# 1 Note/Translation\n\n * 基本规则\n   \n   MLFQ有许多不同的队列，每个队列分配了不同的优先级。在任何给定时间，准备运行的作业都位于单个队列上。 MLFQ 使用优先级来决定在给定时间应运行哪个作业：选择运行具有较高优先级的作业（即较高队列上的作业）。当然，一个队列上可能有多个作业，即具有相同的优先级，这种情况则对这些工作使用RR调度。则MLFQ基本规则如下：\n   \n   * Rule 1:If Priority(A)>Priority(B),A runs (B doesn’t).\\text{Rule}\\space1:\\text{If Priority(A)>Priority(B),A runs (B doesn\'t).}Rule 1:If Priority(A)>Priority(B),A runs (B doesn’t).\n   * Rule 1:If Priority(A)=Priority(B),A and B run in RR.\\text{Rule}\\space1:\\text{If Priority(A)=Priority(B),A and B run in RR.}Rule 1:If Priority(A)=Priority(B),A and B run in RR.\n\n * MLFQ例子\n   \n   如果我们要展示给定时刻队列的样子，我们可能会看到如下所示的内容（图 8.1）。图中，两个作业（A 和 B）的优先级最高，作业 C 处于中间，作业 D 的优先级最低。鉴于我们目前对 MLFQ 工作原理的了解，调度程序只会在 A 和 B 之间交替时间片，因为它们是系统中优先级最高的作业；可怜的工作 C 和 D 根本无法运行！\n\n * 尝试#1：怎么改变作业的优先级\n   \n   现在，我们必须决定 MLFQ 将如何在作业的生命周期内更改作业的优先级（以及它所在的队列）。为此，我们必须牢记我们的工作负载：短期运行的交互式作业（可能经常放弃 CPU），以及一些需要大量 CPU 时间但运行时间较长的“CPU 密集型”作业。其中响应时间并不重要。这是我们对优先级调整算法的第一次尝试：\n   \n   * Rule 3: When a job enters the system, it is placed at the highest priority (the topmost queue).\\text{Rule 3: When a job enters the system, it is placed at the highest priority (the topmost queue).}Rule 3: When a job enters the system, it is placed at the highest priority (the topmost queue).\n   * Rule 4a: If a job uses up an entire time slice while running, its pri- ority is reduced (i.e., it moves down one queue).\\text{Rule 4a: If a job uses up an entire time slice while running, its pri- ority is reduced (i.e., it moves down one queue).}Rule 4a: If a job uses up an entire time slice while running, its pri- ority is reduced (i.e., it moves down one queue).\n   * Rule 4b: If a job gives up the CPU before the time slice is up, it stays at the same priority level.\\text{Rule 4b: If a job gives up the CPU before the time slice is up, it stays at the same priority level.}Rule 4b: If a job gives up the CPU before the time slice is up, it stays at the same priority level.\n\n * 例子#1.1：单个长时间运行的作业\n   \n   首先，我们来看看当系统中有一项长期运行的工作时会发生什么情况。下图显示了在三队列调度程序中该作业随时间发生的变化。\n   \n   如示例所示，作业以最高优先级（Q2）进入。经过 10ms\\text{10ms}10ms 的单个时间片后，调度程序将作业的优先级降低了一个，因此作业的优先级为 Q1。在 Q1 上运行一个时间片后，作业最终被降到系统中的最低优先级（Q0），并保持不变。\n\n * 例子#1.2：加入一个短作业\n   \n   在这个例子中，有两个作业：A是一个长期运行的CPU密集型作业，B是一个短期运行的交互作业。假设A已经运行了一段时间，然后B才到达，这样会发生什么？MLFQ是否会近似于B的SJF？\n   \n   如下图所示，A（黑色显示）在最低优先级队列中运行（任何长期运行的 CPU 密集型作业都是如此）；B（灰色显示）在 T = 100 时到达，因此会插入到最高队列，由于其运行时间很短（仅20ms），B 在到达底层队列之前完成，分两个时间片；然后 A 恢复运行（低优先级）。\n   \n   从这个例子中，你有望理解算法的一个主要目标：因为它不知道一项作业是短作业还是长期作业，所以它首先假定它可能是短作业，从而给予该作业高优先级。如果它确实是短作业，它就会快速运行并完成；如果它不是短作业，它就会在队列中缓慢移动，从而很快证明自己是一个长期运行的更类似批处理的进程。通过这种方式，MLFQ 近似于 SJF。\n\n * 例子#1.3：关于I/O\n   \n   如上文规则 4b 所述，如果进程在用完其时间片之前放弃了处理器，我们会将其保持在相同的优先级。这条规则的用意很简单：例如，如果一个交互式作业正在进行大量的 I/O（比如等待键盘或鼠标的用户输入），那么它就会在其时间片完成之前放弃 CPU；在这种情况下，我们不希望惩罚该作业，因此只需将其保持在同一优先级即可。\n   \n   下图举例说明了这种方法的工作原理，交互式作业 B（灰色显示）只需要 CPU 1 ms，然后执行 I/O，与长期运行的批处理作业 A（黑色显示）争夺 CPU。MLFQ 方法将 B 保持在最高优先级，因为 B 一直在释放 CPU；如果 B 是交互式作业，MLFQ 将进一步实现快速运行交互式作业的目标。\n   \n   \n\n * 我们现在设计的MLFQ存在的问题\n   \n   这样，我们就有了一个基本的 MLFQ。它似乎做得相当不错，在长时间运行的作业之间公平地共享 CPU，并让短时间或 I/O 密集型交互式作业快速运行。遗憾的是，我们迄今为止开发的方法存在严重缺陷。\n   \n   1. 饥饿问题：如果系统存在太多交互作业，它们将会共同消耗所有CPU时间，这样长时间运行的作业将不会获得任何CPU时间（即饥饿）。\n   2. 欺骗调度程序：聪明的用户可以重写程序，玩弄调度程序。即是指偷偷摸摸地欺骗调度程序，让调度程序给你分配更多的资源。我们所描述的算法很容易受到以下攻击：在时间片结束前，进行一次 I/O 操作（对某个你并不关心的文件），从而放弃 CPU；这样做可以让你保持在同一队列中，从而获得更多的 CPU 时间。如果操作得当（例如，运行 99% 的时间片后才放弃 CPU），作业几乎可以垄断 CPU。\n   3. 程序行为改变：一个程序可能会随着时间的推移而改变其行为；原来的 CPU 约束可能会过渡到交互阶段。采用我们目前的方法，这样的作业就会倒霉，不会像系统中的其他交互式作业一样得到处理。\n\n * 尝试#2：优先级提升\n   \n   让我们试着改变规则，看看能否避免 "饥饿 "问题。为了保证占用 CPU 的作业能取得一些进展（即使进展不大），我们可以做些什么？简单来说，就是定期提升系统中所有作业的优先级。实现这一点的方法有很多，但我们只需做一件简单的事：把所有作业都扔到最上面的队列中；因此，我们需要一条新规则：\n   \n   * Rule 5: After some time period S, move all the jobs in the system to the topmost queue.\\text{Rule 5: After some time period S, move all the jobs in the system to the topmost queue.}Rule 5: After some time period S, move all the jobs in the system to the topmost queue.\n   \n   我们的新规则同时解决了两个问题。首先，保证了进程不会饥饿：作业排在队列的最前面，就能与其他高优先级作业以循环方式共享 CPU，从而最终获得服务。其次，如果受 CPU 限制的作业已开始交互，调度程序会在其获得优先级提升后对其进行适当处理。\n\n * 例子#2.1：竞争CPU\n   \n   在这种情况下，我们仅展示一个长时间运行的作业与两个短时间运行的交互式作业竞争 CPU 时的行为。下图显示了两个图表。在左边，没有优先级提升，因此一旦两个短期作业到达，长期运行的作业就会陷入饥饿；右边，每 50 毫秒就有一次优先级提升（这个值可能太小，但这里用于示例），因此我们至少保证长时间运行的作业会取得一些进展，提升到每 50 毫秒设置一次最高优先级，从而定期运行。\n   \n   当然，增加时间段S会带来一个明显的问题：S应该设置为什么？ John Ousterhout，一位受人尊敬的系统研究员 ，过去常常将系统中的此类值称为“巫术常量”，因为它们似乎需要某种形式的黑魔法才能正确设置它们。不幸的是，S有那种味道。如果设置得太高，长时间运行的作业可能会陷入困境；太低，交互式作业可能无法获得适当的 CPU 份额。\n\n * 尝试#3：更好的计算\n   \n   现在，我们还有一个问题要解决：如何防止调度程序被玩弄？正如你可能已经猜到的，真正的罪魁祸首是Rule 4a 和 4b，它们允许作业在时间片到期前放弃 CPU，从而保留其优先级。那么我们该怎么办呢？解决办法是在 MLFQ 的每一级更好地计算 CPU 时间。调度程序不应该忘记进程在特定级别上使用了多少时间片，而应该进行跟踪；一旦进程用完了分配的时间片，就会被降级到下一个优先级队列。至于进程是在一个长的时间段内使用时间片，还是在许多小的时间段内使用时间片，这并不重要。因此，我们将规则 4a 和 4b 重写为以下单一规则：\n   \n   * Rule 4: Once a job uses up its time allotment at a given level (re- gardless of how many times it has given up the CPU), its priority is reduced (i.e., it moves down one queue).\\text{Rule 4: Once a job uses up its time allotment at a given level (re- gardless of how many times it has given up the CPU), its priority is reduced (i.e., it moves down one queue).}Rule 4: Once a job uses up its time allotment at a given level (re- gardless of how many times it has given up the CPU), its priority is reduced (i.e., it moves down one queue).\n\n * 例子#3.1：旧规则和新规则对比\n   \n   下图显示了当工作负载试图利用旧规则 4a 和 4b（左侧）以及新的反玩弄规则 4 来玩弄调度程序时会发生的情况。如果没有任何防止玩弄的保护措施，进程可以在时间片结束前发出 I/O，从而支配 CPU 时间。有了这种保护措施，无论进程的 I/O 行为如何，它都会在队列中缓慢移动，从而无法获得不公平的 CPU 占有率。\n   \n   \n\n * 调整 MLFQ 及其他问题\n   \n   MLFQ 调度还存在其他一些问题。一个大问题是如何为这样的调度器设置参数。例如，应该有多少个队列？每个队列的时间片应该有多大？为了避免饥饿并考虑到行为的变化，应该多久提升一次优先级？这些问题都没有简单的答案，因此只有在工作负载方面积累一定的经验，然后对调度程序进行调整，才能取得令人满意的平衡。\n   \n   例如，大多数 MLFQ 变体都允许在不同队列中使用不同的时间片长度。高优先级队列的时间片通常较短；毕竟它们由交互式作业组成，因此在它们之间快速交替是合理的（例如 10 毫秒或更少）。相比之下，低优先级队列包含的是占用 CPU 的长期运行作业；因此，较长的时间片（如 100 毫秒）也很有效。下图显示了一个例子，其中两个作业在最高队列运行 20 毫秒（时间片为 10 毫秒），在中间队列运行 40 毫秒（时间片为 20 毫秒），在最低队列运行 40 毫秒。\n   \n   Solaris MLFQ 实现——分时调度类（TS）——特别容易配置；它提供了一组表，可以准确确定进程的优先级在其整个生命周期中如何更改、每个时间片的长度以及提高作业优先级的频率；管理员可以修改该表以使调度程序以不同的方式运行。该表的默认值为 60 个队列，时间片长度从 20 毫秒（最高优先级）缓慢增加到几百毫秒（最低），并且优先级大约每 1 秒左右提升一次。\n   \n   其他 MLFQ 调度器并不使用本章所述的表格或精确规则，而是使用数学公式来调整优先级。例如，FreeBSD 调度器（4.3 版）使用一个公式来计算作业当前的优先级，该公式基于进程使用了多少 CPU ；此外，使用率会随着时间的推移而衰减，从而以与本文所述不同的方式提供所需的优先级提升。最后，许多调度器还有一些你可能会遇到的其他功能。例如，有些调度器为操作系统工作保留最高优先级；因此，典型的用户作业永远无法获得系统中的最高优先级。有些系统还允许用户通过一些建议来帮助设置优先级；例如，通过使用命令行实用程序 nice，你可以（在一定程度上）提高或降低作业的优先级，从而增加或减少它在任何特定时间运行的机会。\n\n * MLFQ总结\n   \n   我们已经描述了多级反馈队列（MLFQ）的调度方法。希望你现在能明白它为什么叫这个名字：它有多级队列，并使用反馈来确定给定作业的优先级。历史是它的指南：关注作业在一段时间内的表现，并相应地处理它们。在本章中，MLFQ 规则的精炼集在此重现，供大家欣赏：\n   \n   * Rule 1: If Priority(A) > Priority(B), A runs (B doesn’t).\\text{Rule 1: If Priority(A) > Priority(B), A runs (B doesn’t).}Rule 1: If Priority(A) > Priority(B), A runs (B doesn’t).\n   * Rule 2: If Priority(A) = Priority(B), A and B run in round-robin fash- ion using the time slice (quantum length) of the given queue.\\text{Rule 2: If Priority(A) = Priority(B), A and B run in round-robin fash- ion using the time slice (quantum length) of the given queue.}Rule 2: If Priority(A) = Priority(B), A and B run in round-robin fash- ion using the time slice (quantum length) of the given queue.\n   * Rule 3: When a job enters the system, it is placed at the highest priority (the topmost queue).\\text{Rule 3: When a job enters the system, it is placed at the highest priority (the topmost queue).}Rule 3: When a job enters the system, it is placed at the highest priority (the topmost queue).\n   * Rule 4: Once a job uses up its time allotment at a given level (re- gardless of how many times it has given up the CPU), its priority is reduced (i.e., it moves down one queue).\\text{Rule 4: Once a job uses up its time allotment at a given level (re- gardless of how many times it has given up the CPU), its priority is reduced (i.e., it moves down one queue).}Rule 4: Once a job uses up its time allotment at a given level (re- gardless of how many times it has given up the CPU), its priority is reduced (i.e., it moves down one queue).\n   * Rule 5: After some time period S, move all the jobs in the system to the topmost queue.\\text{Rule 5: After some time period S, move all the jobs in the system to the topmost queue.}Rule 5: After some time period S, move all the jobs in the system to the topmost queue.\n   \n   MLFQ 很有趣，原因如下：它不要求先验了解作业的性质，而是观察作业的执行情况并相应地确定其优先级。通过这种方式，它成功地实现了两全其美：它可以为短时间运行的交互式作业提供出色的整体性能（类似于 SJF/STCF），并且对于长时间运行的 CPU 密集型工作负载来说，它是公平的并取得进步。因此，许多系统，包括 BSD UNIX 衍生系统 、Solaris 以及 Windows NT 和后续的 Windows 操作系统，都使用某种形式的 MLFQ 作为其基本调度程序。\n\n\n# 2 Program Explanation\n\n这个程序 mlfq.py 允许您查看本章中介绍的 MLFQ 调度程序的行为方式。和以前一样，您可以使用它来使用随机种子为自己生成问题，或者使用它构建一个精心设计的实验，以了解 MLFQ 在不同情况下的工作原理。要运行该程序，请键入：\n\n❯ python mlfq.py\n\n\n1\n\n1\n\n\n使用参数-h查看选项帮助：\n\n❯ python mlfq.py -h\nUsage: mlfq.py [options]\n\nOptions:\n  -h, --help            show this help message and exit\n  -s SEED, --seed=SEED  the random seed\n  -n NUMQUEUES, --numQueues=NUMQUEUES\n                        number of queues in MLFQ (if not using -Q)\n  -q QUANTUM, --quantum=QUANTUM\n                        length of time slice (if not using -Q)\n  -a ALLOTMENT, --allotment=ALLOTMENT\n                        length of allotment (if not using -A)\n  -Q QUANTUMLIST, --quantumList=QUANTUMLIST\n                        length of time slice per queue level, specified as\n                        x,y,z,... where x is the quantum length for the\n                        highest priority queue, y the next highest, and so\n                        forth\n  -A ALLOTMENTLIST, --allotmentList=ALLOTMENTLIST\n                        length of time allotment per queue level, specified as\n                        x,y,z,... where x is the # of time slices for the\n                        highest priority queue, y the next highest, and so\n                        forth\n  -j NUMJOBS, --numJobs=NUMJOBS\n                        number of jobs in the system\n  -m MAXLEN, --maxlen=MAXLEN\n                        max run-time of a job (if randomly generating)\n  -M MAXIO, --maxio=MAXIO\n                        max I/O frequency of a job (if randomly generating)\n  -B BOOST, --boost=BOOST\n                        how often to boost the priority of all jobs back to\n                        high priority\n  -i IOTIME, --iotime=IOTIME\n                        how long an I/O should last (fixed constant)\n  -S, --stay            reset and stay at same priority level when issuing I/O\n  -I, --iobump          if specified, jobs that finished I/O move immediately\n                        to front of current queue\n  -l JLIST, --jlist=JLIST\n                        a comma-separated list of jobs to run, in the form\n                        x1,y1,z1:x2,y2,z2:... where x is start time, y is run\n                        time, and z is how often the job issues an I/O request\n  -c                    compute answers for me\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n使用模拟器有几种不同的方法，一种方法是生成一些随机作业，然后看看您是否可以弄清楚它们在给定 MLFQ 调度程序的情况下将如何表现。例如，如果您想创建随机生成的三作业工作负载，您只需运行\n\n❯ python mlfq.py -j 3\nHere is the list of inputs:\nOPTIONS jobs 3\nOPTIONS queues 3\nOPTIONS allotments for queue  2 is   1\nOPTIONS quantum length for queue  2 is  10\nOPTIONS allotments for queue  1 is   1\nOPTIONS quantum length for queue  1 is  10\nOPTIONS allotments for queue  0 is   1\nOPTIONS quantum length for queue  0 is  10\nOPTIONS boost 0\nOPTIONS ioTime 5\nOPTIONS stayAfterIO False\nOPTIONS iobump False\n\n\nFor each job, three defining characteristics are given:\n  startTime : at what time does the job enter the system\n  runTime   : the total CPU time needed by the job to finish\n  ioFreq    : every ioFreq time units, the job issues an I/O\n              (the I/O takes ioTime units to complete)\n\nJob List:\n  Job  0: startTime   0 - runTime  84 - ioFreq   7\n  Job  1: startTime   0 - runTime  42 - ioFreq   3\n  Job  2: startTime   0 - runTime  51 - ioFreq   4\n\nCompute the execution trace for the given workloads.\nIf you would like, also compute the response and turnaround\ntimes for each of the jobs.\n\nUse the -c flag to get the exact results when you are finished.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n这会在具有多个默认设置的默认数量的队列上生成三个作业（根据指定）的随机工作负载。如果您使用 (-c) 上的求解选项再次运行，您将看到与上面相同的打印输出，以及以下内容：\n\nExecution Trace:\n\n[ time 0 ] JOB BEGINS by JOB 0\n[ time 0 ] JOB BEGINS by JOB 1\n[ time 0 ] JOB BEGINS by JOB 2\n[ time 0 ] Run JOB 0 at PRIORITY 2 [ TICKS 9 ALLOT 1 TIME 83 (of 84) ]\n[ time 1 ] Run JOB 0 at PRIORITY 2 [ TICKS 8 ALLOT 1 TIME 82 (of 84) ]\n[ time 2 ] Run JOB 0 at PRIORITY 2 [ TICKS 7 ALLOT 1 TIME 81 (of 84) ]\n[ time 3 ] Run JOB 0 at PRIORITY 2 [ TICKS 6 ALLOT 1 TIME 80 (of 84) ]\n[ time 4 ] Run JOB 0 at PRIORITY 2 [ TICKS 5 ALLOT 1 TIME 79 (of 84) ]\n[ time 5 ] Run JOB 0 at PRIORITY 2 [ TICKS 4 ALLOT 1 TIME 78 (of 84) ]\n[ time 6 ] Run JOB 0 at PRIORITY 2 [ TICKS 3 ALLOT 1 TIME 77 (of 84) ]\n[ time 7 ] IO_START by JOB 0\nIO DONE\n[ time 7 ] Run JOB 1 at PRIORITY 2 [ TICKS 9 ALLOT 1 TIME 41 (of 42) ]\n[ time 8 ] Run JOB 1 at PRIORITY 2 [ TICKS 8 ALLOT 1 TIME 40 (of 42) ]\n[ time 9 ] Run JOB 1 at PRIORITY 2 [ TICKS 7 ALLOT 1 TIME 39 (of 42) ]\n...\n\nFinal statistics:\n  Job  0: startTime   0 - response   0 - turnaround 175\n  Job  1: startTime   0 - response   7 - turnaround 191\n  Job  2: startTime   0 - response   9 - turnaround 168\n\n  Avg  2: startTime n/a - response 5.33 - turnaround 178.00\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n该跟踪以毫秒为单位准确显示了调度程序决定执行的操作。在此示例中，它首先运行作业 0 7 毫秒，直到作业 0 发出 I/O；这是完全可以预测的，因为作业 0 的 I/O 频率设置为 7 ms，这意味着它每运行 7 ms，就会发出一个 I/O 并等待其完成后再继续。此时，调度程序切换到作业 1，该作业在发出 I/O 之前仅运行 2 毫秒。调度程序以这种方式打印整个执行跟踪，最后还计算每个作业的响应时间和周转时间以及平均值。\n\n您还可以控制模拟的各个其他方面。例如，您可以指定系统中希望有多少个队列 (-n) 以及所有这些队列的时间片长度应该是多少 (-q)；如果您想要更多的控制和每个队列不同的时间片长度，您可以使用 -Q 指定每个队列的时间片的长度，例如， -Q 10,20,30] 模拟具有三个队列的调度程序，最高优先级队列具有 10 毫秒时间片，次高优先级队列具有 20 毫秒时间片，低优先级队列具有 30 毫秒时间片。\n\n您也可以单独控制每个队列的时间分配量。可以使用 -a 对所有队列进行设置，或使用 -A 对每个队列进行设置，例如 -A 20,40,60 将每个队列的时间分配分别设置为 20ms、40ms 和 60ms。请注意，虽然本章讨论的是时间方面的分配，但这里是根据时间片的数量来完成的，即，如果给定队列的时间片长度为 10 毫秒，并且分配为 2，则作业可以运行在优先级下降之前，在该队列级别持续 2 个时间片（20 毫秒）。\n\n如果您随机生成作业，您还可以控制它们运行的 时间 (-m) 或它们生成 I/O 的频率 (-M)。但是，如果您希望更多地控制系统中运行的作业的确切特征，则可以使用 -l（小写 L）或 --jlist，它允许您指定要模拟的确切作业集。该列表的格式为：x1,y1,z1:x2,y2,z2:... 其中 x 是作业的开始时间，y 是运行时间（即需要多少 CPU 时间），z I/O 频率（即运行 z ms 后，作业发出 I/O；如果 z 为 0，则不发出 I/O）。 例如，如果您想重新创建图 8.3 中的示例，您可以指定一个作业列表，如下所示： python mlfq.py --jlist 0,180,0:100,20,0 -q 10\n\n以这种方式运行模拟器会创建一个三级 MLFQ，每个级别都有 10 毫秒的时间片。创建了两个作业：作业 0 在时间 0 启动，总共运行 180 毫秒，并且从不发出 I/O；作业 1 从 100 毫秒开始，仅需要 20 毫秒的 CPU 时间即可完成，而且从不发出 I/O。\n\n最后，还有另外三个令人感兴趣的参数。 -B 参数如果设置为非零值，则在调用时每 N 毫秒将所有作业提升到最高优先级队列：\n\n调度程序使用此功能来避免饥饿，如本章中所讨论的。但是，默认情况下它是关闭的。\n\n-S 标志调用旧规则 4a 和 4b，这意味着如果作业在完成其时间片之前发出 I/O，则当它恢复执行时，它将返回到相同的优先级队列，并且其完整分配完好无损。这可以玩弄调度器。\n\n最后，您可以使用 -i 标志轻松更改 I/O 持续的时间。默认情况下，在此简单模型中，每个 I/O 需要 5 毫秒的固定时间或使用此标志设置的任何时间。\n\n您还可以使用 -I 标志尝试将刚刚完成 I/O 的作业移动到它们所在队列的头部还是后面。看看吧，很好玩！\n\n\n# 3 QA\n\n 1. 仅使用两个作业和两个队列运行一些随机生成的问题；计算每个的 MLFQ 执行轨迹。通过限制每个作业的长度和关闭 I/O 让您的生活更轻松。\n    \n    > 例子：python mlfq.py -n 2 -j 2 -m 20 -M 0 -s 66 Job List: Job 0: startTime 0 - runTime 2 - ioFreq 0 Job 1: startTime 0 - runTime 5 - ioFreq 0 Execution Trace: [ time 0 ] JOB BEGINS by JOB 0 [ time 0 ] JOB BEGINS by JOB 1 [ time 0 ] Run JOB 0 at PRIORITY 1 [ TICKS 9 ALLOT 1 TIME 1 (of 2) ] [ time 1 ] Run JOB 0 at PRIORITY 1 [ TICKS 8 ALLOT 1 TIME 0 (of 2) ] [ time 2 ] FINISHED JOB 0 [ time 2 ] Run JOB 1 at PRIORITY 1 [ TICKS 9 ALLOT 1 TIME 4 (of 5) ] [ time 3 ] Run JOB 1 at PRIORITY 1 [ TICKS 8 ALLOT 1 TIME 3 (of 5) ] [ time 4 ] Run JOB 1 at PRIORITY 1 [ TICKS 7 ALLOT 1 TIME 2 (of 5) ] [ time 5 ] Run JOB 1 at PRIORITY 1 [ TICKS 6 ALLOT 1 TIME 1 (of 5) ] [ time 6 ] Run JOB 1 at PRIORITY 1 [ TICKS 5 ALLOT 1 TIME 0 (of 5) ] [ time 7 ] FINISHED JOB 1 Final statistics: Job 0: startTime 0 - response 0 - turnaround 2 Job 1: startTime 0 - response 2 - turnaround 7 Avg 1: startTime n/a - response 1.00 - turnaround 4.50\n\n 2. 您将如何运行调度程序来重现本章中的每个示例？\n    \n    > // Figure 8.2 Long-running Job Over Time >python mlfq.py -n 3 -q 10 -l 0,200,0 -c // Figure 8.3 Along Came An Interactive Job >python mlfq.py -n 3 -q 10 -l 0,180,0:100,20,0 -c // Figure 8.4 A Mixed I/O-intensive and CPU-intensive Workload >python mlfq.py -n 3 -q 10 -l 0,175,0:50,25,1 -i 5 -S -c // Figure 8.5 without priority boost >python mlfq.py -n 3 -q 10 -l 0,120,0:100,50,1:100,50,1 -i 1 -S -c // Figure 8.5 with priority boost python mlfq.py -n 3 -q 10 -l 0,120,0:100,50,1:100,50,1 -i 1 -S -B 50 -c // Figure 8.6 without gaming tolerance > python mlfq.py -n 3 -q 10 -i 1 -S -l 0,200,0:80,100,9 -c // Figure 8.6 with gaming tolerance python mlfq.py -n 3 -q 10 -i 1 -l 0,200,0:80,100,9 -c // Figure 8.7 Lower Priority, Longer Quanta python mlfq.py -n 3 -a 2 -Q 10,20,40 -l 0,200,0:0,200,0 -c\n\n 3. 如何配置调度程序参数以使其像循环调度程序一样运行？\n    \n    > 同一队列上的作业是按时间分片的，因此答案是只有一个队列。\n\n 4. 使用两个作业和调度程序参数制作一个工作负载，以便一个作业利用旧的规则 4a 和 4b（使用 -S 参数打开）来欺骗调度程序并在特定的情况下获得 99% 的 CPU 占用率时间间隔。\n    \n    > 首先，使用 -i 将 I/O 时间设置为 1，然后确保 CPU hog 在 100 个点击时间片长度的第 99 个点击时调用 I/O 操作。另外，包含 -I 标志以确保 CPU 占用者在 I/O 请求完成时重新获得控制权： python mlfq.py -S -i 1 -l 0,297,99:0,60,0 -q 100 -n 3 -I -c\n\n 5. 给定一个系统，其最高队列的时间片长度为 10 毫秒，您需要多久将作业提升回最高优先级（使用 -B 标志）才能保证单个长时间运行的作业（并且可能会饥饿）作业至少获得 5% 的 CPU 资源？\n    \n    > 如果每 10 毫秒就有一个新的 10 毫秒长作业到达 - 如图 8.5（左）所示，每 200 个时钟周期提升可确保长进程将运行 10/200 个 CPU 周期 = 5%。\n\n 6. 调度中出现的一个问题是在队列的哪一端添加刚刚完成 I/O 的作业； -I 参数更改此调度模拟器的此行为。尝试一些工作负载，看看是否可以看到此参数的效果。\n    \n    python mlfq.py -n 2 -q 10 -l 0,50,0:0,50,11 -i 1 -S -c\n    python mlfq.py -n 2 -q 10 -l 0,50,0:0,50,11 -i 1 -S -I -c\n    \n    \n    1\n    2\n    \n    1\n    2\n    \n    使用-I的周转时间下降了很多。',normalizedContent:'github地址\n\n\n# 1 note/translation\n\n * 基本规则\n   \n   mlfq有许多不同的队列，每个队列分配了不同的优先级。在任何给定时间，准备运行的作业都位于单个队列上。 mlfq 使用优先级来决定在给定时间应运行哪个作业：选择运行具有较高优先级的作业（即较高队列上的作业）。当然，一个队列上可能有多个作业，即具有相同的优先级，这种情况则对这些工作使用rr调度。则mlfq基本规则如下：\n   \n   * rule 1:if priority(a)>priority(b),a runs (b doesn’t).\\text{rule}\\space1:\\text{if priority(a)>priority(b),a runs (b doesn\'t).}rule 1:if priority(a)>priority(b),a runs (b doesn’t).\n   * rule 1:if priority(a)=priority(b),a and b run in rr.\\text{rule}\\space1:\\text{if priority(a)=priority(b),a and b run in rr.}rule 1:if priority(a)=priority(b),a and b run in rr.\n\n * mlfq例子\n   \n   如果我们要展示给定时刻队列的样子，我们可能会看到如下所示的内容（图 8.1）。图中，两个作业（a 和 b）的优先级最高，作业 c 处于中间，作业 d 的优先级最低。鉴于我们目前对 mlfq 工作原理的了解，调度程序只会在 a 和 b 之间交替时间片，因为它们是系统中优先级最高的作业；可怜的工作 c 和 d 根本无法运行！\n\n * 尝试#1：怎么改变作业的优先级\n   \n   现在，我们必须决定 mlfq 将如何在作业的生命周期内更改作业的优先级（以及它所在的队列）。为此，我们必须牢记我们的工作负载：短期运行的交互式作业（可能经常放弃 cpu），以及一些需要大量 cpu 时间但运行时间较长的“cpu 密集型”作业。其中响应时间并不重要。这是我们对优先级调整算法的第一次尝试：\n   \n   * rule 3: when a job enters the system, it is placed at the highest priority (the topmost queue).\\text{rule 3: when a job enters the system, it is placed at the highest priority (the topmost queue).}rule 3: when a job enters the system, it is placed at the highest priority (the topmost queue).\n   * rule 4a: if a job uses up an entire time slice while running, its pri- ority is reduced (i.e., it moves down one queue).\\text{rule 4a: if a job uses up an entire time slice while running, its pri- ority is reduced (i.e., it moves down one queue).}rule 4a: if a job uses up an entire time slice while running, its pri- ority is reduced (i.e., it moves down one queue).\n   * rule 4b: if a job gives up the cpu before the time slice is up, it stays at the same priority level.\\text{rule 4b: if a job gives up the cpu before the time slice is up, it stays at the same priority level.}rule 4b: if a job gives up the cpu before the time slice is up, it stays at the same priority level.\n\n * 例子#1.1：单个长时间运行的作业\n   \n   首先，我们来看看当系统中有一项长期运行的工作时会发生什么情况。下图显示了在三队列调度程序中该作业随时间发生的变化。\n   \n   如示例所示，作业以最高优先级（q2）进入。经过 10ms\\text{10ms}10ms 的单个时间片后，调度程序将作业的优先级降低了一个，因此作业的优先级为 q1。在 q1 上运行一个时间片后，作业最终被降到系统中的最低优先级（q0），并保持不变。\n\n * 例子#1.2：加入一个短作业\n   \n   在这个例子中，有两个作业：a是一个长期运行的cpu密集型作业，b是一个短期运行的交互作业。假设a已经运行了一段时间，然后b才到达，这样会发生什么？mlfq是否会近似于b的sjf？\n   \n   如下图所示，a（黑色显示）在最低优先级队列中运行（任何长期运行的 cpu 密集型作业都是如此）；b（灰色显示）在 t = 100 时到达，因此会插入到最高队列，由于其运行时间很短（仅20ms），b 在到达底层队列之前完成，分两个时间片；然后 a 恢复运行（低优先级）。\n   \n   从这个例子中，你有望理解算法的一个主要目标：因为它不知道一项作业是短作业还是长期作业，所以它首先假定它可能是短作业，从而给予该作业高优先级。如果它确实是短作业，它就会快速运行并完成；如果它不是短作业，它就会在队列中缓慢移动，从而很快证明自己是一个长期运行的更类似批处理的进程。通过这种方式，mlfq 近似于 sjf。\n\n * 例子#1.3：关于i/o\n   \n   如上文规则 4b 所述，如果进程在用完其时间片之前放弃了处理器，我们会将其保持在相同的优先级。这条规则的用意很简单：例如，如果一个交互式作业正在进行大量的 i/o（比如等待键盘或鼠标的用户输入），那么它就会在其时间片完成之前放弃 cpu；在这种情况下，我们不希望惩罚该作业，因此只需将其保持在同一优先级即可。\n   \n   下图举例说明了这种方法的工作原理，交互式作业 b（灰色显示）只需要 cpu 1 ms，然后执行 i/o，与长期运行的批处理作业 a（黑色显示）争夺 cpu。mlfq 方法将 b 保持在最高优先级，因为 b 一直在释放 cpu；如果 b 是交互式作业，mlfq 将进一步实现快速运行交互式作业的目标。\n   \n   \n\n * 我们现在设计的mlfq存在的问题\n   \n   这样，我们就有了一个基本的 mlfq。它似乎做得相当不错，在长时间运行的作业之间公平地共享 cpu，并让短时间或 i/o 密集型交互式作业快速运行。遗憾的是，我们迄今为止开发的方法存在严重缺陷。\n   \n   1. 饥饿问题：如果系统存在太多交互作业，它们将会共同消耗所有cpu时间，这样长时间运行的作业将不会获得任何cpu时间（即饥饿）。\n   2. 欺骗调度程序：聪明的用户可以重写程序，玩弄调度程序。即是指偷偷摸摸地欺骗调度程序，让调度程序给你分配更多的资源。我们所描述的算法很容易受到以下攻击：在时间片结束前，进行一次 i/o 操作（对某个你并不关心的文件），从而放弃 cpu；这样做可以让你保持在同一队列中，从而获得更多的 cpu 时间。如果操作得当（例如，运行 99% 的时间片后才放弃 cpu），作业几乎可以垄断 cpu。\n   3. 程序行为改变：一个程序可能会随着时间的推移而改变其行为；原来的 cpu 约束可能会过渡到交互阶段。采用我们目前的方法，这样的作业就会倒霉，不会像系统中的其他交互式作业一样得到处理。\n\n * 尝试#2：优先级提升\n   \n   让我们试着改变规则，看看能否避免 "饥饿 "问题。为了保证占用 cpu 的作业能取得一些进展（即使进展不大），我们可以做些什么？简单来说，就是定期提升系统中所有作业的优先级。实现这一点的方法有很多，但我们只需做一件简单的事：把所有作业都扔到最上面的队列中；因此，我们需要一条新规则：\n   \n   * rule 5: after some time period s, move all the jobs in the system to the topmost queue.\\text{rule 5: after some time period s, move all the jobs in the system to the topmost queue.}rule 5: after some time period s, move all the jobs in the system to the topmost queue.\n   \n   我们的新规则同时解决了两个问题。首先，保证了进程不会饥饿：作业排在队列的最前面，就能与其他高优先级作业以循环方式共享 cpu，从而最终获得服务。其次，如果受 cpu 限制的作业已开始交互，调度程序会在其获得优先级提升后对其进行适当处理。\n\n * 例子#2.1：竞争cpu\n   \n   在这种情况下，我们仅展示一个长时间运行的作业与两个短时间运行的交互式作业竞争 cpu 时的行为。下图显示了两个图表。在左边，没有优先级提升，因此一旦两个短期作业到达，长期运行的作业就会陷入饥饿；右边，每 50 毫秒就有一次优先级提升（这个值可能太小，但这里用于示例），因此我们至少保证长时间运行的作业会取得一些进展，提升到每 50 毫秒设置一次最高优先级，从而定期运行。\n   \n   当然，增加时间段s会带来一个明显的问题：s应该设置为什么？ john ousterhout，一位受人尊敬的系统研究员 ，过去常常将系统中的此类值称为“巫术常量”，因为它们似乎需要某种形式的黑魔法才能正确设置它们。不幸的是，s有那种味道。如果设置得太高，长时间运行的作业可能会陷入困境；太低，交互式作业可能无法获得适当的 cpu 份额。\n\n * 尝试#3：更好的计算\n   \n   现在，我们还有一个问题要解决：如何防止调度程序被玩弄？正如你可能已经猜到的，真正的罪魁祸首是rule 4a 和 4b，它们允许作业在时间片到期前放弃 cpu，从而保留其优先级。那么我们该怎么办呢？解决办法是在 mlfq 的每一级更好地计算 cpu 时间。调度程序不应该忘记进程在特定级别上使用了多少时间片，而应该进行跟踪；一旦进程用完了分配的时间片，就会被降级到下一个优先级队列。至于进程是在一个长的时间段内使用时间片，还是在许多小的时间段内使用时间片，这并不重要。因此，我们将规则 4a 和 4b 重写为以下单一规则：\n   \n   * rule 4: once a job uses up its time allotment at a given level (re- gardless of how many times it has given up the cpu), its priority is reduced (i.e., it moves down one queue).\\text{rule 4: once a job uses up its time allotment at a given level (re- gardless of how many times it has given up the cpu), its priority is reduced (i.e., it moves down one queue).}rule 4: once a job uses up its time allotment at a given level (re- gardless of how many times it has given up the cpu), its priority is reduced (i.e., it moves down one queue).\n\n * 例子#3.1：旧规则和新规则对比\n   \n   下图显示了当工作负载试图利用旧规则 4a 和 4b（左侧）以及新的反玩弄规则 4 来玩弄调度程序时会发生的情况。如果没有任何防止玩弄的保护措施，进程可以在时间片结束前发出 i/o，从而支配 cpu 时间。有了这种保护措施，无论进程的 i/o 行为如何，它都会在队列中缓慢移动，从而无法获得不公平的 cpu 占有率。\n   \n   \n\n * 调整 mlfq 及其他问题\n   \n   mlfq 调度还存在其他一些问题。一个大问题是如何为这样的调度器设置参数。例如，应该有多少个队列？每个队列的时间片应该有多大？为了避免饥饿并考虑到行为的变化，应该多久提升一次优先级？这些问题都没有简单的答案，因此只有在工作负载方面积累一定的经验，然后对调度程序进行调整，才能取得令人满意的平衡。\n   \n   例如，大多数 mlfq 变体都允许在不同队列中使用不同的时间片长度。高优先级队列的时间片通常较短；毕竟它们由交互式作业组成，因此在它们之间快速交替是合理的（例如 10 毫秒或更少）。相比之下，低优先级队列包含的是占用 cpu 的长期运行作业；因此，较长的时间片（如 100 毫秒）也很有效。下图显示了一个例子，其中两个作业在最高队列运行 20 毫秒（时间片为 10 毫秒），在中间队列运行 40 毫秒（时间片为 20 毫秒），在最低队列运行 40 毫秒。\n   \n   solaris mlfq 实现——分时调度类（ts）——特别容易配置；它提供了一组表，可以准确确定进程的优先级在其整个生命周期中如何更改、每个时间片的长度以及提高作业优先级的频率；管理员可以修改该表以使调度程序以不同的方式运行。该表的默认值为 60 个队列，时间片长度从 20 毫秒（最高优先级）缓慢增加到几百毫秒（最低），并且优先级大约每 1 秒左右提升一次。\n   \n   其他 mlfq 调度器并不使用本章所述的表格或精确规则，而是使用数学公式来调整优先级。例如，freebsd 调度器（4.3 版）使用一个公式来计算作业当前的优先级，该公式基于进程使用了多少 cpu ；此外，使用率会随着时间的推移而衰减，从而以与本文所述不同的方式提供所需的优先级提升。最后，许多调度器还有一些你可能会遇到的其他功能。例如，有些调度器为操作系统工作保留最高优先级；因此，典型的用户作业永远无法获得系统中的最高优先级。有些系统还允许用户通过一些建议来帮助设置优先级；例如，通过使用命令行实用程序 nice，你可以（在一定程度上）提高或降低作业的优先级，从而增加或减少它在任何特定时间运行的机会。\n\n * mlfq总结\n   \n   我们已经描述了多级反馈队列（mlfq）的调度方法。希望你现在能明白它为什么叫这个名字：它有多级队列，并使用反馈来确定给定作业的优先级。历史是它的指南：关注作业在一段时间内的表现，并相应地处理它们。在本章中，mlfq 规则的精炼集在此重现，供大家欣赏：\n   \n   * rule 1: if priority(a) > priority(b), a runs (b doesn’t).\\text{rule 1: if priority(a) > priority(b), a runs (b doesn’t).}rule 1: if priority(a) > priority(b), a runs (b doesn’t).\n   * rule 2: if priority(a) = priority(b), a and b run in round-robin fash- ion using the time slice (quantum length) of the given queue.\\text{rule 2: if priority(a) = priority(b), a and b run in round-robin fash- ion using the time slice (quantum length) of the given queue.}rule 2: if priority(a) = priority(b), a and b run in round-robin fash- ion using the time slice (quantum length) of the given queue.\n   * rule 3: when a job enters the system, it is placed at the highest priority (the topmost queue).\\text{rule 3: when a job enters the system, it is placed at the highest priority (the topmost queue).}rule 3: when a job enters the system, it is placed at the highest priority (the topmost queue).\n   * rule 4: once a job uses up its time allotment at a given level (re- gardless of how many times it has given up the cpu), its priority is reduced (i.e., it moves down one queue).\\text{rule 4: once a job uses up its time allotment at a given level (re- gardless of how many times it has given up the cpu), its priority is reduced (i.e., it moves down one queue).}rule 4: once a job uses up its time allotment at a given level (re- gardless of how many times it has given up the cpu), its priority is reduced (i.e., it moves down one queue).\n   * rule 5: after some time period s, move all the jobs in the system to the topmost queue.\\text{rule 5: after some time period s, move all the jobs in the system to the topmost queue.}rule 5: after some time period s, move all the jobs in the system to the topmost queue.\n   \n   mlfq 很有趣，原因如下：它不要求先验了解作业的性质，而是观察作业的执行情况并相应地确定其优先级。通过这种方式，它成功地实现了两全其美：它可以为短时间运行的交互式作业提供出色的整体性能（类似于 sjf/stcf），并且对于长时间运行的 cpu 密集型工作负载来说，它是公平的并取得进步。因此，许多系统，包括 bsd unix 衍生系统 、solaris 以及 windows nt 和后续的 windows 操作系统，都使用某种形式的 mlfq 作为其基本调度程序。\n\n\n# 2 program explanation\n\n这个程序 mlfq.py 允许您查看本章中介绍的 mlfq 调度程序的行为方式。和以前一样，您可以使用它来使用随机种子为自己生成问题，或者使用它构建一个精心设计的实验，以了解 mlfq 在不同情况下的工作原理。要运行该程序，请键入：\n\n❯ python mlfq.py\n\n\n1\n\n1\n\n\n使用参数-h查看选项帮助：\n\n❯ python mlfq.py -h\nusage: mlfq.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -s seed, --seed=seed  the random seed\n  -n numqueues, --numqueues=numqueues\n                        number of queues in mlfq (if not using -q)\n  -q quantum, --quantum=quantum\n                        length of time slice (if not using -q)\n  -a allotment, --allotment=allotment\n                        length of allotment (if not using -a)\n  -q quantumlist, --quantumlist=quantumlist\n                        length of time slice per queue level, specified as\n                        x,y,z,... where x is the quantum length for the\n                        highest priority queue, y the next highest, and so\n                        forth\n  -a allotmentlist, --allotmentlist=allotmentlist\n                        length of time allotment per queue level, specified as\n                        x,y,z,... where x is the # of time slices for the\n                        highest priority queue, y the next highest, and so\n                        forth\n  -j numjobs, --numjobs=numjobs\n                        number of jobs in the system\n  -m maxlen, --maxlen=maxlen\n                        max run-time of a job (if randomly generating)\n  -m maxio, --maxio=maxio\n                        max i/o frequency of a job (if randomly generating)\n  -b boost, --boost=boost\n                        how often to boost the priority of all jobs back to\n                        high priority\n  -i iotime, --iotime=iotime\n                        how long an i/o should last (fixed constant)\n  -s, --stay            reset and stay at same priority level when issuing i/o\n  -i, --iobump          if specified, jobs that finished i/o move immediately\n                        to front of current queue\n  -l jlist, --jlist=jlist\n                        a comma-separated list of jobs to run, in the form\n                        x1,y1,z1:x2,y2,z2:... where x is start time, y is run\n                        time, and z is how often the job issues an i/o request\n  -c                    compute answers for me\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n使用模拟器有几种不同的方法，一种方法是生成一些随机作业，然后看看您是否可以弄清楚它们在给定 mlfq 调度程序的情况下将如何表现。例如，如果您想创建随机生成的三作业工作负载，您只需运行\n\n❯ python mlfq.py -j 3\nhere is the list of inputs:\noptions jobs 3\noptions queues 3\noptions allotments for queue  2 is   1\noptions quantum length for queue  2 is  10\noptions allotments for queue  1 is   1\noptions quantum length for queue  1 is  10\noptions allotments for queue  0 is   1\noptions quantum length for queue  0 is  10\noptions boost 0\noptions iotime 5\noptions stayafterio false\noptions iobump false\n\n\nfor each job, three defining characteristics are given:\n  starttime : at what time does the job enter the system\n  runtime   : the total cpu time needed by the job to finish\n  iofreq    : every iofreq time units, the job issues an i/o\n              (the i/o takes iotime units to complete)\n\njob list:\n  job  0: starttime   0 - runtime  84 - iofreq   7\n  job  1: starttime   0 - runtime  42 - iofreq   3\n  job  2: starttime   0 - runtime  51 - iofreq   4\n\ncompute the execution trace for the given workloads.\nif you would like, also compute the response and turnaround\ntimes for each of the jobs.\n\nuse the -c flag to get the exact results when you are finished.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n这会在具有多个默认设置的默认数量的队列上生成三个作业（根据指定）的随机工作负载。如果您使用 (-c) 上的求解选项再次运行，您将看到与上面相同的打印输出，以及以下内容：\n\nexecution trace:\n\n[ time 0 ] job begins by job 0\n[ time 0 ] job begins by job 1\n[ time 0 ] job begins by job 2\n[ time 0 ] run job 0 at priority 2 [ ticks 9 allot 1 time 83 (of 84) ]\n[ time 1 ] run job 0 at priority 2 [ ticks 8 allot 1 time 82 (of 84) ]\n[ time 2 ] run job 0 at priority 2 [ ticks 7 allot 1 time 81 (of 84) ]\n[ time 3 ] run job 0 at priority 2 [ ticks 6 allot 1 time 80 (of 84) ]\n[ time 4 ] run job 0 at priority 2 [ ticks 5 allot 1 time 79 (of 84) ]\n[ time 5 ] run job 0 at priority 2 [ ticks 4 allot 1 time 78 (of 84) ]\n[ time 6 ] run job 0 at priority 2 [ ticks 3 allot 1 time 77 (of 84) ]\n[ time 7 ] io_start by job 0\nio done\n[ time 7 ] run job 1 at priority 2 [ ticks 9 allot 1 time 41 (of 42) ]\n[ time 8 ] run job 1 at priority 2 [ ticks 8 allot 1 time 40 (of 42) ]\n[ time 9 ] run job 1 at priority 2 [ ticks 7 allot 1 time 39 (of 42) ]\n...\n\nfinal statistics:\n  job  0: starttime   0 - response   0 - turnaround 175\n  job  1: starttime   0 - response   7 - turnaround 191\n  job  2: starttime   0 - response   9 - turnaround 168\n\n  avg  2: starttime n/a - response 5.33 - turnaround 178.00\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n该跟踪以毫秒为单位准确显示了调度程序决定执行的操作。在此示例中，它首先运行作业 0 7 毫秒，直到作业 0 发出 i/o；这是完全可以预测的，因为作业 0 的 i/o 频率设置为 7 ms，这意味着它每运行 7 ms，就会发出一个 i/o 并等待其完成后再继续。此时，调度程序切换到作业 1，该作业在发出 i/o 之前仅运行 2 毫秒。调度程序以这种方式打印整个执行跟踪，最后还计算每个作业的响应时间和周转时间以及平均值。\n\n您还可以控制模拟的各个其他方面。例如，您可以指定系统中希望有多少个队列 (-n) 以及所有这些队列的时间片长度应该是多少 (-q)；如果您想要更多的控制和每个队列不同的时间片长度，您可以使用 -q 指定每个队列的时间片的长度，例如， -q 10,20,30] 模拟具有三个队列的调度程序，最高优先级队列具有 10 毫秒时间片，次高优先级队列具有 20 毫秒时间片，低优先级队列具有 30 毫秒时间片。\n\n您也可以单独控制每个队列的时间分配量。可以使用 -a 对所有队列进行设置，或使用 -a 对每个队列进行设置，例如 -a 20,40,60 将每个队列的时间分配分别设置为 20ms、40ms 和 60ms。请注意，虽然本章讨论的是时间方面的分配，但这里是根据时间片的数量来完成的，即，如果给定队列的时间片长度为 10 毫秒，并且分配为 2，则作业可以运行在优先级下降之前，在该队列级别持续 2 个时间片（20 毫秒）。\n\n如果您随机生成作业，您还可以控制它们运行的 时间 (-m) 或它们生成 i/o 的频率 (-m)。但是，如果您希望更多地控制系统中运行的作业的确切特征，则可以使用 -l（小写 l）或 --jlist，它允许您指定要模拟的确切作业集。该列表的格式为：x1,y1,z1:x2,y2,z2:... 其中 x 是作业的开始时间，y 是运行时间（即需要多少 cpu 时间），z i/o 频率（即运行 z ms 后，作业发出 i/o；如果 z 为 0，则不发出 i/o）。 例如，如果您想重新创建图 8.3 中的示例，您可以指定一个作业列表，如下所示： python mlfq.py --jlist 0,180,0:100,20,0 -q 10\n\n以这种方式运行模拟器会创建一个三级 mlfq，每个级别都有 10 毫秒的时间片。创建了两个作业：作业 0 在时间 0 启动，总共运行 180 毫秒，并且从不发出 i/o；作业 1 从 100 毫秒开始，仅需要 20 毫秒的 cpu 时间即可完成，而且从不发出 i/o。\n\n最后，还有另外三个令人感兴趣的参数。 -b 参数如果设置为非零值，则在调用时每 n 毫秒将所有作业提升到最高优先级队列：\n\n调度程序使用此功能来避免饥饿，如本章中所讨论的。但是，默认情况下它是关闭的。\n\n-s 标志调用旧规则 4a 和 4b，这意味着如果作业在完成其时间片之前发出 i/o，则当它恢复执行时，它将返回到相同的优先级队列，并且其完整分配完好无损。这可以玩弄调度器。\n\n最后，您可以使用 -i 标志轻松更改 i/o 持续的时间。默认情况下，在此简单模型中，每个 i/o 需要 5 毫秒的固定时间或使用此标志设置的任何时间。\n\n您还可以使用 -i 标志尝试将刚刚完成 i/o 的作业移动到它们所在队列的头部还是后面。看看吧，很好玩！\n\n\n# 3 qa\n\n 1. 仅使用两个作业和两个队列运行一些随机生成的问题；计算每个的 mlfq 执行轨迹。通过限制每个作业的长度和关闭 i/o 让您的生活更轻松。\n    \n    > 例子：python mlfq.py -n 2 -j 2 -m 20 -m 0 -s 66 job list: job 0: starttime 0 - runtime 2 - iofreq 0 job 1: starttime 0 - runtime 5 - iofreq 0 execution trace: [ time 0 ] job begins by job 0 [ time 0 ] job begins by job 1 [ time 0 ] run job 0 at priority 1 [ ticks 9 allot 1 time 1 (of 2) ] [ time 1 ] run job 0 at priority 1 [ ticks 8 allot 1 time 0 (of 2) ] [ time 2 ] finished job 0 [ time 2 ] run job 1 at priority 1 [ ticks 9 allot 1 time 4 (of 5) ] [ time 3 ] run job 1 at priority 1 [ ticks 8 allot 1 time 3 (of 5) ] [ time 4 ] run job 1 at priority 1 [ ticks 7 allot 1 time 2 (of 5) ] [ time 5 ] run job 1 at priority 1 [ ticks 6 allot 1 time 1 (of 5) ] [ time 6 ] run job 1 at priority 1 [ ticks 5 allot 1 time 0 (of 5) ] [ time 7 ] finished job 1 final statistics: job 0: starttime 0 - response 0 - turnaround 2 job 1: starttime 0 - response 2 - turnaround 7 avg 1: starttime n/a - response 1.00 - turnaround 4.50\n\n 2. 您将如何运行调度程序来重现本章中的每个示例？\n    \n    > // figure 8.2 long-running job over time >python mlfq.py -n 3 -q 10 -l 0,200,0 -c // figure 8.3 along came an interactive job >python mlfq.py -n 3 -q 10 -l 0,180,0:100,20,0 -c // figure 8.4 a mixed i/o-intensive and cpu-intensive workload >python mlfq.py -n 3 -q 10 -l 0,175,0:50,25,1 -i 5 -s -c // figure 8.5 without priority boost >python mlfq.py -n 3 -q 10 -l 0,120,0:100,50,1:100,50,1 -i 1 -s -c // figure 8.5 with priority boost python mlfq.py -n 3 -q 10 -l 0,120,0:100,50,1:100,50,1 -i 1 -s -b 50 -c // figure 8.6 without gaming tolerance > python mlfq.py -n 3 -q 10 -i 1 -s -l 0,200,0:80,100,9 -c // figure 8.6 with gaming tolerance python mlfq.py -n 3 -q 10 -i 1 -l 0,200,0:80,100,9 -c // figure 8.7 lower priority, longer quanta python mlfq.py -n 3 -a 2 -q 10,20,40 -l 0,200,0:0,200,0 -c\n\n 3. 如何配置调度程序参数以使其像循环调度程序一样运行？\n    \n    > 同一队列上的作业是按时间分片的，因此答案是只有一个队列。\n\n 4. 使用两个作业和调度程序参数制作一个工作负载，以便一个作业利用旧的规则 4a 和 4b（使用 -s 参数打开）来欺骗调度程序并在特定的情况下获得 99% 的 cpu 占用率时间间隔。\n    \n    > 首先，使用 -i 将 i/o 时间设置为 1，然后确保 cpu hog 在 100 个点击时间片长度的第 99 个点击时调用 i/o 操作。另外，包含 -i 标志以确保 cpu 占用者在 i/o 请求完成时重新获得控制权： python mlfq.py -s -i 1 -l 0,297,99:0,60,0 -q 100 -n 3 -i -c\n\n 5. 给定一个系统，其最高队列的时间片长度为 10 毫秒，您需要多久将作业提升回最高优先级（使用 -b 标志）才能保证单个长时间运行的作业（并且可能会饥饿）作业至少获得 5% 的 cpu 资源？\n    \n    > 如果每 10 毫秒就有一个新的 10 毫秒长作业到达 - 如图 8.5（左）所示，每 200 个时钟周期提升可确保长进程将运行 10/200 个 cpu 周期 = 5%。\n\n 6. 调度中出现的一个问题是在队列的哪一端添加刚刚完成 i/o 的作业； -i 参数更改此调度模拟器的此行为。尝试一些工作负载，看看是否可以看到此参数的效果。\n    \n    python mlfq.py -n 2 -q 10 -l 0,50,0:0,50,11 -i 1 -s -c\n    python mlfq.py -n 2 -q 10 -l 0,50,0:0,50,11 -i 1 -s -i -c\n    \n    \n    1\n    2\n    \n    1\n    2\n    \n    使用-i的周转时间下降了很多。',charsets:{cjk:!0},lastUpdated:"2024/05/11, 20:33:38",lastUpdatedTimestamp:1715430818e3},{title:"比例份额调度",frontmatter:{title:"比例份额调度",tags:["OS"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},date:"2024-04-25T22:35:53.000Z",permalink:"/pages/40a229/",categories:["开发","系统架构","操作系统","虚拟化"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/02.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/06.%E6%AF%94%E4%BE%8B%E4%BB%BD%E9%A2%9D%E8%B0%83%E5%BA%A6.html",relativePath:"01.开发/05.系统架构/02.操作系统/06.比例份额调度.md",key:"v-3bc0ad5e",path:"/pages/40a229/",headers:[{level:2,title:"1 基本概念：彩票代表份额",slug:"_1-基本概念-彩票代表份额",normalizedTitle:"1 基本概念：彩票代表份额",charIndex:333},{level:2,title:"2 彩票机制",slug:"_2-彩票机制",normalizedTitle:"2 彩票机制",charIndex:1544},{level:2,title:"3 实现",slug:"_3-实现",normalizedTitle:"3 实现",charIndex:2675},{level:2,title:"4 评估指标",slug:"_4-评估指标",normalizedTitle:"4 评估指标",charIndex:3798},{level:2,title:"5 如何分配彩票",slug:"_5-如何分配彩票",normalizedTitle:"5 如何分配彩票",charIndex:4281},{level:2,title:"6 步幅调度",slug:"_6-步幅调度",normalizedTitle:"6 步幅调度",charIndex:4485},{level:2,title:"7 Linux完全公平调度器（CFS）",slug:"_7-linux完全公平调度器-cfs",normalizedTitle:"7 linux完全公平调度器（cfs）",charIndex:6168},{level:3,title:"7.1 基本操作",slug:"_7-1-基本操作",normalizedTitle:"7.1 基本操作",charIndex:6437},{level:3,title:"7.2 权重（优先级）",slug:"_7-2-权重-优先级",normalizedTitle:"7.2 权重（优先级）",charIndex:7843},{level:3,title:"7.3 使用红黑树",slug:"_7-3-使用红黑树",normalizedTitle:"7.3 使用红黑树",charIndex:9538},{level:3,title:"7.4 处理I/O和休眠进程",slug:"_7-4-处理i-o和休眠进程",normalizedTitle:"7.4 处理i/o和休眠进程",charIndex:10256},{level:2,title:"8 总结",slug:"_8-总结",normalizedTitle:"8 总结",charIndex:10612}],headersStr:"1 基本概念：彩票代表份额 2 彩票机制 3 实现 4 评估指标 5 如何分配彩票 6 步幅调度 7 Linux完全公平调度器（CFS） 7.1 基本操作 7.2 权重（优先级） 7.3 使用红黑树 7.4 处理I/O和休眠进程 8 总结",content:"在本章中，我们将研究一种不同类型的调度器，称为比例份额（Proportional-share）调度器，有时也称为公平共享调度器。比例共享基于一个简单的概念：调度器可能会尝试保证每个作业获得一定百分比的 CPU 时间，而不是针对周转时间或响应时间进行优化。\n\n比例份额调度有一个非常出色的早期例子是彩票调度（lottery scheduling），由 Waldspurger 和 Weihl 发现。其基本思想非常简单，每隔一段时间，就会举行一次彩票抽奖，来确定接下来该运行哪个进程。更频繁运行的进程则更有机会中奖。\n\n在处理细节前先抛出我们的关键问题：如何按比例共享CPU？我们如何设计一个调度器以按比例共享 CPU？这样做的关键机制是什么？它们的效果如何？\n\n\n# 1 基本概念：彩票代表份额\n\n彩票调度背后是一个非常基本的概念：彩票数，代表了进程（或用户或其他）占有某个资源的份额。一个一个进程拥有的彩票数占总彩票数的百分比，就是它占有系统资源的份额。\n\n例如，有两个进程A和B，其中A有75张彩票，而B只有25张彩票。因此，我们希望A占有75%75\\%75%的CPU，B占有25%25\\%25%的CPU。\n\n彩票调度通过每隔一段时间（比如每个时间片）举行一次抽奖，以概率方式（而非确定方式）实现这一目标。举行抽奖很简单：调度器必须知道总共有多少张彩票（在我们的例子中，有 100 张彩票），调度器接下来随机抽取中奖彩票，是[0,99][0,99][0,99]的数字。假设 A 持有 0 到 74 号彩票，B 持有 75 到 99 号彩票，中奖彩票就决定了运行A或B。然后调度程序加载中奖进程的状态，并运行它。\n\n下面是彩票调度程序输出的中奖彩票和对应的调度结果:\n\n63   85   70   39   76   17   29   41   36   39   10   99   68   83   63   62   43   0   49   49\nA         A    A         A    A    A    A    A    A         A         A    A    A    A   A    A\n     B              B                                  B         B                            \n\n从这个例子中我们可以看出，彩票调度的随机性导致了从概率上满足期望的比例，但不能确保。在上面的例子中，工作 B 运行了 20 个时间片中的 4 个，只是占了20%20\\%20%，而不是期望的25%25\\%25%。但是，这两个工作运行得时间越长，它们得到的 CPU 时间比例就会越接近期望。\n\n随机性决策有优势也有劣势：\n\n * 优势\n   1. 避免最差情况\n   2. 轻量，不需要记录过多状态，传统公平调度需要记录进程的大量状态\n   3. 随机方法很快，决策也快\n * 劣势\n   1. 系统行为可能不可预测，因为它们不受先前状态或输入的直接影响，这可能导致一些进程等待时间过长，而另一些则过短。\n   2. 可能导致性能波动\n\n> TIP：使用彩票数代表份额\n> \n> 彩票（和步幅）调度设计中最强大（也是基本）的机制之一就是彩票数机制。在这些示例中，彩票数用于表示进程对 CPU 的份额，但其应用范围可以更广泛。例如，在虚拟机管理程序虚拟内存管理的最新研究中，Waldspurger 展示了如何使用彩票数来表示客户操作系统的内存份额。因此，如果您需要一种机制来代表一定比例的所有权，这个概念可能就是……（等等）……彩票数。\n\n\n# 2 彩票机制\n\n彩票调度还提供了许多机制，以不同的方式（有时是有用的方式）操纵彩票。一种机制是彩票货币（ticket currency）。这种机制允许拥有一组彩票的用户在自己的工作中以任意货币分配彩票；然后系统会自动将所述货币转换为正确的全局彩票。\n\n例如，假设用户A和用户B都有100张彩票，A正在运行两个作业：A1和A2，然后用 A 的货币给它们每人 500 张彩票（总共 1000 张）。用户B正在运行一个作业，然后用B的货币给它分配10张彩票（总共10张）。系统将 A1 和 A2 的分配从 A 货币各 500 转换为全球货币各 50；同样，B1的10张票折算为100张票。然后在全球彩票货币（共 200 个）上进行抽签，以决定哪个工作运行。A1的具体计算方法是TicketA1TicketA1+TicketA2×TicketA\\frac{\\text{Ticket}_{A1}}{\\text{Ticket}_{A1}+\\text{Ticket}_{A2}}\\times \\text{Ticket}_{A}TicketA1 +TicketA2 TicketA1 ×TicketA ，其他同理。\n\nUser A\n\n-> 500 (A's ticket currency) to A1 -> 50 (global currency)\n\n-> 500 (A's ticket currency) to A2 -> 50 (global currency)\n\nUser B\n\n-> 10 (B's ticket currency) to B1 -> 100 (global currency)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n另一个有用的机制是彩票转让（ticket transfer）。通过转让，一个进程可以暂时将其彩票转让给另一个进程。这种能力在客户端/服务器设置中特别有用，其中客户端进程向服务器发送消息，要求服务器代表客户端执行一些工作。为了加快工作速度，客户端可以将彩票转让给服务器，并尝试最大化服务器的性能，同时处理客户端的请求。完成后，服务器将票据归还给客户端，一切如旧。\n\n最后，彩票通胀（ticket inflation）机制有时也很有用。通过通货膨胀，进程可以暂时增加或减少其拥有的彩票数。当然，在进程相互不信任的竞争场景中，这是没有意义的；一个贪婪的进程可以给自己大量的彩票从而接管机器。但是，通胀可以应用于一组进程相互信任的环境中。在这种情况下，如果任何一个进程知道它需要更多的 CPU 时间，它可以增加自己的彩票数，作为向系统反映该需求的一种方式，而无需与任何其他进程进行通信。\n\n\n# 3 实现\n\n彩票调度最令人惊叹的地方可能就是其实施的简单性。你只需要一个好的随机数生成器来挑选中奖彩票，一个跟踪系统进程的数据结构（如列表），以及彩票总数。\n\n假设我们将进程保存在一个列表中。下面是一个由 A、B 和 C 三个进程组成的示例，每个进程都有一定数量的彩票数。\n\n\n\n为了做出调度决策，我们首先要从门票总数（400） 中随机抽取一个数字（中奖号码）。然后，我们只需遍历列表，用一个简单的计数器帮助我们找到中奖者。\n\n# counter: used to track if we've found the winner yet\ncounter = 0\n\n# winner: use some call to a random number generator to get a value, between 0 and the total # of tickets\nwinner = random.randint(0, totaltickets)\n\n# current: use this to walk through the list of jobs\ncurrent = head\n\n# loop until the sum of ticket values is > the winner\nwhile current:\n    counter = counter + current.tickets\n    if counter > winner:\n        break  # found the winner\n    current = current.next\n\n# 'current' is the winner: schedule it...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n该代码从前往后遍历进程列表，将每个彩票值添加到计数器中，直到该值超过获胜者。一旦出现这种情况，当前列表进程就是中奖者。以中奖彩票为 300 的示例为例，会发生以下情况。首先，计数器增加到 100 以计算 A 的票；因为 100 小于 300，所以循环继续。然后计数器会更新为 150（B 的票），仍然少于 300，因此我们再次继续。最后，计数器更新为 400（明显大于 300），因此我们跳出循环，当前指向 C（中奖者）。\n\n要让这个过程更有效率，建议将列表项按照彩票数递减排序。这个顺序并不会影响算法的正确性，但能保证用最小的迭代次数找到需要的结点，尤其当大多彩票被少数进程掌握时。\n\n\n# 4 评估指标\n\n为了更容易理解动态彩票调度，我们现在对两个相互竞争的作业的完成时间进行简要研究，每个作业都有相同数量的彩票 (100) 和相同的运行时间 (R，我们将改变它) 。\n\n在这种情况下，我们希望每个作业大致在同一时间完成，但由于彩票调度的随机性，有时一个作业会先于另一个作业完成。为了量化这种差异，我们定义了一个简单的不公平指标（unfairness metric） UUU，它就是第一个作业完成的时间除以第二个作业完成的时间。\n\n例如，如果 R = 10，并且第一个作业在 10 完成（第二个作业在 20 完成），则 U=1020=0.5U=\\frac{10}{20}=0.5U=2010 =0.5。当两个作业几乎同时完成时，UUU 将非常接近 1。在这种情况下，这就是我们的目标：完全公平的调度程序将实现 U=1U = 1U=1。\n\n下图描绘了在30次试验中，两个作业（R）的长度从1到1000不等时的平均不公平性。从图中可以看出，当工作时间不长时，平均不公平现象可能相当严重。只有当作业运行了大量的时间片时，彩票调度程序才能接近所需的结果。\n\n\n# 5 如何分配彩票\n\n在彩票调度方面，我们尚未解决的一个问题是：如何为作业分配彩票？这是一个棘手的问题，因为系统如何运行当然在很大程度上取决于如何分配彩票。一种方法是假定用户最了解情况；在这种情况下，每个用户都会得到一定数量的门票，用户可以根据需要将门票分配给他们运行的任何作业。然而，这种解决方案不是解决方案：它并没有告诉你该怎么做。因此，在给定一系列工作的情况下，\"彩票分配问题 \"仍然悬而未决。\n\n\n# 6 步幅调度\n\n你可能还想知道：为什么要使用随机性呢？如上所述，虽然随机性可以为我们提供一个简单（且近似正确）的调度器，但它偶尔无法提供精确正确的比例，尤其是在短时间内。为此，Waldspurger 发明了一种确定性公平分配调度器—步幅调度器 。\n\n步幅调度也很简单，系统中每个作业都有一个步幅，这与它拥有的彩票数成反比。在上面的示例中，对于作业 A、B 和 C，分别有 100、50 和 250 张彩票，我们可以通过将某个较大的数字除以每个进程分配的彩票数量来计算每个作业的步幅。例如，如果我们用 10,000 除以每个彩票值，我们将获得 A、B 和 C 的步幅值：100、200 和 40。我们将此值称为每个进程的步幅；每次进程运行时，我们都会按其步幅增加它的计数器（称为其行程值），以跟踪其全局进度。\n\n然后，调度程序使用步幅和行程值来确定接下来应该运行哪个进程。基本思想很简单：在任何给定时间，选择迄今为止具有最低行程值的进程来运行；当您运行一个进程时，按其步幅增加其行程值。 Waldspurger 提供了伪代码实现：\n\ncurr = remove_min(queue); // pick client with min pass\nschedule(curr); // run for quantum\ncurr->pass += curr->stride; // update pass using stride\ninsert(queue, curr); // return curr to queue\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n在我们的示例中，一开始有三个进程（A、B 和 C），它们的步幅分别为 100、200 和 40，所有进程的行程值最初都是 0。假设我们选择 A（任意选择；可以选择任何一个行程值同样低的进程）。A 运行后，在完成时间片后，我们将其行程值更新为 100。然后运行 B，将其行程值设置为 200。最后运行 C，其行程值递增到 40。此时，算法将选择最低的行程值，即 C的行程值，然后运行C，将其行程值更新为 80（C 的步幅为 40）。然后 C 将再次运行（仍然是最低的行程值），将其行程值提升至 120。A 现在运行，将其行程值更新为 200（现在等于 B 的行程值）。然后 C 再运行两次，将其行程值更新为 160，然后是 200。此时，所有行程值再次相等，这个过程将无限重复。下表跟踪了调度器随时间变化的行为。\n\nPASS(A)   PASS(B)   PASS(C)   WHO RUNS?\n0         0         0         A\n100       0         0         B\n100       200       0         C\n100       200       40        C\n100       200       80        C\n100       200       120       A\n200       200       120       C\n200       200       160       C\n200       200       200       ...\n\n从上表可以看出，C运行了5次，A2次，B只有一次，正好与它们的彩票值 250、100 和 50 成比例。彩票调度是随着时间的推移概率性地实现比例的，而步幅调度则是在每个调度周期结束时精确地实现比例。\n\n所以你可能想知道：跨步调度这么精准，为什么还要使用彩票调度呢？嗯，彩票调度有一个步幅调度没有的好特性：没有全局状态。想象一下，在上面的跨步调度示例中，有一个新作业进入；它的行程值应该是多少？应该设置为0吗？如果是的话，就会独占CPU。对于彩票调度，每个进程没有全局状态；我们只需添加一个新进程及其拥有的任何彩票，更新单个全局变量以跟踪我们总共拥有多少彩票，然后从那里开始。通过这种方式，彩票以合理的方式合并新进程更加容易。\n\n\n# 7 Linux完全公平调度器（CFS）\n\n尽管在公平份额调度方面已有早期工作，但当前的Linux方法以另一种方式实现了类似的目标。名为完全公平调度器（或CFS）的调度器实施了公平份额调度，但是以高效且可扩展的方式进行。\n\n为了实现其效率目标，CFS通过其固有设计和对任务非常适合的数据结构巧妙地使用极少时间做出调度决策。最近研究表明，调度器效率非常重要；具体而言，在对谷歌数据中心进行研究时，Kanev等人发现，即使经过积极优化，调度仍然占用整个数据中心约5%的CPU时间。因此，尽可能减少开销是现代调度程序架构的一个关键目标。\n\n\n# 7.1 基本操作\n\n大多数调度程序都基于固定时间片的概念，而 CFS 的运行方式则有些不同。它的目标很简单：将 CPU 公平地平均分配给所有竞争进程。它通过一种简单的基于计数的技术来实现这一目标，这种技术被称为虚拟运行时间（vruntime）。\n\n每个进程运行时，都会累积vruntime。在最基本的情况下，每个进程的 vruntime 都以相同的速率增长，与物理（实际）时间成比例。在进行调度决策时，CFS 会选择 vruntime 最低的进程作为下一个运行进程。\n\n那这就提出了一个问题：调度器怎么知道何时停止正在运行的进程，并运行下一个进程呢？这里矛盾就很明显：如果 CFS 切换过于频繁，公平性就会提高，因为 CFS 将确保每个进程即使在极小的时间窗口内也能获得其 CPU 份额，但代价是性能降低（上下文切换过多）；如果 CFS 切换频率降低，性能就会提高（上下文切换减少），但代价是近期公平性降低。\n\nCFS通过各种控制参数来管理这种矛盾。第一个是sched_latency（调度延迟），CFS使用该值来确定一个进程在考虑切换之前应运行多长时间（以动态方式有效确定其时间片）。典型的sched_latency值为484848（毫秒），CFS 将该值除以 CPU 上运行的进程数（n），以确定进程的时间片，从而确保在这段时间内，CFS 完全公平。\n\n例如，如果这有n=4n=4n=4的进程在运行，CFS将sched_latency的值除以nnn得出每个进程的时间片为12ms12\\text{ms}12ms。然后，CFS 会调度第一个作业并运行它，直到用完 12ms12\\text{ms}12ms 的（虚拟）运行时间，然后检查是否有 vruntime 更低的作业可替代运行。在这种情况下，如果有，CFS 就会切换到其他三个作业中的一个，依此类推。下图展示了这样一个例子：四个作业（A、B、C、D）以这种方式各运行两个时间片；其中两个作业（C、D）完成后，只剩下两个作业，然后它们以循环方式各运行 12ms12\\text{ms}12ms。\n\n\n\n但如果有 \"太多 \"进程在运行呢？这会不会导致时间片太小，从而导致太多的上下文切换？答案是肯定的。\n\n为了解决这个问题，CFS增加了另一个参数min_granularity，通常设置为 6 ms。CFS绝不会设置进程的时间片小于值，确保不会在调度开销上花费太多时间。\n\n例如，这有10个进程正在运行，我们原来的计算会用sched_latency除以101010得出进程时间片（结果为4.8ms4.8\\text{ms}4.8ms）。但因为min_granularity，CFS会每个进程的时间片设置为6ms6\\text{ms}6ms。虽然 CFS 的公平性不会超过在 4.8ms4.8\\text{ms}4.8ms 的目标调度延迟（sched_latency），但它将接近目标值，同时仍能实现较高的 CPU 效率。\n\n需要的注意是，CFS 使用的是周期性定时器中断，这意味着它只能在固定的时间间隔内做出决定。该中断会频繁响起（例如，每 1 ms响一次），让 CFS 有机会唤醒并确定当前作业是否已运行结束。如果作业的时间片不是定时器中断间隔的整数倍，也没关系；CFS 会精确跟踪 vruntime，这意味着从长远来看，它最终会接近理想的 CPU 共享状态。\n\n\n# 7.2 权重（优先级）\n\nCFS 还可以控制进程优先级，使用户或管理员能够为某些进程提供更高的 CPU 份额。它不是通过彩票来实现这一点，而是通过经典 UNIX 机制—进程的nice级别的来实现这一点。对于进程，nice 参数可以设置为 -20 到 +19 之间的任意值，默认值为 0。正的 Nice 值意味着较低的优先级，负值意味着较高的优先级；当你太好的时候，你就不会得到那么多（安排）关注，唉。\n\nCFS将每个进程的nice值映射到一个权重，如下所示：\n\nstatic const int prio_to_weight[40] = {\n\t/* -20 */ 88761, 71755, 56483, 46273, 36291,\n    /* -15 */ 29154, 23254, 18705, 14949, 11916,\n    /* -10 */ 9548, 7620, 6100, 4904, 3906,\n    /* -5 */ 3121, 2501, 1991, 1586, 1277,\n    /* 0 */ 1024, 820, 655, 526, 423,\n    /* 5 */ 335, 272, 215, 172, 137,\n    /* 10 */ 110, 87, 70, 56, 45,\n    /* 15 */ 36, 29, 23, 18, 15,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n有了这些权重，我们就可以计算每个进程的有效时间片（就像我们之前所做的），但现在要考虑它们的优先级差异。计算公式如下：\n\ntime_slicek=weightk∑i=0n−1weighti⋅sched_latency\\text{time\\_slice}_k= \\frac {\\text{weight}_k}{\\sum _ {i=0}^ {n-1}\\text{weight}_ {i}} \\cdot \\text{sched\\_latency} time_slicek =∑i=0n−1 weighti weightk ⋅sched_latency\n\n让我们举个例子来看看它是如何工作的。假定有两个工作，A 和 B。A 因为是我们最宝贵的工作，所以优先级较高，nice值为−5-5−5；B 因为我们不喜欢它，所以优先级为默认值（nice值等于 0）。这意味着weightA\\text{weight}_AweightA （来自权重表）为 3121，而weightB\\text{weight}_BweightB 为 1024。如果计算每个作业的时间片，就会发现 A 的时间片约为sched_latency的 34\\frac{3}{4}43 （即 36ms36\\text{ms}36ms），而 B 约为14\\frac{1}{4}41 （即 12ms12\\text{ms}12ms）。\n\n除了泛化时间片计算外，CFS计算vruntime的方式也必须进行调整，以下是新公式：\n\nvruntimei=vruntimei+weight0weighti⋅runtimei\\text{vruntime}_i=\\text{vruntime}_i+\\frac{\\text{weight}_0}{\\text{weight}_i}\\cdot \\text{runtime}_i vruntimei =vruntimei +weighti weight0 ⋅runtimei\n\n它根据进程iii累积的实际运行时间（runtimei\\text{runtime}_iruntimei ），并与进程的权重成反比。在我们的运行示例中，A 的 vruntime 累积速度是 B 的三分之一。\n\n构建上述权重表的一个巧妙之处在于，当 nice 值的差异恒定时，该表保留了 CPU 比例。例如，如果进程 A 的 nice 值为 5（不是 -5），进程 B 的 nice 值为 10（不是 0），则 CFS 将以与之前完全相同的方式调度它们。\n\n\n# 7.3 使用红黑树\n\n如上所述，CFS 的一个重点是效率。对于调度器来说，效率有很多方面，但其中一个方面非常简单：当调度器需要查找下一个要运行的作业时，它应该尽可能快地找到该作业。简单的数据结构（如列表）不具扩展性：现代系统有时由上千个进程组成，因此每隔几毫秒搜索一次长列表会非常浪费。\n\nCFS 通过将进程保留在红黑树上来解决这个问题。红黑树是多种类型的平衡树之一；与简单的二叉树（在最糟糕的插入模式下，它的性能会退化到类似于列表）不同，平衡树需要做一些额外的工作来保持较低的深度，从而确保操作在时间上是log⁡\\loglog（而非线性）的。\n\nCFS 不会将所有进程都保存在此结构中；相反，只有正在运行（或可运行）的进程才会保存在此结构中。如果某个进程进入休眠状态（例如，等待 I/O 完成或等待网络数据包到达），它就会从进程树中删除，并在其他地方跟踪。\n\n让我们看一个例子来更清楚地说明这一点。假设有十个作业，它们的 vruntime 值分别为：1、5、9、10、14、18、17、21、22 和 24。如果我们将这些作业保存在一个有序列表中，那么查找下一个要运行的作业就很简单了：只需删除第一个元素即可。但是，如果将该作业按顺序放回列表中，我们必须扫描这个列表，寻找正确的位置插入，这是一个 O(n)O(n)O(n) 运算。任何搜索的效率也很低，平均也需要线性时间。\n\n而在红黑树上保持相同的值可以提高大多数操作的效率，如下图所示。\n\n进程在树中按 vruntime 排序，大多数操作（如插入和删除）的时间都是对数级别，即 O(log⁡n)O(\\log n)O(logn)。当 n 越来越大，对数效率明显高于线性效率。\n\n\n# 7.4 处理I/O和休眠进程\n\n对于已经进入休眠状态很长一段时间的作业来说，选择下一个运行的最低 vruntime 会出现一个问题。例如有两个进程 A 和 B，其中一个 (A) 连续运行，另一个 (B) 已经进入休眠状态很长一段时间（例如 10 秒）。当 B 醒来时，它的 vruntime 将落后 A 10 秒，因此（如果我们不小心的话），B 现在将在接下来的 10 秒内独占 CPU，同时赶上 A，这实际上会让A饥饿。\n\nCFS 通过在作业唤醒时更改其 vruntime来处理这种情况。具体来说，CFS 会将该作业的 vruntime 设置为在树中找到的最小值（记住，树中只包含正在运行的作业）。通过这种方式，CFS 避免了饥饿，但也并非没有代价：短时间睡眠的作业往往无法获得公平的 CPU 份额。\n\n\n# 8 总结\n\n我们介绍了比例份额调度的概念，并简要讨论了三种方法：彩票调度、步幅调度和 Linux 的完全公平调度器（CFS）。彩票调度巧妙地利用随机性来实现比例份额，而步幅调度则是确定性地实现比例份额。CFS 是本章讨论的唯一一种 \"真正的 \"调度程序，有点像带有动态时间片的加权循环调度程序，但其设计可在负载情况下进行扩展并表现良好；据我们所知，它是目前使用最广泛的公平分配调度程序。\n\n任何调度器都不是万能的，公平共享调度器也有自己的问题。其中一个问题是，这种方法与 I/O 并不十分匹配；如上所述，偶尔执行 I/O 的作业可能无法获得公平分配的 CPU。另一个问题是，它们没有解决彩票或优先级分配的难题，也就是说，你怎么知道应该给你的浏览器分配多少彩票，或者给你的文本编辑器设置nice的值呢？其他通用调度程序（如我们之前讨论过的 MLFQ 和其他类似的 Linux 调度程序）会自动处理这些问题，因此可能更容易部署。\n\n好消息是，在许多领域中，这些问题并不是主要问题，比例份额调度器的使用效果很好。例如，在虚拟化数据中心（或云计算）中，你可能希望将四分之一的 CPU 周期分配给 Windows VM，其余的分配给基本的 Linux 安装，按比例份额可以简单而有效地做到这一点。这个想法还可以扩展到其他地方。",normalizedContent:"在本章中，我们将研究一种不同类型的调度器，称为比例份额（proportional-share）调度器，有时也称为公平共享调度器。比例共享基于一个简单的概念：调度器可能会尝试保证每个作业获得一定百分比的 cpu 时间，而不是针对周转时间或响应时间进行优化。\n\n比例份额调度有一个非常出色的早期例子是彩票调度（lottery scheduling），由 waldspurger 和 weihl 发现。其基本思想非常简单，每隔一段时间，就会举行一次彩票抽奖，来确定接下来该运行哪个进程。更频繁运行的进程则更有机会中奖。\n\n在处理细节前先抛出我们的关键问题：如何按比例共享cpu？我们如何设计一个调度器以按比例共享 cpu？这样做的关键机制是什么？它们的效果如何？\n\n\n# 1 基本概念：彩票代表份额\n\n彩票调度背后是一个非常基本的概念：彩票数，代表了进程（或用户或其他）占有某个资源的份额。一个一个进程拥有的彩票数占总彩票数的百分比，就是它占有系统资源的份额。\n\n例如，有两个进程a和b，其中a有75张彩票，而b只有25张彩票。因此，我们希望a占有75%75\\%75%的cpu，b占有25%25\\%25%的cpu。\n\n彩票调度通过每隔一段时间（比如每个时间片）举行一次抽奖，以概率方式（而非确定方式）实现这一目标。举行抽奖很简单：调度器必须知道总共有多少张彩票（在我们的例子中，有 100 张彩票），调度器接下来随机抽取中奖彩票，是[0,99][0,99][0,99]的数字。假设 a 持有 0 到 74 号彩票，b 持有 75 到 99 号彩票，中奖彩票就决定了运行a或b。然后调度程序加载中奖进程的状态，并运行它。\n\n下面是彩票调度程序输出的中奖彩票和对应的调度结果:\n\n63   85   70   39   76   17   29   41   36   39   10   99   68   83   63   62   43   0   49   49\na         a    a         a    a    a    a    a    a         a         a    a    a    a   a    a\n     b              b                                  b         b                            \n\n从这个例子中我们可以看出，彩票调度的随机性导致了从概率上满足期望的比例，但不能确保。在上面的例子中，工作 b 运行了 20 个时间片中的 4 个，只是占了20%20\\%20%，而不是期望的25%25\\%25%。但是，这两个工作运行得时间越长，它们得到的 cpu 时间比例就会越接近期望。\n\n随机性决策有优势也有劣势：\n\n * 优势\n   1. 避免最差情况\n   2. 轻量，不需要记录过多状态，传统公平调度需要记录进程的大量状态\n   3. 随机方法很快，决策也快\n * 劣势\n   1. 系统行为可能不可预测，因为它们不受先前状态或输入的直接影响，这可能导致一些进程等待时间过长，而另一些则过短。\n   2. 可能导致性能波动\n\n> tip：使用彩票数代表份额\n> \n> 彩票（和步幅）调度设计中最强大（也是基本）的机制之一就是彩票数机制。在这些示例中，彩票数用于表示进程对 cpu 的份额，但其应用范围可以更广泛。例如，在虚拟机管理程序虚拟内存管理的最新研究中，waldspurger 展示了如何使用彩票数来表示客户操作系统的内存份额。因此，如果您需要一种机制来代表一定比例的所有权，这个概念可能就是……（等等）……彩票数。\n\n\n# 2 彩票机制\n\n彩票调度还提供了许多机制，以不同的方式（有时是有用的方式）操纵彩票。一种机制是彩票货币（ticket currency）。这种机制允许拥有一组彩票的用户在自己的工作中以任意货币分配彩票；然后系统会自动将所述货币转换为正确的全局彩票。\n\n例如，假设用户a和用户b都有100张彩票，a正在运行两个作业：a1和a2，然后用 a 的货币给它们每人 500 张彩票（总共 1000 张）。用户b正在运行一个作业，然后用b的货币给它分配10张彩票（总共10张）。系统将 a1 和 a2 的分配从 a 货币各 500 转换为全球货币各 50；同样，b1的10张票折算为100张票。然后在全球彩票货币（共 200 个）上进行抽签，以决定哪个工作运行。a1的具体计算方法是ticketa1ticketa1+ticketa2×ticketa\\frac{\\text{ticket}_{a1}}{\\text{ticket}_{a1}+\\text{ticket}_{a2}}\\times \\text{ticket}_{a}ticketa1 +ticketa2 ticketa1 ×ticketa ，其他同理。\n\nuser a\n\n-> 500 (a's ticket currency) to a1 -> 50 (global currency)\n\n-> 500 (a's ticket currency) to a2 -> 50 (global currency)\n\nuser b\n\n-> 10 (b's ticket currency) to b1 -> 100 (global currency)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n另一个有用的机制是彩票转让（ticket transfer）。通过转让，一个进程可以暂时将其彩票转让给另一个进程。这种能力在客户端/服务器设置中特别有用，其中客户端进程向服务器发送消息，要求服务器代表客户端执行一些工作。为了加快工作速度，客户端可以将彩票转让给服务器，并尝试最大化服务器的性能，同时处理客户端的请求。完成后，服务器将票据归还给客户端，一切如旧。\n\n最后，彩票通胀（ticket inflation）机制有时也很有用。通过通货膨胀，进程可以暂时增加或减少其拥有的彩票数。当然，在进程相互不信任的竞争场景中，这是没有意义的；一个贪婪的进程可以给自己大量的彩票从而接管机器。但是，通胀可以应用于一组进程相互信任的环境中。在这种情况下，如果任何一个进程知道它需要更多的 cpu 时间，它可以增加自己的彩票数，作为向系统反映该需求的一种方式，而无需与任何其他进程进行通信。\n\n\n# 3 实现\n\n彩票调度最令人惊叹的地方可能就是其实施的简单性。你只需要一个好的随机数生成器来挑选中奖彩票，一个跟踪系统进程的数据结构（如列表），以及彩票总数。\n\n假设我们将进程保存在一个列表中。下面是一个由 a、b 和 c 三个进程组成的示例，每个进程都有一定数量的彩票数。\n\n\n\n为了做出调度决策，我们首先要从门票总数（400） 中随机抽取一个数字（中奖号码）。然后，我们只需遍历列表，用一个简单的计数器帮助我们找到中奖者。\n\n# counter: used to track if we've found the winner yet\ncounter = 0\n\n# winner: use some call to a random number generator to get a value, between 0 and the total # of tickets\nwinner = random.randint(0, totaltickets)\n\n# current: use this to walk through the list of jobs\ncurrent = head\n\n# loop until the sum of ticket values is > the winner\nwhile current:\n    counter = counter + current.tickets\n    if counter > winner:\n        break  # found the winner\n    current = current.next\n\n# 'current' is the winner: schedule it...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n该代码从前往后遍历进程列表，将每个彩票值添加到计数器中，直到该值超过获胜者。一旦出现这种情况，当前列表进程就是中奖者。以中奖彩票为 300 的示例为例，会发生以下情况。首先，计数器增加到 100 以计算 a 的票；因为 100 小于 300，所以循环继续。然后计数器会更新为 150（b 的票），仍然少于 300，因此我们再次继续。最后，计数器更新为 400（明显大于 300），因此我们跳出循环，当前指向 c（中奖者）。\n\n要让这个过程更有效率，建议将列表项按照彩票数递减排序。这个顺序并不会影响算法的正确性，但能保证用最小的迭代次数找到需要的结点，尤其当大多彩票被少数进程掌握时。\n\n\n# 4 评估指标\n\n为了更容易理解动态彩票调度，我们现在对两个相互竞争的作业的完成时间进行简要研究，每个作业都有相同数量的彩票 (100) 和相同的运行时间 (r，我们将改变它) 。\n\n在这种情况下，我们希望每个作业大致在同一时间完成，但由于彩票调度的随机性，有时一个作业会先于另一个作业完成。为了量化这种差异，我们定义了一个简单的不公平指标（unfairness metric） uuu，它就是第一个作业完成的时间除以第二个作业完成的时间。\n\n例如，如果 r = 10，并且第一个作业在 10 完成（第二个作业在 20 完成），则 u=1020=0.5u=\\frac{10}{20}=0.5u=2010 =0.5。当两个作业几乎同时完成时，uuu 将非常接近 1。在这种情况下，这就是我们的目标：完全公平的调度程序将实现 u=1u = 1u=1。\n\n下图描绘了在30次试验中，两个作业（r）的长度从1到1000不等时的平均不公平性。从图中可以看出，当工作时间不长时，平均不公平现象可能相当严重。只有当作业运行了大量的时间片时，彩票调度程序才能接近所需的结果。\n\n\n# 5 如何分配彩票\n\n在彩票调度方面，我们尚未解决的一个问题是：如何为作业分配彩票？这是一个棘手的问题，因为系统如何运行当然在很大程度上取决于如何分配彩票。一种方法是假定用户最了解情况；在这种情况下，每个用户都会得到一定数量的门票，用户可以根据需要将门票分配给他们运行的任何作业。然而，这种解决方案不是解决方案：它并没有告诉你该怎么做。因此，在给定一系列工作的情况下，\"彩票分配问题 \"仍然悬而未决。\n\n\n# 6 步幅调度\n\n你可能还想知道：为什么要使用随机性呢？如上所述，虽然随机性可以为我们提供一个简单（且近似正确）的调度器，但它偶尔无法提供精确正确的比例，尤其是在短时间内。为此，waldspurger 发明了一种确定性公平分配调度器—步幅调度器 。\n\n步幅调度也很简单，系统中每个作业都有一个步幅，这与它拥有的彩票数成反比。在上面的示例中，对于作业 a、b 和 c，分别有 100、50 和 250 张彩票，我们可以通过将某个较大的数字除以每个进程分配的彩票数量来计算每个作业的步幅。例如，如果我们用 10,000 除以每个彩票值，我们将获得 a、b 和 c 的步幅值：100、200 和 40。我们将此值称为每个进程的步幅；每次进程运行时，我们都会按其步幅增加它的计数器（称为其行程值），以跟踪其全局进度。\n\n然后，调度程序使用步幅和行程值来确定接下来应该运行哪个进程。基本思想很简单：在任何给定时间，选择迄今为止具有最低行程值的进程来运行；当您运行一个进程时，按其步幅增加其行程值。 waldspurger 提供了伪代码实现：\n\ncurr = remove_min(queue); // pick client with min pass\nschedule(curr); // run for quantum\ncurr->pass += curr->stride; // update pass using stride\ninsert(queue, curr); // return curr to queue\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n在我们的示例中，一开始有三个进程（a、b 和 c），它们的步幅分别为 100、200 和 40，所有进程的行程值最初都是 0。假设我们选择 a（任意选择；可以选择任何一个行程值同样低的进程）。a 运行后，在完成时间片后，我们将其行程值更新为 100。然后运行 b，将其行程值设置为 200。最后运行 c，其行程值递增到 40。此时，算法将选择最低的行程值，即 c的行程值，然后运行c，将其行程值更新为 80（c 的步幅为 40）。然后 c 将再次运行（仍然是最低的行程值），将其行程值提升至 120。a 现在运行，将其行程值更新为 200（现在等于 b 的行程值）。然后 c 再运行两次，将其行程值更新为 160，然后是 200。此时，所有行程值再次相等，这个过程将无限重复。下表跟踪了调度器随时间变化的行为。\n\npass(a)   pass(b)   pass(c)   who runs?\n0         0         0         a\n100       0         0         b\n100       200       0         c\n100       200       40        c\n100       200       80        c\n100       200       120       a\n200       200       120       c\n200       200       160       c\n200       200       200       ...\n\n从上表可以看出，c运行了5次，a2次，b只有一次，正好与它们的彩票值 250、100 和 50 成比例。彩票调度是随着时间的推移概率性地实现比例的，而步幅调度则是在每个调度周期结束时精确地实现比例。\n\n所以你可能想知道：跨步调度这么精准，为什么还要使用彩票调度呢？嗯，彩票调度有一个步幅调度没有的好特性：没有全局状态。想象一下，在上面的跨步调度示例中，有一个新作业进入；它的行程值应该是多少？应该设置为0吗？如果是的话，就会独占cpu。对于彩票调度，每个进程没有全局状态；我们只需添加一个新进程及其拥有的任何彩票，更新单个全局变量以跟踪我们总共拥有多少彩票，然后从那里开始。通过这种方式，彩票以合理的方式合并新进程更加容易。\n\n\n# 7 linux完全公平调度器（cfs）\n\n尽管在公平份额调度方面已有早期工作，但当前的linux方法以另一种方式实现了类似的目标。名为完全公平调度器（或cfs）的调度器实施了公平份额调度，但是以高效且可扩展的方式进行。\n\n为了实现其效率目标，cfs通过其固有设计和对任务非常适合的数据结构巧妙地使用极少时间做出调度决策。最近研究表明，调度器效率非常重要；具体而言，在对谷歌数据中心进行研究时，kanev等人发现，即使经过积极优化，调度仍然占用整个数据中心约5%的cpu时间。因此，尽可能减少开销是现代调度程序架构的一个关键目标。\n\n\n# 7.1 基本操作\n\n大多数调度程序都基于固定时间片的概念，而 cfs 的运行方式则有些不同。它的目标很简单：将 cpu 公平地平均分配给所有竞争进程。它通过一种简单的基于计数的技术来实现这一目标，这种技术被称为虚拟运行时间（vruntime）。\n\n每个进程运行时，都会累积vruntime。在最基本的情况下，每个进程的 vruntime 都以相同的速率增长，与物理（实际）时间成比例。在进行调度决策时，cfs 会选择 vruntime 最低的进程作为下一个运行进程。\n\n那这就提出了一个问题：调度器怎么知道何时停止正在运行的进程，并运行下一个进程呢？这里矛盾就很明显：如果 cfs 切换过于频繁，公平性就会提高，因为 cfs 将确保每个进程即使在极小的时间窗口内也能获得其 cpu 份额，但代价是性能降低（上下文切换过多）；如果 cfs 切换频率降低，性能就会提高（上下文切换减少），但代价是近期公平性降低。\n\ncfs通过各种控制参数来管理这种矛盾。第一个是sched_latency（调度延迟），cfs使用该值来确定一个进程在考虑切换之前应运行多长时间（以动态方式有效确定其时间片）。典型的sched_latency值为484848（毫秒），cfs 将该值除以 cpu 上运行的进程数（n），以确定进程的时间片，从而确保在这段时间内，cfs 完全公平。\n\n例如，如果这有n=4n=4n=4的进程在运行，cfs将sched_latency的值除以nnn得出每个进程的时间片为12ms12\\text{ms}12ms。然后，cfs 会调度第一个作业并运行它，直到用完 12ms12\\text{ms}12ms 的（虚拟）运行时间，然后检查是否有 vruntime 更低的作业可替代运行。在这种情况下，如果有，cfs 就会切换到其他三个作业中的一个，依此类推。下图展示了这样一个例子：四个作业（a、b、c、d）以这种方式各运行两个时间片；其中两个作业（c、d）完成后，只剩下两个作业，然后它们以循环方式各运行 12ms12\\text{ms}12ms。\n\n\n\n但如果有 \"太多 \"进程在运行呢？这会不会导致时间片太小，从而导致太多的上下文切换？答案是肯定的。\n\n为了解决这个问题，cfs增加了另一个参数min_granularity，通常设置为 6 ms。cfs绝不会设置进程的时间片小于值，确保不会在调度开销上花费太多时间。\n\n例如，这有10个进程正在运行，我们原来的计算会用sched_latency除以101010得出进程时间片（结果为4.8ms4.8\\text{ms}4.8ms）。但因为min_granularity，cfs会每个进程的时间片设置为6ms6\\text{ms}6ms。虽然 cfs 的公平性不会超过在 4.8ms4.8\\text{ms}4.8ms 的目标调度延迟（sched_latency），但它将接近目标值，同时仍能实现较高的 cpu 效率。\n\n需要的注意是，cfs 使用的是周期性定时器中断，这意味着它只能在固定的时间间隔内做出决定。该中断会频繁响起（例如，每 1 ms响一次），让 cfs 有机会唤醒并确定当前作业是否已运行结束。如果作业的时间片不是定时器中断间隔的整数倍，也没关系；cfs 会精确跟踪 vruntime，这意味着从长远来看，它最终会接近理想的 cpu 共享状态。\n\n\n# 7.2 权重（优先级）\n\ncfs 还可以控制进程优先级，使用户或管理员能够为某些进程提供更高的 cpu 份额。它不是通过彩票来实现这一点，而是通过经典 unix 机制—进程的nice级别的来实现这一点。对于进程，nice 参数可以设置为 -20 到 +19 之间的任意值，默认值为 0。正的 nice 值意味着较低的优先级，负值意味着较高的优先级；当你太好的时候，你就不会得到那么多（安排）关注，唉。\n\ncfs将每个进程的nice值映射到一个权重，如下所示：\n\nstatic const int prio_to_weight[40] = {\n\t/* -20 */ 88761, 71755, 56483, 46273, 36291,\n    /* -15 */ 29154, 23254, 18705, 14949, 11916,\n    /* -10 */ 9548, 7620, 6100, 4904, 3906,\n    /* -5 */ 3121, 2501, 1991, 1586, 1277,\n    /* 0 */ 1024, 820, 655, 526, 423,\n    /* 5 */ 335, 272, 215, 172, 137,\n    /* 10 */ 110, 87, 70, 56, 45,\n    /* 15 */ 36, 29, 23, 18, 15,\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n有了这些权重，我们就可以计算每个进程的有效时间片（就像我们之前所做的），但现在要考虑它们的优先级差异。计算公式如下：\n\ntime_slicek=weightk∑i=0n−1weighti⋅sched_latency\\text{time\\_slice}_k= \\frac {\\text{weight}_k}{\\sum _ {i=0}^ {n-1}\\text{weight}_ {i}} \\cdot \\text{sched\\_latency} time_slicek =∑i=0n−1 weighti weightk ⋅sched_latency\n\n让我们举个例子来看看它是如何工作的。假定有两个工作，a 和 b。a 因为是我们最宝贵的工作，所以优先级较高，nice值为−5-5−5；b 因为我们不喜欢它，所以优先级为默认值（nice值等于 0）。这意味着weighta\\text{weight}_aweighta （来自权重表）为 3121，而weightb\\text{weight}_bweightb 为 1024。如果计算每个作业的时间片，就会发现 a 的时间片约为sched_latency的 34\\frac{3}{4}43 （即 36ms36\\text{ms}36ms），而 b 约为14\\frac{1}{4}41 （即 12ms12\\text{ms}12ms）。\n\n除了泛化时间片计算外，cfs计算vruntime的方式也必须进行调整，以下是新公式：\n\nvruntimei=vruntimei+weight0weighti⋅runtimei\\text{vruntime}_i=\\text{vruntime}_i+\\frac{\\text{weight}_0}{\\text{weight}_i}\\cdot \\text{runtime}_i vruntimei =vruntimei +weighti weight0 ⋅runtimei\n\n它根据进程iii累积的实际运行时间（runtimei\\text{runtime}_iruntimei ），并与进程的权重成反比。在我们的运行示例中，a 的 vruntime 累积速度是 b 的三分之一。\n\n构建上述权重表的一个巧妙之处在于，当 nice 值的差异恒定时，该表保留了 cpu 比例。例如，如果进程 a 的 nice 值为 5（不是 -5），进程 b 的 nice 值为 10（不是 0），则 cfs 将以与之前完全相同的方式调度它们。\n\n\n# 7.3 使用红黑树\n\n如上所述，cfs 的一个重点是效率。对于调度器来说，效率有很多方面，但其中一个方面非常简单：当调度器需要查找下一个要运行的作业时，它应该尽可能快地找到该作业。简单的数据结构（如列表）不具扩展性：现代系统有时由上千个进程组成，因此每隔几毫秒搜索一次长列表会非常浪费。\n\ncfs 通过将进程保留在红黑树上来解决这个问题。红黑树是多种类型的平衡树之一；与简单的二叉树（在最糟糕的插入模式下，它的性能会退化到类似于列表）不同，平衡树需要做一些额外的工作来保持较低的深度，从而确保操作在时间上是log⁡\\loglog（而非线性）的。\n\ncfs 不会将所有进程都保存在此结构中；相反，只有正在运行（或可运行）的进程才会保存在此结构中。如果某个进程进入休眠状态（例如，等待 i/o 完成或等待网络数据包到达），它就会从进程树中删除，并在其他地方跟踪。\n\n让我们看一个例子来更清楚地说明这一点。假设有十个作业，它们的 vruntime 值分别为：1、5、9、10、14、18、17、21、22 和 24。如果我们将这些作业保存在一个有序列表中，那么查找下一个要运行的作业就很简单了：只需删除第一个元素即可。但是，如果将该作业按顺序放回列表中，我们必须扫描这个列表，寻找正确的位置插入，这是一个 o(n)o(n)o(n) 运算。任何搜索的效率也很低，平均也需要线性时间。\n\n而在红黑树上保持相同的值可以提高大多数操作的效率，如下图所示。\n\n进程在树中按 vruntime 排序，大多数操作（如插入和删除）的时间都是对数级别，即 o(log⁡n)o(\\log n)o(logn)。当 n 越来越大，对数效率明显高于线性效率。\n\n\n# 7.4 处理i/o和休眠进程\n\n对于已经进入休眠状态很长一段时间的作业来说，选择下一个运行的最低 vruntime 会出现一个问题。例如有两个进程 a 和 b，其中一个 (a) 连续运行，另一个 (b) 已经进入休眠状态很长一段时间（例如 10 秒）。当 b 醒来时，它的 vruntime 将落后 a 10 秒，因此（如果我们不小心的话），b 现在将在接下来的 10 秒内独占 cpu，同时赶上 a，这实际上会让a饥饿。\n\ncfs 通过在作业唤醒时更改其 vruntime来处理这种情况。具体来说，cfs 会将该作业的 vruntime 设置为在树中找到的最小值（记住，树中只包含正在运行的作业）。通过这种方式，cfs 避免了饥饿，但也并非没有代价：短时间睡眠的作业往往无法获得公平的 cpu 份额。\n\n\n# 8 总结\n\n我们介绍了比例份额调度的概念，并简要讨论了三种方法：彩票调度、步幅调度和 linux 的完全公平调度器（cfs）。彩票调度巧妙地利用随机性来实现比例份额，而步幅调度则是确定性地实现比例份额。cfs 是本章讨论的唯一一种 \"真正的 \"调度程序，有点像带有动态时间片的加权循环调度程序，但其设计可在负载情况下进行扩展并表现良好；据我们所知，它是目前使用最广泛的公平分配调度程序。\n\n任何调度器都不是万能的，公平共享调度器也有自己的问题。其中一个问题是，这种方法与 i/o 并不十分匹配；如上所述，偶尔执行 i/o 的作业可能无法获得公平分配的 cpu。另一个问题是，它们没有解决彩票或优先级分配的难题，也就是说，你怎么知道应该给你的浏览器分配多少彩票，或者给你的文本编辑器设置nice的值呢？其他通用调度程序（如我们之前讨论过的 mlfq 和其他类似的 linux 调度程序）会自动处理这些问题，因此可能更容易部署。\n\n好消息是，在许多领域中，这些问题并不是主要问题，比例份额调度器的使用效果很好。例如，在虚拟化数据中心（或云计算）中，你可能希望将四分之一的 cpu 周期分配给 windows vm，其余的分配给基本的 linux 安装，按比例份额可以简单而有效地做到这一点。这个想法还可以扩展到其他地方。",charsets:{cjk:!0},lastUpdated:"2024/05/11, 20:33:38",lastUpdatedTimestamp:1715430818e3},{title:"段",frontmatter:{title:"段",tags:["OS"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},date:"2024-04-25T22:37:48.000Z",permalink:"/pages/506cee/",categories:["开发","系统架构","操作系统","虚拟化"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/02.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/11.%E6%AE%B5.html",relativePath:"01.开发/05.系统架构/02.操作系统/11.段.md",key:"v-3be97cb8",path:"/pages/506cee/",headers:[{level:2,title:"1 分段：广义基数/边界",slug:"_1-分段-广义基数-边界",normalizedTitle:"1 分段：广义基数/边界",charIndex:2},{level:2,title:"2 引用段",slug:"_2-引用段",normalizedTitle:"2 引用段",charIndex:1329},{level:2,title:"3 关于栈",slug:"_3-关于栈",normalizedTitle:"3 关于栈",charIndex:2568},{level:2,title:"4 支持段共享",slug:"_4-支持段共享",normalizedTitle:"4 支持段共享",charIndex:3357},{level:2,title:"5 细粒度分段与粗粒度分段",slug:"_5-细粒度分段与粗粒度分段",normalizedTitle:"5 细粒度分段与粗粒度分段",charIndex:3818},{level:2,title:"6 操作系统支持",slug:"_6-操作系统支持",normalizedTitle:"6 操作系统支持",charIndex:4160},{level:2,title:"7 总结",slug:"_7-总结",normalizedTitle:"7 总结",charIndex:5257}],headersStr:"1 分段：广义基数/边界 2 引用段 3 关于栈 4 支持段共享 5 细粒度分段与粗粒度分段 6 操作系统支持 7 总结",content:"# 1 分段：广义基数/边界\n\n到目前为止，我们已经将每个进程的整个地址空间放入内存中。通过基址寄存器和边界寄存器，操作系统可以轻松地将进程重新定位到物理内存的不同部分。然而，您可能已经注意到我们的这些地址空间有一些有趣的地方：在栈和堆之间的中间有一大块“空闲”空间，如下图所示。\n\n虽然栈和堆之间的空间没有被进程使用，但当我们将整个地址空间重新定位到物理内存中的某个位置时，它仍然占用物理内存；因此，使用基址和边界寄存器对来虚拟化内存的简单方法是浪费的。当整个地址空间无法放入内存时，它也会使程序的运行变得非常困难；因此，基数和边界并不像我们希望的那样灵活。因此：关键：如何支持大地址空间 我们如何支持大地址空间以及栈和堆之间（可能）有大量可用空间？\n\n为了解决这个问题，一个想法应运而生，它就是分段。这是一个相当古老的想法，至少可以追溯到 1960 年代初。这个想法很简单：与其在我们的 MMU 中只有一个基址和边界对，为什么不在地址空间的每个逻辑段都有一个基址和边界对呢？段只是特定长度的地址空间的连续部分，在我们的规范地址空间中，我们有三个逻辑上不同的段：代码、栈和堆。分段允许操作系统做的是将每个段放置在物理内存的不同部分，从而避免用未使用的虚拟地址空间填充物理内存。\n\n让我们看一下例子，假设我们要将下图中的地址空间放入物理内存中。由于每个段都有一个基址和边界对，我们可以将每个段独立地放置在物理内存中。您可以看到 64KB 物理内存，其中包含这三个段（还有 16KB 为操作系统保留）\n\n从图中可以看到，代码段放置在物理地址32KB，大小为2KB，堆段放置在34KB，大小也为2KB。假设对虚拟地址 100（位于代码段中，代码段从地址空间中的虚拟地址0开始。）进行了引用。当发生引用时（例如，在指令获取时），硬件会将基址值添加到该段的偏移量（本例中为 100），以达到所需的物理地址：100 + 32KB，或 32868。然后检查该地址是否在范围内（100小于2KB），发现它在范围内，然后发出对物理内存地址32868的引用。\n\n现在让我们看一下堆中的一个地址，虚拟地址 4200，如下图所示。如果我们只是将虚拟地址 4200 添加到堆基址 (34KB)，我们会得到物理地址 39016，这不是正确的物理地址。我们首先需要做的是将偏移量提取到堆中，即地址引用了该段中的哪个字节。因为堆从虚拟地址 4KB (4096) 开始，所以 4200 的偏移量实际上是 4200 减去 4096，即 104。然后我们将这个偏移量 (104) 添加到基址寄存器物理地址 (34K) 以获得所需的结果：34920。\n\n如果我们尝试引用非法地址，例如超出堆末尾的7KB，如下图所示，该怎么办？您可以想象会发生什么：硬件检测到地址越界，进入操作系统中断，可能导致违规进程终止。现在您知道了所有 C 程序员都害怕的著名术语的由来：分段违规或分段错误。\n\n> “分段错误”或“违规”是由分段机器上对非法地址的内存访问引起的。有趣的是，这个术语仍然存在，即使在根本不支持分段的机器上也是如此。或者，如果你无法弄清楚为什么你的代码总是出错，那就不那么幽默了。\n\n\n\n\n# 2 引用段\n\n硬件在转换期间使用段寄存器。它如何知道段中的偏移量以及地址引用哪个段？\n\n一种常见的方法（有时称为显式方法）是根据虚拟地址的前几位将地址空间分成多个段；该技术用于 VAX/VMS 系统。在上面的例子中，我们有三个部分；因此我们需要两个位来完成我们的任务。如果我们使用 14 位虚拟地址的前两位来选择段，我们的虚拟地址如下所示：\n\n\n\n在我们的示例中，如果前两位是 00，则硬件知道虚拟地址位于代码段中，因此使用代码基址和边界对将地址重新定位到正确的物理位置。如果前两位是 01，则硬件知道该地址在堆中，因此使用堆基址和边界。让我们以上面的示例堆虚拟地址 (4200) 为例并对其进行转换，只是为了确保这一点是清楚的。二进制形式的虚拟地址 4200 可以在这里看到：\n\n\n\n从图中可以看出，前两位 (01) 告诉硬件我们正在引用哪个段。底部 12 位是段中的偏移量：0000 0110 1000，或十六进制 0x068，或十进制 104。因此，硬件只需使用前两位来确定要使用哪个段寄存器，然后将接下来的 12 位作为段中的偏移量。通过将基址寄存器与偏移量相加，硬件得出最终的物理地址。请注意，偏移量也简化了边界检查：我们可以简单地检查偏移量是否小于边界；如果不是，则该地址是非法的。因此，如果基址和边界是数组（每个段一个条目），硬件将执行类似以下操作来获取所需的物理地址：\n\n// get top 2 bits of 14-bit VA\nSegment = (VirtualAddress & SEG_MASK) >> SEG_SHIFT;\n// now get offset\nOffset = VirtualAddress & OFFSET_MASK;\nif (Offset >= Bounds[Segment]) {\n    RaiseException(PROTECTION_FAULT);\n} else {\n    PhysAddr = Base[Segment] + Offset;\n    Register = AccessMemory(PhysAddr);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在我们的运行示例中，我们可以填写上面常量的值。具体来说，SEG MASK 将设置为 0x3000，SEG SHIFT 设置为 12，OFFSET MASK 设置为 0xFFF。您可能还注意到，当我们使用前两位时，并且只有三个段（代码、堆、栈），地址空间的一个段未被使用。因此，一些系统将代码放在与堆相同的段中，从而仅使用一位来选择要使用的段。\n\n硬件还有其他方法来确定特定地址位于哪个段。在隐式方法中，硬件通过注意地址的形成方式来确定段。例如，如果地址是从程序计数器生成的（即，它是指令提取），则该地址在代码段内；如果地址基于栈或基址指针，则它必须位于栈段中；任何其他地址则都位于堆中。\n\n\n# 3 关于栈\n\n到目前为止，我们遗漏了地址空间的一个重要组成部分：栈。上图中，栈已重新定位到物理地址 28KB，但有一个关键区别：它向后增长。在物理内存中，从28KB开始，增长到26KB，对应虚拟地址16KB到14KB；地址转换必须以不同的方式进行。\n\n我们首先需要的是一些额外的硬件支持。硬件不仅需要知道基址值和边界值，还需要知道段增长的方式（例如，当段沿正方向增长时设置为 1，当段沿负方向增长时设置为 0）。我们对硬件跟踪内容的更新视图如下表所示：\n\nSEGMENT   BASE   SIZE   GROWS POSITIVE?   PROTECTION\nCode      32K    2K     1                 Read-Execute\nHeap      34K    2K     1                 Read-Write\nStack     28K    2K     0                 Read-Write\n\n由于硬件了解段可以向负方向增长，因此硬件现在必须稍微不同地转换此类虚拟地址。让我们举一个栈虚拟地址的例子，并转换它来理解这个过程。\n\n在此示例中，假设我们希望访问虚拟地址 15KB，该地址应映射到物理地址 27KB。我们的二进制形式的虚拟地址如下所示：11 1100 0000 0000（十六进制0x3C00）。硬件使用前两位 (11) 来指定段，但我们留下了 3KB 的偏移量。为了获得正确的负偏移量，我们必须从 3KB 中减去最大段大小：在本例中，一个段可以是 4KB，因此正确的负偏移量是 3KB 减去 4KB，等于 -1KB。我们只需将负偏移量 (-1KB) 添加到基址 (28KB) 即可得到正确的物理地址：27KB。可以通过确保负偏移的绝对值小于段的大小来计算边界检查。\n\n\n# 4 支持段共享\n\n随着对分段的支持不断增长，系统设计人员很快意识到，他们可以通过更多的硬件支持来实现新型效率。具体来说，为了节省内存，有时在地址空间之间共享某些内存段很有用。特别是，代码共享很常见，并且在当今的系统中仍在使用。\n\n为了支持共享，我们需要硬件以保护位的形式提供一些额外的支持。基本支持为每个段添加一些位，指示程序是否可以读取或写入段，或者是否可以执行段内的代码。通过将代码段设置为只读，可以在多个进程之间共享相同的代码，而不必担心损害隔离性；虽然每个进程仍然认为它正在访问自己的私有内存，但操作系统正在秘密共享该进程无法修改的内存，因此保留了这种错觉。\n\n上表显示了硬件（和操作系统）跟踪的附加信息的示例。可以看到，代码段被设置为读取和执行，因此内存中的同一物理段可以映射到多个虚拟地址空间。\n\n有了保护位，前面描述的硬件算法也必须改变。除了检查虚拟地址是否在范围内之外，硬件还必须检查是否允许特定访问。如果用户进程尝试写入只读段，或从不可执行段执行，则硬件应引发异常，从而让操作系统处理违规进程。\n\n\n# 5 细粒度分段与粗粒度分段\n\n迄今为止，我们的大多数示例都集中在只有几个分段（即代码、栈、堆）的系统上；我们可以将这种分段视为粗粒度分段，因为它将地址空间分割成相对较大、较粗的块。然而，一些早期的系统（如 Multics）更加灵活，允许地址空间由大量较小的段组成，称为细粒度分段。\n\n支持多分段需要更多硬件支持，在内存中存储某种分段表。这种段表通常支持创建大量的段，从而使系统能够以比我们迄今为止讨论的更灵活的方式使用段。例如，早期的机器（如 Burroughs B5000）支持数千个分段，并期望编译器将代码和数据切分成独立的分段，然后操作系统和硬件将支持这些分段。当时的想法是，通过细化分段，操作系统可以更好地了解哪些分段正在使用，哪些没有使用，从而更有效地利用主内存。\n\n\n# 6 操作系统支持\n\n您现在应该对分段的工作原理有一个基本的了解。当系统运行时，地址空间的各个部分会被重新定位到物理内存中，因此，相对于整个地址空间仅使用单个基址/边界对的更简单方法，可以节省大量物理内存。具体来说，栈和堆之间所有未使用的空间都不需要分配在物理内存中，从而允许我们将更多的地址空间放入物理内存中。\n\n然而，分段引发了许多新问题。我们将首先描述必须解决的新操作系统问题。\n\n第一个是旧的：操作系统在上下文切换时应该做什么？现在您应该有一个很好的猜测：必须保存和恢复段寄存器。显然，每个进程都有自己的虚拟地址空间，操作系统必须确保在让进程再次运行之前正确设置这些寄存器。\n\n第二个也是更重要的问题是管理物理内存中的可用空间。当创建新的地址空间时，操作系统必须能够在物理内存中为其段找到空间。以前，我们假设每个地址空间的大小相同，因此物理内存可以被认为是进程可以容纳的一堆插槽。现在，每个进程有多个段，每个段可能是不同的尺寸。\n\n出现的普遍问题是物理内存很快就会充满可用空间的小孔，使得分配新段或增加现有段变得困难。我们称这个问题为外部碎片；如下图所示（左）。\n\n在示例中，一个进程出现并希望分配一个 20KB 的段。在该示例中，有 24KB 空闲空间，但不是在一个连续的段中（而是在三个不连续的块中）。因此，操作系统无法满足 20KB 请求。\n\n该问题的一种解决方案是通过重新排列现有段来压缩物理内存。例如，操作系统可以停止正在运行的进程，将其数据复制到一个连续的内存区域，更改其段寄存器值以指向新的物理位置，从而拥有大量可用的可用内存。通过这样做，操作系统使新的分配请求能够成功。然而，压缩的成本很高，且因为复制段是内存密集型的，并且通常会占用相当多的处理器时间。如上图所示（右），可查看压缩物理内存后的结果。\n\n一种更简单的方法是使用空闲列表管理算法，该算法尝试保持大范围的内存可用于分配。人们实际上已经采用了数百种方法，包括经典算法，例如最佳适应（保留可用空间列表并返回满足请求者所需分配的最接近大小的算法）、最差适应、首次适应，以及更复杂的方案，如伙伴算法 。但不幸的是，无论算法多么聪明，外部碎片仍然存在；因此，一个好的算法只是尝试将其最小化。\n\n> TIP：如果存在 1000 种解决方案，那么没有一个是最好的解决方案\n> \n> 存在如此多不同的算法来尝试最大限度地减少外部碎片这一事实表明了一个更强有力的潜在事实：没有一种“最佳”方法可以解决问题。因此，我们选择合理的东西，并希望它足够好。唯一真正的解决方案是完全避免这个问题，永远不要以可变大小的块分配内存。\n\n\n# 7 总结\n\n分段解决了许多问题，并帮助我们构建更有效的内存虚拟化。除了动态重定位之外，分段还可以通过避免地址空间的逻辑段之间潜在的巨大内存浪费来更好地支持稀疏地址空间。它也很快，因为进行算术分段所需的操作很容易并且非常适合硬件；地址转换费用很少。还出现了一个附带好处：代码共享。如果代码放置在单独的段中，则这样的段可能会在多个正在运行的程序之间共享。\n\n然而，正如我们所知，在内存中分配可变大小的段会导致一些我们希望克服的问题。如上所述，第一个是外部碎片。因为段是可变的，所以可用内存被分成奇数大小的块，因此满足内存分配请求可能很困难。人们可以尝试使用智能算法或定期压缩内存，但问题是根本性的且难以避免。\n\n第二个也许更重要的问题是分段仍然不够灵活，无法支持我们完全通用的稀疏地址空间。例如，如果我们在一个逻辑段中有一个大但很少使用的堆，则整个堆必须仍然驻留在内存中才能被访问。换句话说，如果我们的地址空间使用方式模型与底层分段的设计支持方式不完全匹配，分段就不能很好地工作。因此我们需要寻找一些新的解决方案。",normalizedContent:"# 1 分段：广义基数/边界\n\n到目前为止，我们已经将每个进程的整个地址空间放入内存中。通过基址寄存器和边界寄存器，操作系统可以轻松地将进程重新定位到物理内存的不同部分。然而，您可能已经注意到我们的这些地址空间有一些有趣的地方：在栈和堆之间的中间有一大块“空闲”空间，如下图所示。\n\n虽然栈和堆之间的空间没有被进程使用，但当我们将整个地址空间重新定位到物理内存中的某个位置时，它仍然占用物理内存；因此，使用基址和边界寄存器对来虚拟化内存的简单方法是浪费的。当整个地址空间无法放入内存时，它也会使程序的运行变得非常困难；因此，基数和边界并不像我们希望的那样灵活。因此：关键：如何支持大地址空间 我们如何支持大地址空间以及栈和堆之间（可能）有大量可用空间？\n\n为了解决这个问题，一个想法应运而生，它就是分段。这是一个相当古老的想法，至少可以追溯到 1960 年代初。这个想法很简单：与其在我们的 mmu 中只有一个基址和边界对，为什么不在地址空间的每个逻辑段都有一个基址和边界对呢？段只是特定长度的地址空间的连续部分，在我们的规范地址空间中，我们有三个逻辑上不同的段：代码、栈和堆。分段允许操作系统做的是将每个段放置在物理内存的不同部分，从而避免用未使用的虚拟地址空间填充物理内存。\n\n让我们看一下例子，假设我们要将下图中的地址空间放入物理内存中。由于每个段都有一个基址和边界对，我们可以将每个段独立地放置在物理内存中。您可以看到 64kb 物理内存，其中包含这三个段（还有 16kb 为操作系统保留）\n\n从图中可以看到，代码段放置在物理地址32kb，大小为2kb，堆段放置在34kb，大小也为2kb。假设对虚拟地址 100（位于代码段中，代码段从地址空间中的虚拟地址0开始。）进行了引用。当发生引用时（例如，在指令获取时），硬件会将基址值添加到该段的偏移量（本例中为 100），以达到所需的物理地址：100 + 32kb，或 32868。然后检查该地址是否在范围内（100小于2kb），发现它在范围内，然后发出对物理内存地址32868的引用。\n\n现在让我们看一下堆中的一个地址，虚拟地址 4200，如下图所示。如果我们只是将虚拟地址 4200 添加到堆基址 (34kb)，我们会得到物理地址 39016，这不是正确的物理地址。我们首先需要做的是将偏移量提取到堆中，即地址引用了该段中的哪个字节。因为堆从虚拟地址 4kb (4096) 开始，所以 4200 的偏移量实际上是 4200 减去 4096，即 104。然后我们将这个偏移量 (104) 添加到基址寄存器物理地址 (34k) 以获得所需的结果：34920。\n\n如果我们尝试引用非法地址，例如超出堆末尾的7kb，如下图所示，该怎么办？您可以想象会发生什么：硬件检测到地址越界，进入操作系统中断，可能导致违规进程终止。现在您知道了所有 c 程序员都害怕的著名术语的由来：分段违规或分段错误。\n\n> “分段错误”或“违规”是由分段机器上对非法地址的内存访问引起的。有趣的是，这个术语仍然存在，即使在根本不支持分段的机器上也是如此。或者，如果你无法弄清楚为什么你的代码总是出错，那就不那么幽默了。\n\n\n\n\n# 2 引用段\n\n硬件在转换期间使用段寄存器。它如何知道段中的偏移量以及地址引用哪个段？\n\n一种常见的方法（有时称为显式方法）是根据虚拟地址的前几位将地址空间分成多个段；该技术用于 vax/vms 系统。在上面的例子中，我们有三个部分；因此我们需要两个位来完成我们的任务。如果我们使用 14 位虚拟地址的前两位来选择段，我们的虚拟地址如下所示：\n\n\n\n在我们的示例中，如果前两位是 00，则硬件知道虚拟地址位于代码段中，因此使用代码基址和边界对将地址重新定位到正确的物理位置。如果前两位是 01，则硬件知道该地址在堆中，因此使用堆基址和边界。让我们以上面的示例堆虚拟地址 (4200) 为例并对其进行转换，只是为了确保这一点是清楚的。二进制形式的虚拟地址 4200 可以在这里看到：\n\n\n\n从图中可以看出，前两位 (01) 告诉硬件我们正在引用哪个段。底部 12 位是段中的偏移量：0000 0110 1000，或十六进制 0x068，或十进制 104。因此，硬件只需使用前两位来确定要使用哪个段寄存器，然后将接下来的 12 位作为段中的偏移量。通过将基址寄存器与偏移量相加，硬件得出最终的物理地址。请注意，偏移量也简化了边界检查：我们可以简单地检查偏移量是否小于边界；如果不是，则该地址是非法的。因此，如果基址和边界是数组（每个段一个条目），硬件将执行类似以下操作来获取所需的物理地址：\n\n// get top 2 bits of 14-bit va\nsegment = (virtualaddress & seg_mask) >> seg_shift;\n// now get offset\noffset = virtualaddress & offset_mask;\nif (offset >= bounds[segment]) {\n    raiseexception(protection_fault);\n} else {\n    physaddr = base[segment] + offset;\n    register = accessmemory(physaddr);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在我们的运行示例中，我们可以填写上面常量的值。具体来说，seg mask 将设置为 0x3000，seg shift 设置为 12，offset mask 设置为 0xfff。您可能还注意到，当我们使用前两位时，并且只有三个段（代码、堆、栈），地址空间的一个段未被使用。因此，一些系统将代码放在与堆相同的段中，从而仅使用一位来选择要使用的段。\n\n硬件还有其他方法来确定特定地址位于哪个段。在隐式方法中，硬件通过注意地址的形成方式来确定段。例如，如果地址是从程序计数器生成的（即，它是指令提取），则该地址在代码段内；如果地址基于栈或基址指针，则它必须位于栈段中；任何其他地址则都位于堆中。\n\n\n# 3 关于栈\n\n到目前为止，我们遗漏了地址空间的一个重要组成部分：栈。上图中，栈已重新定位到物理地址 28kb，但有一个关键区别：它向后增长。在物理内存中，从28kb开始，增长到26kb，对应虚拟地址16kb到14kb；地址转换必须以不同的方式进行。\n\n我们首先需要的是一些额外的硬件支持。硬件不仅需要知道基址值和边界值，还需要知道段增长的方式（例如，当段沿正方向增长时设置为 1，当段沿负方向增长时设置为 0）。我们对硬件跟踪内容的更新视图如下表所示：\n\nsegment   base   size   grows positive?   protection\ncode      32k    2k     1                 read-execute\nheap      34k    2k     1                 read-write\nstack     28k    2k     0                 read-write\n\n由于硬件了解段可以向负方向增长，因此硬件现在必须稍微不同地转换此类虚拟地址。让我们举一个栈虚拟地址的例子，并转换它来理解这个过程。\n\n在此示例中，假设我们希望访问虚拟地址 15kb，该地址应映射到物理地址 27kb。我们的二进制形式的虚拟地址如下所示：11 1100 0000 0000（十六进制0x3c00）。硬件使用前两位 (11) 来指定段，但我们留下了 3kb 的偏移量。为了获得正确的负偏移量，我们必须从 3kb 中减去最大段大小：在本例中，一个段可以是 4kb，因此正确的负偏移量是 3kb 减去 4kb，等于 -1kb。我们只需将负偏移量 (-1kb) 添加到基址 (28kb) 即可得到正确的物理地址：27kb。可以通过确保负偏移的绝对值小于段的大小来计算边界检查。\n\n\n# 4 支持段共享\n\n随着对分段的支持不断增长，系统设计人员很快意识到，他们可以通过更多的硬件支持来实现新型效率。具体来说，为了节省内存，有时在地址空间之间共享某些内存段很有用。特别是，代码共享很常见，并且在当今的系统中仍在使用。\n\n为了支持共享，我们需要硬件以保护位的形式提供一些额外的支持。基本支持为每个段添加一些位，指示程序是否可以读取或写入段，或者是否可以执行段内的代码。通过将代码段设置为只读，可以在多个进程之间共享相同的代码，而不必担心损害隔离性；虽然每个进程仍然认为它正在访问自己的私有内存，但操作系统正在秘密共享该进程无法修改的内存，因此保留了这种错觉。\n\n上表显示了硬件（和操作系统）跟踪的附加信息的示例。可以看到，代码段被设置为读取和执行，因此内存中的同一物理段可以映射到多个虚拟地址空间。\n\n有了保护位，前面描述的硬件算法也必须改变。除了检查虚拟地址是否在范围内之外，硬件还必须检查是否允许特定访问。如果用户进程尝试写入只读段，或从不可执行段执行，则硬件应引发异常，从而让操作系统处理违规进程。\n\n\n# 5 细粒度分段与粗粒度分段\n\n迄今为止，我们的大多数示例都集中在只有几个分段（即代码、栈、堆）的系统上；我们可以将这种分段视为粗粒度分段，因为它将地址空间分割成相对较大、较粗的块。然而，一些早期的系统（如 multics）更加灵活，允许地址空间由大量较小的段组成，称为细粒度分段。\n\n支持多分段需要更多硬件支持，在内存中存储某种分段表。这种段表通常支持创建大量的段，从而使系统能够以比我们迄今为止讨论的更灵活的方式使用段。例如，早期的机器（如 burroughs b5000）支持数千个分段，并期望编译器将代码和数据切分成独立的分段，然后操作系统和硬件将支持这些分段。当时的想法是，通过细化分段，操作系统可以更好地了解哪些分段正在使用，哪些没有使用，从而更有效地利用主内存。\n\n\n# 6 操作系统支持\n\n您现在应该对分段的工作原理有一个基本的了解。当系统运行时，地址空间的各个部分会被重新定位到物理内存中，因此，相对于整个地址空间仅使用单个基址/边界对的更简单方法，可以节省大量物理内存。具体来说，栈和堆之间所有未使用的空间都不需要分配在物理内存中，从而允许我们将更多的地址空间放入物理内存中。\n\n然而，分段引发了许多新问题。我们将首先描述必须解决的新操作系统问题。\n\n第一个是旧的：操作系统在上下文切换时应该做什么？现在您应该有一个很好的猜测：必须保存和恢复段寄存器。显然，每个进程都有自己的虚拟地址空间，操作系统必须确保在让进程再次运行之前正确设置这些寄存器。\n\n第二个也是更重要的问题是管理物理内存中的可用空间。当创建新的地址空间时，操作系统必须能够在物理内存中为其段找到空间。以前，我们假设每个地址空间的大小相同，因此物理内存可以被认为是进程可以容纳的一堆插槽。现在，每个进程有多个段，每个段可能是不同的尺寸。\n\n出现的普遍问题是物理内存很快就会充满可用空间的小孔，使得分配新段或增加现有段变得困难。我们称这个问题为外部碎片；如下图所示（左）。\n\n在示例中，一个进程出现并希望分配一个 20kb 的段。在该示例中，有 24kb 空闲空间，但不是在一个连续的段中（而是在三个不连续的块中）。因此，操作系统无法满足 20kb 请求。\n\n该问题的一种解决方案是通过重新排列现有段来压缩物理内存。例如，操作系统可以停止正在运行的进程，将其数据复制到一个连续的内存区域，更改其段寄存器值以指向新的物理位置，从而拥有大量可用的可用内存。通过这样做，操作系统使新的分配请求能够成功。然而，压缩的成本很高，且因为复制段是内存密集型的，并且通常会占用相当多的处理器时间。如上图所示（右），可查看压缩物理内存后的结果。\n\n一种更简单的方法是使用空闲列表管理算法，该算法尝试保持大范围的内存可用于分配。人们实际上已经采用了数百种方法，包括经典算法，例如最佳适应（保留可用空间列表并返回满足请求者所需分配的最接近大小的算法）、最差适应、首次适应，以及更复杂的方案，如伙伴算法 。但不幸的是，无论算法多么聪明，外部碎片仍然存在；因此，一个好的算法只是尝试将其最小化。\n\n> tip：如果存在 1000 种解决方案，那么没有一个是最好的解决方案\n> \n> 存在如此多不同的算法来尝试最大限度地减少外部碎片这一事实表明了一个更强有力的潜在事实：没有一种“最佳”方法可以解决问题。因此，我们选择合理的东西，并希望它足够好。唯一真正的解决方案是完全避免这个问题，永远不要以可变大小的块分配内存。\n\n\n# 7 总结\n\n分段解决了许多问题，并帮助我们构建更有效的内存虚拟化。除了动态重定位之外，分段还可以通过避免地址空间的逻辑段之间潜在的巨大内存浪费来更好地支持稀疏地址空间。它也很快，因为进行算术分段所需的操作很容易并且非常适合硬件；地址转换费用很少。还出现了一个附带好处：代码共享。如果代码放置在单独的段中，则这样的段可能会在多个正在运行的程序之间共享。\n\n然而，正如我们所知，在内存中分配可变大小的段会导致一些我们希望克服的问题。如上所述，第一个是外部碎片。因为段是可变的，所以可用内存被分成奇数大小的块，因此满足内存分配请求可能很困难。人们可以尝试使用智能算法或定期压缩内存，但问题是根本性的且难以避免。\n\n第二个也许更重要的问题是分段仍然不够灵活，无法支持我们完全通用的稀疏地址空间。例如，如果我们在一个逻辑段中有一个大但很少使用的堆，则整个堆必须仍然驻留在内存中才能被访问。换句话说，如果我们的地址空间使用方式模型与底层分段的设计支持方式不完全匹配，分段就不能很好地工作。因此我们需要寻找一些新的解决方案。",charsets:{cjk:!0},lastUpdated:"2024/05/11, 20:33:38",lastUpdatedTimestamp:1715430818e3},{title:"多CPU调度",frontmatter:{title:"多CPU调度",tags:["OS"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},date:"2024-04-25T22:36:55.000Z",permalink:"/pages/326999/",categories:["开发","系统架构","操作系统","虚拟化"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/02.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/07.%E5%A4%9ACPU%E8%B0%83%E5%BA%A6.html",relativePath:"01.开发/05.系统架构/02.操作系统/07.多CPU调度.md",key:"v-e5f4dafa",path:"/pages/326999/",headers:[{level:2,title:"1 多处理器架构",slug:"_1-多处理器架构",normalizedTitle:"1 多处理器架构",charIndex:2},{level:2,title:"2 不要忘记同步",slug:"_2-不要忘记同步",normalizedTitle:"2 不要忘记同步",charIndex:1288},{level:2,title:"3 最后一个问题：缓存亲和性",slug:"_3-最后一个问题-缓存亲和性",normalizedTitle:"3 最后一个问题：缓存亲和性",charIndex:3175},{level:2,title:"4 Single queue Multiprocessor Scheduling (SQMS)",slug:"_4-single-queue-multiprocessor-scheduling-sqms",normalizedTitle:"4 single queue multiprocessor scheduling (sqms)",charIndex:3487},{level:2,title:"5 Multi-queue Multiprocessor Scheduling (MQMS)",slug:"_5-multi-queue-multiprocessor-scheduling-mqms",normalizedTitle:"5 multi-queue multiprocessor scheduling (mqms)",charIndex:4456},{level:2,title:"6 Linux 多处理器调度器",slug:"_6-linux-多处理器调度器",normalizedTitle:"6 linux 多处理器调度器",charIndex:6093},{level:2,title:"7 总结",slug:"_7-总结",normalizedTitle:"7 总结",charIndex:6508}],headersStr:"1 多处理器架构 2 不要忘记同步 3 最后一个问题：缓存亲和性 4 Single queue Multiprocessor Scheduling (SQMS) 5 Multi-queue Multiprocessor Scheduling (MQMS) 6 Linux 多处理器调度器 7 总结",content:'# 1 多处理器架构\n\n要理解围绕多处理器调度的新问题，我们必须了解单 CPU 硬件与多 CPU 硬件之间的一个新的根本区别。这种区别主要围绕硬件缓存的使用（如下图所示），以及多个处理器之间共享数据的具体方式。\n\n在单个CPU系统中，硬件缓存（Cache）的层次结构通常有助于处理器更快地运行程序。Cache是一种小型快速存储器，（一般来说）保存系统主存储器中常用数据的副本。相比之下，主存储器保存了所有数据，但访问这个较大的内存时速度较慢。通过将频繁访问的数据保存在高速缓存中，系统可以让又大又慢的内存看起来很快。\n\n例如，一个程序要从内存中获取一个值，需要发出一条显式加载指令，而一个简单的系统只有一个 CPU；CPU 有一个小缓存（比如 64 KB）和一个大主存。程序首次发出加载指令时，数据位于主内存中，因此需要很长时间（可能是几十纳秒，甚至几百纳秒）才能获取。处理器预计数据可能会被重复使用，因此会将加载数据的副本放入 CPU 缓存。如果程序稍后再次提取相同的数据项，CPU 会首先检查缓存中是否有该数据项；如果在缓存中找到了该数据项，提取数据的速度就会快得多（比如只需几纳秒），从而加快程序的运行速度。\n\n因此，缓存是以局部性概念为基础的，局部性有两种：时间局部性和空间局部性。时间局部性背后的理念是，当一个数据被访问时，它很可能在不久的将来再次被访问；想象一下变量甚至指令本身在循环中被反复访问的情景。空间局部性背后的理念是，如果程序访问了地址为 x 的数据项，那么它很可能也会访问 x 附近的数据项；在这里，可以想象程序在数组中流水作业，或者指令被一条接一条地执行。由于许多程序都存在这些类型的局部性，因此硬件系统可以很好地猜测哪些数据应放入高速缓存，从而很好地工作。\n\n但如果在一个系统中使用多个处理器和一个共享主存储器，如下图所示，会发生什么情况？\n\n事实证明，多 CPU 缓存要复杂得多。如下图所示，假设在 CPU 1 上运行的程序读取并更新了地址 A 上的一个数据项（值为 D）；由于 CPU 1 的缓存中没有该数据，系统会从主存中获取该数据项，并得到值 D。然后假设操作系统决定停止运行程序，并将其移至 CPU 2。然后程序重新读取地址 A 处的值，发现缓存没有这样的数据 ，因此系统从主内存中获取值，并获取旧值 D 而不是正确值 D ′。这个普遍问题称为缓存一致性问题。\n\n\n\n硬件提供了基本的解决方案：通过监控内存访问，硬件可以确保基本上 "正确的事情 "发生了，并且单个共享内存的视图得以保留。在基于总线的系统（如上所述）上实现这一点的一种方法是使用一种称为总线窥探（bus snooping）的古老技术；每个高速缓存通过观察连接内存和主内存的总线来关注内存更新。当 CPU 看到其缓存中的数据项有更新时，就会注意到这一变化，要么使其副本失效（即从自己的缓存中删除），要么进行更新（即把新值也放入自己的缓存中）。如上文述，回写缓存会使这一过程变得更加复杂（因为写入主内存的内容要到稍后才能看到），但你可以想象一下基本方案是如何工作的。\n\n\n# 2 不要忘记同步\n\n既然缓存为提供一致性做了所有这些工作，那么程序（或操作系统本身）在访问共享数据时还需要担心什么吗？答案是肯定的，程序（或操作系统）在访问共享数据时仍然需要考虑一些问题：\n\n 1. 竞争条件（Race Conditions）：即当多个进程或线程试图同时访问共享资源时可能出现的问题。\n 2. 原子性操作：某些操作可能涉及多个步骤，需要确保这些步骤的执行是原子的。\n 3. 内存栅栏和同步：在某些情况下，需要使用内存栅栏（memory barriers）或者同步机制来确保在不同处理器上的操作执行顺序。这是因为缓存一致性只保证了缓存之间和缓存与内存之间的一致性，而不是对所有指令的执行顺序做出保证。\n\n在跨 CPU 访问（尤其是更新）共享数据项或结构时，应使用互斥原语（如锁）来保证正确性（其他方法，如构建无锁数据结构，比较复杂，只能偶尔使用）。例如，假设多个 CPU 同时访问一个共享队列。如果没有锁，即使使用了底层一致性协议，并发添加或删除队列中的元素也无法达到预期效果；我们需要用锁将数据结构原子更新到新状态。\n\n为了更具体地说明这一点，我们可以看下面这段用于从共享链表中删除一个元素的代码序列。想象一下，如果两个 CPU 上的线程同时进入这个例程。如果线程 1 执行了第一行，它的 tmp 变量中将存储 head 的当前值；如果线程 2 也执行了第一行，它的私有 tmp 变量中也将存储 head 的相同值（tmp 在栈中分配，因此每个线程都有自己的私有存储空间）。这样，每个线程就不会从列表头部删除一个元素了，而是尝试删除这相同的头元素，就会导致各种问题（例如第 4 行中试图对头部元素进行双重释放，以及可能两次返回相同的数据值）。\n\ntypedef struct __Node_t {\n    int value;\n    struct __Node_t *next;\n} Node_t;\n\nint List_Pop() {\n    Node_t *tmp = head;         // remember old head ...\n    int value = head->value;    // ... and its value\n    head = head->next;          // advance head to next pointer\n    free(tmp);                  // free old head\n    return value;               // return value at head\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n当然，解决方案是通过锁定来使此类例程正确。在这种情况下，分配一个简单的互斥体（例如，pthread mutex t m;），然后在例程的开头添加一个 lock(&m) 并在末尾添加一个 unlock(&m) 将解决问题，确保代码能够执行如预期的。不幸的是，正如我们将看到的，这种方法并非没有问题，特别是在性能方面。具体来说，随着CPU数量的增加，对同步共享数据结构的访问变得相当慢。\n\npthread_mutex_t m;\n\ntypedef struct __Node_t {\n    int value;\n    struct __Node_t *next;\n} Node_t;\n\nint List_Pop() {\n    lock(&m);\n    Node_t *tmp = head;         // remember old head ...\n    int value = head->value;    // ... and its value\n    head = head->next;          // advance head to next pointer\n    free(tmp);                  // free old head\n    unlock(&m);\n    return value;               // return value at head\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 3 最后一个问题：缓存亲和性\n\n最后一个问题是在构建多处理器缓存调度程序时出现的，称为缓存亲和性。这个概念很简单：进程在特定 CPU 上运行时，会在 CPU 的缓存（和 TLB）中构建相当多的状态。下一次进程运行时，在同一个 CPU 上运行它通常是有利的，因为如果它的某些状态已经存在于该 CPU 上的缓存中，那么它会运行得更快。相反，如果每次在不同的 CPU 上运行一个进程，则该进程的性能会更差，因为每次运行时都必须重新加载状态（注意，由于硬件的缓存一致性协议，它可以在不同的 CPU 上正常运行）。因此，多处理器调度程序在做出调度决策时应考虑缓存关联性，如果可能的话，可能更愿意将进程保留在同一 CPU 上。\n\n\n# 4 Single queue Multiprocessor Scheduling (SQMS)\n\n有了这个背景，我们现在讨论如何为多处理器系统构建调度程序。最基本的方法是简单地重用单处理器调度的基本框架，将所有需要调度的作业放入单个队列中；我们将此称为单队列多处理器调度或简称为 SQMS。这种方法的优点是简单；不需要太多工作就可以采用现有策略来选择接下来运行的最佳作业，并将其调整为在多个 CPU 上工作（例如，如果有两个 CPU，它可能会选择最好的两个作业来运行） 。\n\n然而，SQMS 也有明显的缺点。\n\n第一个问题是缺乏可扩展性。为了确保调度程序在多个 CPU 上正常工作，开发人员将在代码中插入某种形式的锁，如上所述。锁确保当 SQMS 代码访问单个队列（例如，查找下一个要运行的作业）时，会出现正确的结果。但锁会大大降低性能，尤其是当系统中的 CPU 数量增加。随着对单个锁的争夺增加，系统花在锁开销上的时间越来越多，而花在系统本应完成的工作上的时间却越来越少。\n\nSQMS 的第二个主要问题是缓存亲和性。例如，假设我们有五个作业（A、B、C、D、E）和四个处理器。因此，我们的调度队列看起来是这样的：\n\n\n\n随着时间的推移，假设每个作业运行一个时间片，然后选择另一个作业，下面是一个可能的跨 CPU 作业时间表：\n\n\n\n由于每个 CPU 只需从全局共享队列中选择下一个要运行的作业，因此每个作业最终都会在 CPU 之间来回跳转，这与缓存亲和性的观点恰恰相反。\n\n为了解决这个问题，大多数 SQMS 调度器都包含某种亲和性机制，以尽可能使进程更有可能继续在同一 CPU 上运行。具体来说，调度器可能会为某些作业提供亲和性，但会移动其他作业以平衡负载。例如，设想同样的五个工作调度如下：\n\n\n\n在这种安排下，作业 A 到 D 不会跨处理器迁移，只有作业 E 会从 CPU 迁移到 CPU，从而保留了大部分的亲和性。然后，你可以决定在下一次迁移时迁移不同的作业，从而实现某种亲和性公平性。不过，实施这样的方案可能会很复杂。因此，我们可以看到 SQMS 方法有其优点和缺点。对于现有的单 CPU 调度器（顾名思义，它只有一个队列）来说，它可以直接实施。但是，它的扩展性不佳（由于同步开销），而且不能轻易保留高速缓存亲和性。\n\n\n# 5 Multi-queue Multiprocessor Scheduling (MQMS)\n\n由于单队列调度器所带来的问题，一些系统选择了多队列，例如每个 CPU 一个队列。我们称这种方法为多队列多处理器调度（或 MQMS）。\n\n在 MQMS 中，我们的基本调度框架由多个调度队列组成。每个队列都可能遵循特定的调度规则，如循环调度（RR），当然也可以使用任何算法。当作业进入系统时，会根据某种启发式（如随机，或挑选作业数量少于其他队列的队列），将其恰好置于一个调度队列中。然后，它基本上被独立调度，从而避免了单队列方法中的信息共享和同步问题。\n\n例如，假设系统中只有两个 CPU（CPU 0 和 CPU 1），有若干作业进入系统：例如 A、B、C 和 D。鉴于每个 CPU 现在都有一个调度队列，操作系统必须决定将每个作业放入哪个队列。操作系统可能会这样做：\n\n\n\n根据队列调度策略的不同，现在每个 CPU 在决定运行什么作业时都有两个作业可供选择。例如，如果采用循环调度，系统可能会产生如下调度：\n\n\n\n与 SQMS 相比，MQMS 有一个明显的优势，那就是它本质上更具可扩展性。随着 CPU 数量的增加，队列的数量也会增加，因此锁和缓存争用不会成为核心问题。此外，MQMS 本身还提供缓存亲和性，这些工作都在同一个 CPU 上运行，因此可以获得重复使用其中缓存内容的优势。\n\n但是，你可能会发现我们遇到了一个新问题，这也是基于多队列方法的基本问题：负载不平衡。假设我们有与上述相同的设置（四个工作、两个 CPU），但其中一个工作（比如 C）完成了。现在我们有以下调度队列：\n\n\n\n如果我们在系统的每个队列上运行轮循策略，就会看到这样的调度表：\n\n\n\n从图中可以看出，A 获得的 CPU 资源是 B 和 D 的两倍，这并不是我们想要的结果。更糟的是，假设 A 和 C 都完成了工作，系统中只剩下工作 B 和 D。调度队列将如下所示：\n\n\n\n因此，CPU 0 将处于闲置状态！\n\n\n\n那么，关键是怎么解决负载不均衡的问题呢？MQMS应如何处理负载不平衡问题，从而更好地实现预期调度目标？\n\n对于这个问题，显而易见的答案就是移动作业，我们（再次）将这种技术称为迁移。通过将作业从一个 CPU 迁移到另一个 CPU，可以实现真正的负载平衡。让我们看几个例子来进一步说明。我们再一次遇到这样的情况：一个 CPU 空闲，另一个 CPU 有一些作业。\n\n在这种情况下，所需的迁移很容易理解：操作系统只需将 B 或 D 中的一个迁移到 CPU 0。 这种单一作业迁移的结果是负载均衡，大家都很高兴。\n\n在我们之前的示例中出现了一个更棘手的情况，其中 A 单独留在 CPU 0 上，而 B 和 D 交替出现在 CPU 1 上：\n\n\n\n在这种情况下，一次迁移并不能解决问题。在这种情况下该怎么办呢？答案是连续迁移一个或多个工作。一种可能的解决方案是不断切换工作，如下图所示。在图中，首先 A 单独运行在 CPU 0 上，B 和 D 交替运行在 CPU 1 上。几个时间片后，B 被转移到 CPU 0 上与 A 竞争，而 D 则在 CPU 1 上单独运行几个时间片。这样，负载就平衡了：\n\n\n\n当然，还存在许多其他可能的迁移模式。但现在是棘手的部分：系统应该如何决定实施这样的迁移？\n\n一种基本方法是使用一种称为工作窃取（work stealing）的技术。通过工作窃取方法，作业量较低的（源）队列偶尔会查看另一个（目标）队列，看看它有多满。如果目标队列（特别是）比源队列更满，则源队列将从目标“窃取”一个或多个作业以帮助平衡负载。\n\n当然，这种方法自然会产生矛盾。如果过于频繁地查看其他队列，就会造成高开销和扩展困难，而实施多队列调度的目的就是为了解决这个问题！！另一方面，如果不经常查看其他队列，就有可能出现严重的负载不平衡。在系统策略设计中，找到合适的阈值仍然是一门黑科技。\n\n\n# 6 Linux 多处理器调度器\n\n有趣的是，Linux 社区在构建多处理器调度程序方面没有通用的解决方案。随着时间的推移，出现了三种不同的调度器：\n\n 1. O(1)调度器\n    \n    * 基于优先级的调度程序\n    * 使用多队列（类似于MLFQ）\n    * 随着时间的推移改变流程的优先级\n    * 调度优先级高的进程\n    * 交互性是关注的重点\n\n 2. 完全公平调度器（CFS）\n    \n    * 使用多队列\n    \n    * 确定性比例份额方法\n    \n    * 基于阶梯截止日期（公平是重点）\n    \n    * 红黑树可扩展性\n\n 3. BF调度器（BFS）\n    \n    * 单队列调度方法\n    * 使用比例份额方法\n    * 基于最早符合条件的虚拟截止时间优先（EEVDF）\n    * 侧重于交互式（不能很好地扩展内核）。已被 MuQSS 取代，以解决这一问题\n\n\n# 7 总结\n\n我们已经看到了多种多处理器调度方法。单队列方法 (SQMS) 构建起来相当简单，并且可以很好地平衡负载，但本质上难以扩展到许多处理器和缓存亲和力。多队列方法（MQMS）可扩展性更好，并且可以很好地处理缓存亲和性，但存在负载不平衡的问题，并且更复杂。无论您采用哪种方法，都没有简单的答案：构建通用调度器仍然是一项艰巨的任务，因为小的代码更改可能会导致大的行为差异。',normalizedContent:'# 1 多处理器架构\n\n要理解围绕多处理器调度的新问题，我们必须了解单 cpu 硬件与多 cpu 硬件之间的一个新的根本区别。这种区别主要围绕硬件缓存的使用（如下图所示），以及多个处理器之间共享数据的具体方式。\n\n在单个cpu系统中，硬件缓存（cache）的层次结构通常有助于处理器更快地运行程序。cache是一种小型快速存储器，（一般来说）保存系统主存储器中常用数据的副本。相比之下，主存储器保存了所有数据，但访问这个较大的内存时速度较慢。通过将频繁访问的数据保存在高速缓存中，系统可以让又大又慢的内存看起来很快。\n\n例如，一个程序要从内存中获取一个值，需要发出一条显式加载指令，而一个简单的系统只有一个 cpu；cpu 有一个小缓存（比如 64 kb）和一个大主存。程序首次发出加载指令时，数据位于主内存中，因此需要很长时间（可能是几十纳秒，甚至几百纳秒）才能获取。处理器预计数据可能会被重复使用，因此会将加载数据的副本放入 cpu 缓存。如果程序稍后再次提取相同的数据项，cpu 会首先检查缓存中是否有该数据项；如果在缓存中找到了该数据项，提取数据的速度就会快得多（比如只需几纳秒），从而加快程序的运行速度。\n\n因此，缓存是以局部性概念为基础的，局部性有两种：时间局部性和空间局部性。时间局部性背后的理念是，当一个数据被访问时，它很可能在不久的将来再次被访问；想象一下变量甚至指令本身在循环中被反复访问的情景。空间局部性背后的理念是，如果程序访问了地址为 x 的数据项，那么它很可能也会访问 x 附近的数据项；在这里，可以想象程序在数组中流水作业，或者指令被一条接一条地执行。由于许多程序都存在这些类型的局部性，因此硬件系统可以很好地猜测哪些数据应放入高速缓存，从而很好地工作。\n\n但如果在一个系统中使用多个处理器和一个共享主存储器，如下图所示，会发生什么情况？\n\n事实证明，多 cpu 缓存要复杂得多。如下图所示，假设在 cpu 1 上运行的程序读取并更新了地址 a 上的一个数据项（值为 d）；由于 cpu 1 的缓存中没有该数据，系统会从主存中获取该数据项，并得到值 d。然后假设操作系统决定停止运行程序，并将其移至 cpu 2。然后程序重新读取地址 a 处的值，发现缓存没有这样的数据 ，因此系统从主内存中获取值，并获取旧值 d 而不是正确值 d ′。这个普遍问题称为缓存一致性问题。\n\n\n\n硬件提供了基本的解决方案：通过监控内存访问，硬件可以确保基本上 "正确的事情 "发生了，并且单个共享内存的视图得以保留。在基于总线的系统（如上所述）上实现这一点的一种方法是使用一种称为总线窥探（bus snooping）的古老技术；每个高速缓存通过观察连接内存和主内存的总线来关注内存更新。当 cpu 看到其缓存中的数据项有更新时，就会注意到这一变化，要么使其副本失效（即从自己的缓存中删除），要么进行更新（即把新值也放入自己的缓存中）。如上文述，回写缓存会使这一过程变得更加复杂（因为写入主内存的内容要到稍后才能看到），但你可以想象一下基本方案是如何工作的。\n\n\n# 2 不要忘记同步\n\n既然缓存为提供一致性做了所有这些工作，那么程序（或操作系统本身）在访问共享数据时还需要担心什么吗？答案是肯定的，程序（或操作系统）在访问共享数据时仍然需要考虑一些问题：\n\n 1. 竞争条件（race conditions）：即当多个进程或线程试图同时访问共享资源时可能出现的问题。\n 2. 原子性操作：某些操作可能涉及多个步骤，需要确保这些步骤的执行是原子的。\n 3. 内存栅栏和同步：在某些情况下，需要使用内存栅栏（memory barriers）或者同步机制来确保在不同处理器上的操作执行顺序。这是因为缓存一致性只保证了缓存之间和缓存与内存之间的一致性，而不是对所有指令的执行顺序做出保证。\n\n在跨 cpu 访问（尤其是更新）共享数据项或结构时，应使用互斥原语（如锁）来保证正确性（其他方法，如构建无锁数据结构，比较复杂，只能偶尔使用）。例如，假设多个 cpu 同时访问一个共享队列。如果没有锁，即使使用了底层一致性协议，并发添加或删除队列中的元素也无法达到预期效果；我们需要用锁将数据结构原子更新到新状态。\n\n为了更具体地说明这一点，我们可以看下面这段用于从共享链表中删除一个元素的代码序列。想象一下，如果两个 cpu 上的线程同时进入这个例程。如果线程 1 执行了第一行，它的 tmp 变量中将存储 head 的当前值；如果线程 2 也执行了第一行，它的私有 tmp 变量中也将存储 head 的相同值（tmp 在栈中分配，因此每个线程都有自己的私有存储空间）。这样，每个线程就不会从列表头部删除一个元素了，而是尝试删除这相同的头元素，就会导致各种问题（例如第 4 行中试图对头部元素进行双重释放，以及可能两次返回相同的数据值）。\n\ntypedef struct __node_t {\n    int value;\n    struct __node_t *next;\n} node_t;\n\nint list_pop() {\n    node_t *tmp = head;         // remember old head ...\n    int value = head->value;    // ... and its value\n    head = head->next;          // advance head to next pointer\n    free(tmp);                  // free old head\n    return value;               // return value at head\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n当然，解决方案是通过锁定来使此类例程正确。在这种情况下，分配一个简单的互斥体（例如，pthread mutex t m;），然后在例程的开头添加一个 lock(&m) 并在末尾添加一个 unlock(&m) 将解决问题，确保代码能够执行如预期的。不幸的是，正如我们将看到的，这种方法并非没有问题，特别是在性能方面。具体来说，随着cpu数量的增加，对同步共享数据结构的访问变得相当慢。\n\npthread_mutex_t m;\n\ntypedef struct __node_t {\n    int value;\n    struct __node_t *next;\n} node_t;\n\nint list_pop() {\n    lock(&m);\n    node_t *tmp = head;         // remember old head ...\n    int value = head->value;    // ... and its value\n    head = head->next;          // advance head to next pointer\n    free(tmp);                  // free old head\n    unlock(&m);\n    return value;               // return value at head\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 3 最后一个问题：缓存亲和性\n\n最后一个问题是在构建多处理器缓存调度程序时出现的，称为缓存亲和性。这个概念很简单：进程在特定 cpu 上运行时，会在 cpu 的缓存（和 tlb）中构建相当多的状态。下一次进程运行时，在同一个 cpu 上运行它通常是有利的，因为如果它的某些状态已经存在于该 cpu 上的缓存中，那么它会运行得更快。相反，如果每次在不同的 cpu 上运行一个进程，则该进程的性能会更差，因为每次运行时都必须重新加载状态（注意，由于硬件的缓存一致性协议，它可以在不同的 cpu 上正常运行）。因此，多处理器调度程序在做出调度决策时应考虑缓存关联性，如果可能的话，可能更愿意将进程保留在同一 cpu 上。\n\n\n# 4 single queue multiprocessor scheduling (sqms)\n\n有了这个背景，我们现在讨论如何为多处理器系统构建调度程序。最基本的方法是简单地重用单处理器调度的基本框架，将所有需要调度的作业放入单个队列中；我们将此称为单队列多处理器调度或简称为 sqms。这种方法的优点是简单；不需要太多工作就可以采用现有策略来选择接下来运行的最佳作业，并将其调整为在多个 cpu 上工作（例如，如果有两个 cpu，它可能会选择最好的两个作业来运行） 。\n\n然而，sqms 也有明显的缺点。\n\n第一个问题是缺乏可扩展性。为了确保调度程序在多个 cpu 上正常工作，开发人员将在代码中插入某种形式的锁，如上所述。锁确保当 sqms 代码访问单个队列（例如，查找下一个要运行的作业）时，会出现正确的结果。但锁会大大降低性能，尤其是当系统中的 cpu 数量增加。随着对单个锁的争夺增加，系统花在锁开销上的时间越来越多，而花在系统本应完成的工作上的时间却越来越少。\n\nsqms 的第二个主要问题是缓存亲和性。例如，假设我们有五个作业（a、b、c、d、e）和四个处理器。因此，我们的调度队列看起来是这样的：\n\n\n\n随着时间的推移，假设每个作业运行一个时间片，然后选择另一个作业，下面是一个可能的跨 cpu 作业时间表：\n\n\n\n由于每个 cpu 只需从全局共享队列中选择下一个要运行的作业，因此每个作业最终都会在 cpu 之间来回跳转，这与缓存亲和性的观点恰恰相反。\n\n为了解决这个问题，大多数 sqms 调度器都包含某种亲和性机制，以尽可能使进程更有可能继续在同一 cpu 上运行。具体来说，调度器可能会为某些作业提供亲和性，但会移动其他作业以平衡负载。例如，设想同样的五个工作调度如下：\n\n\n\n在这种安排下，作业 a 到 d 不会跨处理器迁移，只有作业 e 会从 cpu 迁移到 cpu，从而保留了大部分的亲和性。然后，你可以决定在下一次迁移时迁移不同的作业，从而实现某种亲和性公平性。不过，实施这样的方案可能会很复杂。因此，我们可以看到 sqms 方法有其优点和缺点。对于现有的单 cpu 调度器（顾名思义，它只有一个队列）来说，它可以直接实施。但是，它的扩展性不佳（由于同步开销），而且不能轻易保留高速缓存亲和性。\n\n\n# 5 multi-queue multiprocessor scheduling (mqms)\n\n由于单队列调度器所带来的问题，一些系统选择了多队列，例如每个 cpu 一个队列。我们称这种方法为多队列多处理器调度（或 mqms）。\n\n在 mqms 中，我们的基本调度框架由多个调度队列组成。每个队列都可能遵循特定的调度规则，如循环调度（rr），当然也可以使用任何算法。当作业进入系统时，会根据某种启发式（如随机，或挑选作业数量少于其他队列的队列），将其恰好置于一个调度队列中。然后，它基本上被独立调度，从而避免了单队列方法中的信息共享和同步问题。\n\n例如，假设系统中只有两个 cpu（cpu 0 和 cpu 1），有若干作业进入系统：例如 a、b、c 和 d。鉴于每个 cpu 现在都有一个调度队列，操作系统必须决定将每个作业放入哪个队列。操作系统可能会这样做：\n\n\n\n根据队列调度策略的不同，现在每个 cpu 在决定运行什么作业时都有两个作业可供选择。例如，如果采用循环调度，系统可能会产生如下调度：\n\n\n\n与 sqms 相比，mqms 有一个明显的优势，那就是它本质上更具可扩展性。随着 cpu 数量的增加，队列的数量也会增加，因此锁和缓存争用不会成为核心问题。此外，mqms 本身还提供缓存亲和性，这些工作都在同一个 cpu 上运行，因此可以获得重复使用其中缓存内容的优势。\n\n但是，你可能会发现我们遇到了一个新问题，这也是基于多队列方法的基本问题：负载不平衡。假设我们有与上述相同的设置（四个工作、两个 cpu），但其中一个工作（比如 c）完成了。现在我们有以下调度队列：\n\n\n\n如果我们在系统的每个队列上运行轮循策略，就会看到这样的调度表：\n\n\n\n从图中可以看出，a 获得的 cpu 资源是 b 和 d 的两倍，这并不是我们想要的结果。更糟的是，假设 a 和 c 都完成了工作，系统中只剩下工作 b 和 d。调度队列将如下所示：\n\n\n\n因此，cpu 0 将处于闲置状态！\n\n\n\n那么，关键是怎么解决负载不均衡的问题呢？mqms应如何处理负载不平衡问题，从而更好地实现预期调度目标？\n\n对于这个问题，显而易见的答案就是移动作业，我们（再次）将这种技术称为迁移。通过将作业从一个 cpu 迁移到另一个 cpu，可以实现真正的负载平衡。让我们看几个例子来进一步说明。我们再一次遇到这样的情况：一个 cpu 空闲，另一个 cpu 有一些作业。\n\n在这种情况下，所需的迁移很容易理解：操作系统只需将 b 或 d 中的一个迁移到 cpu 0。 这种单一作业迁移的结果是负载均衡，大家都很高兴。\n\n在我们之前的示例中出现了一个更棘手的情况，其中 a 单独留在 cpu 0 上，而 b 和 d 交替出现在 cpu 1 上：\n\n\n\n在这种情况下，一次迁移并不能解决问题。在这种情况下该怎么办呢？答案是连续迁移一个或多个工作。一种可能的解决方案是不断切换工作，如下图所示。在图中，首先 a 单独运行在 cpu 0 上，b 和 d 交替运行在 cpu 1 上。几个时间片后，b 被转移到 cpu 0 上与 a 竞争，而 d 则在 cpu 1 上单独运行几个时间片。这样，负载就平衡了：\n\n\n\n当然，还存在许多其他可能的迁移模式。但现在是棘手的部分：系统应该如何决定实施这样的迁移？\n\n一种基本方法是使用一种称为工作窃取（work stealing）的技术。通过工作窃取方法，作业量较低的（源）队列偶尔会查看另一个（目标）队列，看看它有多满。如果目标队列（特别是）比源队列更满，则源队列将从目标“窃取”一个或多个作业以帮助平衡负载。\n\n当然，这种方法自然会产生矛盾。如果过于频繁地查看其他队列，就会造成高开销和扩展困难，而实施多队列调度的目的就是为了解决这个问题！！另一方面，如果不经常查看其他队列，就有可能出现严重的负载不平衡。在系统策略设计中，找到合适的阈值仍然是一门黑科技。\n\n\n# 6 linux 多处理器调度器\n\n有趣的是，linux 社区在构建多处理器调度程序方面没有通用的解决方案。随着时间的推移，出现了三种不同的调度器：\n\n 1. o(1)调度器\n    \n    * 基于优先级的调度程序\n    * 使用多队列（类似于mlfq）\n    * 随着时间的推移改变流程的优先级\n    * 调度优先级高的进程\n    * 交互性是关注的重点\n\n 2. 完全公平调度器（cfs）\n    \n    * 使用多队列\n    \n    * 确定性比例份额方法\n    \n    * 基于阶梯截止日期（公平是重点）\n    \n    * 红黑树可扩展性\n\n 3. bf调度器（bfs）\n    \n    * 单队列调度方法\n    * 使用比例份额方法\n    * 基于最早符合条件的虚拟截止时间优先（eevdf）\n    * 侧重于交互式（不能很好地扩展内核）。已被 muqss 取代，以解决这一问题\n\n\n# 7 总结\n\n我们已经看到了多种多处理器调度方法。单队列方法 (sqms) 构建起来相当简单，并且可以很好地平衡负载，但本质上难以扩展到许多处理器和缓存亲和力。多队列方法（mqms）可扩展性更好，并且可以很好地处理缓存亲和性，但存在负载不平衡的问题，并且更复杂。无论您采用哪种方法，都没有简单的答案：构建通用调度器仍然是一项艰巨的任务，因为小的代码更改可能会导致大的行为差异。',charsets:{cjk:!0},lastUpdated:"2024/05/11, 20:33:38",lastUpdatedTimestamp:1715430818e3},{title:"CPU调度",frontmatter:{title:"CPU调度",tags:["OS"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},date:"2024-04-25T22:32:51.000Z",permalink:"/pages/f0c724/",categories:["开发","系统架构","操作系统","虚拟化"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/02.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/04.CPU%E8%B0%83%E5%BA%A6.html",relativePath:"01.开发/05.系统架构/02.操作系统/04.CPU调度.md",key:"v-75583a06",path:"/pages/f0c724/",headers:[{level:2,title:"1 Program Explanation",slug:"_1-program-explanation",normalizedTitle:"1 program explanation",charIndex:13},{level:2,title:"2 QA",slug:"_2-qa",normalizedTitle:"2 qa",charIndex:5983}],headersStr:"1 Program Explanation 2 QA",content:"github代码\n\n\n# 1 Program Explanation\n\n程序scheduler.py允许您查看不同调度程序在响应时间、周转时间和总等待时间等调度指标下的执行情况。 “实现”了三个调度程序：FIFO、SJF 和 RR。 要运行该程序获取其选项，可执行以下操作： ./scheduler.py -h 或者 python scheduler.py -h 得到：\n\n❯ python scheduler.py -h\nUsage: scheduler.py [options]\n\nOptions:\n  -h, --help            show this help message and exit\n  -s SEED, --seed=SEED  the random seed\n  -j JOBS, --jobs=JOBS  number of jobs in the system\n  -l JLIST, --jlist=JLIST\n                        instead of random jobs, provide a comma-separated list\n                        of run times\n  -m MAXLEN, --maxlen=MAXLEN\n                        max length of job\n  -p POLICY, --policy=POLICY\n                        sched policy to use: SJF, FIFO, RR\n  -q QUANTUM, --quantum=QUANTUM\n                        length of time slice for RR policy\n  -c                    compute answers for me\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n首先，在不带 -c 选项的情况下运行：这会向您显示要解决的问题而不透露答案。例如，如果您想要使用 FIFO 策略计算响应、周转和等待三个作业，请运行以下命令： python scheduler.py -p FIFO -j 3 -s 100 这指定了具有三个作业的 FIFO 策略，而且重要的是，指定了 100 的特定随机种子。如果您想查看该问题的解决方案，则必须再次指定该完全相同的随机种子。让我们运行一下，看看会发生什么。这是您应该看到的：\n\n❯ python scheduler.py -p FIFO -j 3 -s 100\nARG policy FIFO\nARG jobs 3\nARG maxlen 10\nARG seed 100\n\nHere is the job list, with the run time of each job: \n  Job 0 ( length = 2 )\n  Job 1 ( length = 5 )\n  Job 2 ( length = 8 )\n\n\nCompute the turnaround time, response time, and wait time for each job.\nWhen you are done, run this program again, with the same arguments,\nbut with -c, which will thus provide you with the answers. You can use\n-s <somenumber> or your own job list (-l 10,15,20 for example)\nto generate different problems for yourself.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n计算每个作业的周转时间、响应时间和等待时间。完成后，使用相同的参数再次运行该程序，但使用 -c选项，这将为您提供答案。您可以使用 -s 或您自己的作业列表（例如 -l 10,15,20）为自己生成不同的问题。 从这个例子中可以看出，生成了三个作业：长度为 2 的作业 0、长度为 5 的作业 1 和长度为 8 的作业 2。正如程序所述，您现在可以使用它来计算一些统计数据，看看是否可以掌握基本概念。 完成后，您可以使用相同的程序来“解决”问题并查看您的工作是否正确。为此，请使用“-c”选项。输出：\n\n❯ python scheduler.py -p FIFO -j 3 -s 100 -c\nARG policy FIFO\nARG jobs 3\nARG maxlen 10\nARG seed 100\n\nHere is the job list, with the run time of each job: \n  Job 0 ( length = 2 )\n  Job 1 ( length = 5 )\n  Job 2 ( length = 8 )\n\n\n** Solutions **\n\nExecution trace:\n  [ time   0 ] Run job 0 for 2.00 secs ( DONE at 2.00 )\n  [ time   2 ] Run job 1 for 5.00 secs ( DONE at 7.00 )\n  [ time   7 ] Run job 2 for 8.00 secs ( DONE at 15.00 )\n\nFinal statistics:\n  Job   0 -- Response: 0.00  Turnaround 2.00  Wait 0.00\n  Job   1 -- Response: 2.00  Turnaround 7.00  Wait 2.00\n  Job   2 -- Response: 7.00  Turnaround 15.00  Wait 7.00\n\n  Average -- Response: 3.00  Turnaround 8.00  Wait 3.00\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n从上述输出我们可以看到，作业0首先运行了2秒，作业2接着运行了5秒，最后作业2运行了8秒。 最终的统计数据也很有用：它们计算“响应时间”（作业到达后第一次运行之前等待所花费的时间）、“周转时间”（自第一次到达以来完成作业所花费的时间）以及总时间。 “等待时间”（准备好但未运行的任何时间）。统计数据按作业显示，然后显示所有作业的平均值。当然，您应该在使用“-c”选项运行之前计算出所有这些内容！ 如果您想尝试相同类型的问题但使用不同的输入，请尝试更改作业数量或随机种子或同时更改两者。不同的随机种子基本上为您提供了一种为自己生成无数不同问题的方法，并且“-c”选项可以让您检查自己的工作。继续这样做，直到您觉得自己真正理解了这些概念。 另一个有用的选项是“-l”（这是一个小写的 L），它可以让您指定您希望看到的计划的确切作业。例如，如果您想了解 SJF 如何执行长度为 5、10 和 15 的三个作业，您可以运行：\n\n❯ python scheduler.py -p SJF -l 5,10,15\nARG policy SJF\nARG jlist 5,10,15\n\nHere is the job list, with the run time of each job: \n  Job 0 ( length = 5.0 )\n  Job 1 ( length = 10.0 )\n  Job 2 ( length = 15.0 )\n\n\nCompute the turnaround time, response time, and wait time for each job.\nWhen you are done, run this program again, with the same arguments,\nbut with -c, which will thus provide you with the answers. You can use\n-s <somenumber> or your own job list (-l 10,15,20 for example)\nto generate different problems for yourself.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n计算完后还是通过-c选项获得答案。指定确切的作业时，无须指定随机种子或者作业数量。 我们最后测试一下RR，可以运行：\n\n❯ python scheduler.py -p RR -l 5,10,15 -c\nARG policy RR\nARG jlist 5,10,15\n\nHere is the job list, with the run time of each job: \n  Job 0 ( length = 5.0 )\n  Job 1 ( length = 10.0 )\n  Job 2 ( length = 15.0 )\n\n\n** Solutions **\n\nExecution trace:\n  [ time   0 ] Run job   0 for 1.00 secs\n  [ time   1 ] Run job   1 for 1.00 secs\n  [ time   2 ] Run job   2 for 1.00 secs\n  [ time   3 ] Run job   0 for 1.00 secs\n  [ time   4 ] Run job   1 for 1.00 secs\n  [ time   5 ] Run job   2 for 1.00 secs\n  [ time   6 ] Run job   0 for 1.00 secs\n  [ time   7 ] Run job   1 for 1.00 secs\n  [ time   8 ] Run job   2 for 1.00 secs\n  [ time   9 ] Run job   0 for 1.00 secs\n  [ time  10 ] Run job   1 for 1.00 secs\n  [ time  11 ] Run job   2 for 1.00 secs\n  [ time  12 ] Run job   0 for 1.00 secs ( DONE at 13.00 )\n  [ time  13 ] Run job   1 for 1.00 secs\n  [ time  14 ] Run job   2 for 1.00 secs\n  [ time  15 ] Run job   1 for 1.00 secs\n  [ time  16 ] Run job   2 for 1.00 secs\n  [ time  17 ] Run job   1 for 1.00 secs\n  [ time  18 ] Run job   2 for 1.00 secs\n  [ time  19 ] Run job   1 for 1.00 secs\n  [ time  20 ] Run job   2 for 1.00 secs\n  [ time  21 ] Run job   1 for 1.00 secs\n  [ time  22 ] Run job   2 for 1.00 secs\n  [ time  23 ] Run job   1 for 1.00 secs ( DONE at 24.00 )\n  [ time  24 ] Run job   2 for 1.00 secs\n  [ time  25 ] Run job   2 for 1.00 secs\n  [ time  26 ] Run job   2 for 1.00 secs\n  [ time  27 ] Run job   2 for 1.00 secs\n  [ time  28 ] Run job   2 for 1.00 secs\n  [ time  29 ] Run job   2 for 1.00 secs ( DONE at 30.00 )\n\nFinal statistics:\n  Job   0 -- Response: 0.00  Turnaround 13.00  Wait 8.00\n  Job   1 -- Response: 1.00  Turnaround 24.00  Wait 14.00\n  Job   2 -- Response: 2.00  Turnaround 30.00  Wait 15.00\n\n  Average -- Response: 1.00  Turnaround 22.33  Wait 12.33\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 2 QA\n\n> 以下问题都可以通过scheduler.py进行验证\n\n 1. 使用 SJF 和 FIFO 调度器运行长度为 200 的三个作业时，计算响应时间和周转时间\n    * SJF turnaround=200−0+400−0+600−03=400turnaround = \\frac{200-0+400-0+600-0}{3}=400turnaround=3200−0+400−0+600−0 =400 response=0+200+4003=200response=\\frac{0+200+400}{3}=200response=30+200+400 =200\n    * FIFO 跟SJF一样\n 2. 现在执行相同的操作，但使用不同长度的作业：100、200 和 300。\n    * SJF turnaround=100−0+300−0+600−03=333turnaround = \\frac{100-0+300-0+600-0}{3}=333turnaround=3100−0+300−0+600−0 =333 response=0+100+3003=133response=\\frac{0+100+300}{3}=133response=30+100+300 =133\n    * FIFO 由于到达时间是一样，所以调度具有不确定性，最佳方案就是和SJF一样。\n 3. 现在执行相同的操作，但也使用 RR 调度程序和时间片 1 对于RR，response=0+1+23=1response=\\frac{0+1+2}{3}=1response=30+1+2 =1 turnaround=298+499+6003=265.67turnaround=\\frac{298+499+600}{3}=265.67turnaround=3298+499+600 =265.67\n 4. 在哪些类型的工作负载中，SJF 的周转时间与 FIFO 相同？\n    \n    > SJF 始终提供与 FIFO 相同的周转时间，除非较短的作业在较长的作业之后到达。只要所有作业长度相等或按升序到达，周转时间就会相同。\n\n 5. 在哪些类型的工作负载和时间片长度下，SJF 可以提供与 RR 相同的响应时间？\n    \n    > 如果所有作业长度(x)相同，且时间片长度(q)=x，在这种情况下，SJF提供与RR相同的响应时间。通过运行以下代码验证： ./scheduler.py -p SJF -l 100,100,100 -c ./scheduler.py -p RR -l 100,100,100 -c -q 100\n\n 6. 随着作业长度的增加，SJF 的响应时间会发生什么变化？您能否使用模拟器来演示这一趋势？\n    \n    > 如果我们将每个工作的长度加倍，平均响应时间也会加倍。这意味着工作长度和响应时间之间存在线性关系。\n\n 7. 随着时间片长度的增加，RR 的响应时间会发生什么变化？你能写出一个方程，在给定 N 个作业的情况下给出最坏情况的响应时间吗？\n    \n    > 响应时间随着时间片长度的增加而线性增加。令 N 为作业数量，q 为时间片长度，则最坏情况的响应时间为 (N−1)qN\\frac{(N-1)q}{N}N(N−1)q 。",normalizedContent:"github代码\n\n\n# 1 program explanation\n\n程序scheduler.py允许您查看不同调度程序在响应时间、周转时间和总等待时间等调度指标下的执行情况。 “实现”了三个调度程序：fifo、sjf 和 rr。 要运行该程序获取其选项，可执行以下操作： ./scheduler.py -h 或者 python scheduler.py -h 得到：\n\n❯ python scheduler.py -h\nusage: scheduler.py [options]\n\noptions:\n  -h, --help            show this help message and exit\n  -s seed, --seed=seed  the random seed\n  -j jobs, --jobs=jobs  number of jobs in the system\n  -l jlist, --jlist=jlist\n                        instead of random jobs, provide a comma-separated list\n                        of run times\n  -m maxlen, --maxlen=maxlen\n                        max length of job\n  -p policy, --policy=policy\n                        sched policy to use: sjf, fifo, rr\n  -q quantum, --quantum=quantum\n                        length of time slice for rr policy\n  -c                    compute answers for me\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n首先，在不带 -c 选项的情况下运行：这会向您显示要解决的问题而不透露答案。例如，如果您想要使用 fifo 策略计算响应、周转和等待三个作业，请运行以下命令： python scheduler.py -p fifo -j 3 -s 100 这指定了具有三个作业的 fifo 策略，而且重要的是，指定了 100 的特定随机种子。如果您想查看该问题的解决方案，则必须再次指定该完全相同的随机种子。让我们运行一下，看看会发生什么。这是您应该看到的：\n\n❯ python scheduler.py -p fifo -j 3 -s 100\narg policy fifo\narg jobs 3\narg maxlen 10\narg seed 100\n\nhere is the job list, with the run time of each job: \n  job 0 ( length = 2 )\n  job 1 ( length = 5 )\n  job 2 ( length = 8 )\n\n\ncompute the turnaround time, response time, and wait time for each job.\nwhen you are done, run this program again, with the same arguments,\nbut with -c, which will thus provide you with the answers. you can use\n-s <somenumber> or your own job list (-l 10,15,20 for example)\nto generate different problems for yourself.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n计算每个作业的周转时间、响应时间和等待时间。完成后，使用相同的参数再次运行该程序，但使用 -c选项，这将为您提供答案。您可以使用 -s 或您自己的作业列表（例如 -l 10,15,20）为自己生成不同的问题。 从这个例子中可以看出，生成了三个作业：长度为 2 的作业 0、长度为 5 的作业 1 和长度为 8 的作业 2。正如程序所述，您现在可以使用它来计算一些统计数据，看看是否可以掌握基本概念。 完成后，您可以使用相同的程序来“解决”问题并查看您的工作是否正确。为此，请使用“-c”选项。输出：\n\n❯ python scheduler.py -p fifo -j 3 -s 100 -c\narg policy fifo\narg jobs 3\narg maxlen 10\narg seed 100\n\nhere is the job list, with the run time of each job: \n  job 0 ( length = 2 )\n  job 1 ( length = 5 )\n  job 2 ( length = 8 )\n\n\n** solutions **\n\nexecution trace:\n  [ time   0 ] run job 0 for 2.00 secs ( done at 2.00 )\n  [ time   2 ] run job 1 for 5.00 secs ( done at 7.00 )\n  [ time   7 ] run job 2 for 8.00 secs ( done at 15.00 )\n\nfinal statistics:\n  job   0 -- response: 0.00  turnaround 2.00  wait 0.00\n  job   1 -- response: 2.00  turnaround 7.00  wait 2.00\n  job   2 -- response: 7.00  turnaround 15.00  wait 7.00\n\n  average -- response: 3.00  turnaround 8.00  wait 3.00\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n从上述输出我们可以看到，作业0首先运行了2秒，作业2接着运行了5秒，最后作业2运行了8秒。 最终的统计数据也很有用：它们计算“响应时间”（作业到达后第一次运行之前等待所花费的时间）、“周转时间”（自第一次到达以来完成作业所花费的时间）以及总时间。 “等待时间”（准备好但未运行的任何时间）。统计数据按作业显示，然后显示所有作业的平均值。当然，您应该在使用“-c”选项运行之前计算出所有这些内容！ 如果您想尝试相同类型的问题但使用不同的输入，请尝试更改作业数量或随机种子或同时更改两者。不同的随机种子基本上为您提供了一种为自己生成无数不同问题的方法，并且“-c”选项可以让您检查自己的工作。继续这样做，直到您觉得自己真正理解了这些概念。 另一个有用的选项是“-l”（这是一个小写的 l），它可以让您指定您希望看到的计划的确切作业。例如，如果您想了解 sjf 如何执行长度为 5、10 和 15 的三个作业，您可以运行：\n\n❯ python scheduler.py -p sjf -l 5,10,15\narg policy sjf\narg jlist 5,10,15\n\nhere is the job list, with the run time of each job: \n  job 0 ( length = 5.0 )\n  job 1 ( length = 10.0 )\n  job 2 ( length = 15.0 )\n\n\ncompute the turnaround time, response time, and wait time for each job.\nwhen you are done, run this program again, with the same arguments,\nbut with -c, which will thus provide you with the answers. you can use\n-s <somenumber> or your own job list (-l 10,15,20 for example)\nto generate different problems for yourself.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n计算完后还是通过-c选项获得答案。指定确切的作业时，无须指定随机种子或者作业数量。 我们最后测试一下rr，可以运行：\n\n❯ python scheduler.py -p rr -l 5,10,15 -c\narg policy rr\narg jlist 5,10,15\n\nhere is the job list, with the run time of each job: \n  job 0 ( length = 5.0 )\n  job 1 ( length = 10.0 )\n  job 2 ( length = 15.0 )\n\n\n** solutions **\n\nexecution trace:\n  [ time   0 ] run job   0 for 1.00 secs\n  [ time   1 ] run job   1 for 1.00 secs\n  [ time   2 ] run job   2 for 1.00 secs\n  [ time   3 ] run job   0 for 1.00 secs\n  [ time   4 ] run job   1 for 1.00 secs\n  [ time   5 ] run job   2 for 1.00 secs\n  [ time   6 ] run job   0 for 1.00 secs\n  [ time   7 ] run job   1 for 1.00 secs\n  [ time   8 ] run job   2 for 1.00 secs\n  [ time   9 ] run job   0 for 1.00 secs\n  [ time  10 ] run job   1 for 1.00 secs\n  [ time  11 ] run job   2 for 1.00 secs\n  [ time  12 ] run job   0 for 1.00 secs ( done at 13.00 )\n  [ time  13 ] run job   1 for 1.00 secs\n  [ time  14 ] run job   2 for 1.00 secs\n  [ time  15 ] run job   1 for 1.00 secs\n  [ time  16 ] run job   2 for 1.00 secs\n  [ time  17 ] run job   1 for 1.00 secs\n  [ time  18 ] run job   2 for 1.00 secs\n  [ time  19 ] run job   1 for 1.00 secs\n  [ time  20 ] run job   2 for 1.00 secs\n  [ time  21 ] run job   1 for 1.00 secs\n  [ time  22 ] run job   2 for 1.00 secs\n  [ time  23 ] run job   1 for 1.00 secs ( done at 24.00 )\n  [ time  24 ] run job   2 for 1.00 secs\n  [ time  25 ] run job   2 for 1.00 secs\n  [ time  26 ] run job   2 for 1.00 secs\n  [ time  27 ] run job   2 for 1.00 secs\n  [ time  28 ] run job   2 for 1.00 secs\n  [ time  29 ] run job   2 for 1.00 secs ( done at 30.00 )\n\nfinal statistics:\n  job   0 -- response: 0.00  turnaround 13.00  wait 8.00\n  job   1 -- response: 1.00  turnaround 24.00  wait 14.00\n  job   2 -- response: 2.00  turnaround 30.00  wait 15.00\n\n  average -- response: 1.00  turnaround 22.33  wait 12.33\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 2 qa\n\n> 以下问题都可以通过scheduler.py进行验证\n\n 1. 使用 sjf 和 fifo 调度器运行长度为 200 的三个作业时，计算响应时间和周转时间\n    * sjf turnaround=200−0+400−0+600−03=400turnaround = \\frac{200-0+400-0+600-0}{3}=400turnaround=3200−0+400−0+600−0 =400 response=0+200+4003=200response=\\frac{0+200+400}{3}=200response=30+200+400 =200\n    * fifo 跟sjf一样\n 2. 现在执行相同的操作，但使用不同长度的作业：100、200 和 300。\n    * sjf turnaround=100−0+300−0+600−03=333turnaround = \\frac{100-0+300-0+600-0}{3}=333turnaround=3100−0+300−0+600−0 =333 response=0+100+3003=133response=\\frac{0+100+300}{3}=133response=30+100+300 =133\n    * fifo 由于到达时间是一样，所以调度具有不确定性，最佳方案就是和sjf一样。\n 3. 现在执行相同的操作，但也使用 rr 调度程序和时间片 1 对于rr，response=0+1+23=1response=\\frac{0+1+2}{3}=1response=30+1+2 =1 turnaround=298+499+6003=265.67turnaround=\\frac{298+499+600}{3}=265.67turnaround=3298+499+600 =265.67\n 4. 在哪些类型的工作负载中，sjf 的周转时间与 fifo 相同？\n    \n    > sjf 始终提供与 fifo 相同的周转时间，除非较短的作业在较长的作业之后到达。只要所有作业长度相等或按升序到达，周转时间就会相同。\n\n 5. 在哪些类型的工作负载和时间片长度下，sjf 可以提供与 rr 相同的响应时间？\n    \n    > 如果所有作业长度(x)相同，且时间片长度(q)=x，在这种情况下，sjf提供与rr相同的响应时间。通过运行以下代码验证： ./scheduler.py -p sjf -l 100,100,100 -c ./scheduler.py -p rr -l 100,100,100 -c -q 100\n\n 6. 随着作业长度的增加，sjf 的响应时间会发生什么变化？您能否使用模拟器来演示这一趋势？\n    \n    > 如果我们将每个工作的长度加倍，平均响应时间也会加倍。这意味着工作长度和响应时间之间存在线性关系。\n\n 7. 随着时间片长度的增加，rr 的响应时间会发生什么变化？你能写出一个方程，在给定 n 个作业的情况下给出最坏情况的响应时间吗？\n    \n    > 响应时间随着时间片长度的增加而线性增加。令 n 为作业数量，q 为时间片长度，则最坏情况的响应时间为 (n−1)qn\\frac{(n-1)q}{n}n(n−1)q 。",charsets:{cjk:!0},lastUpdated:"2024/05/11, 20:33:38",lastUpdatedTimestamp:1715430818e3},{title:"地址转换",frontmatter:{title:"地址转换",tags:["OS"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},date:"2024-04-25T22:37:32.000Z",permalink:"/pages/542fcd/",categories:["开发","系统架构","操作系统","虚拟化"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/02.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/10.%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.html",relativePath:"01.开发/05.系统架构/02.操作系统/10.地址转换.md",key:"v-61cadb70",path:"/pages/542fcd/",headers:[{level:2,title:"1 假设（第一次尝试）",slug:"_1-假设-第一次尝试",normalizedTitle:"1 假设（第一次尝试）",charIndex:453},{level:2,title:"2 例子",slug:"_2-例子",normalizedTitle:"2 例子",charIndex:540},{level:2,title:"3 动态（基于硬件）重定位",slug:"_3-动态-基于硬件-重定位",normalizedTitle:"3 动态（基于硬件）重定位",charIndex:1659},{level:2,title:"4 内存虚拟化的操作系统问题",slug:"_4-内存虚拟化的操作系统问题",normalizedTitle:"4 内存虚拟化的操作系统问题",charIndex:3239},{level:2,title:"5 总结",slug:"_5-总结",normalizedTitle:"5 总结",charIndex:6513}],headersStr:"1 假设（第一次尝试） 2 例子 3 动态（基于硬件）重定位 4 内存虚拟化的操作系统问题 5 总结",content:'虚拟化内存使用的通用技术被称为基于硬件的地址转换，或者简称为地址转换，您可以将其视为对有限直接执行的通用方法的补充。通过地址转换，硬件可以转换每个内存访问（例如，指令提取、加载或存储），将指令提供的虚拟地址更改为所需信息实际所在的物理地址。因此，对于每个存储器引用，硬件都会执行地址转换，以将应用程序存储器引用重定向到它们在存储器中的实际位置。当然，硬件本身无法虚拟化内存，因为它只是提供了有效地虚拟化内存的低级机制。操作系统必须在关键点参与设置硬件，以便进行正确的转换；因此，它必须管理内存，跟踪哪些位置是空闲的，哪些位置正在使用，并明智地进行干预以保持对内存使用方式的控制。\n\n所有这些工作的目标再次是创造一个美丽的幻觉：程序拥有自己的私有内存，其中驻留着自己的代码和数据。虚拟现实的背后隐藏着丑陋的物理事实：当 CPU（或多个 CPU）在运行一个程序和下一个程序之间切换时，许多程序实际上同时共享内存。通过虚拟化，操作系统（在硬件的帮助下）将丑陋的机器现实转变为有用、强大且易于使用的抽象。\n\n\n# 1 假设（第一次尝试）\n\n 1. 用户地址空间在内存中是连续的\n 2. 用户地址空间小于物理内存（最大64KB）\n 3. 每个地址空间具有相同的大小（最大16KB）\n\n\n# 2 例子\n\n我们看一个简单的例子。假设有一个进程，其地址空间如下图所示。\n\n我们要研究的是一个简短的代码序列：从内存中加载一个值，将其增加 3，然后将该值存储回内存中。\n\nvoid func() {\nint x = 3000;\nx = x + 3; // this is the line of code we are interested in\n...\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n编译器将这行代码转换为汇编语言，可能看起来像这样（在 x86 汇编语言中）。在 Linux 上使用 objdump 或在 Mac 上使用 otool 来反汇编它：\n\n128: movl 0x0(%ebx), %eax ;load 0+ebx into eax\n132: addl $0x03, %eax ;add 3 to eax register\n135: movl %eax, 0x0(%ebx) ;store eax back to mem\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n这段代码相对简单；它假定 x 的地址已放入寄存器 ebx 中，然后使用 movl 指令（用于“长字”移动）将该地址处的值加载到通用寄存器 eax 中。下一条指令将 eax 加 3，最后一条指令将 eax 中的值存储回内存中的同一位置。\n\n在上图中，观察代码和数据在进程地址空间中的布局方式；三指令代码序列位于地址 128（在靠近顶部的代码段中），变量 x 的值位于地址 15 KB（在靠近底部的堆栈中）。图中，x的初始值为3000，如其在堆栈中的位置所示。当这些指令运行时，从进程的角度来看，会发生以下内存访问。\n\n 1. 取地址 128 的指令\n 2. 执行该指令（从地址 15 KB 加载）\n 3. 取地址 132 的指令 - 执行该指令（无内存引用）\n 4. 取地址 135 的指令\n 5. 执行该指令（存储到地址 15 KB）\n\n从程序的角度来看，它的地址空间从地址0开始，最大增长到16KB；它生成的所有内存引用都应该在这些范围内。然而，为了虚拟化内存，操作系统希望将进程放置在物理内存中的其他位置，而不一定是地址0。因此，我们遇到了问题：如何以对进程透明的方式在内存中重新定位该进程？当实际上地址空间位于其他物理地址时，我们如何提供从 0 开始的虚拟地址空间的假象？\n\n下图展示了进程的地址空间放入内存后物理内存可能是什么样子。在图中，您可以看到操作系统为自己使用物理内存的第一个插槽，并且它已将上例中的进程重新定位到从物理内存地址 32 KB 开始的插槽中。另外两个插槽是空闲的（16 KB-32 KB 和 48 KB-64 KB）。\n\n\n# 3 动态（基于硬件）重定位\n\n为了对基于硬件的地址转换有一定的了解，我们首先讨论它的第一个版本。 1950 年代末的第一台分时机中引入了一个简单的概念，称为基数和边界；该技术也称为动态重定位；我们将交替使用这两个术语。\n\n具体来说，每个 CPU 中我们需要两个硬件寄存器：一个称为基址寄存器，另一个称为边界寄存器（有时称为限制寄存器）。这个基址和边界对将允许我们将地址空间放置在物理内存中的任何位置，并同时确保进程只能访问自己的地址空间。\n\n在此设置中，每个程序都被编写和编译，就好像它被加载到地址零一样。但是，当程序开始运行时，操作系统会决定应将其加载到物理内存中的何处，并将基址寄存器设置为该值。\n\n在上面的示例中，操作系统决定在物理地址 32 KB 处加载进程，从而将基址寄存器设置为该值，如下图所示。\n\n当进程运行时，有趣的事情开始发生。现在，当进程生成任何内存引用时，处理器会按以下方式对其进行转换：\n\nphysical address = virtual address + base\n\n\n1\n\n1\n\n\n进程生成的每个内存引用都是一个虚拟地址；硬件依次将基址寄存器的内容添加到该地址，结果是内存系统的物理地址。\n\n为了更好地理解这一点，让我们追踪一下执行单个指令时会发生什么。具体来说，让我们看一下前面序列中的一条指令：\n\nasm 128: movl 0x0(%ebx), %eax\n\n\n1\n\n1\n\n\n程序计数器 (PC) 设置为 128；当硬件需要取该指令时，首先将该值与基址寄存器值32 KB（32768）相加，得到物理地址32896；然后硬件从该物理地址获取指令。\n\n接下来，处理器开始执行指令。在某个时刻，进程会从虚拟地址 15 KB 发出加载，处理器将其获取并再次添加到基址寄存器 (32 KB)，从而获得 47 KB 的最终物理地址，从而获得所需的内容。\n\n将虚拟地址转换为物理地址正是我们所说的地址转换技术；也就是说，硬件获取进程认为它正在引用的虚拟地址，并将其转换为数据实际驻留的物理地址。因为这种地址重定位发生在运行时，并且即使在进程开始运行后我们也可以移动地址空间，所以该技术通常称为动态重定位。\n\n现在您可能会问：边界（限制）寄存器发生了什么，起到了什么作用？毕竟，这不是基数和边界方法吗？它的确是。正如您可能已经猜到的，边界寄存器是为了帮助保护。具体来说，处理器会首先检查内存引用是否在范围内，以确保它是合法的；在上面的简单示例中，边界寄存器将始终设置为 16 KB。如果进程生成的虚拟地址大于边界，或者为负数，CPU 将引发异常，并且该进程可能会被终止。因此，边界的目的是确保进程生成的所有地址都是合法的并且在进程的“边界”内。\n\n我们应该注意，基址寄存器和边界寄存器是保存在芯片上的硬件结构（每个 CPU 一对）。有时人们将处理器中帮助进行地址转换的部分称为内存管理单元（MMU）；随着我们开发更复杂的内存管理技术，我们将为 MMU 添加更多电路。如下图所示。\n\n为了更详细地理解通过基址和边界进行的地址转换，让我们来看一个例子。想象一下，一个地址空间大小为 4 KB的进程被加载到物理地址 16 KB。下面是一些地址转换的结果：\n\nVIRTUAL ADDRESS   PHYSICAL ADDRESS\n0                 16 KB\n1 KB              17 KB\n3000              19384\n4400              Fault (Out of Bounds)\n\n从示例中可以看出，只需将基地址与虚拟地址相加（可以正确地将其视为地址空间的偏移量），就可以轻松得到物理地址。只有当虚拟地址 "过大 "或为负数时，结果才会是一个错误，从而引发异常。\n\n\n# 4 内存虚拟化的操作系统问题\n\n正如硬件提供了支持动态重定位的新功能一样，操作系统现在也有必须处理的新问题；硬件支持和操作系统管理的结合导致了简单虚拟内存的实现。具体来说，有几个关键时刻，操作系统必须参与其中，以实现我们的虚拟内存的基址和边界版本。\n\n首先，操作系统必须在创建进程时采取行动，为其在内存中的地址空间找到空间。幸运的是，考虑到我们假设每个地址空间（a）小于物理内存的大小以及（b）相同的大小，这对于操作系统来说非常容易；它可以简单地将物理内存视为一组插槽，并跟踪每个插槽是否空闲或正在使用。创建新进程时，操作系统必须搜索数据结构（通常称为空闲列表）来为新地址空间找到空间，然后将其标记为已使用。对于可变大小的地址空间，情况会更加复杂。\n\n让我们看一个例子。如下图所示，您可以看到操作系统为自己使用物理内存的第一个插槽，并且它已将上面示例中的进程重新定位到从物理内存地址 32 KB 开始的插槽中。另外两个插槽是空闲的（16 KB-32 KB 和 48 KB-64 KB）；因此，空闲列表应该由这两个条目组成。\n\n第二，当进程终止时（即，当它正常退出或由于行为不当而被强制终止时），操作系统必须做一些工作，回收其所有内存以供其他进程或操作系统使用。进程终止后，操作系统会将其内存放回到空闲列表中，并根据需要清理任何关联的数据结构，如下图所示。\n\n第三，当发生上下文切换时，操作系统还必须执行一些额外的步骤。毕竟，每个 CPU 上只有一对基址和边界寄存器，并且每个正在运行的程序的值都不同，因为每个程序都加载到内存中不同的物理地址。因此，操作系统在进程之间切换时必须保存和恢复基址和边界对。\n\n具体来说，当操作系统决定停止运行某个进程时，它必须将基址寄存器和边界寄存器的值保存到内存中的某些每个进程的结构中，例如进程结构或进程控制块 (PCB)。同样，当操作系统恢复正在运行的进程（或第一次运行它）时，它必须将 CPU 上的基数和边界值设置为该进程的正确值，如下图所示。\n\n我们应该注意到，当进程停止（即不运行）时，操作系统可以很容易地将地址空间从内存中的一个位置移动到另一个位置。要移动进程的地址空间，操作系统首先会对进程取消调度；然后，操作系统会将地址空间从当前位置复制到新位置；最后，操作系统会更新（进程结构中的）保存基址寄存器，使其指向新位置。当进程恢复时，它的（新）基址寄存器会被恢复，然后它又开始运行，全然不顾它的指令和数据现在在内存中一个全新的位置。\n\n第四，如上所述，操作系统必须提供异常处理程序或调用函数；操作系统在启动时（通过特权指令）安装这些处理程序。例如，如果一个进程试图访问超出其边界的内存，CPU 就会引发异常；操作系统必须做好准备，在出现这种异常时采取行动。操作系统的通常反应是敌意：它可能会终止违规进程。操作系统应高度保护它所运行的机器，因此它不会善待试图访问内存或执行不该执行指令的进程。\n\n下表以时间轴的形式展示了硬件与操作系统之间的交互。表中显示了操作系统在启动时为准备使用机器所做的工作，以及进程（进程 A）开始运行时发生的情况；请注意其内存转换是如何在没有操作系统干预的情况下由硬件处理的。此时，操作系统必须介入，终止进程并清理 B 的内存，将其从进程表中删除。从表中可以看出，我们仍然遵循有限直接执行的基本方法。在大多数情况下，操作系统只需适当设置硬件，让进程直接在 CPU 上运行；只有当进程出现异常时，操作系统才会介入。\n\nOS @ BOOT (KERNEL MODE)                                       HARDWARE                                           PROGRAM (USER MODE)\n初始化中断表                                                        记住系统调用处理程序、定时器处理程序 、非法内存访问处理程序、非法指令处理程序......的地址   -\n启动中断定时器                                                       启动计时器；X 毫秒后中断                                      -\n初始化进程表；初始化空闲列表                                                -                                                  -\nOS @ run (kernel mode)                                        Hardware                                           Program (user mode)\n启动进程 A： 分配进程表中的条目；为进程分配内存；设置基准/边界寄存器 ；从中断返回（进入 A）             -                                                  -\n                                                              恢复 A 的寄存器；移动到用户模式；跳转到 A 的（初始）PC                    进程 A 运行；取指令\n                                                              转换虚拟地址并执行提取                                        执行指令\n                                                              如果是显式加载/存储：确保地址在边界内；转换虚拟地址并执行加载/存储                 \n                                                              定时器中断转入内核模式；跳转到中断处理程序                              \n处理中断； 调用 switch() 例程 ；将 regs(A) 保存到 proc-struct(A)（包括基址/边界）                                                      \n；从 proc-struct(B)（包括基址/边界）恢复 regs(B) ；从中断返回 (进入B）\n                                                              恢复B的寄存器；转移到用户模式； 跳转到B的PC                           \n                                                                                                                 进程B运行；执行错误加载\n                                                              加载越界；转入内核模式，跳转到中断处理程序                              \n处理中断；决定终止进程 B；释放 B 的内存；释放 B 在进程表中的条目                                                                             \n\n\n# 5 总结\n\n在本章中，我们用虚拟内存中使用的一种特定机制（即地址转换）扩展了有限直接执行的概念。通过地址转换，操作系统可以控制进程的每次内存访问，确保访问不超出地址空间的范围。硬件支持是这项技术高效的关键，它能为每次访问快速执行转换，将虚拟地址（进程对内存的看法）转换为物理地址（实际看法）。所有这些都是以对被重定位的进程透明的方式进行的，进程根本不知道其内存引用正在被转换，这就造成了一种奇妙的错觉。\n\n我们还看到了一种特殊形式的虚拟化，即基址边界虚拟化或动态重定位。基址边界虚拟化相当高效，因为只需要多一点硬件逻辑，就能在虚拟地址中添加一个基址寄存器，并检查进程生成的地址是否在边界内。基址边界虚拟化还能提供保护；操作系统和硬件相结合，确保任何进程都无法在自身地址空间之外生成内存引用。保护无疑是操作系统最重要的目标之一；如果没有保护，操作系统就无法控制机器（如果进程可以随意覆盖内存，它们就能轻易做出一些令人讨厌的事情，比如覆盖中断表并接管系统）。\n\n不过，这种简单的动态重定位技术确实存在效率低下的问题。例如，如上图所示，重定位后的进程使用的物理内存从 32 KB 增加到 48 KB，但由于进程堆栈和堆并不太大，两者之间的所有空间都被浪费掉了。这种浪费通常被称为内部碎片，因为分配单元内部的空间没有被全部使用（即被碎片化），从而造成浪费。在我们目前的方法中，虽然可能有足够的物理内存来容纳更多进程，但我们目前只能将地址空间放置在固定大小的插槽中，因此可能会出现内部碎片。因此，我们需要更复杂的机制来更好地利用物理内存，避免内部碎片。',normalizedContent:'虚拟化内存使用的通用技术被称为基于硬件的地址转换，或者简称为地址转换，您可以将其视为对有限直接执行的通用方法的补充。通过地址转换，硬件可以转换每个内存访问（例如，指令提取、加载或存储），将指令提供的虚拟地址更改为所需信息实际所在的物理地址。因此，对于每个存储器引用，硬件都会执行地址转换，以将应用程序存储器引用重定向到它们在存储器中的实际位置。当然，硬件本身无法虚拟化内存，因为它只是提供了有效地虚拟化内存的低级机制。操作系统必须在关键点参与设置硬件，以便进行正确的转换；因此，它必须管理内存，跟踪哪些位置是空闲的，哪些位置正在使用，并明智地进行干预以保持对内存使用方式的控制。\n\n所有这些工作的目标再次是创造一个美丽的幻觉：程序拥有自己的私有内存，其中驻留着自己的代码和数据。虚拟现实的背后隐藏着丑陋的物理事实：当 cpu（或多个 cpu）在运行一个程序和下一个程序之间切换时，许多程序实际上同时共享内存。通过虚拟化，操作系统（在硬件的帮助下）将丑陋的机器现实转变为有用、强大且易于使用的抽象。\n\n\n# 1 假设（第一次尝试）\n\n 1. 用户地址空间在内存中是连续的\n 2. 用户地址空间小于物理内存（最大64kb）\n 3. 每个地址空间具有相同的大小（最大16kb）\n\n\n# 2 例子\n\n我们看一个简单的例子。假设有一个进程，其地址空间如下图所示。\n\n我们要研究的是一个简短的代码序列：从内存中加载一个值，将其增加 3，然后将该值存储回内存中。\n\nvoid func() {\nint x = 3000;\nx = x + 3; // this is the line of code we are interested in\n...\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n编译器将这行代码转换为汇编语言，可能看起来像这样（在 x86 汇编语言中）。在 linux 上使用 objdump 或在 mac 上使用 otool 来反汇编它：\n\n128: movl 0x0(%ebx), %eax ;load 0+ebx into eax\n132: addl $0x03, %eax ;add 3 to eax register\n135: movl %eax, 0x0(%ebx) ;store eax back to mem\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n这段代码相对简单；它假定 x 的地址已放入寄存器 ebx 中，然后使用 movl 指令（用于“长字”移动）将该地址处的值加载到通用寄存器 eax 中。下一条指令将 eax 加 3，最后一条指令将 eax 中的值存储回内存中的同一位置。\n\n在上图中，观察代码和数据在进程地址空间中的布局方式；三指令代码序列位于地址 128（在靠近顶部的代码段中），变量 x 的值位于地址 15 kb（在靠近底部的堆栈中）。图中，x的初始值为3000，如其在堆栈中的位置所示。当这些指令运行时，从进程的角度来看，会发生以下内存访问。\n\n 1. 取地址 128 的指令\n 2. 执行该指令（从地址 15 kb 加载）\n 3. 取地址 132 的指令 - 执行该指令（无内存引用）\n 4. 取地址 135 的指令\n 5. 执行该指令（存储到地址 15 kb）\n\n从程序的角度来看，它的地址空间从地址0开始，最大增长到16kb；它生成的所有内存引用都应该在这些范围内。然而，为了虚拟化内存，操作系统希望将进程放置在物理内存中的其他位置，而不一定是地址0。因此，我们遇到了问题：如何以对进程透明的方式在内存中重新定位该进程？当实际上地址空间位于其他物理地址时，我们如何提供从 0 开始的虚拟地址空间的假象？\n\n下图展示了进程的地址空间放入内存后物理内存可能是什么样子。在图中，您可以看到操作系统为自己使用物理内存的第一个插槽，并且它已将上例中的进程重新定位到从物理内存地址 32 kb 开始的插槽中。另外两个插槽是空闲的（16 kb-32 kb 和 48 kb-64 kb）。\n\n\n# 3 动态（基于硬件）重定位\n\n为了对基于硬件的地址转换有一定的了解，我们首先讨论它的第一个版本。 1950 年代末的第一台分时机中引入了一个简单的概念，称为基数和边界；该技术也称为动态重定位；我们将交替使用这两个术语。\n\n具体来说，每个 cpu 中我们需要两个硬件寄存器：一个称为基址寄存器，另一个称为边界寄存器（有时称为限制寄存器）。这个基址和边界对将允许我们将地址空间放置在物理内存中的任何位置，并同时确保进程只能访问自己的地址空间。\n\n在此设置中，每个程序都被编写和编译，就好像它被加载到地址零一样。但是，当程序开始运行时，操作系统会决定应将其加载到物理内存中的何处，并将基址寄存器设置为该值。\n\n在上面的示例中，操作系统决定在物理地址 32 kb 处加载进程，从而将基址寄存器设置为该值，如下图所示。\n\n当进程运行时，有趣的事情开始发生。现在，当进程生成任何内存引用时，处理器会按以下方式对其进行转换：\n\nphysical address = virtual address + base\n\n\n1\n\n1\n\n\n进程生成的每个内存引用都是一个虚拟地址；硬件依次将基址寄存器的内容添加到该地址，结果是内存系统的物理地址。\n\n为了更好地理解这一点，让我们追踪一下执行单个指令时会发生什么。具体来说，让我们看一下前面序列中的一条指令：\n\nasm 128: movl 0x0(%ebx), %eax\n\n\n1\n\n1\n\n\n程序计数器 (pc) 设置为 128；当硬件需要取该指令时，首先将该值与基址寄存器值32 kb（32768）相加，得到物理地址32896；然后硬件从该物理地址获取指令。\n\n接下来，处理器开始执行指令。在某个时刻，进程会从虚拟地址 15 kb 发出加载，处理器将其获取并再次添加到基址寄存器 (32 kb)，从而获得 47 kb 的最终物理地址，从而获得所需的内容。\n\n将虚拟地址转换为物理地址正是我们所说的地址转换技术；也就是说，硬件获取进程认为它正在引用的虚拟地址，并将其转换为数据实际驻留的物理地址。因为这种地址重定位发生在运行时，并且即使在进程开始运行后我们也可以移动地址空间，所以该技术通常称为动态重定位。\n\n现在您可能会问：边界（限制）寄存器发生了什么，起到了什么作用？毕竟，这不是基数和边界方法吗？它的确是。正如您可能已经猜到的，边界寄存器是为了帮助保护。具体来说，处理器会首先检查内存引用是否在范围内，以确保它是合法的；在上面的简单示例中，边界寄存器将始终设置为 16 kb。如果进程生成的虚拟地址大于边界，或者为负数，cpu 将引发异常，并且该进程可能会被终止。因此，边界的目的是确保进程生成的所有地址都是合法的并且在进程的“边界”内。\n\n我们应该注意，基址寄存器和边界寄存器是保存在芯片上的硬件结构（每个 cpu 一对）。有时人们将处理器中帮助进行地址转换的部分称为内存管理单元（mmu）；随着我们开发更复杂的内存管理技术，我们将为 mmu 添加更多电路。如下图所示。\n\n为了更详细地理解通过基址和边界进行的地址转换，让我们来看一个例子。想象一下，一个地址空间大小为 4 kb的进程被加载到物理地址 16 kb。下面是一些地址转换的结果：\n\nvirtual address   physical address\n0                 16 kb\n1 kb              17 kb\n3000              19384\n4400              fault (out of bounds)\n\n从示例中可以看出，只需将基地址与虚拟地址相加（可以正确地将其视为地址空间的偏移量），就可以轻松得到物理地址。只有当虚拟地址 "过大 "或为负数时，结果才会是一个错误，从而引发异常。\n\n\n# 4 内存虚拟化的操作系统问题\n\n正如硬件提供了支持动态重定位的新功能一样，操作系统现在也有必须处理的新问题；硬件支持和操作系统管理的结合导致了简单虚拟内存的实现。具体来说，有几个关键时刻，操作系统必须参与其中，以实现我们的虚拟内存的基址和边界版本。\n\n首先，操作系统必须在创建进程时采取行动，为其在内存中的地址空间找到空间。幸运的是，考虑到我们假设每个地址空间（a）小于物理内存的大小以及（b）相同的大小，这对于操作系统来说非常容易；它可以简单地将物理内存视为一组插槽，并跟踪每个插槽是否空闲或正在使用。创建新进程时，操作系统必须搜索数据结构（通常称为空闲列表）来为新地址空间找到空间，然后将其标记为已使用。对于可变大小的地址空间，情况会更加复杂。\n\n让我们看一个例子。如下图所示，您可以看到操作系统为自己使用物理内存的第一个插槽，并且它已将上面示例中的进程重新定位到从物理内存地址 32 kb 开始的插槽中。另外两个插槽是空闲的（16 kb-32 kb 和 48 kb-64 kb）；因此，空闲列表应该由这两个条目组成。\n\n第二，当进程终止时（即，当它正常退出或由于行为不当而被强制终止时），操作系统必须做一些工作，回收其所有内存以供其他进程或操作系统使用。进程终止后，操作系统会将其内存放回到空闲列表中，并根据需要清理任何关联的数据结构，如下图所示。\n\n第三，当发生上下文切换时，操作系统还必须执行一些额外的步骤。毕竟，每个 cpu 上只有一对基址和边界寄存器，并且每个正在运行的程序的值都不同，因为每个程序都加载到内存中不同的物理地址。因此，操作系统在进程之间切换时必须保存和恢复基址和边界对。\n\n具体来说，当操作系统决定停止运行某个进程时，它必须将基址寄存器和边界寄存器的值保存到内存中的某些每个进程的结构中，例如进程结构或进程控制块 (pcb)。同样，当操作系统恢复正在运行的进程（或第一次运行它）时，它必须将 cpu 上的基数和边界值设置为该进程的正确值，如下图所示。\n\n我们应该注意到，当进程停止（即不运行）时，操作系统可以很容易地将地址空间从内存中的一个位置移动到另一个位置。要移动进程的地址空间，操作系统首先会对进程取消调度；然后，操作系统会将地址空间从当前位置复制到新位置；最后，操作系统会更新（进程结构中的）保存基址寄存器，使其指向新位置。当进程恢复时，它的（新）基址寄存器会被恢复，然后它又开始运行，全然不顾它的指令和数据现在在内存中一个全新的位置。\n\n第四，如上所述，操作系统必须提供异常处理程序或调用函数；操作系统在启动时（通过特权指令）安装这些处理程序。例如，如果一个进程试图访问超出其边界的内存，cpu 就会引发异常；操作系统必须做好准备，在出现这种异常时采取行动。操作系统的通常反应是敌意：它可能会终止违规进程。操作系统应高度保护它所运行的机器，因此它不会善待试图访问内存或执行不该执行指令的进程。\n\n下表以时间轴的形式展示了硬件与操作系统之间的交互。表中显示了操作系统在启动时为准备使用机器所做的工作，以及进程（进程 a）开始运行时发生的情况；请注意其内存转换是如何在没有操作系统干预的情况下由硬件处理的。此时，操作系统必须介入，终止进程并清理 b 的内存，将其从进程表中删除。从表中可以看出，我们仍然遵循有限直接执行的基本方法。在大多数情况下，操作系统只需适当设置硬件，让进程直接在 cpu 上运行；只有当进程出现异常时，操作系统才会介入。\n\nos @ boot (kernel mode)                                       hardware                                           program (user mode)\n初始化中断表                                                        记住系统调用处理程序、定时器处理程序 、非法内存访问处理程序、非法指令处理程序......的地址   -\n启动中断定时器                                                       启动计时器；x 毫秒后中断                                      -\n初始化进程表；初始化空闲列表                                                -                                                  -\nos @ run (kernel mode)                                        hardware                                           program (user mode)\n启动进程 a： 分配进程表中的条目；为进程分配内存；设置基准/边界寄存器 ；从中断返回（进入 a）             -                                                  -\n                                                              恢复 a 的寄存器；移动到用户模式；跳转到 a 的（初始）pc                    进程 a 运行；取指令\n                                                              转换虚拟地址并执行提取                                        执行指令\n                                                              如果是显式加载/存储：确保地址在边界内；转换虚拟地址并执行加载/存储                 \n                                                              定时器中断转入内核模式；跳转到中断处理程序                              \n处理中断； 调用 switch() 例程 ；将 regs(a) 保存到 proc-struct(a)（包括基址/边界）                                                      \n；从 proc-struct(b)（包括基址/边界）恢复 regs(b) ；从中断返回 (进入b）\n                                                              恢复b的寄存器；转移到用户模式； 跳转到b的pc                           \n                                                                                                                 进程b运行；执行错误加载\n                                                              加载越界；转入内核模式，跳转到中断处理程序                              \n处理中断；决定终止进程 b；释放 b 的内存；释放 b 在进程表中的条目                                                                             \n\n\n# 5 总结\n\n在本章中，我们用虚拟内存中使用的一种特定机制（即地址转换）扩展了有限直接执行的概念。通过地址转换，操作系统可以控制进程的每次内存访问，确保访问不超出地址空间的范围。硬件支持是这项技术高效的关键，它能为每次访问快速执行转换，将虚拟地址（进程对内存的看法）转换为物理地址（实际看法）。所有这些都是以对被重定位的进程透明的方式进行的，进程根本不知道其内存引用正在被转换，这就造成了一种奇妙的错觉。\n\n我们还看到了一种特殊形式的虚拟化，即基址边界虚拟化或动态重定位。基址边界虚拟化相当高效，因为只需要多一点硬件逻辑，就能在虚拟地址中添加一个基址寄存器，并检查进程生成的地址是否在边界内。基址边界虚拟化还能提供保护；操作系统和硬件相结合，确保任何进程都无法在自身地址空间之外生成内存引用。保护无疑是操作系统最重要的目标之一；如果没有保护，操作系统就无法控制机器（如果进程可以随意覆盖内存，它们就能轻易做出一些令人讨厌的事情，比如覆盖中断表并接管系统）。\n\n不过，这种简单的动态重定位技术确实存在效率低下的问题。例如，如上图所示，重定位后的进程使用的物理内存从 32 kb 增加到 48 kb，但由于进程堆栈和堆并不太大，两者之间的所有空间都被浪费掉了。这种浪费通常被称为内部碎片，因为分配单元内部的空间没有被全部使用（即被碎片化），从而造成浪费。在我们目前的方法中，虽然可能有足够的物理内存来容纳更多进程，但我们目前只能将地址空间放置在固定大小的插槽中，因此可能会出现内部碎片。因此，我们需要更复杂的机制来更好地利用物理内存，避免内部碎片。',charsets:{cjk:!0},lastUpdated:"2024/05/11, 20:33:38",lastUpdatedTimestamp:1715430818e3},{title:"Linux常用文件管理命令",frontmatter:{title:"Linux常用文件管理命令",date:"2022-01-21T00:00:00.000Z",tags:["Linux"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/b04f81/",categories:["开发","系统架构","Linux"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/01.Linux/02.Linux%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4.html",relativePath:"01.开发/05.系统架构/01.Linux/02.Linux常用文件管理命令.md",key:"v-0b3ccae2",path:"/pages/b04f81/",headers:[{level:2,title:"1. 通用基础知识",slug:"_1-通用基础知识",normalizedTitle:"1. 通用基础知识",charIndex:2},{level:2,title:"2. 文件基础操作",slug:"_2-文件基础操作",normalizedTitle:"2. 文件基础操作",charIndex:197},{level:2,title:"3 编译运行C/C++文件",slug:"_3-编译运行c-c-文件",normalizedTitle:"3 编译运行c/c++文件",charIndex:1975},{level:2,title:"4 参考文献",slug:"_4-参考文献",normalizedTitle:"4 参考文献",charIndex:2152}],headersStr:"1. 通用基础知识 2. 文件基础操作 3 编译运行C/C++文件 4 参考文献",content:'# 1. 通用基础知识\n\n * 查询指令命令help，通过指令名 --help或者man 指令名。\n   \n   例如，我们需要查询ls这个指令的参数用法以及作用，即通过ls --help即可得到如下：\n   \n   \n\n * ctrl c：取消命令，并且换行。\n\n * ctrl u：清空本行命令\n\n * tab：补全命令和文件名，如果补全不了就快速按两下tab键，可以显示备选项。\n\n\n# 2. 文件基础操作\n\n * 注意事项\n   \n   * 如果文件名或者文件夹名存在空格或者一些特殊字符，我们要进行转移表示，即通过转移字符\\来实现。\n   * \n\n * 创建文件夹：mkdir [-p][dirNmae]\n   \n   其中-p确保目录名称一定存在，如果不存在就会创建一个。\n\n * 创建文件：touch [dirName + fileName]\n\n * 显示当前目录下或者指定目录下的所有文件：ls [参数][dirName]\n   \n   其中显示的蓝色是文件夹，白色是普通文件，绿色是可执行文件，如图：\n   \n   \n   \n   参数有：\n   \n   * -a显示所有文件及目录 (. 开头的隐藏文件也会列出)\n   * -l除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出\n   * -r 将文件以相反次序显示(原定依英文字母次序)\n   * -t将文件依建立时间之先后次序列出\n   * -A 同 -a，但不列出 "." (目前目录) 及 ".." (父目录)\n   * -F 在列出的文件名称后加一符号；例如可执行档则加 "*", 目录则加 "/"\n   * -R 若目录下有文件，则以下之文件亦皆依序列出\n\n * 显示目前所在的工作目录的绝对路径名称：pwd\n\n * 切换当前工作目录：cd [dirName]\n   \n   其中dirName可为绝对路径或相对路径，如果没有给出，默认返回家目录。cd -会返回之前的工作目录\n\n * 删除文件或文件夹：rm [dirName] [options]，\n   \n   其中选项包括：\n   \n   ` -i` 删除前逐一询问确认。\n   \n   \n   -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。\n   \n   -r 将目录及以下之档案亦逐一删除,递归所有的子目录,逐一询问。\n   \n   一般删除普通文件直接使用rm [dirName]\n\n * 创建编写文件：vim [dirName]\n   \n   创建好之后会自动进入文件，这个时候我们事写不动东西的，所以我们需要输入小写字母i（为insert的缩写）即可写入，写完之后如何保存？我们先需要按ESC键锁住文件，再输入:wq即可，这个命令就是保存并退出的意思。\n\n * 查看文件：cat [dirName]\n\n * 复制文件：cp [options] source dest\n   \n   其中参数说明：\n   \n   * -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。\n   * -d：复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式。\n   * -f：覆盖已经存在的目标文件而不给出提示。\n   * -i：与 -f 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答 y 时目标文件将被覆盖。\n   * -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。\n   * -r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。复制目录的时候一定要添加的参数\n   * -l：不复制文件，只是生成链接文件。\n   \n   即cp = 复制+粘贴+重命名，我们可以看一个例子cp a/tmp.txt b/tmp2.txt，那么会从a中的\n   \n   tmp.txt复制到b中并重命名为tmp2.txt。\n\n * 为文件或目录改名、或将文件或目录移入其它位置：mv [options] source dest。\n   \n   如果需要重命名，就在后面加上新的文件名。\n   \n   其中参数说明\n   \n   * -b: 当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。\n   * -i: 如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作。\n   * -f: 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。\n   * -n: 不要覆盖任何已存在的文件或目录。\n   * -u：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。\n\n\n# 3 编译运行C/C++文件\n\n * 编译\n   \n   g++ 文件名.cpp -o 文件名 -std=版本\n   \n   例如:g++ main.cpp -o main -std=c++11\n   \n   \n   \n   值得注意的一点就是在AC Terminal里面是用不了万能头文件的。\n\n * 运行\n   \n   ./文件名，即可运行。\n\n\n# 4 参考文献\n\ny总Linux基础课',normalizedContent:'# 1. 通用基础知识\n\n * 查询指令命令help，通过指令名 --help或者man 指令名。\n   \n   例如，我们需要查询ls这个指令的参数用法以及作用，即通过ls --help即可得到如下：\n   \n   \n\n * ctrl c：取消命令，并且换行。\n\n * ctrl u：清空本行命令\n\n * tab：补全命令和文件名，如果补全不了就快速按两下tab键，可以显示备选项。\n\n\n# 2. 文件基础操作\n\n * 注意事项\n   \n   * 如果文件名或者文件夹名存在空格或者一些特殊字符，我们要进行转移表示，即通过转移字符\\来实现。\n   * \n\n * 创建文件夹：mkdir [-p][dirnmae]\n   \n   其中-p确保目录名称一定存在，如果不存在就会创建一个。\n\n * 创建文件：touch [dirname + filename]\n\n * 显示当前目录下或者指定目录下的所有文件：ls [参数][dirname]\n   \n   其中显示的蓝色是文件夹，白色是普通文件，绿色是可执行文件，如图：\n   \n   \n   \n   参数有：\n   \n   * -a显示所有文件及目录 (. 开头的隐藏文件也会列出)\n   * -l除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出\n   * -r 将文件以相反次序显示(原定依英文字母次序)\n   * -t将文件依建立时间之先后次序列出\n   * -a 同 -a，但不列出 "." (目前目录) 及 ".." (父目录)\n   * -f 在列出的文件名称后加一符号；例如可执行档则加 "*", 目录则加 "/"\n   * -r 若目录下有文件，则以下之文件亦皆依序列出\n\n * 显示目前所在的工作目录的绝对路径名称：pwd\n\n * 切换当前工作目录：cd [dirname]\n   \n   其中dirname可为绝对路径或相对路径，如果没有给出，默认返回家目录。cd -会返回之前的工作目录\n\n * 删除文件或文件夹：rm [dirname] [options]，\n   \n   其中选项包括：\n   \n   ` -i` 删除前逐一询问确认。\n   \n   \n   -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。\n   \n   -r 将目录及以下之档案亦逐一删除,递归所有的子目录,逐一询问。\n   \n   一般删除普通文件直接使用rm [dirname]\n\n * 创建编写文件：vim [dirname]\n   \n   创建好之后会自动进入文件，这个时候我们事写不动东西的，所以我们需要输入小写字母i（为insert的缩写）即可写入，写完之后如何保存？我们先需要按esc键锁住文件，再输入:wq即可，这个命令就是保存并退出的意思。\n\n * 查看文件：cat [dirname]\n\n * 复制文件：cp [options] source dest\n   \n   其中参数说明：\n   \n   * -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpr参数组合。\n   * -d：复制时保留链接。这里所说的链接相当于 windows 系统中的快捷方式。\n   * -f：覆盖已经存在的目标文件而不给出提示。\n   * -i：与 -f 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答 y 时目标文件将被覆盖。\n   * -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。\n   * -r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。复制目录的时候一定要添加的参数\n   * -l：不复制文件，只是生成链接文件。\n   \n   即cp = 复制+粘贴+重命名，我们可以看一个例子cp a/tmp.txt b/tmp2.txt，那么会从a中的\n   \n   tmp.txt复制到b中并重命名为tmp2.txt。\n\n * 为文件或目录改名、或将文件或目录移入其它位置：mv [options] source dest。\n   \n   如果需要重命名，就在后面加上新的文件名。\n   \n   其中参数说明\n   \n   * -b: 当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。\n   * -i: 如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作。\n   * -f: 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。\n   * -n: 不要覆盖任何已存在的文件或目录。\n   * -u：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。\n\n\n# 3 编译运行c/c++文件\n\n * 编译\n   \n   g++ 文件名.cpp -o 文件名 -std=版本\n   \n   例如:g++ main.cpp -o main -std=c++11\n   \n   \n   \n   值得注意的一点就是在ac terminal里面是用不了万能头文件的。\n\n * 运行\n   \n   ./文件名，即可运行。\n\n\n# 4 参考文献\n\ny总linux基础课',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"页",frontmatter:{title:"页",tags:["OS"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},date:"2024-04-25T22:38:48.000Z",permalink:"/pages/69f0fb/",categories:["开发","系统架构","操作系统","虚拟化"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/02.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/13.%E9%A1%B5.html",relativePath:"01.开发/05.系统架构/02.操作系统/13.页.md",key:"v-12a20be9",path:"/pages/69f0fb/",headers:[{level:2,title:"1 示例：一个简单的分页",slug:"_1-示例-一个简单的分页",normalizedTitle:"1 示例：一个简单的分页",charIndex:437},{level:2,title:"2 页表存储在哪？",slug:"_2-页表存储在哪",normalizedTitle:"2 页表存储在哪？",charIndex:2258},{level:2,title:"3 页表中到底有什么？",slug:"_3-页表中到底有什么",normalizedTitle:"3 页表中到底有什么？",charIndex:2783},{level:2,title:"4 分页：也太慢",slug:"_4-分页-也太慢",normalizedTitle:"4 分页：也太慢",charIndex:3700},{level:2,title:"5 内存跟踪",slug:"_5-内存跟踪",normalizedTitle:"5 内存跟踪",charIndex:5520}],headersStr:"1 示例：一个简单的分页 2 页表存储在哪？ 3 页表中到底有什么？ 4 分页：也太慢 5 内存跟踪",content:"有时有人说，操作系统在解决大多数空间管理问题时会采用两种方法之一。第一种方法是将事物切成可变大小的块，正如我们在虚拟内存中的分段中看到的那样。不幸的是，这个解决方案有其固有的困难。特别是，当将空间划分为不同大小的块时，空间本身可能会变得碎片化，因此随着时间的推移，分配变得更具挑战性。\n\n因此，可能值得考虑第二种方法：将空间切成固定大小的块。在虚拟内存中，我们将这种想法称为分页，它可以追溯到一个早期且重要的系统，Atlas。我们不是将进程的地址空间划分为一定数量的可变大小的逻辑段（例如代码、堆、栈），而是将其划分为固定大小的单元，每个单元称为页面。相应地，我们将物理内存视为一组固定大小的槽（称为页框）；每个框都可以包含一个虚拟内存页；每个进程都需要页表来将虚拟地址转换为物理地址。。我们的挑战：\n\n> 关键：如何使用页面虚拟化内存 ?\n> \n> 如何使用页面虚拟化内存，从而避免分段问题？有哪些基本技术？我们如何以最小的空间和时间开销使这些技术发挥良好作用？\n\n\n# 1 示例：一个简单的分页\n\n为了更清楚地说明这种方法，让我们来看一个简单的例子。下图展示了一个很小的地址空间，总大小只有 64 字节，有四个 16 字节的页面（虚拟页面 0、1、2 和 3）。\n\n\n\n当然，真实的地址空间要大得多，通常为 32 位，因此有 4GB 的地址空间，甚至 64 位。\n\n如下图所示，物理内存也由许多固定大小的槽组成，在本例中是 8 个页框（对于 128 字节的物理内存来说，也小得离谱）。虚拟地址空间的页面被放置在整个物理内存的不同位置；该图还显示操作系统自身使用一些物理内存。\n\n\n\n正如我们将看到的，分页比我们以前的方法有许多优点。最重要的改进可能是灵活性：通过完全开发的分页方法，系统将能够有效地支持地址空间的抽象，无论进程如何使用地址空间；例如，我们不会对堆和栈的增长方向以及它们的使用方式做出假设。\n\n另一个优点是分页提供的可用空间管理的简单性。例如，当操作系统希望将我们微小的 64 字节地址空间放入我们的八页物理内存中时，它只会找到四个空闲页；也许操作系统为此保留了所有空闲页面的空闲列表，并且只从该列表中获取前四个空闲页面。在示例中，操作系统已将地址空间 (AS) 的虚拟页 0 放置在物理页 3 中，将 AS 的虚拟页 1 放置在物理页7 中，将页 2 放置在物理页 5 中，将页 3 放置在物理页 2 中。 页框 1 、4 和 6 目前空闲。\n\n为了记录地址空间的每个虚拟页在物理内存中的位置，操作系统通常会为每个进程保存一个名为页表的数据结构。页表的主要作用是存储地址空间中每个虚拟页的地址转换，从而让我们知道每个页位于物理内存中的位置。对于我们的简单示例，页表将具有以下四个条目：（虚拟页 0 → 物理页3）、（VP 1 → PF 7）、（VP 2 → PF 5）和（VP 3 → PF 2）。\n\n重要的是要记住，这个页表是一个每个进程的数据结构（我们讨论的大多数页表结构都是每个进程的结构；我们将提到一个例外，即反向页表）。如果在上面的示例中运行另一个进程，则操作系统必须为其管理不同的页表，因为它的虚拟页面显然映射到不同的物理页面（除非有任何共享正在进行）。\n\n现在，我们知道足够多以执行地址转换示例。让我们想象一下具有微小地址空间（64字节）的进程正在执行内存访问：\n\nmovl <virtual address>, %eax\n\n\n1\n\n1\n\n\n具体来说，让我们注意将数据从地址<virtual address>显式加载到寄存器 eax 中（从而忽略之前必须发生的指令获取）。\n\n为了转换进程生成的虚拟地址，我们必须首先将其分为两个部分：虚拟页号（Vitrual page number,VPN）和页面内的偏移量。对于此示例，由于进程的虚拟地址空间为 64 字节，因此我们的虚拟地址总共需要 6 位 (26=642^6 = 6426=64)。因此，我们的虚拟地址可以概念化如下：\n\n\n\n其中，Va5是虚拟地址的最高位，Va0是最低位。因为我们知道页面大小（16字节），则前两位代表虚拟页号，后四位代表页面偏移量。在 64 字节地址空间中，页面大小为 16 字节；因此我们需要能够选择 4 个页面，地址的前 2 位就可以做到这一点。因此，我们有一个 2 位虚拟页码 (VPN)。剩余的位则表示页面偏移量。\n\n当进程生成虚拟地址时，操作系统和硬件必须结合起来将其转换为有意义的物理地址。例如，假设上述加载到虚拟地址 21：\n\nmovl 21, %eax\n\n\n1\n\n1\n\n\n将“21”转换为二进制形式，我们得到“010101”，因此我们可以检查这个虚拟地址并查看它如何分解为虚拟页号（VPN）和偏移量：\n\n\n\n因此，虚拟地址“21”位于虚拟页“01”（或1）的第5（“0101”）字节。有了虚拟页号，我们现在可以索引页表并找到虚拟页 1 所在的物理页。在上面的页表中，物理页号 (Physical page number, PPN)（有时也称为物理帧号或 PFN）为 7（二进制 111）。因此，我们可以通过用 PPN 替换 VPN 来转换这个虚拟地址，然后向物理内存加载数据，如下图所示。\n\n\n\n请注意，偏移量保持不变（即，它没有被转换），因为偏移量只是告诉我们我们想要页面中的哪个字节。我们的最终物理地址是 1110101（十进制为 117），这正是我们希望加载获取数据的位置。\n\n\n# 2 页表存储在哪？\n\n页表可以变得非常大，比我们之前讨论的小分段表或基址/边界对大得多。例如，想象一个典型的 32 位地址空间，具有 4KB 页面。该虚拟地址分为 20 位 VPN 和 12 位偏移量（回想一下，1KB 页面大小需要 10 位，只需再添加两位即可达到 4KB）。\n\n20 位 VPN 意味着操作系统必须为每个进程管理 2202^{20}220 个转换（大约一百万个）；假设每个页表项 (page table entry, PTE) 需要 4 个字节来保存物理转换以及任何其他有用的内容，那么每个页表需要 4MB 的巨大内存！那是相当大的。现在假设有 100 个进程正在运行：这意味着操作系统需要 400MB 内存来用于所有这些地址转换！即使在机器拥有千兆字节内存的现代，将大量内存用于地址转换似乎也有点疯狂，不是吗？我们甚至没有考虑对于 64 位地址空间来说这样的页表有多大；那太可怕了，也许会把你完全吓跑。\n\n由于页表太大，我们没有在MMU中保留任何特殊的片上硬件来存储当前运行进程的页表。相反，我们将每个进程的页表存储在内存中的某个位置。现在我们假设页表位于操作系统管理的物理内存中，下图是操作系统内存中页表的图片。\n\n\n\n\n# 3 页表中到底有什么？\n\n让我们来谈谈页表的组织结构。页表只是一种数据结构，用于将虚拟地址（或实际上是虚拟页码）映射到物理地址（物理页号）。因此，任何数据结构都可以使用。最简单的形式称为线性页表，它只是一个数组。操作系统根据虚拟页码（VPN）对数组进行索引，并查找该索引下的页表项（PTE），以找到所需的物理页号（PFN）。目前，我们将假设这种简单的线性结构；在后面的章节中，我们将使用更高级的数据结构来帮助解决分页中的一些问题。\n\n至于每个 PTE 的内容，我们有许多不同的bit位值得在一定程度上了解。有效位通常用于指示特定转换是否有效。例如，当程序开始运行时，其地址空间的一端是代码和堆，另一端是栈。中间所有未使用的空间都会被标记为无效，如果进程试图访问这些内存，就会向操作系统发出中断，操作系统很可能会终止进程。因此，有效位对于支持稀疏地址空间至关重要；只需将地址空间中所有未使用的页面标记为无效，我们就无需为这些页面分配物理页号，从而节省了大量内存。\n\n我们还可以使用保护位来表明是否可以读取、写入或执行页面。同样，如果以这些位不允许的方式访问页面，就会向操作系统发出中断。\n\n还有一些其他的位也很重要，但我们现在就不多说了。存在位表示该页面是在物理内存中还是在磁盘上（即已被换出）。当我们研究如何将部分地址空间交换到磁盘以支持比物理内存更大的地址空间时，我们将进一步了解这一机制；交换允许操作系统通过将很少使用的页面移动到磁盘来释放物理内存。**脏位（dirty bit）**也很常见，表示页面进入内存后是否被修改过。\n\n参考位（又称访问位）有时用于跟踪页面是否被访问过，它有助于确定哪些页面受欢迎，因此应保留在内存中；在页面替换过程中，这种知识至关重要。\n\n下图显示了 x86 架构中的一个页表条目示例。它包含一个存在位 (P)；一个读/写位 (R/W)，用于确定是否允许写入该页面；一个用户/监管者位 (U/S)，用于确定用户模式进程是否可以访问该页面；几个位（PWT、PCD、PAT 和 G），用于确定这些页面的硬件缓存工作方式；一个已访问位 (A) 和一个脏位 (D)；最后是物理页号（PFN）本身。\n\n\n\n\n# 4 分页：也太慢\n\n对于内存中的页表，我们已经知道它们可能过大。事实证明，它们也会拖慢运行速度。举个简单的例子：\n\nmovl 21, %eax\n\n\n1\n\n1\n\n\n同样，我们只检查对地址 21 的显式引用，而不用担心取指令。在这个例子中，我们假设硬件为我们执行地址转换。为了获取所需的数据，系统必须首先将虚拟地址（21）转换为正确的物理地址（117）。因此，在从地址 117 获取数据之前，系统必须首先从进程的页表中获取正确的页表条目，执行转换，然后从物理内存加载数据。\n\n为此，硬件必须知道当前运行进程的页表在哪里。现在我们假设单个页表基址寄存器包含页表起始位置的物理地址。为了找到所需 PTE 的位置，硬件将执行以下功能：\n\nVPN = (VirtualAddress & VPN_MASK) >> SHIFT\nPTEAddr = PageTableBaseRegister + (VPN * sizeof(PTE))\n\n\n1\n2\n\n1\n2\n\n\n在我们的示例中，VPN_MASK 将设置为 0x30（十六进制 30，或二进制 110000），它从完整虚拟地址中挑选出 VPN 位； SHIFT 设置为 4（偏移量中的位数），以便我们将 VPN 位向下移动以形成正确的整数虚拟页号。例如，对于虚拟地址21（010101），掩码将该值变成010000；根据需要，移位会将其变为 01 或虚拟页 1。然后，我们使用该值作为页表基址寄存器指向的 PTE 数组的索引。\n\n一旦知道这个物理地址，硬件就可以从内存中获取 PTE，提取 PFN，并将其与虚拟地址的偏移量连接起来，形成所需的物理地址。具体来说，可以认为 PFN 通过 SHIFT 左移，然后与偏移量按位或运算形成最终地址，如下所示：\n\noffset = VirtualAddress & OFFSET_MASK\nPhysAddr = (PFN << SHIFT) | offset\n\n\n1\n2\n\n1\n2\n\n\n最后，硬件可以从内存中取出所需的数据并将其放入寄存器eax中。程序现在已成功从内存加载一个值！\n\n总而言之，我们现在描述每个内存引用上发生的情况的初始协议。下面这段代码显示了基本方法。\n\n# Extract the VPN from the virtual address\nVPN = (VirtualAddress & VPN_MASK) >> SHIFT\n\n# Form the address of the page-table entry (PTE)\nPTEAddr = PTBR + (VPN * sizeof(PTE))\n\n# Fetch the PTE\nPTE = AccessMemory(PTEAddr)\n\n# Check if process can access the page\nif (PTE.Valid == False)\n    RaiseException(SEGMENTATION_FAULT)\nelse if (CanAccess(PTE.ProtectBits) == False)\n    RaiseException(PROTECTION_FAULT)\nelse\n    # Access is OK: form physical address and fetch it\n    offset = VirtualAddress & OFFSET_MASK\n    PhysAddr = (PTE.PFN << PFN_SHIFT) | offset\n    Register = AccessMemory(PhysAddr)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n对于每个内存引用（无论是指令获取还是显式加载或存储），分页要求我们执行一次额外的内存引用，以便首先从页表中获取。这是很多工作！额外的内存引用成本高昂，在这种情况下可能会使进程减慢两倍或更多。\n\n现在您有望看到我们必须解决两个真正的问题。如果没有仔细设计硬件和软件，页表会导致系统运行速度过慢，并且占用过多的内存。虽然这似乎是满足我们内存虚拟化需求的一个很好的解决方案，但必须首先克服这两个关键问题。\n\n\n# 5 内存跟踪\n\n在结束之前，我们现在通过一个简单的内存访问示例来演示使用分页时发生的所有结果内存访问。我们感兴趣的代码片段（在 C 语言中，在名为 array.c 的文件中）如下：\n\nint array[1000];\n...\nfor (i = 0; i < 1000; i++)\n\tarray[i] = 0;\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n我们编译 array.c 并使用以下命令运行它：\n\ngcc -o array array.c -Wall -O\n./array\n\n\n1\n2\n\n1\n2\n\n\n当然，为了真正理解内存访问此代码片段（它只是初始化一个数组）会产生什么，我们必须知道（或假设）更多的事情。首先，我们必须反汇编生成的二进制文件（在 Linux 上使用 objdump，在 Mac 上使用 otool）以查看使用哪些汇编指令来初始化循环中的数组。这是生成的汇编代码：\n\n0x1024 movl $0x0,(%edi,%eax,4) #Power of CISC! edi+eax*4\n0x1028 incl %eax #Increase counter\n0x102c cmpl $0x03e8,%eax #Check if last element\n0x1030 jne 0x1024 #Implicit (eflags) Zero bit access\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n如果您了解一点 x86，该代码实际上很容易理解。第一条指令将值零（显示为 $0x0）移动到数组位置的虚拟内存地址中；该地址是通过获取 %edi 的内容并添加 %eax 乘以四来计算的。因此，%edi 保存数组的基地址，而 %eax 保存数组索引 (i)；我们乘以四，因为该数组是整数数组，每个整数大小为四个字节。\n\n第二条指令递增 %eax 中保存的数组索引，第三条指令将该寄存器的内容与十六进制值 0x03e8 或十进制 1000 进行比较。如果比较显示两个值还不相等（这就是 jne 指令测试的结果），第四条指令跳回循环顶部。\n\n为了了解该指令序列访问哪些内存（在虚拟和物理级别），我们必须假设代码片段和数组在虚拟内存中的位置，以及页表的内容和位置。对于此示例，我们假设虚拟地址空间大小为 64KB（小得不切实际）。我们还假设页面大小为 1KB。\n\n我们现在需要知道的是页表的内容及其在物理内存中的位置。假设我们有一个线性（基于数组）页表，并且它位于物理地址 1KB (1024)。\n\n至于其内容，我们只需要担心在本示例中映射了几个虚拟页面。首先，代码所在的虚拟页面。由于页面大小为 1KB，因此虚拟地址 1024 驻留在虚拟地址空间的第二页上（VPN=1，因为 VPN=0 是第一页）。我们假设该虚拟页面映射到物理帧 4 (VPN 1 → PFN 4)。\n\n接下来是数组本身。它的大小是 4000 字节（1000 个整数），我们假设它驻留在虚拟地址 40000 到 44000（不包括最后一个字节）。此十进制范围的虚拟页面为 VPN=39 ... VPN=42。因此，我们需要这些页面的映射。我们假设以下虚拟到物理映射为示例：(VPN 39 → PFN 7)、(VPN 40 → PFN 8)、(VPN 41 → PFN 9)、(VPN 42 → PFN 10)。\n\n我们现在准备跟踪程序的内存引用。当它运行时，每个指令获取都会生成两个内存引用：一个到页表以查找指令所在的物理页，另一个到指令本身以将其获取到 CPU 进行处理。此外，还有一个以 mov 指令形式出现的显式内存引用；这首先增加了另一个页表访问（将数组虚拟地址转换为正确的物理地址），然后才是数组访问本身。\n\n下图描述了前五个循环迭代的整个过程。最下面的图以黑色显示 y 轴上的指令内存引用（左边是虚拟地址，右边是实际物理地址）；中间的图以深灰色显示数组访问（同样是左边是虚拟地址，右边是物理地址）；最后，最上面的图以浅灰色显示页表内存访问（只是物理访问，因为本例中的页表位于物理内存中）。整个跟踪的 x 轴显示了循环前五次迭代的内存访问；每个循环有 10 次内存访问，其中包括四次指令取回、一次内存显式更新和五次页表访问，以转换这四次取回和一次显式更新。\n\n",normalizedContent:"有时有人说，操作系统在解决大多数空间管理问题时会采用两种方法之一。第一种方法是将事物切成可变大小的块，正如我们在虚拟内存中的分段中看到的那样。不幸的是，这个解决方案有其固有的困难。特别是，当将空间划分为不同大小的块时，空间本身可能会变得碎片化，因此随着时间的推移，分配变得更具挑战性。\n\n因此，可能值得考虑第二种方法：将空间切成固定大小的块。在虚拟内存中，我们将这种想法称为分页，它可以追溯到一个早期且重要的系统，atlas。我们不是将进程的地址空间划分为一定数量的可变大小的逻辑段（例如代码、堆、栈），而是将其划分为固定大小的单元，每个单元称为页面。相应地，我们将物理内存视为一组固定大小的槽（称为页框）；每个框都可以包含一个虚拟内存页；每个进程都需要页表来将虚拟地址转换为物理地址。。我们的挑战：\n\n> 关键：如何使用页面虚拟化内存 ?\n> \n> 如何使用页面虚拟化内存，从而避免分段问题？有哪些基本技术？我们如何以最小的空间和时间开销使这些技术发挥良好作用？\n\n\n# 1 示例：一个简单的分页\n\n为了更清楚地说明这种方法，让我们来看一个简单的例子。下图展示了一个很小的地址空间，总大小只有 64 字节，有四个 16 字节的页面（虚拟页面 0、1、2 和 3）。\n\n\n\n当然，真实的地址空间要大得多，通常为 32 位，因此有 4gb 的地址空间，甚至 64 位。\n\n如下图所示，物理内存也由许多固定大小的槽组成，在本例中是 8 个页框（对于 128 字节的物理内存来说，也小得离谱）。虚拟地址空间的页面被放置在整个物理内存的不同位置；该图还显示操作系统自身使用一些物理内存。\n\n\n\n正如我们将看到的，分页比我们以前的方法有许多优点。最重要的改进可能是灵活性：通过完全开发的分页方法，系统将能够有效地支持地址空间的抽象，无论进程如何使用地址空间；例如，我们不会对堆和栈的增长方向以及它们的使用方式做出假设。\n\n另一个优点是分页提供的可用空间管理的简单性。例如，当操作系统希望将我们微小的 64 字节地址空间放入我们的八页物理内存中时，它只会找到四个空闲页；也许操作系统为此保留了所有空闲页面的空闲列表，并且只从该列表中获取前四个空闲页面。在示例中，操作系统已将地址空间 (as) 的虚拟页 0 放置在物理页 3 中，将 as 的虚拟页 1 放置在物理页7 中，将页 2 放置在物理页 5 中，将页 3 放置在物理页 2 中。 页框 1 、4 和 6 目前空闲。\n\n为了记录地址空间的每个虚拟页在物理内存中的位置，操作系统通常会为每个进程保存一个名为页表的数据结构。页表的主要作用是存储地址空间中每个虚拟页的地址转换，从而让我们知道每个页位于物理内存中的位置。对于我们的简单示例，页表将具有以下四个条目：（虚拟页 0 → 物理页3）、（vp 1 → pf 7）、（vp 2 → pf 5）和（vp 3 → pf 2）。\n\n重要的是要记住，这个页表是一个每个进程的数据结构（我们讨论的大多数页表结构都是每个进程的结构；我们将提到一个例外，即反向页表）。如果在上面的示例中运行另一个进程，则操作系统必须为其管理不同的页表，因为它的虚拟页面显然映射到不同的物理页面（除非有任何共享正在进行）。\n\n现在，我们知道足够多以执行地址转换示例。让我们想象一下具有微小地址空间（64字节）的进程正在执行内存访问：\n\nmovl <virtual address>, %eax\n\n\n1\n\n1\n\n\n具体来说，让我们注意将数据从地址<virtual address>显式加载到寄存器 eax 中（从而忽略之前必须发生的指令获取）。\n\n为了转换进程生成的虚拟地址，我们必须首先将其分为两个部分：虚拟页号（vitrual page number,vpn）和页面内的偏移量。对于此示例，由于进程的虚拟地址空间为 64 字节，因此我们的虚拟地址总共需要 6 位 (26=642^6 = 6426=64)。因此，我们的虚拟地址可以概念化如下：\n\n\n\n其中，va5是虚拟地址的最高位，va0是最低位。因为我们知道页面大小（16字节），则前两位代表虚拟页号，后四位代表页面偏移量。在 64 字节地址空间中，页面大小为 16 字节；因此我们需要能够选择 4 个页面，地址的前 2 位就可以做到这一点。因此，我们有一个 2 位虚拟页码 (vpn)。剩余的位则表示页面偏移量。\n\n当进程生成虚拟地址时，操作系统和硬件必须结合起来将其转换为有意义的物理地址。例如，假设上述加载到虚拟地址 21：\n\nmovl 21, %eax\n\n\n1\n\n1\n\n\n将“21”转换为二进制形式，我们得到“010101”，因此我们可以检查这个虚拟地址并查看它如何分解为虚拟页号（vpn）和偏移量：\n\n\n\n因此，虚拟地址“21”位于虚拟页“01”（或1）的第5（“0101”）字节。有了虚拟页号，我们现在可以索引页表并找到虚拟页 1 所在的物理页。在上面的页表中，物理页号 (physical page number, ppn)（有时也称为物理帧号或 pfn）为 7（二进制 111）。因此，我们可以通过用 ppn 替换 vpn 来转换这个虚拟地址，然后向物理内存加载数据，如下图所示。\n\n\n\n请注意，偏移量保持不变（即，它没有被转换），因为偏移量只是告诉我们我们想要页面中的哪个字节。我们的最终物理地址是 1110101（十进制为 117），这正是我们希望加载获取数据的位置。\n\n\n# 2 页表存储在哪？\n\n页表可以变得非常大，比我们之前讨论的小分段表或基址/边界对大得多。例如，想象一个典型的 32 位地址空间，具有 4kb 页面。该虚拟地址分为 20 位 vpn 和 12 位偏移量（回想一下，1kb 页面大小需要 10 位，只需再添加两位即可达到 4kb）。\n\n20 位 vpn 意味着操作系统必须为每个进程管理 2202^{20}220 个转换（大约一百万个）；假设每个页表项 (page table entry, pte) 需要 4 个字节来保存物理转换以及任何其他有用的内容，那么每个页表需要 4mb 的巨大内存！那是相当大的。现在假设有 100 个进程正在运行：这意味着操作系统需要 400mb 内存来用于所有这些地址转换！即使在机器拥有千兆字节内存的现代，将大量内存用于地址转换似乎也有点疯狂，不是吗？我们甚至没有考虑对于 64 位地址空间来说这样的页表有多大；那太可怕了，也许会把你完全吓跑。\n\n由于页表太大，我们没有在mmu中保留任何特殊的片上硬件来存储当前运行进程的页表。相反，我们将每个进程的页表存储在内存中的某个位置。现在我们假设页表位于操作系统管理的物理内存中，下图是操作系统内存中页表的图片。\n\n\n\n\n# 3 页表中到底有什么？\n\n让我们来谈谈页表的组织结构。页表只是一种数据结构，用于将虚拟地址（或实际上是虚拟页码）映射到物理地址（物理页号）。因此，任何数据结构都可以使用。最简单的形式称为线性页表，它只是一个数组。操作系统根据虚拟页码（vpn）对数组进行索引，并查找该索引下的页表项（pte），以找到所需的物理页号（pfn）。目前，我们将假设这种简单的线性结构；在后面的章节中，我们将使用更高级的数据结构来帮助解决分页中的一些问题。\n\n至于每个 pte 的内容，我们有许多不同的bit位值得在一定程度上了解。有效位通常用于指示特定转换是否有效。例如，当程序开始运行时，其地址空间的一端是代码和堆，另一端是栈。中间所有未使用的空间都会被标记为无效，如果进程试图访问这些内存，就会向操作系统发出中断，操作系统很可能会终止进程。因此，有效位对于支持稀疏地址空间至关重要；只需将地址空间中所有未使用的页面标记为无效，我们就无需为这些页面分配物理页号，从而节省了大量内存。\n\n我们还可以使用保护位来表明是否可以读取、写入或执行页面。同样，如果以这些位不允许的方式访问页面，就会向操作系统发出中断。\n\n还有一些其他的位也很重要，但我们现在就不多说了。存在位表示该页面是在物理内存中还是在磁盘上（即已被换出）。当我们研究如何将部分地址空间交换到磁盘以支持比物理内存更大的地址空间时，我们将进一步了解这一机制；交换允许操作系统通过将很少使用的页面移动到磁盘来释放物理内存。**脏位（dirty bit）**也很常见，表示页面进入内存后是否被修改过。\n\n参考位（又称访问位）有时用于跟踪页面是否被访问过，它有助于确定哪些页面受欢迎，因此应保留在内存中；在页面替换过程中，这种知识至关重要。\n\n下图显示了 x86 架构中的一个页表条目示例。它包含一个存在位 (p)；一个读/写位 (r/w)，用于确定是否允许写入该页面；一个用户/监管者位 (u/s)，用于确定用户模式进程是否可以访问该页面；几个位（pwt、pcd、pat 和 g），用于确定这些页面的硬件缓存工作方式；一个已访问位 (a) 和一个脏位 (d)；最后是物理页号（pfn）本身。\n\n\n\n\n# 4 分页：也太慢\n\n对于内存中的页表，我们已经知道它们可能过大。事实证明，它们也会拖慢运行速度。举个简单的例子：\n\nmovl 21, %eax\n\n\n1\n\n1\n\n\n同样，我们只检查对地址 21 的显式引用，而不用担心取指令。在这个例子中，我们假设硬件为我们执行地址转换。为了获取所需的数据，系统必须首先将虚拟地址（21）转换为正确的物理地址（117）。因此，在从地址 117 获取数据之前，系统必须首先从进程的页表中获取正确的页表条目，执行转换，然后从物理内存加载数据。\n\n为此，硬件必须知道当前运行进程的页表在哪里。现在我们假设单个页表基址寄存器包含页表起始位置的物理地址。为了找到所需 pte 的位置，硬件将执行以下功能：\n\nvpn = (virtualaddress & vpn_mask) >> shift\npteaddr = pagetablebaseregister + (vpn * sizeof(pte))\n\n\n1\n2\n\n1\n2\n\n\n在我们的示例中，vpn_mask 将设置为 0x30（十六进制 30，或二进制 110000），它从完整虚拟地址中挑选出 vpn 位； shift 设置为 4（偏移量中的位数），以便我们将 vpn 位向下移动以形成正确的整数虚拟页号。例如，对于虚拟地址21（010101），掩码将该值变成010000；根据需要，移位会将其变为 01 或虚拟页 1。然后，我们使用该值作为页表基址寄存器指向的 pte 数组的索引。\n\n一旦知道这个物理地址，硬件就可以从内存中获取 pte，提取 pfn，并将其与虚拟地址的偏移量连接起来，形成所需的物理地址。具体来说，可以认为 pfn 通过 shift 左移，然后与偏移量按位或运算形成最终地址，如下所示：\n\noffset = virtualaddress & offset_mask\nphysaddr = (pfn << shift) | offset\n\n\n1\n2\n\n1\n2\n\n\n最后，硬件可以从内存中取出所需的数据并将其放入寄存器eax中。程序现在已成功从内存加载一个值！\n\n总而言之，我们现在描述每个内存引用上发生的情况的初始协议。下面这段代码显示了基本方法。\n\n# extract the vpn from the virtual address\nvpn = (virtualaddress & vpn_mask) >> shift\n\n# form the address of the page-table entry (pte)\npteaddr = ptbr + (vpn * sizeof(pte))\n\n# fetch the pte\npte = accessmemory(pteaddr)\n\n# check if process can access the page\nif (pte.valid == false)\n    raiseexception(segmentation_fault)\nelse if (canaccess(pte.protectbits) == false)\n    raiseexception(protection_fault)\nelse\n    # access is ok: form physical address and fetch it\n    offset = virtualaddress & offset_mask\n    physaddr = (pte.pfn << pfn_shift) | offset\n    register = accessmemory(physaddr)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n对于每个内存引用（无论是指令获取还是显式加载或存储），分页要求我们执行一次额外的内存引用，以便首先从页表中获取。这是很多工作！额外的内存引用成本高昂，在这种情况下可能会使进程减慢两倍或更多。\n\n现在您有望看到我们必须解决两个真正的问题。如果没有仔细设计硬件和软件，页表会导致系统运行速度过慢，并且占用过多的内存。虽然这似乎是满足我们内存虚拟化需求的一个很好的解决方案，但必须首先克服这两个关键问题。\n\n\n# 5 内存跟踪\n\n在结束之前，我们现在通过一个简单的内存访问示例来演示使用分页时发生的所有结果内存访问。我们感兴趣的代码片段（在 c 语言中，在名为 array.c 的文件中）如下：\n\nint array[1000];\n...\nfor (i = 0; i < 1000; i++)\n\tarray[i] = 0;\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n我们编译 array.c 并使用以下命令运行它：\n\ngcc -o array array.c -wall -o\n./array\n\n\n1\n2\n\n1\n2\n\n\n当然，为了真正理解内存访问此代码片段（它只是初始化一个数组）会产生什么，我们必须知道（或假设）更多的事情。首先，我们必须反汇编生成的二进制文件（在 linux 上使用 objdump，在 mac 上使用 otool）以查看使用哪些汇编指令来初始化循环中的数组。这是生成的汇编代码：\n\n0x1024 movl $0x0,(%edi,%eax,4) #power of cisc! edi+eax*4\n0x1028 incl %eax #increase counter\n0x102c cmpl $0x03e8,%eax #check if last element\n0x1030 jne 0x1024 #implicit (eflags) zero bit access\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n如果您了解一点 x86，该代码实际上很容易理解。第一条指令将值零（显示为 $0x0）移动到数组位置的虚拟内存地址中；该地址是通过获取 %edi 的内容并添加 %eax 乘以四来计算的。因此，%edi 保存数组的基地址，而 %eax 保存数组索引 (i)；我们乘以四，因为该数组是整数数组，每个整数大小为四个字节。\n\n第二条指令递增 %eax 中保存的数组索引，第三条指令将该寄存器的内容与十六进制值 0x03e8 或十进制 1000 进行比较。如果比较显示两个值还不相等（这就是 jne 指令测试的结果），第四条指令跳回循环顶部。\n\n为了了解该指令序列访问哪些内存（在虚拟和物理级别），我们必须假设代码片段和数组在虚拟内存中的位置，以及页表的内容和位置。对于此示例，我们假设虚拟地址空间大小为 64kb（小得不切实际）。我们还假设页面大小为 1kb。\n\n我们现在需要知道的是页表的内容及其在物理内存中的位置。假设我们有一个线性（基于数组）页表，并且它位于物理地址 1kb (1024)。\n\n至于其内容，我们只需要担心在本示例中映射了几个虚拟页面。首先，代码所在的虚拟页面。由于页面大小为 1kb，因此虚拟地址 1024 驻留在虚拟地址空间的第二页上（vpn=1，因为 vpn=0 是第一页）。我们假设该虚拟页面映射到物理帧 4 (vpn 1 → pfn 4)。\n\n接下来是数组本身。它的大小是 4000 字节（1000 个整数），我们假设它驻留在虚拟地址 40000 到 44000（不包括最后一个字节）。此十进制范围的虚拟页面为 vpn=39 ... vpn=42。因此，我们需要这些页面的映射。我们假设以下虚拟到物理映射为示例：(vpn 39 → pfn 7)、(vpn 40 → pfn 8)、(vpn 41 → pfn 9)、(vpn 42 → pfn 10)。\n\n我们现在准备跟踪程序的内存引用。当它运行时，每个指令获取都会生成两个内存引用：一个到页表以查找指令所在的物理页，另一个到指令本身以将其获取到 cpu 进行处理。此外，还有一个以 mov 指令形式出现的显式内存引用；这首先增加了另一个页表访问（将数组虚拟地址转换为正确的物理地址），然后才是数组访问本身。\n\n下图描述了前五个循环迭代的整个过程。最下面的图以黑色显示 y 轴上的指令内存引用（左边是虚拟地址，右边是实际物理地址）；中间的图以深灰色显示数组访问（同样是左边是虚拟地址，右边是物理地址）；最后，最上面的图以浅灰色显示页表内存访问（只是物理访问，因为本例中的页表位于物理内存中）。整个跟踪的 x 轴显示了循环前五次迭代的内存访问；每个循环有 10 次内存访问，其中包括四次指令取回、一次内存显式更新和五次页表访问，以转换这四次取回和一次显式更新。\n\n",charsets:{cjk:!0},lastUpdated:"2024/05/11, 20:33:38",lastUpdatedTimestamp:1715430818e3},{title:"高级页表",frontmatter:{title:"高级页表",tags:["OS"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},date:"2024-04-25T22:39:35.000Z",permalink:"/pages/165f2d/",categories:["开发","系统架构","操作系统","虚拟化"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/02.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/15.%E9%AB%98%E7%BA%A7%E9%A1%B5%E8%A1%A8.html",relativePath:"01.开发/05.系统架构/02.操作系统/15.高级页表.md",key:"v-47ac947e",path:"/pages/165f2d/",headers:[{level:2,title:"1 简单的解决方案：更大的页面",slug:"_1-简单的解决方案-更大的页面",normalizedTitle:"1 简单的解决方案：更大的页面",charIndex:402},{level:2,title:"2 混合方法：分页和分段",slug:"_2-混合方法-分页和分段",normalizedTitle:"2 混合方法：分页和分段",charIndex:796},{level:2,title:"3 多级页表",slug:"_3-多级页表",normalizedTitle:"3 多级页表",charIndex:2520},{level:3,title:"3.1 介绍",slug:"_3-1-介绍",normalizedTitle:"3.1 介绍",charIndex:2531},{level:3,title:"3.2 多级页表示例",slug:"_3-2-多级页表示例",normalizedTitle:"3.2 多级页表示例",charIndex:3875},{level:3,title:"3.3 不止两级",slug:"_3-3-不止两级",normalizedTitle:"3.3 不止两级",charIndex:5935},{level:3,title:"3.4 转换过程：记住 TLB",slug:"_3-4-转换过程-记住-tlb",normalizedTitle:"3.4 转换过程：记住 tlb",charIndex:6772},{level:3,title:"3.5 真实的多级页表",slug:"_3-5-真实的多级页表",normalizedTitle:"3.5 真实的多级页表",charIndex:8349},{level:2,title:"4 反向页表",slug:"_4-反向页表",normalizedTitle:"4 反向页表",charIndex:9265},{level:2,title:"5 将页表交换到磁盘",slug:"_5-将页表交换到磁盘",normalizedTitle:"5 将页表交换到磁盘",charIndex:9605}],headersStr:"1 简单的解决方案：更大的页面 2 混合方法：分页和分段 3 多级页表 3.1 介绍 3.2 多级页表示例 3.3 不止两级 3.4 转换过程：记住 TLB 3.5 真实的多级页表 4 反向页表 5 将页表交换到磁盘",content:"现在我们解决分页带来的第二个问题：页表太大，因此消耗太多内存。让我们从线性页表开始。您可能还记得，线性页表变得相当大。再次假设 32 位地址空间（2322^{32}232字节），具有 4KB（2122^{12}212 字节）页面和 4 字节页表条目。因此，地址空间中大约有一百万个虚拟页（232212\\frac{2^{32}}{2^{12}}212232 ）；乘以页表条目大小，您会看到页表大小为 4MB。\n\n\n\n另回想一下：我们通常为系统中的每个进程都有一个页表！对于一百个活动进程（在现代系统上并不罕见），我们将为页表分配数百兆字节的内存！因此，我们正在寻找一些技术来减轻这种沉重的负担。它们有很多，所以让我们开始吧。但在之前我们的问题关键是：简单的基于数组的页表（通常称为线性页表）太大，在典型系统上占用太多内存。如何才能让页表变小呢？关键的想法是什么？这些新的数据结构会导致哪些低效率？\n\n\n# 1 简单的解决方案：更大的页面\n\n我们可以通过一种简单的方法来减小页表的大小：使用较大的页面。再次使用我们的 32 位地址空间，但这次假设页面为 16KB。因此，我们将拥有一个 18 位 VPN 加上一个 14 位偏移量。假设每个 PTE 的大小相同（4 字节），我们的线性页表中现在有 2182^{18}218 个条目，因此每个页表的总大小为 1MB，页表大小减少了四倍（毫不奇怪，减少恰好反映了页面大小四倍的增加）。\n\n\n\n然而，这种方法的主要问题是大页面会导致每个页面内的浪费，这个问题称为内部碎片（因为浪费是分配单元内部的）。因此，应用程序最终会分配页面，但只使用每个页面的一小部分，并且内存很快就会被这些过大的页面填满。因此，大多数系统在常见情况下使用相对较小的页面大小：4KB（如在 x86 中）或 8KB（如在 SPARCv9 中）。我们的问题不会这么简单地解决。\n\n\n# 2 混合方法：分页和分段\n\n每当你对生活中的某件事有两种合理但不同的方法时，你应该始终检查两者的结合，看看是否能获得两全其美的效果。我们将这种组合称为混合体。\n\n多年前，Multics 的创建者（特别是 Jack Dennis）在构建 Multics 虚拟内存系统时偶然想到了这样的想法。具体来说，Dennis 提出了将分页和分段相结合的想法，以减少页表的内存开销。通过更详细地检查典型的线性页表，我们可以明白为什么这可能起作用。假设我们有一个地址空间，其中堆和栈的已使用部分很小。例如，如下图所示，我们使用 16KB 的微小地址空间和 1KB 页面；\n\n该地址空间的页表如图下图所示。\n\n本例假定单个代码页（VPN 0）映射到物理页 10，单个堆页（VPN 4）映射到物理页 23，地址空间另一端的两个栈页（VPN 14 和 15）分别映射到物理页 28 和 4。从图中可以看出，大部分页表都未使用，充满了无效条目。非常浪费空间，且这只是一个 16KB 的小地址空间，如果是32位，会浪费的更多。\n\n因此，我们的混合方法是：与其为进程的整个地址空间制作一个页表，为什么不为每个逻辑段制作一个页表呢？在这个例子中，我们可能会有三个页表，分别用于地址空间的代码、堆和栈部分。\n\n现在，请记住分段，我们有一个基址寄存器告诉我们每个段在物理内存中的位置，还有一个边界或限制寄存器告诉我们所述段的大小。在我们的混合中，我们在 MMU 中仍然有这些结构；在这里，我们使用基址不是指向段本身，而是保存该段页表的物理地址。边界寄存器用于指示页表的末尾（即，它有多少个有效页）。\n\n让我们举一个简单的例子来说明。假设 32 位虚拟地址空间有 4KB 页面，地址空间分为四个段。在本例中，我们只使用三个段：一个用于代码，一个用于堆，一个用于栈。\n\n为了确定地址引用哪个段，我们将使用地址空间的前两位。假设 00 是未使用的段，01 表示代码，10 表示堆，11 表示堆栈。因此，虚拟地址如下所示：\n\n\n\n在硬件中，假设有三个基寄存器/边界对，代码、堆和栈各一个。当进程运行时，每个分段的基寄存器都包含该分段线性页表的物理地址；因此，系统中的每个进程现在都有三个与之相关的页表。在上下文切换时，必须更改这些寄存器，以反映新运行进程的页表位置。\n\n在 TLB 未命中时（假设 TLB 由硬件管理，即由硬件负责处理 TLB 未命中），硬件会使用段位（SN）来确定要使用的基址和边界对。然后，硬件将其中的物理地址与 VPN 进行如下组合，形成页表项 (PTE) 的地址：\n\nSN = (VirtualAddress & SEG_MASK) >> SN_SHIFT\nVPN = (VirtualAddress & VPN_MASK) >> VPN_SHIFT\nAddressOfPTE = Base[SN] + (VPN * sizeof(PTE))\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n这个序列看起来应该很熟悉；它实际上与我们之前看到的线性页表相同。当然，唯一的区别是使用三个段基址寄存器之一而不是单页表基址寄存器。\n\n我们的混合方案的关键区别是每个段都存在一个边界寄存器；每个边界寄存器保存段中最大有效页的值。例如，如果代码段正在使用其前三页（0、1 和 2），则代码段页表将仅分配有三个条目，并且边界寄存器将设置为 3；超出段末尾的内存访问将生成异常，并可能导致进程终止。通过这种方式，与线性页表相比，我们的混合方法实现了显著的内存节省；栈和堆之间未分配的页面不再占用页表中的空间（只是将它们标记为无效）。\n\n然而，正如您可能注意到的，这种方法并非没有问题。首先，它仍然需要我们使用分段；正如我们之前讨论的，分段并不像我们希望的那么灵活，因为它假设地址空间有某种使用模式；例如，如果我们有一个大但很少使用的堆，我们仍然可能会产生大量页表浪费。其次，这种混合导致外部碎片再次出现。虽然大多数内存都是以页大小为单位进行管理的，但页表现在可以是任意大小（PTE 的倍数）。因此，在内存中为它们找到可用空间更加复杂。由于这些原因，人们不断寻找更好的方法来实现更小的页表。\n\n\n# 3 多级页表\n\n\n# 3.1 介绍\n\n另一种方法不依赖于分段，但解决了同样的问题：如何摆脱页表中的所有无效区域，而不是将它们全部保留在内存中？我们将这种方法称为多级页表，因为它将线性页表变成了类似树的东西。这种方法非常有效，以至于许多现代系统都采用它（例如 x86 [BOH10]）。我们现在详细描述这种方法。\n\n多级页表背后的基本思想很简单。首先，将页表切分成页大小的单元；然后，如果页表条目 (PTE) 的整个页无效，则根本不分配页表的该页。要跟踪页表的页面是否有效（以及如果有效，则它在内存中的位置），则使用称为页目录的新结构。因此，页目录可以用来告诉您页表的某个页在哪里，或者页表的整个页不包含有效页。\n\n下图展示了一个示例。图左边是经典的线性页表；即使地址空间的大多数中间区域无效，我们仍然需要为这些区域分配页表空间（即页表的中间两页）。右边是多级页表。页目录仅将页表的两页标记为有效（第一页和最后一页）；因此，只有页表的那两页驻留在内存中。因此，您可以看到一种可视化多级表正在执行的操作的方法：它只是使部分线性页表消失（释放这些页以供其他用途），并跟踪页表的哪些页分配了该页目录。\n\n\n\n页目录在一个简单的两级表中，页表的每一页包含一个条目。它由许多页目录项（PDE）组成。 PDE（至少）具有有效位和物理页框号 (PFN)，与 PTE 类似。然而，正如上面所暗示的，该有效位的含义略有不同：如果 PDE 有效，则意味着该条目（通过 PFN）指向的页表中的至少一页是有效的，即，在该PDE指向的该页上的至少一个PTE中，该PTE中的有效位被设置为1。如果 PDE 无效（即等于 0），则 PDE 的其余部分未定义。\n\n与我们迄今为止看到的方法相比，多级页表具有一些明显的优势。首先，也许最明显的是，多级表仅根据您正在使用的地址空间量按比例分配页表空间；因此它通常是紧凑的并且支持稀疏地址空间。\n\n其次，如果精心构建，页表的每个部分都可以整齐地容纳在一个页面中，从而更容易管理内存；当操作系统需要分配或增长页表时，它可以简单地获取下一个空闲页面。将此与简单（非分页）线性页表 进行对比，后者只是由 VPN 索引的 PTE 数组；采用这样的结构，整个线性页表必须连续地驻留在物理内存中。对于大页表（例如 4MB），找到这么大块未使用的连续空闲物理内存可能是一个相当大的挑战。对于多级结构，我们通过使用页目录来添加间接层，页目录指向页表的各个部分；这种间接允许我们将页表页面放置在物理内存中的任何位置。\n\n需要注意的是，多级表是有成本的；如果 TLB 未命中，则需要从内存加载两次才能从页表获取正确的转换信息（一次用于页目录，一次用于 PTE 本身），而线性页表只需加载一次。因此，多级表是时空权衡的一个小例子。我们想要更小的表（并且得到了），但不是免费的；虽然在常见情况下（TLB 命中），性能显然是相同的，但是对于这个较小的表，TLB 未命中会遭受更高的成本。\n\n另一个明显的负面因素是复杂性。无论是硬件还是操作系统处理页表查找（在 TLB 未命中时），这样做无疑比简单的线性页表查找更复杂。通常我们愿意增加复杂性以提高性能或减少开销；对于多级表，我们使页表查找更加复杂，以节省宝贵的内存。\n\n\n# 3.2 多级页表示例\n\n为了更好地理解多级页表背后的想法，让我们举一个例子。想象一个大小为 16KB、具有 64 字节页面的小地址空间。因此，我们有一个 14 位虚拟地址空间，其中 8 位用于 VPN，6 位用于偏移量。即使仅使用一小部分地址空间，线性页表也将具有 282^828 (256) 个条目。下图展示了此类地址空间的一个示例。\n\n\n\n在此示例中，虚拟页 0 和 1 用于代码，虚拟页 4 和 5 用于堆，虚拟页 254 和 255 用于堆栈；地址空间的其余页面未使用。\n\n为了为此地址空间构建两级页表，我们从完整的线性页表开始，并将其分解为页面大小的单元。回想一下我们的完整表（在本例中）有 256 个条目；假设每个 PTE 的大小为 4 字节。因此，我们的页表大小为 1KB（256 × 4 字节）。假设我们有64字节的页面，那么1KB的页表可以分为16个64字节的页面；每页可容纳 16 个 PTE。\n\n我们现在需要了解的是如何使用VPN并使用它首先索引到页目录，然后索引到页表的页面。请记住，每个都是一个条目数组；因此，我们需要弄清楚的是如何为 VPN 的每个部分构建索引。\n\n让我们首先索引到页面目录。本例中的页表很小：256 个条目，分布在 16 个页面上。页目录需要页表的每一页一个条目；因此，它有 16 个条目。因此，我们需要 VPN 的四位来索引目录；我们使用VPN的前四位，如下：\n\n\n\n一旦我们从VPN中提取出页目录索引（简称PDIndex），我们就可以通过简单的计算来找到页目录条目（PDE）的地址： PDEAddr = PageDirBase + (PDIndex * sizeof(PDE) ）。这就产生了我们的页面目录，现在我们对其进行研究，以进一步推进我们的转换工作\n\n如果页目录条目被标记为无效，我们就知道访问无效，从而引发异常。然而，如果PDE有效，我们还有更多工作要做。具体来说，我们现在必须从该页目录项指向的页表页中获取页表项（PTE）。为了找到这个 PTE，我们必须使用 VPN 的剩余位来索引页表的部分：\n\n\n\n然后可以使用此页表索引（简称 PTIndex）对页表本身进行索引，从而为我们提供 PTE 的地址：\n\nPTEAddr = (PDE.PFN << SHIFT) + (PTIndex * sizeof(PTE))\n\n请注意，从页目录项获得的物理页框号 (PFN) 必须先左移到位，然后才能与页表索引组合以形成 PTE 的地址。为了看看这一切是否有意义，我们现在将用一些实际值填充多级页表，并转换单个虚拟地址。让我们从本例的页面目录开始（如下图左侧）。\n\n\n\n在图中，您可以看到每个页目录项 (PDE) 描述了有关地址空间页表中的一页的信息。在此示例中，我们在地址空间中有两个有效区域（位于开头和结尾），以及中间的许多无效映射。在物理页100（页表第0页的物理帧号）中，我们有地址空间中前16个VPN的16个页表条目的第一页。这部分页表的内容见上图（中间部分）。\n\n页表的该页包含前 16 个 VPN 的映射；在我们的示例中，VPN 0 和 1 有效（代码段），4 和 5（堆）也是有效的。因此，该表具有每个页面的映射信息。其余条目被标记为无效。\n\n页表的另一个有效页位于 PFN 101 内。该页包含地址空间最后 16 个 VPN 的映射；如上图所示（右）。\n\n在示例中，VPN 254 和 255（堆栈）具有有效映射。希望我们可以从这个示例中看到，使用多级索引结构可以节省多少空间。在此示例中，我们没有为线性页表分配完整的 16 个页面，而是仅分配三个页面：一个用于页目录，两个用于具有有效映射的页表块。对于大型（32 位或 64 位）地址空间来说，节省的成本显然要大得多。\n\n最后，让我们使用这些信息来执行转换。这是一个引用 VPN 254 第 0 个字节的地址：0x3F80，或二进制的 11 1111 1000 0000。\n\n回想一下，我们将使用 VPN 的前 4 位来索引页面目录。因此，1111 将选择上面页目录的最后一个（如果从第 0 个开始，则为第 15 个）条目。这将我们指向位于地址 101 的页表的有效页面。然后，我们使用 VPN (1110) 的接下来 4 位来索引页表的该页面并找到所需的 PTE。 1110 是页面上的倒数第二个（第 14 个）条目，它告诉我们虚拟地址空间的第 254 页映射到物理页 55。通过将 PFN=55（或十六进制 0x37）与 offset=000000 连接，我们因此可以形成我们想要的物理地址并向内存系统发出请求：PhysAddr = (PTE.PFN << SHIFT) + offset = 00 1101 1100 0000 = 0x0DC0。您现在应该了解如何使用指向页表页面的页目录来构造两级页表。然而不幸的是，我们的工作还没有完成。正如我们现在将讨论的，有时两级页表是不够的！\n\n\n# 3.3 不止两级\n\n到目前为止，在我们的示例中，我们假设多级页表只有两个级别：页目录，然后是页表的各个部分。在某些情况下，更深的树是可能的（而且确实是需要的）。\n\n让我们举一个简单的例子，并用它来说明为什么更深的多级表会很有用。在此示例中，假设我们有一个 30 位虚拟地址空间和一个小（512 字节）页面。因此，我们的虚拟地址有一个 21 位虚拟页号组件和一个 9 位偏移量。\n\n请记住我们构建多级页表的目标：使页表的每一部分都适合单个页面。到目前为止，我们只考虑了页表本身；但是，如果页面目录变得太大怎么办？\n\n为了确定多级表中需要多少级才能使页表的所有部分都适合一个页面，我们首先确定一个页面适合多少个页表条目。鉴于我们的页面大小为 512 字节，并假设 PTE 大小为 4 字节，您应该会发现单个页面上可以容纳 128 个 PTE。当我们对页表的某个页面进行索引时，我们可以得出结论，我们需要 VPN 的最低有效 7 位 (log⁡2128\\log _2{128}log2 128) 作为索引：\n\n\n\n从上图中您还可能注意到，（大）页目录中还剩下多少位： 14。如果我们的页目录有 2142^{14}214个条目，那么它跨越的不是一页而是 128，因此，我们将多级页表的每一部分都放入一个页面的目标就消失了。\n\n为了解决这个问题，我们通过将页面目录本身拆分为多个页面来构建树的更高级别，然后在其顶部添加另一个页面目录，以指向页面目录的页面。因此，我们可以将虚拟地址拆分如下：\n\n现在，在索引上层页面目录时，我们使用虚拟地址的最顶层位（图中的 PD 索引 0）；该索引可用于从上层页面目录中获取页面目录条目。如果有效，则结合顶层 PDE 的物理页号和 VPN 的下一部分（PD 索引 1)，查询页面目录的第二层。最后，如果有效，就可以使用页表索引与二级 PDE 中的地址相结合，形成 PTE 地址。啧啧这可是个大工程。而这一切仅仅是为了在多级表中查找某个内容。\n\n\n# 3.4 转换过程：记住 TLB\n\n为了总结使用二级页表进行地址转换的整个过程，我们再次以算法形式呈现控制流，如下面这段代码所示。\n\nVPN = (VirtualAddress & VPN_MASK) >> SHIFT;\n(Success, TlbEntry) = TLB_Lookup(VPN);\nif (Success == True) { // TLB Hit\n    if (CanAccess(TlbEntry.ProtectBits) == True) {\n        Offset = VirtualAddress & OFFSET_MASK;\n        PhysAddr = (TlbEntry.PFN << SHIFT) | Offset;\n        Register = AccessMemory(PhysAddr);\n    } else {\n        RaiseException(PROTECTION_FAULT);\n    }\n} else { // TLB Miss\n    // first, get page directory entry\n    PDIndex = (VPN & PD_MASK) >> PD_SHIFT;\n    PDEAddr = PDBR + (PDIndex * sizeof(PDE));\n    PDE = AccessMemory(PDEAddr);\n    if (PDE.Valid == False) {\n        RaiseException(SEGMENTATION_FAULT);\n    } else {\n        // PDE is valid: now fetch PTE from page table\n        PTIndex = (VPN & PT_MASK) >> PT_SHIFT;\n        PTEAddr = (PDE.PFN << SHIFT) + (PTIndex * sizeof(PTE));\n        PTE = AccessMemory(PTEAddr);\n        if (PTE.Valid == False) {\n            RaiseException(SEGMENTATION_FAULT);\n        } else if (CanAccess(PTE.ProtectBits) == False) {\n            RaiseException(PROTECTION_FAULT);\n        } else {\n            TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits);\n            RetryInstruction();\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n该段代码显示了每次内存引用时硬件（假设有硬件管理的 TLB）中发生的情况。从代码中可以看出，在任何复杂的多级页表访问发生之前，硬件首先会检查TLB；一旦命中，物理地址就直接形成，而无需像以前一样访问页表。仅当 TLB 未命中时，硬件才需要执行完整的多级查找。在此路径上，您可以看到传统两级页表的成本：两次额外的内存访问来查找有效的转换。\n\n\n# 3.5 真实的多级页表\n\n * 真实多级页面表（2482^{48}248B=256TB）\n   \n   \n   \n   如上图所示，线性地址的结构包含48位，这些位被划分为几个关键部分，每部分负责指向下一级的内存映射结构或确定页内的偏移量。\n   \n   1. PML4 (Page Map Level 4): 线性地址的最高9位（位39-47）用于索引PML4（Page Map Level 4）表。PML4表是一个包含着页映射表指针的数组，每个指针指向一个页目录指针表（PDPT）。\n   2. Directory Pointer (PDPT): 接下来的9位（位30-38）用于在PDPT中索引一个条目，该条目指向一个页目录。\n   3. Directory (PD): 紧接着的9位（位21-29）用于在页目录中索引一个条目，该条目指向一个页表。\n   4. Page Table (PT): 再下来的9位（位12-20）用于在页表中索引一个页表项（PTE），该页表项包含了最终物理页面的地址信息。\n   5. Page Offset: 最后的12位（位0-11）是页内偏移量，用于确定在物理页面内的具体地址。\n   \n   通过这种分层的索引机制，操作系统可以从线性地址生成对应的物理地址，从而允许更有效地管理内存，并实现诸如虚拟内存和内存保护等高级功能\n\n * 自2021年起（2562^{56}256B=128PB）\n   \n   \n   \n   相比之前的48位线性地址结构，现在的线性地址结构包含57位，多出了一个PML5级别，这使得页表层次结构更加深入，从而能够管理更大的地址空间。PML5 (Page Map Level 5): 新增的最高9位（位48-56）用于索引PML5表。PML5表是一个包含着页映射表指针的数组，每个指针指向一个PML4表。这一级页表的存在允许系统支持更大的物理内存，因为它增加了地址转换的层次，使得能够映射的地址空间成倍增长。PML5的引入进一步扩展了这种机制，使得系统能够处理更多的内存，这对于现代计算机系统处理大量数据和运行大型应用程序是非常重要的。\n   \n   \n   # 4 反向页表\n   \n   在页表的世界里，反向页表可以节省更多的空间。在这种情况下，我们不需要许多页表（系统的每个进程一个），而只需保存一个页表，该页表为系统的每个物理页提供一个条目。这个条目告诉我们哪个进程在使用这个页面，以及该进程的哪个虚拟页面映射到这个物理页面。\n   \n   要找到正确的条目，只需在这个数据结构中进行搜索。线性扫描的成本很高，因此通常会在基础结构上建立一个哈希表，以加快查找速度。PowerPC 就是这种架构的一个例子。\n   \n   更广泛地说，反向页表说明了我们从一开始就说过的：页表只是一种数据结构。你可以用数据结构做很多疯狂的事情，让它们变小或变大，变慢或变快。多级页表和倒转页表只是其中的两个例子。\n   \n   \n   \n   \n   # 5 将页表交换到磁盘\n   \n   最后，我们讨论放宽最后一个假设的问题。到目前为止，我们一直假设页表位于内核所有的物理内存中。即使我们采用了许多技巧来缩小页表的大小，但仍有可能出现页表过大，无法一次性放入内存的情况。因此，有些系统会将这些页表放在内核虚拟内存中，这样当内存压力有点紧张时，系统就可以将其中一些页表交换到磁盘上。我们将在以后的章节（即有关 VAX/VMS 的案例研究）中进一步讨论这个问题，届时我们将更详细地了解如何将页面移入和移出内存。",normalizedContent:"现在我们解决分页带来的第二个问题：页表太大，因此消耗太多内存。让我们从线性页表开始。您可能还记得，线性页表变得相当大。再次假设 32 位地址空间（2322^{32}232字节），具有 4kb（2122^{12}212 字节）页面和 4 字节页表条目。因此，地址空间中大约有一百万个虚拟页（232212\\frac{2^{32}}{2^{12}}212232 ）；乘以页表条目大小，您会看到页表大小为 4mb。\n\n\n\n另回想一下：我们通常为系统中的每个进程都有一个页表！对于一百个活动进程（在现代系统上并不罕见），我们将为页表分配数百兆字节的内存！因此，我们正在寻找一些技术来减轻这种沉重的负担。它们有很多，所以让我们开始吧。但在之前我们的问题关键是：简单的基于数组的页表（通常称为线性页表）太大，在典型系统上占用太多内存。如何才能让页表变小呢？关键的想法是什么？这些新的数据结构会导致哪些低效率？\n\n\n# 1 简单的解决方案：更大的页面\n\n我们可以通过一种简单的方法来减小页表的大小：使用较大的页面。再次使用我们的 32 位地址空间，但这次假设页面为 16kb。因此，我们将拥有一个 18 位 vpn 加上一个 14 位偏移量。假设每个 pte 的大小相同（4 字节），我们的线性页表中现在有 2182^{18}218 个条目，因此每个页表的总大小为 1mb，页表大小减少了四倍（毫不奇怪，减少恰好反映了页面大小四倍的增加）。\n\n\n\n然而，这种方法的主要问题是大页面会导致每个页面内的浪费，这个问题称为内部碎片（因为浪费是分配单元内部的）。因此，应用程序最终会分配页面，但只使用每个页面的一小部分，并且内存很快就会被这些过大的页面填满。因此，大多数系统在常见情况下使用相对较小的页面大小：4kb（如在 x86 中）或 8kb（如在 sparcv9 中）。我们的问题不会这么简单地解决。\n\n\n# 2 混合方法：分页和分段\n\n每当你对生活中的某件事有两种合理但不同的方法时，你应该始终检查两者的结合，看看是否能获得两全其美的效果。我们将这种组合称为混合体。\n\n多年前，multics 的创建者（特别是 jack dennis）在构建 multics 虚拟内存系统时偶然想到了这样的想法。具体来说，dennis 提出了将分页和分段相结合的想法，以减少页表的内存开销。通过更详细地检查典型的线性页表，我们可以明白为什么这可能起作用。假设我们有一个地址空间，其中堆和栈的已使用部分很小。例如，如下图所示，我们使用 16kb 的微小地址空间和 1kb 页面；\n\n该地址空间的页表如图下图所示。\n\n本例假定单个代码页（vpn 0）映射到物理页 10，单个堆页（vpn 4）映射到物理页 23，地址空间另一端的两个栈页（vpn 14 和 15）分别映射到物理页 28 和 4。从图中可以看出，大部分页表都未使用，充满了无效条目。非常浪费空间，且这只是一个 16kb 的小地址空间，如果是32位，会浪费的更多。\n\n因此，我们的混合方法是：与其为进程的整个地址空间制作一个页表，为什么不为每个逻辑段制作一个页表呢？在这个例子中，我们可能会有三个页表，分别用于地址空间的代码、堆和栈部分。\n\n现在，请记住分段，我们有一个基址寄存器告诉我们每个段在物理内存中的位置，还有一个边界或限制寄存器告诉我们所述段的大小。在我们的混合中，我们在 mmu 中仍然有这些结构；在这里，我们使用基址不是指向段本身，而是保存该段页表的物理地址。边界寄存器用于指示页表的末尾（即，它有多少个有效页）。\n\n让我们举一个简单的例子来说明。假设 32 位虚拟地址空间有 4kb 页面，地址空间分为四个段。在本例中，我们只使用三个段：一个用于代码，一个用于堆，一个用于栈。\n\n为了确定地址引用哪个段，我们将使用地址空间的前两位。假设 00 是未使用的段，01 表示代码，10 表示堆，11 表示堆栈。因此，虚拟地址如下所示：\n\n\n\n在硬件中，假设有三个基寄存器/边界对，代码、堆和栈各一个。当进程运行时，每个分段的基寄存器都包含该分段线性页表的物理地址；因此，系统中的每个进程现在都有三个与之相关的页表。在上下文切换时，必须更改这些寄存器，以反映新运行进程的页表位置。\n\n在 tlb 未命中时（假设 tlb 由硬件管理，即由硬件负责处理 tlb 未命中），硬件会使用段位（sn）来确定要使用的基址和边界对。然后，硬件将其中的物理地址与 vpn 进行如下组合，形成页表项 (pte) 的地址：\n\nsn = (virtualaddress & seg_mask) >> sn_shift\nvpn = (virtualaddress & vpn_mask) >> vpn_shift\naddressofpte = base[sn] + (vpn * sizeof(pte))\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n这个序列看起来应该很熟悉；它实际上与我们之前看到的线性页表相同。当然，唯一的区别是使用三个段基址寄存器之一而不是单页表基址寄存器。\n\n我们的混合方案的关键区别是每个段都存在一个边界寄存器；每个边界寄存器保存段中最大有效页的值。例如，如果代码段正在使用其前三页（0、1 和 2），则代码段页表将仅分配有三个条目，并且边界寄存器将设置为 3；超出段末尾的内存访问将生成异常，并可能导致进程终止。通过这种方式，与线性页表相比，我们的混合方法实现了显著的内存节省；栈和堆之间未分配的页面不再占用页表中的空间（只是将它们标记为无效）。\n\n然而，正如您可能注意到的，这种方法并非没有问题。首先，它仍然需要我们使用分段；正如我们之前讨论的，分段并不像我们希望的那么灵活，因为它假设地址空间有某种使用模式；例如，如果我们有一个大但很少使用的堆，我们仍然可能会产生大量页表浪费。其次，这种混合导致外部碎片再次出现。虽然大多数内存都是以页大小为单位进行管理的，但页表现在可以是任意大小（pte 的倍数）。因此，在内存中为它们找到可用空间更加复杂。由于这些原因，人们不断寻找更好的方法来实现更小的页表。\n\n\n# 3 多级页表\n\n\n# 3.1 介绍\n\n另一种方法不依赖于分段，但解决了同样的问题：如何摆脱页表中的所有无效区域，而不是将它们全部保留在内存中？我们将这种方法称为多级页表，因为它将线性页表变成了类似树的东西。这种方法非常有效，以至于许多现代系统都采用它（例如 x86 [boh10]）。我们现在详细描述这种方法。\n\n多级页表背后的基本思想很简单。首先，将页表切分成页大小的单元；然后，如果页表条目 (pte) 的整个页无效，则根本不分配页表的该页。要跟踪页表的页面是否有效（以及如果有效，则它在内存中的位置），则使用称为页目录的新结构。因此，页目录可以用来告诉您页表的某个页在哪里，或者页表的整个页不包含有效页。\n\n下图展示了一个示例。图左边是经典的线性页表；即使地址空间的大多数中间区域无效，我们仍然需要为这些区域分配页表空间（即页表的中间两页）。右边是多级页表。页目录仅将页表的两页标记为有效（第一页和最后一页）；因此，只有页表的那两页驻留在内存中。因此，您可以看到一种可视化多级表正在执行的操作的方法：它只是使部分线性页表消失（释放这些页以供其他用途），并跟踪页表的哪些页分配了该页目录。\n\n\n\n页目录在一个简单的两级表中，页表的每一页包含一个条目。它由许多页目录项（pde）组成。 pde（至少）具有有效位和物理页框号 (pfn)，与 pte 类似。然而，正如上面所暗示的，该有效位的含义略有不同：如果 pde 有效，则意味着该条目（通过 pfn）指向的页表中的至少一页是有效的，即，在该pde指向的该页上的至少一个pte中，该pte中的有效位被设置为1。如果 pde 无效（即等于 0），则 pde 的其余部分未定义。\n\n与我们迄今为止看到的方法相比，多级页表具有一些明显的优势。首先，也许最明显的是，多级表仅根据您正在使用的地址空间量按比例分配页表空间；因此它通常是紧凑的并且支持稀疏地址空间。\n\n其次，如果精心构建，页表的每个部分都可以整齐地容纳在一个页面中，从而更容易管理内存；当操作系统需要分配或增长页表时，它可以简单地获取下一个空闲页面。将此与简单（非分页）线性页表 进行对比，后者只是由 vpn 索引的 pte 数组；采用这样的结构，整个线性页表必须连续地驻留在物理内存中。对于大页表（例如 4mb），找到这么大块未使用的连续空闲物理内存可能是一个相当大的挑战。对于多级结构，我们通过使用页目录来添加间接层，页目录指向页表的各个部分；这种间接允许我们将页表页面放置在物理内存中的任何位置。\n\n需要注意的是，多级表是有成本的；如果 tlb 未命中，则需要从内存加载两次才能从页表获取正确的转换信息（一次用于页目录，一次用于 pte 本身），而线性页表只需加载一次。因此，多级表是时空权衡的一个小例子。我们想要更小的表（并且得到了），但不是免费的；虽然在常见情况下（tlb 命中），性能显然是相同的，但是对于这个较小的表，tlb 未命中会遭受更高的成本。\n\n另一个明显的负面因素是复杂性。无论是硬件还是操作系统处理页表查找（在 tlb 未命中时），这样做无疑比简单的线性页表查找更复杂。通常我们愿意增加复杂性以提高性能或减少开销；对于多级表，我们使页表查找更加复杂，以节省宝贵的内存。\n\n\n# 3.2 多级页表示例\n\n为了更好地理解多级页表背后的想法，让我们举一个例子。想象一个大小为 16kb、具有 64 字节页面的小地址空间。因此，我们有一个 14 位虚拟地址空间，其中 8 位用于 vpn，6 位用于偏移量。即使仅使用一小部分地址空间，线性页表也将具有 282^828 (256) 个条目。下图展示了此类地址空间的一个示例。\n\n\n\n在此示例中，虚拟页 0 和 1 用于代码，虚拟页 4 和 5 用于堆，虚拟页 254 和 255 用于堆栈；地址空间的其余页面未使用。\n\n为了为此地址空间构建两级页表，我们从完整的线性页表开始，并将其分解为页面大小的单元。回想一下我们的完整表（在本例中）有 256 个条目；假设每个 pte 的大小为 4 字节。因此，我们的页表大小为 1kb（256 × 4 字节）。假设我们有64字节的页面，那么1kb的页表可以分为16个64字节的页面；每页可容纳 16 个 pte。\n\n我们现在需要了解的是如何使用vpn并使用它首先索引到页目录，然后索引到页表的页面。请记住，每个都是一个条目数组；因此，我们需要弄清楚的是如何为 vpn 的每个部分构建索引。\n\n让我们首先索引到页面目录。本例中的页表很小：256 个条目，分布在 16 个页面上。页目录需要页表的每一页一个条目；因此，它有 16 个条目。因此，我们需要 vpn 的四位来索引目录；我们使用vpn的前四位，如下：\n\n\n\n一旦我们从vpn中提取出页目录索引（简称pdindex），我们就可以通过简单的计算来找到页目录条目（pde）的地址： pdeaddr = pagedirbase + (pdindex * sizeof(pde) ）。这就产生了我们的页面目录，现在我们对其进行研究，以进一步推进我们的转换工作\n\n如果页目录条目被标记为无效，我们就知道访问无效，从而引发异常。然而，如果pde有效，我们还有更多工作要做。具体来说，我们现在必须从该页目录项指向的页表页中获取页表项（pte）。为了找到这个 pte，我们必须使用 vpn 的剩余位来索引页表的部分：\n\n\n\n然后可以使用此页表索引（简称 ptindex）对页表本身进行索引，从而为我们提供 pte 的地址：\n\npteaddr = (pde.pfn << shift) + (ptindex * sizeof(pte))\n\n请注意，从页目录项获得的物理页框号 (pfn) 必须先左移到位，然后才能与页表索引组合以形成 pte 的地址。为了看看这一切是否有意义，我们现在将用一些实际值填充多级页表，并转换单个虚拟地址。让我们从本例的页面目录开始（如下图左侧）。\n\n\n\n在图中，您可以看到每个页目录项 (pde) 描述了有关地址空间页表中的一页的信息。在此示例中，我们在地址空间中有两个有效区域（位于开头和结尾），以及中间的许多无效映射。在物理页100（页表第0页的物理帧号）中，我们有地址空间中前16个vpn的16个页表条目的第一页。这部分页表的内容见上图（中间部分）。\n\n页表的该页包含前 16 个 vpn 的映射；在我们的示例中，vpn 0 和 1 有效（代码段），4 和 5（堆）也是有效的。因此，该表具有每个页面的映射信息。其余条目被标记为无效。\n\n页表的另一个有效页位于 pfn 101 内。该页包含地址空间最后 16 个 vpn 的映射；如上图所示（右）。\n\n在示例中，vpn 254 和 255（堆栈）具有有效映射。希望我们可以从这个示例中看到，使用多级索引结构可以节省多少空间。在此示例中，我们没有为线性页表分配完整的 16 个页面，而是仅分配三个页面：一个用于页目录，两个用于具有有效映射的页表块。对于大型（32 位或 64 位）地址空间来说，节省的成本显然要大得多。\n\n最后，让我们使用这些信息来执行转换。这是一个引用 vpn 254 第 0 个字节的地址：0x3f80，或二进制的 11 1111 1000 0000。\n\n回想一下，我们将使用 vpn 的前 4 位来索引页面目录。因此，1111 将选择上面页目录的最后一个（如果从第 0 个开始，则为第 15 个）条目。这将我们指向位于地址 101 的页表的有效页面。然后，我们使用 vpn (1110) 的接下来 4 位来索引页表的该页面并找到所需的 pte。 1110 是页面上的倒数第二个（第 14 个）条目，它告诉我们虚拟地址空间的第 254 页映射到物理页 55。通过将 pfn=55（或十六进制 0x37）与 offset=000000 连接，我们因此可以形成我们想要的物理地址并向内存系统发出请求：physaddr = (pte.pfn << shift) + offset = 00 1101 1100 0000 = 0x0dc0。您现在应该了解如何使用指向页表页面的页目录来构造两级页表。然而不幸的是，我们的工作还没有完成。正如我们现在将讨论的，有时两级页表是不够的！\n\n\n# 3.3 不止两级\n\n到目前为止，在我们的示例中，我们假设多级页表只有两个级别：页目录，然后是页表的各个部分。在某些情况下，更深的树是可能的（而且确实是需要的）。\n\n让我们举一个简单的例子，并用它来说明为什么更深的多级表会很有用。在此示例中，假设我们有一个 30 位虚拟地址空间和一个小（512 字节）页面。因此，我们的虚拟地址有一个 21 位虚拟页号组件和一个 9 位偏移量。\n\n请记住我们构建多级页表的目标：使页表的每一部分都适合单个页面。到目前为止，我们只考虑了页表本身；但是，如果页面目录变得太大怎么办？\n\n为了确定多级表中需要多少级才能使页表的所有部分都适合一个页面，我们首先确定一个页面适合多少个页表条目。鉴于我们的页面大小为 512 字节，并假设 pte 大小为 4 字节，您应该会发现单个页面上可以容纳 128 个 pte。当我们对页表的某个页面进行索引时，我们可以得出结论，我们需要 vpn 的最低有效 7 位 (log⁡2128\\log _2{128}log2 128) 作为索引：\n\n\n\n从上图中您还可能注意到，（大）页目录中还剩下多少位： 14。如果我们的页目录有 2142^{14}214个条目，那么它跨越的不是一页而是 128，因此，我们将多级页表的每一部分都放入一个页面的目标就消失了。\n\n为了解决这个问题，我们通过将页面目录本身拆分为多个页面来构建树的更高级别，然后在其顶部添加另一个页面目录，以指向页面目录的页面。因此，我们可以将虚拟地址拆分如下：\n\n现在，在索引上层页面目录时，我们使用虚拟地址的最顶层位（图中的 pd 索引 0）；该索引可用于从上层页面目录中获取页面目录条目。如果有效，则结合顶层 pde 的物理页号和 vpn 的下一部分（pd 索引 1)，查询页面目录的第二层。最后，如果有效，就可以使用页表索引与二级 pde 中的地址相结合，形成 pte 地址。啧啧这可是个大工程。而这一切仅仅是为了在多级表中查找某个内容。\n\n\n# 3.4 转换过程：记住 tlb\n\n为了总结使用二级页表进行地址转换的整个过程，我们再次以算法形式呈现控制流，如下面这段代码所示。\n\nvpn = (virtualaddress & vpn_mask) >> shift;\n(success, tlbentry) = tlb_lookup(vpn);\nif (success == true) { // tlb hit\n    if (canaccess(tlbentry.protectbits) == true) {\n        offset = virtualaddress & offset_mask;\n        physaddr = (tlbentry.pfn << shift) | offset;\n        register = accessmemory(physaddr);\n    } else {\n        raiseexception(protection_fault);\n    }\n} else { // tlb miss\n    // first, get page directory entry\n    pdindex = (vpn & pd_mask) >> pd_shift;\n    pdeaddr = pdbr + (pdindex * sizeof(pde));\n    pde = accessmemory(pdeaddr);\n    if (pde.valid == false) {\n        raiseexception(segmentation_fault);\n    } else {\n        // pde is valid: now fetch pte from page table\n        ptindex = (vpn & pt_mask) >> pt_shift;\n        pteaddr = (pde.pfn << shift) + (ptindex * sizeof(pte));\n        pte = accessmemory(pteaddr);\n        if (pte.valid == false) {\n            raiseexception(segmentation_fault);\n        } else if (canaccess(pte.protectbits) == false) {\n            raiseexception(protection_fault);\n        } else {\n            tlb_insert(vpn, pte.pfn, pte.protectbits);\n            retryinstruction();\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n该段代码显示了每次内存引用时硬件（假设有硬件管理的 tlb）中发生的情况。从代码中可以看出，在任何复杂的多级页表访问发生之前，硬件首先会检查tlb；一旦命中，物理地址就直接形成，而无需像以前一样访问页表。仅当 tlb 未命中时，硬件才需要执行完整的多级查找。在此路径上，您可以看到传统两级页表的成本：两次额外的内存访问来查找有效的转换。\n\n\n# 3.5 真实的多级页表\n\n * 真实多级页面表（2482^{48}248b=256tb）\n   \n   \n   \n   如上图所示，线性地址的结构包含48位，这些位被划分为几个关键部分，每部分负责指向下一级的内存映射结构或确定页内的偏移量。\n   \n   1. pml4 (page map level 4): 线性地址的最高9位（位39-47）用于索引pml4（page map level 4）表。pml4表是一个包含着页映射表指针的数组，每个指针指向一个页目录指针表（pdpt）。\n   2. directory pointer (pdpt): 接下来的9位（位30-38）用于在pdpt中索引一个条目，该条目指向一个页目录。\n   3. directory (pd): 紧接着的9位（位21-29）用于在页目录中索引一个条目，该条目指向一个页表。\n   4. page table (pt): 再下来的9位（位12-20）用于在页表中索引一个页表项（pte），该页表项包含了最终物理页面的地址信息。\n   5. page offset: 最后的12位（位0-11）是页内偏移量，用于确定在物理页面内的具体地址。\n   \n   通过这种分层的索引机制，操作系统可以从线性地址生成对应的物理地址，从而允许更有效地管理内存，并实现诸如虚拟内存和内存保护等高级功能\n\n * 自2021年起（2562^{56}256b=128pb）\n   \n   \n   \n   相比之前的48位线性地址结构，现在的线性地址结构包含57位，多出了一个pml5级别，这使得页表层次结构更加深入，从而能够管理更大的地址空间。pml5 (page map level 5): 新增的最高9位（位48-56）用于索引pml5表。pml5表是一个包含着页映射表指针的数组，每个指针指向一个pml4表。这一级页表的存在允许系统支持更大的物理内存，因为它增加了地址转换的层次，使得能够映射的地址空间成倍增长。pml5的引入进一步扩展了这种机制，使得系统能够处理更多的内存，这对于现代计算机系统处理大量数据和运行大型应用程序是非常重要的。\n   \n   \n   # 4 反向页表\n   \n   在页表的世界里，反向页表可以节省更多的空间。在这种情况下，我们不需要许多页表（系统的每个进程一个），而只需保存一个页表，该页表为系统的每个物理页提供一个条目。这个条目告诉我们哪个进程在使用这个页面，以及该进程的哪个虚拟页面映射到这个物理页面。\n   \n   要找到正确的条目，只需在这个数据结构中进行搜索。线性扫描的成本很高，因此通常会在基础结构上建立一个哈希表，以加快查找速度。powerpc 就是这种架构的一个例子。\n   \n   更广泛地说，反向页表说明了我们从一开始就说过的：页表只是一种数据结构。你可以用数据结构做很多疯狂的事情，让它们变小或变大，变慢或变快。多级页表和倒转页表只是其中的两个例子。\n   \n   \n   \n   \n   # 5 将页表交换到磁盘\n   \n   最后，我们讨论放宽最后一个假设的问题。到目前为止，我们一直假设页表位于内核所有的物理内存中。即使我们采用了许多技巧来缩小页表的大小，但仍有可能出现页表过大，无法一次性放入内存的情况。因此，有些系统会将这些页表放在内核虚拟内存中，这样当内存压力有点紧张时，系统就可以将其中一些页表交换到磁盘上。我们将在以后的章节（即有关 vax/vms 的案例研究）中进一步讨论这个问题，届时我们将更详细地了解如何将页面移入和移出内存。",charsets:{cjk:!0},lastUpdated:"2024/05/11, 20:33:38",lastUpdatedTimestamp:1715430818e3},{title:"内存API",frontmatter:{title:"内存API",tags:["OS"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},date:"2024-04-25T22:37:23.000Z",permalink:"/pages/174348/",categories:["开发","系统架构","操作系统","虚拟化"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/02.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/09.%E5%86%85%E5%AD%98API.html",relativePath:"01.开发/05.系统架构/02.操作系统/09.内存API.md",key:"v-14654b08",path:"/pages/174348/",headersStr:null,content:'github地址\n\n 1. 首先，编写一个名为 null.c 的简单程序，该程序创建一个指向整数的指针，将其设置为 NULL，然后尝试取消引用它。将其编译为名为 null 的可执行文件。当你运行这个程序时会发生什么？\n    \n    #include <stdio.h>\n    \n    int main() {\n        int *p = NULL;\n        printf("Value of p: %d\\n", *p);\n        return 0;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n    \n    ❯ gcc null.c -o null\n    ❯ ./null\n    [1]    67350 segmentation fault  ./null\n    \n    \n    1\n    2\n    3\n    \n    1\n    2\n    3\n    \n\n 2. 接下来，在编译程序时加入符号信息（使用 -g 标志）。这样做可以在可执行文件中加入更多信息，使调试器可以访问更多有用的变量名等信息。在调试器下运行程序，键入 gdb null，然后在 gdb 运行后键入 run。gdb 会显示什么？\n    \n    > gcc null.c -g -o null\n    > gdb null\n    GNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1\n    Copyright (C) 2022 Free Software Foundation, Inc.\n    License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n    This is free software: you are free to change and redistribute it.\n    There is NO WARRANTY, to the extent permitted by law.\n    Type "show copying" and "show warranty" for details.\n    This GDB was configured as "x86_64-linux-gnu".\n    Type "show configuration" for configuration details.\n    For bug reporting instructions, please see:\n    <https://www.gnu.org/software/gdb/bugs/>.\n    Find the GDB manual and other documentation resources online at:\n        <http://www.gnu.org/software/gdb/documentation/>.\n    \n    For help, type "help".\n    Type "apropos word" to search for commands related to "word"...\n    Reading symbols from null...\n    (gdb) run\n    Starting program: /home/zfhe/null\n    [Thread debugging using libthread_db enabled]\n    Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".\n    \n    Program received signal SIGSEGV, Segmentation fault.\n    0x0000555555555161 in main () at null.c:5\n    5\t    printf("Value of p: %d\\n", *p);\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    \n\n 3. 最后，在这个程序上使用 valgrind 工具。我们将使用 valgrind 中的 memcheck 工具来分析发生的情况。运行时输入以下内容：valgrind --leak-check=yes ./null。运行时会发生什么？你能解释该工具的输出吗？\n    \n    > valgrind --leak-check=yes ./null\n    ==1316115== Memcheck, a memory error detector\n    ==1316115== Copyright (C) 2002-2017, and GNU GPL\'d, by Julian Seward et al.\n    ==1316115== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info\n    ==1316115== Command: ./null\n    ==1316115==\n    ==1316115== Invalid read of size 4\n    ==1316115==    at 0x109161: main (null.c:5)\n    ==1316115==  Address 0x0 is not stack\'d, malloc\'d or (recently) free\'d\n    ==1316115==\n    ==1316115==\n    ==1316115== Process terminating with default action of signal 11 (SIGSEGV)\n    ==1316115==  Access not within mapped region at address 0x0\n    ==1316115==    at 0x109161: main (null.c:5)\n    ==1316115==  If you believe this happened as a result of a stack\n    ==1316115==  overflow in your program\'s main thread (unlikely but\n    ==1316115==  possible), you can try to increase the size of the\n    ==1316115==  main thread stack using the --main-stacksize= flag.\n    ==1316115==  The main thread stack size used in this run was 8388608.\n    ==1316115==\n    ==1316115== HEAP SUMMARY:\n    ==1316115==     in use at exit: 0 bytes in 0 blocks\n    ==1316115==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated\n    ==1316115==\n    ==1316115== All heap blocks were freed -- no leaks are possible\n    ==1316115==\n    ==1316115== For lists of detected and suppressed errors, rerun with: -s\n    ==1316115== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\n    [1]    1316115 segmentation fault (core dumped)  valgrind --leak-check=yes ./null\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    \n    \n    输出的解释：\n    \n    1. Invalid read of size 4：程序尝试读取一个无效的内存地址，该地址的大小为 4 字节。这表明在程序执行过程中发生了一次无效的内存读取操作。\n    2. Address 0x0 is not stack\'d, malloc\'d or (recently) free\'d：Valgrind 报告了试图访问的内存地址是 0x0，即空指针。程序尝试读取了一个空指针，这是非法操作，因为空指针通常不指向任何有效的内存位置。\n    3. Process terminating with default action of signal 11 (SIGSEGV)：由于程序尝试访问无效的内存地址导致了段错误，程序被终止，并且默认行为是发送信号 11 (SIGSEGV)。\n    4. Access not within mapped region at address 0x0：Valgrind 报告了访问的内存地址不在映射区域内，即程序试图访问未分配或未初始化的内存区域。\n    5. HEAP SUMMARY 和 ERROR SUMMARY：Valgrind 提供了堆内存使用情况的总结和错误摘要。在这个例子中，堆内存中没有分配任何内存块，也没有发生内存泄漏。\n    6. All heap blocks were freed -- no leaks are possible：Valgrind 告诉我们在程序结束时所有的堆内存都已被释放，因此不存在内存泄漏的可能性。\n\n 4. 编写一个简单的程序，使用 malloc() 分配内存，但在退出前忘记释放内存。程序运行时会发生什么？你能用 gdb 查找出任何问题吗？使用 valgrind（同样使用 --leak-check=yes 标志）如何？\n    \n    #include <stdio.h>\n    #include <stdlib.h>\n    \n    void malloc_but_nofree() {\n        int *p = (int *)malloc(sizeof(int));\n    }\n    int main() {\n        malloc_but_nofree();\n        return 0;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n    \n    程序正常运行正常结束，gdb也无法发现内存泄漏，但valgrind可以。\n\n 5. 编写一个程序，使用 malloc 创建一个大小为 100 的名为 data 的整数数组，然后将 data[100] 设置为零。运行这个程序时会发生什么？使用 valgrind 运行此程序时会发生什么？程序正确吗？\n    \n    #include <stdio.h>\n    #include <stdlib.h>\n    \n    int main() {\n        // create size of 100 array\n        int *p = (int *)malloc(100);\n        // set p[100] = 0\n        p[100] = 0;\n        return 0;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n    \n    程序正常运行。\n    \n    ==1316673== Memcheck, a memory error detector\n    ==1316673== Copyright (C) 2002-2017, and GNU GPL\'d, by Julian Seward et al.\n    ==1316673== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info\n    ==1316673== Command: ./a.out\n    ==1316673==\n    ==1316673== Invalid write of size 4\n    ==1316673==    at 0x10916D: main (in /home/zfhe/a.out)\n    ==1316673==  Address 0x4a921d0 is 224 bytes inside an unallocated block of size 4,194,032 in arena "client"\n    ==1316673==\n    ==1316673==\n    ==1316673== HEAP SUMMARY:\n    ==1316673==     in use at exit: 100 bytes in 1 blocks\n    ==1316673==   total heap usage: 1 allocs, 0 frees, 100 bytes allocated\n    ==1316673==\n    ==1316673== 100 bytes in 1 blocks are definitely lost in loss record 1 of 1\n    ==1316673==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)\n    ==1316673==    by 0x10915E: main (in /home/zfhe/a.out)\n    ==1316673==\n    ==1316673== LEAK SUMMARY:\n    ==1316673==    definitely lost: 100 bytes in 1 blocks\n    ==1316673==    indirectly lost: 0 bytes in 0 blocks\n    ==1316673==      possibly lost: 0 bytes in 0 blocks\n    ==1316673==    still reachable: 0 bytes in 0 blocks\n    ==1316673==         suppressed: 0 bytes in 0 blocks\n    ==1316673==\n    ==1316673== For lists of detected and suppressed errors, rerun with: -s\n    ==1316673== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    \n\n 6. 创建一个程序，分配一个整数数组（如上所述），释放它们，然后尝试打印该数组的一个元素的值。程序能运行吗？当你使用 valgrind 时会发生什么？\n    \n    #include <stdio.h>\n    #include <stdlib.h>\n    \n    int main() {\n        // create size of 100 array\n        int *p = (int *)malloc(100);\n        free(p);\n        // use p\n        p[0] = 0;\n        return 0;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n    \n    程序能运行。\n    \n    > valgrind --leak-check=yes ./a.out\n    ==1316773== Memcheck, a memory error detector\n    ==1316773== Copyright (C) 2002-2017, and GNU GPL\'d, by Julian Seward et al.\n    ==1316773== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info\n    ==1316773== Command: ./a.out\n    ==1316773==\n    ==1316773== Invalid write of size 4\n    ==1316773==    at 0x109193: main (in /home/zfhe/a.out)\n    ==1316773==  Address 0x4a92040 is 0 bytes inside a block of size 100 free\'d\n    ==1316773==    at 0x484B27F: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)\n    ==1316773==    by 0x10918E: main (in /home/zfhe/a.out)\n    ==1316773==  Block was alloc\'d at\n    ==1316773==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)\n    ==1316773==    by 0x10917E: main (in /home/zfhe/a.out)\n    ==1316773==\n    ==1316773==\n    ==1316773== HEAP SUMMARY:\n    ==1316773==     in use at exit: 0 bytes in 0 blocks\n    ==1316773==   total heap usage: 1 allocs, 1 frees, 100 bytes allocated\n    ==1316773==\n    ==1316773== All heap blocks were freed -- no leaks are possible\n    ==1316773==\n    ==1316773== For lists of detected and suppressed errors, rerun with: -s\n    ==1316773== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    \n\n 7. 现在向 free 传递一个有趣的值（例如，上面分配的数组中间的指针）。会发生什么？你需要工具来发现这类问题吗？\n    \n    #include <stdio.h>\n    #include <stdlib.h>\n    \n    int main() {\n        // create size of 100 array\n        int *p = (int *)malloc(100);\n        // free the pointer in the middle of the array\n        free(p + 50);\n        return 0;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n    \n    test.c: In function ‘main’:\n    test.c:8:5: warning: ‘free’ called on pointer ‘p’ with nonzero offset 200 [-Wfree-nonheap-object]\n        8 |     free(p + 50);\n          |     ^~~~~~~~~~~~\n    test.c:6:21: note: returned from ‘malloc’\n        6 |     int *p = (int *)malloc(100);\n          |                     ^~~~~~~~~~~\n    > ./a.out\n    free(): invalid pointer\n    [1]    1316922 IOT instruction (core dumped)  ./a.out\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n    \n    编译时提供warning，运行时直接报错。可以不通过工具就能发现这个问题。\n\n 8. 了解内存分配的其他接口。例如，创建一个简单的类似向量的数据结构和使用 realloc() 管理向量的相关例程。使用数组存储矢量元素；当用户向矢量添加条目时，使用 realloc() 为其分配更多空间。这样的向量性能如何？与链表相比如何？使用 valgrind 查找错误。\n    \n    #include <stdio.h>\n    #include <stdlib.h>\n    \n    typedef struct vect {\n        int *data;          // pointer to the data\n        size_t length;\n        size_t population;\n    } Vector;\n    \n    Vector *new_vector(size_t length);  // Allocate memory for a new Vector\n    void delete(Vector *v);             // Free memory allocated for a Vector\n    void add(Vector *v, int elem);      // Add an element to the Vector    \n    int get(Vector *v, int index);      // Get the element at the specified index from the Vector\n    \n    int main(int argc, char *argv[]) {\n        Vector *vector = new_vector(0);\n        if (vector == NULL) \n            return EXIT_FAILURE;\n    \n        printf("Vector has %d spaces and %d items stored\\n", \n                (int) vector->length, (int) vector->population);\n        \n        add (vector, 5);\n        printf("Vector has %d spaces and %d items stored\\n", \n                (int) vector->length, (int) vector->population);\n    \n        printf("The value at index %d is %d\\n", \n                0, vector->data[0]);\n        delete(vector);\n        return 0;\n    }\n    \n    Vector *new_vector(size_t length) {\n        Vector *v = (Vector *) malloc(sizeof(Vector));\n        if (v == NULL) {\n            fprintf(stderr, "Failed to allocate memory\\n");\n            return NULL;\n        }\n        v->length = length;\n        v->population = 0;\n        v->data = (int *) calloc(length, sizeof(int));\n        if (v->data == NULL) {\n            fprintf(stderr, "Failed to allocate memory\\n");\n            return NULL;\n        }\n        return v;\n    }\n    \n    void delete(Vector *v) {\n        free(v->data);\n        free(v);\n    }\n    \n    void add(Vector *v, int elem) {\n        if (v->population >= v->length) { // need more space\n            v->data = realloc(v->data, (v->length + 1) * sizeof(int));\n            v->length++;\n        }\n        *(v->data + v->population++) = elem;\n    }\n    \n    int get(Vector *v, int index) {\n        return v->data[index];\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    63\n    64\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    63\n    64\n    \n    \n    随机访问快速，空间利用率高，但插入和删除元素较慢，且内存需要重新分配开销，而链表只需要单独为每个节点开辟内存。',normalizedContent:'github地址\n\n 1. 首先，编写一个名为 null.c 的简单程序，该程序创建一个指向整数的指针，将其设置为 null，然后尝试取消引用它。将其编译为名为 null 的可执行文件。当你运行这个程序时会发生什么？\n    \n    #include <stdio.h>\n    \n    int main() {\n        int *p = null;\n        printf("value of p: %d\\n", *p);\n        return 0;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n    \n    ❯ gcc null.c -o null\n    ❯ ./null\n    [1]    67350 segmentation fault  ./null\n    \n    \n    1\n    2\n    3\n    \n    1\n    2\n    3\n    \n\n 2. 接下来，在编译程序时加入符号信息（使用 -g 标志）。这样做可以在可执行文件中加入更多信息，使调试器可以访问更多有用的变量名等信息。在调试器下运行程序，键入 gdb null，然后在 gdb 运行后键入 run。gdb 会显示什么？\n    \n    > gcc null.c -g -o null\n    > gdb null\n    gnu gdb (ubuntu 12.1-0ubuntu1~22.04) 12.1\n    copyright (c) 2022 free software foundation, inc.\n    license gplv3+: gnu gpl version 3 or later <http://gnu.org/licenses/gpl.html>\n    this is free software: you are free to change and redistribute it.\n    there is no warranty, to the extent permitted by law.\n    type "show copying" and "show warranty" for details.\n    this gdb was configured as "x86_64-linux-gnu".\n    type "show configuration" for configuration details.\n    for bug reporting instructions, please see:\n    <https://www.gnu.org/software/gdb/bugs/>.\n    find the gdb manual and other documentation resources online at:\n        <http://www.gnu.org/software/gdb/documentation/>.\n    \n    for help, type "help".\n    type "apropos word" to search for commands related to "word"...\n    reading symbols from null...\n    (gdb) run\n    starting program: /home/zfhe/null\n    [thread debugging using libthread_db enabled]\n    using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".\n    \n    program received signal sigsegv, segmentation fault.\n    0x0000555555555161 in main () at null.c:5\n    5\t    printf("value of p: %d\\n", *p);\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    \n\n 3. 最后，在这个程序上使用 valgrind 工具。我们将使用 valgrind 中的 memcheck 工具来分析发生的情况。运行时输入以下内容：valgrind --leak-check=yes ./null。运行时会发生什么？你能解释该工具的输出吗？\n    \n    > valgrind --leak-check=yes ./null\n    ==1316115== memcheck, a memory error detector\n    ==1316115== copyright (c) 2002-2017, and gnu gpl\'d, by julian seward et al.\n    ==1316115== using valgrind-3.18.1 and libvex; rerun with -h for copyright info\n    ==1316115== command: ./null\n    ==1316115==\n    ==1316115== invalid read of size 4\n    ==1316115==    at 0x109161: main (null.c:5)\n    ==1316115==  address 0x0 is not stack\'d, malloc\'d or (recently) free\'d\n    ==1316115==\n    ==1316115==\n    ==1316115== process terminating with default action of signal 11 (sigsegv)\n    ==1316115==  access not within mapped region at address 0x0\n    ==1316115==    at 0x109161: main (null.c:5)\n    ==1316115==  if you believe this happened as a result of a stack\n    ==1316115==  overflow in your program\'s main thread (unlikely but\n    ==1316115==  possible), you can try to increase the size of the\n    ==1316115==  main thread stack using the --main-stacksize= flag.\n    ==1316115==  the main thread stack size used in this run was 8388608.\n    ==1316115==\n    ==1316115== heap summary:\n    ==1316115==     in use at exit: 0 bytes in 0 blocks\n    ==1316115==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated\n    ==1316115==\n    ==1316115== all heap blocks were freed -- no leaks are possible\n    ==1316115==\n    ==1316115== for lists of detected and suppressed errors, rerun with: -s\n    ==1316115== error summary: 1 errors from 1 contexts (suppressed: 0 from 0)\n    [1]    1316115 segmentation fault (core dumped)  valgrind --leak-check=yes ./null\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    \n    \n    输出的解释：\n    \n    1. invalid read of size 4：程序尝试读取一个无效的内存地址，该地址的大小为 4 字节。这表明在程序执行过程中发生了一次无效的内存读取操作。\n    2. address 0x0 is not stack\'d, malloc\'d or (recently) free\'d：valgrind 报告了试图访问的内存地址是 0x0，即空指针。程序尝试读取了一个空指针，这是非法操作，因为空指针通常不指向任何有效的内存位置。\n    3. process terminating with default action of signal 11 (sigsegv)：由于程序尝试访问无效的内存地址导致了段错误，程序被终止，并且默认行为是发送信号 11 (sigsegv)。\n    4. access not within mapped region at address 0x0：valgrind 报告了访问的内存地址不在映射区域内，即程序试图访问未分配或未初始化的内存区域。\n    5. heap summary 和 error summary：valgrind 提供了堆内存使用情况的总结和错误摘要。在这个例子中，堆内存中没有分配任何内存块，也没有发生内存泄漏。\n    6. all heap blocks were freed -- no leaks are possible：valgrind 告诉我们在程序结束时所有的堆内存都已被释放，因此不存在内存泄漏的可能性。\n\n 4. 编写一个简单的程序，使用 malloc() 分配内存，但在退出前忘记释放内存。程序运行时会发生什么？你能用 gdb 查找出任何问题吗？使用 valgrind（同样使用 --leak-check=yes 标志）如何？\n    \n    #include <stdio.h>\n    #include <stdlib.h>\n    \n    void malloc_but_nofree() {\n        int *p = (int *)malloc(sizeof(int));\n    }\n    int main() {\n        malloc_but_nofree();\n        return 0;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n    \n    程序正常运行正常结束，gdb也无法发现内存泄漏，但valgrind可以。\n\n 5. 编写一个程序，使用 malloc 创建一个大小为 100 的名为 data 的整数数组，然后将 data[100] 设置为零。运行这个程序时会发生什么？使用 valgrind 运行此程序时会发生什么？程序正确吗？\n    \n    #include <stdio.h>\n    #include <stdlib.h>\n    \n    int main() {\n        // create size of 100 array\n        int *p = (int *)malloc(100);\n        // set p[100] = 0\n        p[100] = 0;\n        return 0;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n    \n    程序正常运行。\n    \n    ==1316673== memcheck, a memory error detector\n    ==1316673== copyright (c) 2002-2017, and gnu gpl\'d, by julian seward et al.\n    ==1316673== using valgrind-3.18.1 and libvex; rerun with -h for copyright info\n    ==1316673== command: ./a.out\n    ==1316673==\n    ==1316673== invalid write of size 4\n    ==1316673==    at 0x10916d: main (in /home/zfhe/a.out)\n    ==1316673==  address 0x4a921d0 is 224 bytes inside an unallocated block of size 4,194,032 in arena "client"\n    ==1316673==\n    ==1316673==\n    ==1316673== heap summary:\n    ==1316673==     in use at exit: 100 bytes in 1 blocks\n    ==1316673==   total heap usage: 1 allocs, 0 frees, 100 bytes allocated\n    ==1316673==\n    ==1316673== 100 bytes in 1 blocks are definitely lost in loss record 1 of 1\n    ==1316673==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)\n    ==1316673==    by 0x10915e: main (in /home/zfhe/a.out)\n    ==1316673==\n    ==1316673== leak summary:\n    ==1316673==    definitely lost: 100 bytes in 1 blocks\n    ==1316673==    indirectly lost: 0 bytes in 0 blocks\n    ==1316673==      possibly lost: 0 bytes in 0 blocks\n    ==1316673==    still reachable: 0 bytes in 0 blocks\n    ==1316673==         suppressed: 0 bytes in 0 blocks\n    ==1316673==\n    ==1316673== for lists of detected and suppressed errors, rerun with: -s\n    ==1316673== error summary: 2 errors from 2 contexts (suppressed: 0 from 0)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    \n\n 6. 创建一个程序，分配一个整数数组（如上所述），释放它们，然后尝试打印该数组的一个元素的值。程序能运行吗？当你使用 valgrind 时会发生什么？\n    \n    #include <stdio.h>\n    #include <stdlib.h>\n    \n    int main() {\n        // create size of 100 array\n        int *p = (int *)malloc(100);\n        free(p);\n        // use p\n        p[0] = 0;\n        return 0;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n    \n    程序能运行。\n    \n    > valgrind --leak-check=yes ./a.out\n    ==1316773== memcheck, a memory error detector\n    ==1316773== copyright (c) 2002-2017, and gnu gpl\'d, by julian seward et al.\n    ==1316773== using valgrind-3.18.1 and libvex; rerun with -h for copyright info\n    ==1316773== command: ./a.out\n    ==1316773==\n    ==1316773== invalid write of size 4\n    ==1316773==    at 0x109193: main (in /home/zfhe/a.out)\n    ==1316773==  address 0x4a92040 is 0 bytes inside a block of size 100 free\'d\n    ==1316773==    at 0x484b27f: free (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)\n    ==1316773==    by 0x10918e: main (in /home/zfhe/a.out)\n    ==1316773==  block was alloc\'d at\n    ==1316773==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)\n    ==1316773==    by 0x10917e: main (in /home/zfhe/a.out)\n    ==1316773==\n    ==1316773==\n    ==1316773== heap summary:\n    ==1316773==     in use at exit: 0 bytes in 0 blocks\n    ==1316773==   total heap usage: 1 allocs, 1 frees, 100 bytes allocated\n    ==1316773==\n    ==1316773== all heap blocks were freed -- no leaks are possible\n    ==1316773==\n    ==1316773== for lists of detected and suppressed errors, rerun with: -s\n    ==1316773== error summary: 1 errors from 1 contexts (suppressed: 0 from 0)\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    \n\n 7. 现在向 free 传递一个有趣的值（例如，上面分配的数组中间的指针）。会发生什么？你需要工具来发现这类问题吗？\n    \n    #include <stdio.h>\n    #include <stdlib.h>\n    \n    int main() {\n        // create size of 100 array\n        int *p = (int *)malloc(100);\n        // free the pointer in the middle of the array\n        free(p + 50);\n        return 0;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n    \n    test.c: in function ‘main’:\n    test.c:8:5: warning: ‘free’ called on pointer ‘p’ with nonzero offset 200 [-wfree-nonheap-object]\n        8 |     free(p + 50);\n          |     ^~~~~~~~~~~~\n    test.c:6:21: note: returned from ‘malloc’\n        6 |     int *p = (int *)malloc(100);\n          |                     ^~~~~~~~~~~\n    > ./a.out\n    free(): invalid pointer\n    [1]    1316922 iot instruction (core dumped)  ./a.out\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n    \n    编译时提供warning，运行时直接报错。可以不通过工具就能发现这个问题。\n\n 8. 了解内存分配的其他接口。例如，创建一个简单的类似向量的数据结构和使用 realloc() 管理向量的相关例程。使用数组存储矢量元素；当用户向矢量添加条目时，使用 realloc() 为其分配更多空间。这样的向量性能如何？与链表相比如何？使用 valgrind 查找错误。\n    \n    #include <stdio.h>\n    #include <stdlib.h>\n    \n    typedef struct vect {\n        int *data;          // pointer to the data\n        size_t length;\n        size_t population;\n    } vector;\n    \n    vector *new_vector(size_t length);  // allocate memory for a new vector\n    void delete(vector *v);             // free memory allocated for a vector\n    void add(vector *v, int elem);      // add an element to the vector    \n    int get(vector *v, int index);      // get the element at the specified index from the vector\n    \n    int main(int argc, char *argv[]) {\n        vector *vector = new_vector(0);\n        if (vector == null) \n            return exit_failure;\n    \n        printf("vector has %d spaces and %d items stored\\n", \n                (int) vector->length, (int) vector->population);\n        \n        add (vector, 5);\n        printf("vector has %d spaces and %d items stored\\n", \n                (int) vector->length, (int) vector->population);\n    \n        printf("the value at index %d is %d\\n", \n                0, vector->data[0]);\n        delete(vector);\n        return 0;\n    }\n    \n    vector *new_vector(size_t length) {\n        vector *v = (vector *) malloc(sizeof(vector));\n        if (v == null) {\n            fprintf(stderr, "failed to allocate memory\\n");\n            return null;\n        }\n        v->length = length;\n        v->population = 0;\n        v->data = (int *) calloc(length, sizeof(int));\n        if (v->data == null) {\n            fprintf(stderr, "failed to allocate memory\\n");\n            return null;\n        }\n        return v;\n    }\n    \n    void delete(vector *v) {\n        free(v->data);\n        free(v);\n    }\n    \n    void add(vector *v, int elem) {\n        if (v->population >= v->length) { // need more space\n            v->data = realloc(v->data, (v->length + 1) * sizeof(int));\n            v->length++;\n        }\n        *(v->data + v->population++) = elem;\n    }\n    \n    int get(vector *v, int index) {\n        return v->data[index];\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    63\n    64\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    63\n    64\n    \n    \n    随机访问快速，空间利用率高，但插入和删除元素较慢，且内存需要重新分配开销，而链表只需要单独为每个节点开辟内存。',charsets:{cjk:!0},lastUpdated:"2024/05/11, 20:33:38",lastUpdatedTimestamp:1715430818e3},{title:"空闲空间管理",frontmatter:{title:"空闲空间管理",tags:["OS"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},date:"2024-04-25T22:38:12.000Z",permalink:"/pages/d34e64/",categories:["开发","系统架构","操作系统","虚拟化"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/02.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/12.%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86.html",relativePath:"01.开发/05.系统架构/02.操作系统/12.空闲空间管理.md",key:"v-72ba3a16",path:"/pages/d34e64/",headers:[{level:2,title:"1 假设",slug:"_1-假设",normalizedTitle:"1 假设",charIndex:2},{level:2,title:"2 低级机制",slug:"_2-低级机制",normalizedTitle:"2 低级机制",charIndex:852},{level:3,title:"2.1 分割与合并",slug:"_2-1-分割与合并",normalizedTitle:"2.1 分割与合并",charIndex:863},{level:3,title:"2.2 跟踪分配区域的大小",slug:"_2-2-跟踪分配区域的大小",normalizedTitle:"2.2 跟踪分配区域的大小",charIndex:1842},{level:3,title:"2.3 嵌入空闲列表",slug:"_2-3-嵌入空闲列表",normalizedTitle:"2.3 嵌入空闲列表",charIndex:2749},{level:3,title:"2.4 增加堆",slug:"_2-4-增加堆",normalizedTitle:"2.4 增加堆",charIndex:4579},{level:2,title:"3 管理空闲空间：基本策略",slug:"_3-管理空闲空间-基本策略",normalizedTitle:"3 管理空闲空间：基本策略",charIndex:4856},{level:3,title:"3.1 最佳适应算法",slug:"_3-1-最佳适应算法",normalizedTitle:"3.1 最佳适应算法",charIndex:4874},{level:3,title:"3.2 最差适应算法",slug:"_3-2-最差适应算法",normalizedTitle:"3.2 最差适应算法",charIndex:5081},{level:3,title:"3.3 首次适应算法",slug:"_3-3-首次适应算法",normalizedTitle:"3.3 首次适应算法",charIndex:5252},{level:3,title:"3.4 循环首次适应算法",slug:"_3-4-循环首次适应算法",normalizedTitle:"3.4 循环首次适应算法",charIndex:5445},{level:3,title:"3.5 四种算法实例对比",slug:"_3-5-四种算法实例对比",normalizedTitle:"3.5 四种算法实例对比",charIndex:5587},{level:2,title:"4 其他方法",slug:"_4-其他方法",normalizedTitle:"4 其他方法",charIndex:5946},{level:3,title:"4.1 隔离列表：slab分配器",slug:"_4-1-隔离列表-slab分配器",normalizedTitle:"4.1 隔离列表：slab分配器",charIndex:5957},{level:3,title:"4.2 伙伴分配器",slug:"_4-2-伙伴分配器",normalizedTitle:"4.2 伙伴分配器",charIndex:6648},{level:3,title:"4.3 其他方法",slug:"_4-3-其他方法",normalizedTitle:"4.3 其他方法",charIndex:7205}],headersStr:"1 假设 2 低级机制 2.1 分割与合并 2.2 跟踪分配区域的大小 2.3 嵌入空闲列表 2.4 增加堆 3 管理空闲空间：基本策略 3.1 最佳适应算法 3.2 最差适应算法 3.3 首次适应算法 3.4 循环首次适应算法 3.5 四种算法实例对比 4 其他方法 4.1 隔离列表：slab分配器 4.2 伙伴分配器 4.3 其他方法",content:"# 1 假设\n\n本讨论的大部分内容将集中于用户级内存分配库中分配器的伟大历史。\n\n我们假设有一个基本接口，例如 malloc() 和 free() 提供的接口。具体来说，void *malloc(size t size) 采用单个参数 size，它是应用程序请求的字节数；它返回一个指向该大小（或更大）的区域的指针（没有特定类型，或者 C 语言中的 void 指针）。补充例程 void free(void *ptr) 接受一个指针并释放相应的块。注意该接口的含义：用户在释放空间时，并不告知库其大小；因此，当只提供指向内存块的指针时，库必须能够计算出内存块有多大。\n\n该库管理的空间历史上称为堆，用于管理堆中空闲空间的通用数据结构是某种空闲列表。该结构包含对托管内存区域中所有空闲空间块的引用。当然，该数据结构本身不必是列表，而只是某种用于跟踪可用空间的数据结构。\n\n我们进一步假设我们主要关注外部碎片。分配器当然也可能存在内部碎片的问题；如果分配器分配的内存块大于请求的内存块，则此类块中任何未请求的（因此未使用的）空间都被视为内部碎片（因为浪费发生在分配的单元内），并且是空间浪费的一种情况。然而，为了简单起见，并且因为它是两种类型的碎片中更有趣的一种，所以我们将主要关注外部碎片。\n\n我们还假设一旦内存被分发给客户端，它就不能被重新定位到内存中的另一个位置。例如，如果程序调用 malloc() 并获得一个指向堆内某个空间的指针，则该内存区域本质上由程序“拥有”（并且不能由库移动），直到程序通过相应的free()调用返回它为止。因此，不可能压缩可用空间，而压缩有助于消除碎片。然而，在实现分段时，可以在操作系统中使用压缩来处理碎片。\n\n最后，我们假设分配器管理一个连续的字节区域。在某些情况下，分配者可能会要求该区域增长；例如，当空间不足时，用户级内存分配库可能会调用内核来增加堆（通过 sbrk 等系统调用）。然而，为了简单起见，我们假设该区域在其整个生命周期中都是单一的固定大小。\n\n\n# 2 低级机制\n\n\n# 2.1 分割与合并\n\n空闲列表包含一组元素，这些元素描述堆中仍剩余的空闲空间。因此，假设有以下 30 字节堆：\n\n\n\n该堆的空闲列表上有两个元素。一个条目描述第一个 10 字节空闲段（字节 0-9），一个条目描述另一个空闲段（字节 20-29）：\n\n如上所述，任何大于 10 字节的请求都会失败（返回 NULL），只是没有该大小的连续内存块可用。任何一个空闲块都可以轻松满足对该大小（10 字节）的请求。但如果请求的内容小于 10 个字节，会发生什么情况？\n\n假设我们只请求一个字节的内存。在这种情况下，分配器将执行称为分割的操作：它将找到可以满足请求的空闲内存块并将其分割为两部分。它将返回给调用者的第一个块；第二块将保留在列表中。因此，在上面的示例中，如果发出了 1 个字节的请求，并且分配器决定使用列表中两个元素中的第二个来满足请求，则对 malloc() 的调用将返回 20（分配器的地址）。 1 字节分配区域），列表最终将如下所示：\n\n\n\n从图中可以看到列表基本保持完整；唯一的变化是空闲区域现在从 21 而不是 20 开始，并且该空闲区域的长度现在仅为 9。因此，当请求小于任何特定空闲块的大小时，分配器通常会使用分割方法。许多分配器中都有一个推论机制，称为空闲空间合并。再次以上面的例子为例（空闲 10 个字节，已用 10 个字节，还有另外一个空闲 10 个字节）。\n\n给定这个（很小的）堆，当应用程序调用 free(10) 时会发生什么，从而返回堆中间的空间？如果我们只是简单地将这个可用空间添加回我们的列表中而不需要太多思考，我们最终可能会得到一个如下所示的列表：\n\n\n\n虽然整个堆现在是空闲的，但它似乎被分为三个块，每个块 10 字节。因此，如果用户请求 20 个字节，简单的列表遍历将找不到这样的空闲块，并返回失败。\n\n为了避免这个问题，分配器所做的就是在释放一块内存时合并可用空间。这个想法很简单：当返回内存中的空闲块时，仔细查看要返回的块的地址以及附近的空闲空间块；如果新释放的空间紧邻一个（或两个，如本示例中所示）现有空闲块，请将它们合并为一个更大的空闲块。因此，通过合并，我们的最终列表应该如下所示：\n\n\n\n事实上，这就是在进行任何分配之前堆列表最初的样子。通过合并，分配器可以更好地确保大的空闲范围可供应用程序使用。\n\n\n# 2.2 跟踪分配区域的大小\n\n您可能已经注意到 free(void *ptr) 的接口不采用大小参数；因此，假设给定一个指针，malloc 库可以快速确定正在释放的内存区域的大小，从而将空间合并回空闲列表中。\n\n为了完成此任务，大多数分配器在header块中存储一些额外信息，该header块保存在内存中，通常就在分配的内存块之前。让我们再看一个例子，如下图所示。\n\n在此示例中，我们正在检查由 ptr 指向的大小为 20 字节的已分配块；想象一下用户调用 malloc() 并将结果存储在 ptr 中，例如 ptr = malloc(20);\n\nheader至少包含分配区域的大小（在本例中为 20）；它还可能包含用于加速释放的附加指针、用于提供附加完整性检查的幻数以及其他信息。让我们假设一个简单的标头，其中包含区域的大小和一个幻数，如下所示：\n\ntypedef struct __header_t {\n\tint size;\n\tint magic;\n} header_t;\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n上面的示例如下图所示：\n\n\n\n当用户调用 free(ptr)，然后库使用简单的指针算术来确定标头的开始位置：\n\nvoid free(void *ptr) {\n\theader_t *hptr = (void *)ptr - sizeof(header_t);\n    assert(hptr->magic == 1234567 && “Heap is corrupt”);\n\t...\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n获得这样一个指向header的指针后，库可以轻松确定幻数是否与预期值匹配作为健全性检查（assert(hptr->magic == 1234567)），并通过简单的数学运算（即，将header的大小添加到区域的大小）计算新释放区域的总大小。请注意最后一句中的小但关键的细节：空闲区域的大小是header的大小加上分配给用户的空间的大小。因此，当用户请求 N 字节的内存时，库不会搜索大小为 N 的空闲块；相反，它会搜索大小为 N 加上header大小的空闲块。\n\n\n# 2.3 嵌入空闲列表\n\n到目前为止，我们已经将简单的空闲列表视为一个概念实体；它只是一个描述堆中空闲内存块的列表。但是我们如何在空间空间本身内构建这样的列表呢？\n\n在更典型的列表中，分配新节点时，只需在需要该节点的空间时调用 malloc() 即可。不幸的是，在内存分配库中，你不能这样做！相反，您需要在可用空间本身内构建列表。如果这听起来有点奇怪，请不要担心；是的，但并不奇怪到你做不到！\n\n假设我们有一个 4096 字节的内存块需要管理（即堆为 4KB）。要将其作为空闲列表进行管理，我们首先必须初始化该列表；最初，列表应该有一个条目，大小为 4096（减去header大小）。以下是链表节点的描述：\n\ntypedef struct __node_t {\n\tint size;\n\tstruct __node_t *next;\n} node_t;\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n现在让我们看一些初始化堆并将空闲列表的第一个元素放入该空间的代码。我们假设堆是在通过调用系统调用 mmap() 获得的一些可用空间内构建的；这不是构建此类堆的唯一方法，但在本例中对我们很有帮助。这是代码：\n\n// mmap() returns a pointer to a chunk of free space\nnode_t *head = mmap(NULL, 4096, PROT_READ|PROT_WRITE,\n                    MAP_ANON|MAP_PRIVATE, -1, 0);\nhead->size = 4096 - sizeof(node_t);\nhead->next = NULL;\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n运行这段代码后，列表的状态是只有一个条目，大小为 4088。是的，这是一个很小的堆，但它为我们提供了一个很好的例子。\n\nhead指针包含该范围的起始地址；我们假设它是 16KB（尽管任何虚拟地址都可以）。从视觉上看，堆看起来就像下面这样。\n\n\n\n现在，我们假设请求一块内存，大小为 100 字节。为了服务这个请求，库将首先找到一个足够大的块来容纳该请求；因为只有一个空闲块（大小：4088），所以将选择该块。然后，该块将被分割成两部分：一个足够大以服务请求（和header，如上所述），以及剩余的空闲块。假设有一个 8 字节的header（整数大小和整数幻数），堆中的空间现在看起来如下图所示：\n\n\n\n因此，在请求 100 字节时，库从现有的一个空闲块中分配了 108 字节，返回一个指向它的指针（上图中标记为 ptr），将header信息存储在分配的空间之前，以便之后供free()使用，并将链表中的一个空闲节点缩小到 3980 字节（4088 减 108）。\n\n现在让我们看看有 3 个分配区域的堆，每个区域 100 个字节（或 108 个字节，包括header）。该堆的可视化如下图所示。\n\n\n\n正如您在其中看到的，堆的前 324 字节现已分配，因此我们在该空间中看到三个header以及调用程序正在使用的三个 100 字节区域。空闲列表仍然无趣：只是一个节点（由head指向），但在三个分割之后现在大小只有 3764 字节。但是当调用程序通过 free() 返回一些内存时会发生什么？\n\n在此示例中，应用程序通过调用 free(16500)（值16500是通过将内存区域的起始地址16384与前一个块的108相加以及此块头部的8字节来得到的。） 返回已分配内存的中间块。该值在上图中由指针 sptr 显示。\n\n库立即计算出空闲区域的大小，然后将空闲块添加回空闲列表。假设我们在空闲列表的头部插入，空间现在看起来如下图所示。\n\n\n\n现在，我们有了一个以小空闲块（100 字节，由列表首部指向）和大空闲块（3764 字节）开始的列表。我们的列表终于多了一个元素！是的，空闲空间是支离破碎的，这是一种不幸但常见的现象。\n\n最后一个例子：现在让我们假设最后两个正在使用的块已被释放。如果不进行合并，您最终可能会得到一个高度碎片化的空闲列表，如下图所示。\n\n\n\n从图中可以看出，我们现在一团糟！为什么？很简单，我们忘记合并列表。虽然所有的内存都是空闲的，但它却被分割成碎片，因此不是完整的内存，而是呈现出碎片化的内存。解决方案很简单：遍历列表并合并相邻块；完成后，堆将再次完整。\n\n\n# 2.4 增加堆\n\n我们应该讨论许多分配库中的最后一种机制。具体来说，如果堆空间不足该怎么办？最简单的方法就是失败。在某些情况下，这是唯一的选择，因此返回 NULL 是一种值得尊敬的方法。\n\n大多数传统分配器都从一个小堆开始，然后在内存耗尽时向操作系统请求更多内存。通常，这意味着它们进行某种系统调用（例如，大多数 UNIX 系统中的 sbrk）来增加堆，然后从那里分配新的块。为了服务 sbrk 请求，操作系统查找空闲物理页，将它们映射到请求进程的地址空间，然后返回新堆末尾的值；此时，可以使用更大的堆，并且可以成功地处理请求，如下图所示。\n\n\n\n\n# 3 管理空闲空间：基本策略\n\n\n# 3.1 最佳适应算法\n\n最佳适应算法的策略非常简单：首先，搜索空闲列表并找到与请求大小一样大或更大的空闲内存块。然后，返回该组候选者中最小的那个；这就是所谓的最佳适应块（也可以称为最小适应）。遍历一次空闲列表就足以找到要返回的正确块。\n\n最佳适应背后的直觉很简单：通过返回接近用户要求的块，最佳适应尝试减少浪费的空间。然而，这是有代价的；当对正确的空闲块执行详尽的搜索时，幼稚的实现会带来严重的性能损失。\n\n\n# 3.2 最差适应算法\n\n最差适应算法与最佳适应算法相反；找到最大的块并返回请求的数量；将剩余的（大）块保留在空闲列表中。因此，最差适应尝试留下大块，而不是最佳适应方法可能产生的大量小块。然而，再次需要对可用空间进行全面搜索，因此这种方法的成本可能很高。更糟糕的是，大多数研究表明它的性能很差，导致过多的碎片，同时仍然具有很高的开销。\n\n\n# 3.3 首次适应算法\n\n首次适应算法只需找到第一个足够大的区块，并将请求的大小返回给用户。与之前一样，剩余的空闲空间将保留给后续请求。\n\n首次适应算法的优点是速度快，无需穷举搜索所有空闲空间，但有时会用小对象污染空闲列表的开头部分。因此，分配器如何管理空闲列表的顺序就成了一个问题。一种方法是使用基于地址的排序；通过保持列表按空闲空间的地址排序，凝聚变得更容易，碎片也会减少。\n\n\n# 3.4 循环首次适应算法\n\n循环首次适应算法并不总是在列表的开头开始首次适应搜索，而是保留一个额外的指针，指向列表中最后一次查找的位置。这个想法是在整个列表中更均匀地分布对可用空间的搜索，从而避免列表开头的分割。这种方法的性能与首次适应算法非常相似，因为再次避免了穷举搜索。\n\n\n# 3.5 四种算法实例对比\n\n以下是上述策略的一些示例。设想一个空闲列表，其中包含三个元素，大小分别为 10、30 和 20（这里我们将忽略headers和其他细节，而只关注策略的运作方式）：\n\n\n\n假设分配请求大小为 15。最佳适应算法会搜索整个列表并发现 20 是最适合的，因为它是可以容纳请求的最小可用空间。生成的空闲列表：\n\n\n\n正如本例中发生的情况，也是最佳适应方法经常发生的情况，现在剩下了一个小的空闲块。最差拟合方法与此类似，但它找到的是最大的块，在本例中为 30。结果列表如下：\n\n\n\n在本例中，首次适应算法与最差适应算法执行相同的操作，也是查找可以满足请求的第一个空闲块。区别在于搜索成本；最佳算法和最差算法都会浏览整个列表； 首次适应算法 仅检查空闲块，直到找到适合的块，从而降低搜索成本。\n\n\n# 4 其他方法\n\n\n# 4.1 隔离列表：slab分配器\n\n一种已经存在一段时间的有趣方法是使用隔离列表。基本思想很简单：如果特定应用程序发出一个（或几个）常见大小的请求，则保留一个单独的列表来管理该大小的对象；所有其他请求都转发到更通用的内存分配器。\n\n这种方法的好处是显而易见的。通过将一块内存专用于特定大小的请求，碎片就不再是一个问题。此外，当分配和释放请求的大小合适时，可以非常快速地处理它们，因为不需要复杂的列表搜索。\n\n但这种方法也会给系统带来新的复杂性。例如，与通用内存池相比，应该将多少内存专门用于服务给定大小的特殊请求的内存池？一个特殊的分配器，由超级工程师 Jeff Bonwick 设计的slab 分配器（设计用于 Solaris 内核），以一种相当好的方式处理这个问题。\n\n具体来说，当内核启动时，它会为可能被频繁请求的内核对象（例如锁、文件系统 inode 等）分配一些对象缓存。因此，对象缓存都是给定大小的隔离空闲列表，并快速服务内存分配和空闲请求。当给定的缓存可用空间不足时，它会从更通用的内存分配器请求一些内存块（slab）（请求的总量是页面大小和相关对象的倍数）。相反，当给定slab内的对象的引用计数全部变为零时，通用分配器可以从专用分配器中回收它们，这通常在VM系统需要更多内存时执行。\n\n通过将列表上的空闲对象保持在预初始化状态，slab 分配器还超越了大多数隔离列表方法。 Bonwick 表明数据结构的初始化和销毁代价高昂 ，通过将特定列表中的已释放对象保持在其初始化状态，slab 分配器因此避免了每个对象的频繁初始化和销毁周期，从而显着降低了开销。\n\n\n# 4.2 伙伴分配器\n\n由于合并对于分配器至关重要，因此设计了一些方法来简化合并。二进制伙伴分配器就是一个很好的例子。\n\n在这样的系统中，空闲内存首先在概念上被认为是大小为 2N2^N2N 的大空间。当发出内存请求时，对可用空间的搜索会递归地将可用空间一分为二，直到找到足够大以容纳请求的块（进一步分成两部分将导致空间太小）。此时，所请求的块就返回给用户了。以下是在搜索 7KB 块时划分 64KB 可用空间的示例：\n\n\n\n在示例中，最左边的 8KB 块被分配（如较深的蓝色阴影所示）并返回给用户；请注意，该方案可能会受到内部碎片的影响，因为您只能给出两倍大小的块。\n\n伙伴分配的美妙之处在于释放该块时发生的情况。当将8KB块返回到空闲列表时，分配器检查“伙伴”8KB是否空闲；如果是，它将把两个块合并成一个 16KB 的块。然后分配器检查 16KB 块的伙伴是否仍然空闲；如果是这样，它将合并这两个块。这种递归合并过程沿着树继续进行，要么恢复整个可用空间，要么在发现伙伴正在使用时停止。\n\n伙伴分配工作如此顺利的原因是确定特定块的伙伴很简单。想想上面空闲空间中块的地址。如果您仔细思考，您会发现每个好友对的地址仅相差一位；哪一位由好友树中的级别决定。这样您就对二进制好友分配方案的工作原理有了基本的了解。\n\n\n# 4.3 其他方法\n\n上述许多方法的一个主要问题是它们缺乏扩展性。具体来说，搜索列表可能会非常慢。因此，高级分配器使用更复杂的数据结构来解决这些成本，以简单性换取性能。例如平衡二叉树、展开树或部分排序树等。\n\n鉴于现代系统通常具有多个处理器并运行多线程工作负载，因此在基于多处理器的系统上花费大量精力使分配器正常工作也就不足为奇了。\n\nUnderstanding glibc malloc",normalizedContent:"# 1 假设\n\n本讨论的大部分内容将集中于用户级内存分配库中分配器的伟大历史。\n\n我们假设有一个基本接口，例如 malloc() 和 free() 提供的接口。具体来说，void *malloc(size t size) 采用单个参数 size，它是应用程序请求的字节数；它返回一个指向该大小（或更大）的区域的指针（没有特定类型，或者 c 语言中的 void 指针）。补充例程 void free(void *ptr) 接受一个指针并释放相应的块。注意该接口的含义：用户在释放空间时，并不告知库其大小；因此，当只提供指向内存块的指针时，库必须能够计算出内存块有多大。\n\n该库管理的空间历史上称为堆，用于管理堆中空闲空间的通用数据结构是某种空闲列表。该结构包含对托管内存区域中所有空闲空间块的引用。当然，该数据结构本身不必是列表，而只是某种用于跟踪可用空间的数据结构。\n\n我们进一步假设我们主要关注外部碎片。分配器当然也可能存在内部碎片的问题；如果分配器分配的内存块大于请求的内存块，则此类块中任何未请求的（因此未使用的）空间都被视为内部碎片（因为浪费发生在分配的单元内），并且是空间浪费的一种情况。然而，为了简单起见，并且因为它是两种类型的碎片中更有趣的一种，所以我们将主要关注外部碎片。\n\n我们还假设一旦内存被分发给客户端，它就不能被重新定位到内存中的另一个位置。例如，如果程序调用 malloc() 并获得一个指向堆内某个空间的指针，则该内存区域本质上由程序“拥有”（并且不能由库移动），直到程序通过相应的free()调用返回它为止。因此，不可能压缩可用空间，而压缩有助于消除碎片。然而，在实现分段时，可以在操作系统中使用压缩来处理碎片。\n\n最后，我们假设分配器管理一个连续的字节区域。在某些情况下，分配者可能会要求该区域增长；例如，当空间不足时，用户级内存分配库可能会调用内核来增加堆（通过 sbrk 等系统调用）。然而，为了简单起见，我们假设该区域在其整个生命周期中都是单一的固定大小。\n\n\n# 2 低级机制\n\n\n# 2.1 分割与合并\n\n空闲列表包含一组元素，这些元素描述堆中仍剩余的空闲空间。因此，假设有以下 30 字节堆：\n\n\n\n该堆的空闲列表上有两个元素。一个条目描述第一个 10 字节空闲段（字节 0-9），一个条目描述另一个空闲段（字节 20-29）：\n\n如上所述，任何大于 10 字节的请求都会失败（返回 null），只是没有该大小的连续内存块可用。任何一个空闲块都可以轻松满足对该大小（10 字节）的请求。但如果请求的内容小于 10 个字节，会发生什么情况？\n\n假设我们只请求一个字节的内存。在这种情况下，分配器将执行称为分割的操作：它将找到可以满足请求的空闲内存块并将其分割为两部分。它将返回给调用者的第一个块；第二块将保留在列表中。因此，在上面的示例中，如果发出了 1 个字节的请求，并且分配器决定使用列表中两个元素中的第二个来满足请求，则对 malloc() 的调用将返回 20（分配器的地址）。 1 字节分配区域），列表最终将如下所示：\n\n\n\n从图中可以看到列表基本保持完整；唯一的变化是空闲区域现在从 21 而不是 20 开始，并且该空闲区域的长度现在仅为 9。因此，当请求小于任何特定空闲块的大小时，分配器通常会使用分割方法。许多分配器中都有一个推论机制，称为空闲空间合并。再次以上面的例子为例（空闲 10 个字节，已用 10 个字节，还有另外一个空闲 10 个字节）。\n\n给定这个（很小的）堆，当应用程序调用 free(10) 时会发生什么，从而返回堆中间的空间？如果我们只是简单地将这个可用空间添加回我们的列表中而不需要太多思考，我们最终可能会得到一个如下所示的列表：\n\n\n\n虽然整个堆现在是空闲的，但它似乎被分为三个块，每个块 10 字节。因此，如果用户请求 20 个字节，简单的列表遍历将找不到这样的空闲块，并返回失败。\n\n为了避免这个问题，分配器所做的就是在释放一块内存时合并可用空间。这个想法很简单：当返回内存中的空闲块时，仔细查看要返回的块的地址以及附近的空闲空间块；如果新释放的空间紧邻一个（或两个，如本示例中所示）现有空闲块，请将它们合并为一个更大的空闲块。因此，通过合并，我们的最终列表应该如下所示：\n\n\n\n事实上，这就是在进行任何分配之前堆列表最初的样子。通过合并，分配器可以更好地确保大的空闲范围可供应用程序使用。\n\n\n# 2.2 跟踪分配区域的大小\n\n您可能已经注意到 free(void *ptr) 的接口不采用大小参数；因此，假设给定一个指针，malloc 库可以快速确定正在释放的内存区域的大小，从而将空间合并回空闲列表中。\n\n为了完成此任务，大多数分配器在header块中存储一些额外信息，该header块保存在内存中，通常就在分配的内存块之前。让我们再看一个例子，如下图所示。\n\n在此示例中，我们正在检查由 ptr 指向的大小为 20 字节的已分配块；想象一下用户调用 malloc() 并将结果存储在 ptr 中，例如 ptr = malloc(20);\n\nheader至少包含分配区域的大小（在本例中为 20）；它还可能包含用于加速释放的附加指针、用于提供附加完整性检查的幻数以及其他信息。让我们假设一个简单的标头，其中包含区域的大小和一个幻数，如下所示：\n\ntypedef struct __header_t {\n\tint size;\n\tint magic;\n} header_t;\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n上面的示例如下图所示：\n\n\n\n当用户调用 free(ptr)，然后库使用简单的指针算术来确定标头的开始位置：\n\nvoid free(void *ptr) {\n\theader_t *hptr = (void *)ptr - sizeof(header_t);\n    assert(hptr->magic == 1234567 && “heap is corrupt”);\n\t...\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n获得这样一个指向header的指针后，库可以轻松确定幻数是否与预期值匹配作为健全性检查（assert(hptr->magic == 1234567)），并通过简单的数学运算（即，将header的大小添加到区域的大小）计算新释放区域的总大小。请注意最后一句中的小但关键的细节：空闲区域的大小是header的大小加上分配给用户的空间的大小。因此，当用户请求 n 字节的内存时，库不会搜索大小为 n 的空闲块；相反，它会搜索大小为 n 加上header大小的空闲块。\n\n\n# 2.3 嵌入空闲列表\n\n到目前为止，我们已经将简单的空闲列表视为一个概念实体；它只是一个描述堆中空闲内存块的列表。但是我们如何在空间空间本身内构建这样的列表呢？\n\n在更典型的列表中，分配新节点时，只需在需要该节点的空间时调用 malloc() 即可。不幸的是，在内存分配库中，你不能这样做！相反，您需要在可用空间本身内构建列表。如果这听起来有点奇怪，请不要担心；是的，但并不奇怪到你做不到！\n\n假设我们有一个 4096 字节的内存块需要管理（即堆为 4kb）。要将其作为空闲列表进行管理，我们首先必须初始化该列表；最初，列表应该有一个条目，大小为 4096（减去header大小）。以下是链表节点的描述：\n\ntypedef struct __node_t {\n\tint size;\n\tstruct __node_t *next;\n} node_t;\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n现在让我们看一些初始化堆并将空闲列表的第一个元素放入该空间的代码。我们假设堆是在通过调用系统调用 mmap() 获得的一些可用空间内构建的；这不是构建此类堆的唯一方法，但在本例中对我们很有帮助。这是代码：\n\n// mmap() returns a pointer to a chunk of free space\nnode_t *head = mmap(null, 4096, prot_read|prot_write,\n                    map_anon|map_private, -1, 0);\nhead->size = 4096 - sizeof(node_t);\nhead->next = null;\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n运行这段代码后，列表的状态是只有一个条目，大小为 4088。是的，这是一个很小的堆，但它为我们提供了一个很好的例子。\n\nhead指针包含该范围的起始地址；我们假设它是 16kb（尽管任何虚拟地址都可以）。从视觉上看，堆看起来就像下面这样。\n\n\n\n现在，我们假设请求一块内存，大小为 100 字节。为了服务这个请求，库将首先找到一个足够大的块来容纳该请求；因为只有一个空闲块（大小：4088），所以将选择该块。然后，该块将被分割成两部分：一个足够大以服务请求（和header，如上所述），以及剩余的空闲块。假设有一个 8 字节的header（整数大小和整数幻数），堆中的空间现在看起来如下图所示：\n\n\n\n因此，在请求 100 字节时，库从现有的一个空闲块中分配了 108 字节，返回一个指向它的指针（上图中标记为 ptr），将header信息存储在分配的空间之前，以便之后供free()使用，并将链表中的一个空闲节点缩小到 3980 字节（4088 减 108）。\n\n现在让我们看看有 3 个分配区域的堆，每个区域 100 个字节（或 108 个字节，包括header）。该堆的可视化如下图所示。\n\n\n\n正如您在其中看到的，堆的前 324 字节现已分配，因此我们在该空间中看到三个header以及调用程序正在使用的三个 100 字节区域。空闲列表仍然无趣：只是一个节点（由head指向），但在三个分割之后现在大小只有 3764 字节。但是当调用程序通过 free() 返回一些内存时会发生什么？\n\n在此示例中，应用程序通过调用 free(16500)（值16500是通过将内存区域的起始地址16384与前一个块的108相加以及此块头部的8字节来得到的。） 返回已分配内存的中间块。该值在上图中由指针 sptr 显示。\n\n库立即计算出空闲区域的大小，然后将空闲块添加回空闲列表。假设我们在空闲列表的头部插入，空间现在看起来如下图所示。\n\n\n\n现在，我们有了一个以小空闲块（100 字节，由列表首部指向）和大空闲块（3764 字节）开始的列表。我们的列表终于多了一个元素！是的，空闲空间是支离破碎的，这是一种不幸但常见的现象。\n\n最后一个例子：现在让我们假设最后两个正在使用的块已被释放。如果不进行合并，您最终可能会得到一个高度碎片化的空闲列表，如下图所示。\n\n\n\n从图中可以看出，我们现在一团糟！为什么？很简单，我们忘记合并列表。虽然所有的内存都是空闲的，但它却被分割成碎片，因此不是完整的内存，而是呈现出碎片化的内存。解决方案很简单：遍历列表并合并相邻块；完成后，堆将再次完整。\n\n\n# 2.4 增加堆\n\n我们应该讨论许多分配库中的最后一种机制。具体来说，如果堆空间不足该怎么办？最简单的方法就是失败。在某些情况下，这是唯一的选择，因此返回 null 是一种值得尊敬的方法。\n\n大多数传统分配器都从一个小堆开始，然后在内存耗尽时向操作系统请求更多内存。通常，这意味着它们进行某种系统调用（例如，大多数 unix 系统中的 sbrk）来增加堆，然后从那里分配新的块。为了服务 sbrk 请求，操作系统查找空闲物理页，将它们映射到请求进程的地址空间，然后返回新堆末尾的值；此时，可以使用更大的堆，并且可以成功地处理请求，如下图所示。\n\n\n\n\n# 3 管理空闲空间：基本策略\n\n\n# 3.1 最佳适应算法\n\n最佳适应算法的策略非常简单：首先，搜索空闲列表并找到与请求大小一样大或更大的空闲内存块。然后，返回该组候选者中最小的那个；这就是所谓的最佳适应块（也可以称为最小适应）。遍历一次空闲列表就足以找到要返回的正确块。\n\n最佳适应背后的直觉很简单：通过返回接近用户要求的块，最佳适应尝试减少浪费的空间。然而，这是有代价的；当对正确的空闲块执行详尽的搜索时，幼稚的实现会带来严重的性能损失。\n\n\n# 3.2 最差适应算法\n\n最差适应算法与最佳适应算法相反；找到最大的块并返回请求的数量；将剩余的（大）块保留在空闲列表中。因此，最差适应尝试留下大块，而不是最佳适应方法可能产生的大量小块。然而，再次需要对可用空间进行全面搜索，因此这种方法的成本可能很高。更糟糕的是，大多数研究表明它的性能很差，导致过多的碎片，同时仍然具有很高的开销。\n\n\n# 3.3 首次适应算法\n\n首次适应算法只需找到第一个足够大的区块，并将请求的大小返回给用户。与之前一样，剩余的空闲空间将保留给后续请求。\n\n首次适应算法的优点是速度快，无需穷举搜索所有空闲空间，但有时会用小对象污染空闲列表的开头部分。因此，分配器如何管理空闲列表的顺序就成了一个问题。一种方法是使用基于地址的排序；通过保持列表按空闲空间的地址排序，凝聚变得更容易，碎片也会减少。\n\n\n# 3.4 循环首次适应算法\n\n循环首次适应算法并不总是在列表的开头开始首次适应搜索，而是保留一个额外的指针，指向列表中最后一次查找的位置。这个想法是在整个列表中更均匀地分布对可用空间的搜索，从而避免列表开头的分割。这种方法的性能与首次适应算法非常相似，因为再次避免了穷举搜索。\n\n\n# 3.5 四种算法实例对比\n\n以下是上述策略的一些示例。设想一个空闲列表，其中包含三个元素，大小分别为 10、30 和 20（这里我们将忽略headers和其他细节，而只关注策略的运作方式）：\n\n\n\n假设分配请求大小为 15。最佳适应算法会搜索整个列表并发现 20 是最适合的，因为它是可以容纳请求的最小可用空间。生成的空闲列表：\n\n\n\n正如本例中发生的情况，也是最佳适应方法经常发生的情况，现在剩下了一个小的空闲块。最差拟合方法与此类似，但它找到的是最大的块，在本例中为 30。结果列表如下：\n\n\n\n在本例中，首次适应算法与最差适应算法执行相同的操作，也是查找可以满足请求的第一个空闲块。区别在于搜索成本；最佳算法和最差算法都会浏览整个列表； 首次适应算法 仅检查空闲块，直到找到适合的块，从而降低搜索成本。\n\n\n# 4 其他方法\n\n\n# 4.1 隔离列表：slab分配器\n\n一种已经存在一段时间的有趣方法是使用隔离列表。基本思想很简单：如果特定应用程序发出一个（或几个）常见大小的请求，则保留一个单独的列表来管理该大小的对象；所有其他请求都转发到更通用的内存分配器。\n\n这种方法的好处是显而易见的。通过将一块内存专用于特定大小的请求，碎片就不再是一个问题。此外，当分配和释放请求的大小合适时，可以非常快速地处理它们，因为不需要复杂的列表搜索。\n\n但这种方法也会给系统带来新的复杂性。例如，与通用内存池相比，应该将多少内存专门用于服务给定大小的特殊请求的内存池？一个特殊的分配器，由超级工程师 jeff bonwick 设计的slab 分配器（设计用于 solaris 内核），以一种相当好的方式处理这个问题。\n\n具体来说，当内核启动时，它会为可能被频繁请求的内核对象（例如锁、文件系统 inode 等）分配一些对象缓存。因此，对象缓存都是给定大小的隔离空闲列表，并快速服务内存分配和空闲请求。当给定的缓存可用空间不足时，它会从更通用的内存分配器请求一些内存块（slab）（请求的总量是页面大小和相关对象的倍数）。相反，当给定slab内的对象的引用计数全部变为零时，通用分配器可以从专用分配器中回收它们，这通常在vm系统需要更多内存时执行。\n\n通过将列表上的空闲对象保持在预初始化状态，slab 分配器还超越了大多数隔离列表方法。 bonwick 表明数据结构的初始化和销毁代价高昂 ，通过将特定列表中的已释放对象保持在其初始化状态，slab 分配器因此避免了每个对象的频繁初始化和销毁周期，从而显着降低了开销。\n\n\n# 4.2 伙伴分配器\n\n由于合并对于分配器至关重要，因此设计了一些方法来简化合并。二进制伙伴分配器就是一个很好的例子。\n\n在这样的系统中，空闲内存首先在概念上被认为是大小为 2n2^n2n 的大空间。当发出内存请求时，对可用空间的搜索会递归地将可用空间一分为二，直到找到足够大以容纳请求的块（进一步分成两部分将导致空间太小）。此时，所请求的块就返回给用户了。以下是在搜索 7kb 块时划分 64kb 可用空间的示例：\n\n\n\n在示例中，最左边的 8kb 块被分配（如较深的蓝色阴影所示）并返回给用户；请注意，该方案可能会受到内部碎片的影响，因为您只能给出两倍大小的块。\n\n伙伴分配的美妙之处在于释放该块时发生的情况。当将8kb块返回到空闲列表时，分配器检查“伙伴”8kb是否空闲；如果是，它将把两个块合并成一个 16kb 的块。然后分配器检查 16kb 块的伙伴是否仍然空闲；如果是这样，它将合并这两个块。这种递归合并过程沿着树继续进行，要么恢复整个可用空间，要么在发现伙伴正在使用时停止。\n\n伙伴分配工作如此顺利的原因是确定特定块的伙伴很简单。想想上面空闲空间中块的地址。如果您仔细思考，您会发现每个好友对的地址仅相差一位；哪一位由好友树中的级别决定。这样您就对二进制好友分配方案的工作原理有了基本的了解。\n\n\n# 4.3 其他方法\n\n上述许多方法的一个主要问题是它们缺乏扩展性。具体来说，搜索列表可能会非常慢。因此，高级分配器使用更复杂的数据结构来解决这些成本，以简单性换取性能。例如平衡二叉树、展开树或部分排序树等。\n\n鉴于现代系统通常具有多个处理器并运行多线程工作负载，因此在基于多处理器的系统上花费大量精力使分配器正常工作也就不足为奇了。\n\nunderstanding glibc malloc",charsets:{cjk:!0},lastUpdated:"2024/05/11, 20:33:38",lastUpdatedTimestamp:1715430818e3},{title:"快表",frontmatter:{title:"快表",tags:["OS"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},date:"2024-04-25T22:39:21.000Z",permalink:"/pages/fe36b0/",categories:["开发","系统架构","操作系统","虚拟化"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/02.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/14.%E5%BF%AB%E8%A1%A8.html",relativePath:"01.开发/05.系统架构/02.操作系统/14.快表.md",key:"v-35052366",path:"/pages/fe36b0/",headers:[{level:2,title:"1 TLB基本算法",slug:"_1-tlb基本算法",normalizedTitle:"1 tlb基本算法",charIndex:521},{level:2,title:"2 示例：访问数组",slug:"_2-示例-访问数组",normalizedTitle:"2 示例：访问数组",charIndex:2141},{level:2,title:"3 谁处理TLB未命中？",slug:"_3-谁处理tlb未命中",normalizedTitle:"3 谁处理tlb未命中？",charIndex:3781},{level:2,title:"4 TLB 内容：里面有什么？",slug:"_4-tlb-内容-里面有什么",normalizedTitle:"4 tlb 内容：里面有什么？",charIndex:5321},{level:2,title:"5 TLB 问题：上下文切换",slug:"_5-tlb-问题-上下文切换",normalizedTitle:"5 tlb 问题：上下文切换",charIndex:5685},{level:2,title:"6 TLB 替换策略",slug:"_6-tlb-替换策略",normalizedTitle:"6 tlb 替换策略",charIndex:7145},{level:2,title:"7 实际系统里的TLB",slug:"_7-实际系统里的tlb",normalizedTitle:"7 实际系统里的tlb",charIndex:7600},{level:2,title:"8 总结",slug:"_8-总结",normalizedTitle:"8 总结",charIndex:8951}],headersStr:"1 TLB基本算法 2 示例：访问数组 3 谁处理TLB未命中？ 4 TLB 内容：里面有什么？ 5 TLB 问题：上下文切换 6 TLB 替换策略 7 实际系统里的TLB 8 总结",content:"使用分页作为支持虚拟内存的核心机制可能会导致较高的性能开销。通过将地址空间分割成小的、固定大小的单元（即页），分页需要大量的映射信息。由于映射信息通常存储在物理内存中，因此分页逻辑上需要对程序生成的每个虚拟地址进行额外的内存查找。在每次取指令或显式加载或存储之前访问内存以获取地址转换信息的速度非常慢。\n\n因此我们的问题关键是：我们如何才能加快地址转换，并从总体上避免分页似乎需要的额外内存引用？需要什么硬件支持？需要什么操作系统参与？\n\n当我们想让事情变得更快时，操作系统通常需要一些帮助。帮助通常来自操作系统的老朋友：硬件。为了加速地址转换，我们将添加一个叫做快表（translation-lookaside buffer, TLB）的硬件缓存。 TLB 是芯片内存管理单元 (MMU) 的一部分，只是常用的虚拟到物理地址转换的硬件缓存；因此，更好的名称是地址转换缓存（address-translation cache）。在每次虚拟内存引用时，硬件首先检查 TLB 以查看其中是否保存了所需的转换；如果是这样，则（快速）执行转换，而无需查阅页表（其中包含所有转换）。由于其巨大的性能影响，TLB 真正意义上使虚拟内存成为可能。\n\n\n# 1 TLB基本算法\n\n下段代码粗略显示了硬件如何处理虚拟地址转换，假定有一个简单的线性页表（即页表是一个数组）和一个硬件管理的 TLB（即硬件处理页表访问的大部分责任）。\n\n1:  VPN = (VirtualAddress & VPN_MASK) >> SHIFT\n2:  (Success, TlbEntry) = TLB_Lookup(VPN)\n3:  if (Success == True) // TLB Hit\n4:      if (CanAccess(TlbEntry.ProtectBits) == True)\n5:          Offset = VirtualAddress & OFFSET_MASK\n6:          PhysAddr = (TlbEntry.PFN << SHIFT) | Offset\n7:          Register = AccessMemory(PhysAddr)\n8:      else\n9:          RaiseException(PROTECTION_FAULT)\n10: else // TLB Miss\n11:     PTEAddr = PTBR + (VPN * sizeof(PTE))\n12:     PTE = AccessMemory(PTEAddr)\n13:     if (PTE.Valid == False)\n14:         RaiseException(SEGMENTATION_FAULT)\n15:     else if (CanAccess(PTE.ProtectBits) == False)\n16:         RaiseException(PROTECTION_FAULT)\n17:     else\n18:         TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits)\n19:         RetryInstruction()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n硬件遵循的算法是这样工作的：首先，从虚拟地址中提取虚拟页码（VPN）（第一行），然后检查 TLB 是否持有该 VPN 的转换（第 2 行）。如果是，我们就有一个 TLB 命中，这意味着 TLB 保留了转换。成功！现在我们可以从相关的 TLB 条目中提取物理页码 (PFN)，将其与原始虚拟地址的偏移量连接起来，形成所需的物理地址 (PA)，然后访问内存（第 5-7 行），前提是保护检查没有失败（第 4 行）。\n\n如果 CPU 在 TLB 中没有找到转换（TLB 未命中），我们还需要做一些工作。在此示例中，硬件会访问页表以查找转换（第 11-12 行），并假设进程生成的虚拟内存引用有效且可访问（第 13、15 行），然后用转换更新 TLB（第 18 行）。这一系列操作代价高昂，主要是因为访问页表需要额外的内存引用（第 12 行）。最后，一旦更新了 TLB，硬件就会重试指令；这一次，转换可以在 TLB 中找到，内存引用也会得到快速处理。\n\nTLB 和所有缓存一样，其建立的前提是在一般情况下，转换都能在缓存中找到（即命中）。在这种情况下，由于 TLB 位于处理核心附近，而且设计得相当快，因此几乎不会增加开销。当出现未命中时，就会产生高昂的分页成本；必须访问页表才能找到转换，这就会产生额外的内存引用（或更多，如果页表更复杂）。如果这种情况经常发生，程序的运行速度可能会明显变慢；相对于大多数 CPU 指令而言，内存访问的成本相当高，而 TLB 未命中会导致更多的内存访问。因此，我们希望尽可能避免 TLB 未命中。\n\n\n# 2 示例：访问数组\n\n为了弄清楚 TLB 的操作，让我们研究一个简单的虚拟地址跟踪，看看 TLB 如何提高其性能。在此示例中，假设内存中有一个由 10 个 4 字节整数组成的数组，从虚拟地址 100 开始。进一步假设我们有一个小的 8 位虚拟地址空间，具有 16 字节大小的页面；因此，虚拟地址分为 4 位 VPN（有 16 个虚拟页面）和 4 位偏移量（每个页面有 16 个字节）。\n\n下图显示了系统 16 个 16 字节页面上的布局。如图所示，数组的第一个条目（a[0]）开始于（VPN=06，偏移量=04）；在这一页上只能容纳三个 4 字节的整数。数组继续进入下一页（VPN=07），在这一页上找到接下来四个条目（a[3] ... a[6]）。最后，10 个条目数组的最后三个条目（a[7] ... a[9]）位于地址空间的下一页（VPN=08）。\n\n现在让我们考虑一个访问每个数组元素的简单循环，在 C 中看起来像这样：\n\nint sum = 0;\nfor (i = 0; i < 10; i++) {\n\tsum += a[i];\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n为了简单起见，我们假设循环生成的唯一内存访问是数组（忽略变量 i 和 sum，以及指令本身）。当访问第一个数组元素 (a[0]) 时，CPU 将看到对虚拟地址 100 的加载。硬件从中提取 VPN (VPN=06)，并使用它来检查 TLB 的有效转换。假设这是程序第一次访问数组，结果将是 TLB 未命中。\n\n下一次访问是 a[1]，这里有一个好消息：TLB 命中！因为数组的第二个元素紧挨着第一个元素，所以它位于同一个页面上；因为我们在访问数组的第一个元素时已经访问了这个页面，所以转换已经加载到TLB中。这就是我们成功的原因。访问 a[2] 会遇到类似的成功（另一个命中），因为它也与 a[0] 和 a[1] 位于同一页面上。\n\n不幸的是，当程序访问a[3]时，我们遇到了另一个TLB未命中。然而，下一个条目 (a[4] ... a[6]) 将再次命中 TLB，因为它们都驻留在内存中的同一页上。\n\n最后，访问 a[7] 会导致最后一次 TLB 未命中。硬件再次查询页表以找出该虚拟页在物理内存中的位置，并相应地更新TLB。最后两次访问（a[8] 和 a[9]）受益于该 TLB 更新；当硬件在 TLB 中查找转换时，会产生另外两次命中。\n\n让我们总结一下在对数组进行十次访问期间 TLB 的活动：miss、hit、hit、miss、hit、hit、hit、miss、hit、hit。因此，我们的 TLB 命中率（即命中次数除以总访问次数）为 70%。虽然这不是太高（事实上，我们希望命中率接近 100%），但它是非零的，这可能会令人惊讶。尽管这是程序第一次访问数组，但 TLB 由于空间局部性而提高了性能。数组的元素被紧密地打包到页面中（即，它们在空间上彼此靠近），因此只有第一次访问页面上的元素才会产生 TLB 未命中。\n\n\n\n还要注意页面大小在本例中的作用。如果页面大小是原来的两倍（32 字节，而不是 16 字节），那么阵列访问的未命中次数就会更少。由于典型的页面大小更接近 4KB，这些类型的密集、基于数组的访问实现了出色的 TLB 性能，每页访问只出现一次未命中。\n\n关于 TLB 性能的最后一点：如果程序在循环结束后不久再次访问数组，我们很可能会看到更好的结果，前提是我们有足够大的 TLB 来缓存所需的转换：hit、hit、hit、hit、hit、hit、hit、hit、hit、hit。在这种情况下，TLB 命中率会很高，这是因为时间局部性，即在时间上快速重新引用内存项。与其他高速缓存一样，TLB 的成功依赖于空间和时间的局部性，而空间和时间的局部性是程序的属性。如果相关程序具有这种局部性（许多程序都具有这种局部性），那么 TLB 的命中率很可能会很高。\n\n\n\n\n# 3 谁处理TLB未命中？\n\n我们必须回答一个问题：谁来处理 TLB 未命中？有两个可能的答案：硬件或软件（操作系统）。在过去，硬件具有复杂的指令集（有时称为CISC，用于复杂指令集计算机），而构建硬件的人不太信任那些鬼鬼祟祟的操作系统人员。因此，硬件将完全处理 TLB 未命中。为此，硬件必须确切地知道页表在内存中的位置（通过页表基址寄存器），以及它们的确切格式；如果未命中，硬件将“遍历”页表，找到正确的页表条目并提取所需的转换，用转换更新 TLB，然后重试指令。具有硬件管理 TLB 的“旧”架构的一个示例是 Intel x86 架构，它使用固定的多级页表；当前页表由CR3寄存器指向。\n\n更现代的架构（例如，MIPS R10k 或 Sun 的 SPARC v9，RISC 或精简指令集计算机）具有所谓的软件管理 TLB。当 TLB 未命中时，硬件只会引发异常，该异常会暂停当前指令流，将特权级别提升到内核模式，并跳转到中断处理程序。您可能会猜到，此中断处理程序是操作系统中的代码，其编写的明确目的是处理 TLB 未命中。运行时，代码将在页表中查找转换，使用特殊的“特权”指令来更新TLB，然后从中断返回；此时，硬件会重试该指令（导致 TLB 命中）。\n\n让我们讨论几个重要的细节。首先，从中断返回指令需要与我们之前在服务系统调用时看到的从中断返回指令略有不同。在后一种情况下，从中断返回应该在中断进入操作系统后的指令处恢复执行，就像从过程调用返回到紧随过程调用之后的指令一样。在前一种情况下，当从 TLB 未命中处理中断返回时，硬件必须在导致中断的指令处恢复执行；因此，此重试让指令再次运行，这一次导致 TLB 命中。因此，根据中断或异常的引发方式，硬件在中断进入操作系统时必须保存不同的 PC，以便在时间到来时正确恢复。\n\n其次，当运行 TLB 未命中处理代码时，操作系统需要格外小心，不要导致发生无限的 TLB 未命中链。存在许多解决方案；例如，您可以将 TLB 未命中处理程序保留在物理内存中（它们未映射且不受地址转换影响），或者在 TLB 中保留一些条目以进行永久有效的转换，并将其中一些永久转换槽用于处理程序代码本身;这些有线转换总是命中 TLB。\n\n软件管理方法的主要优点是灵活性：操作系统可以使用它想要实现页表的任何数据结构，而无需更改硬件。另一个优点是简单。如下面这段代码所示，硬件在未命中时不会做太多事情：只是引发异常，然后让操作系统 TLB 未命中处理程序完成其余的工作。\n\n1: VPN = (VirtualAddress & VPN_MASK) >> SHIFT\n2: (Success, TlbEntry) = TLB_Lookup(VPN)\n3: if (Success == True) // TLB Hit\n4:     if (CanAccess(TlbEntry.ProtectBits) == True)\n5:         Offset = VirtualAddress & OFFSET_MASK\n6:         PhysAddr = (TlbEntry.PFN << SHIFT) | Offset\n7:         Register = AccessMemory(PhysAddr)\n8:     else\n9:         RaiseException(PROTECTION_FAULT)\n10: else // TLB Miss\n11:     RaiseException(TLB_MISS)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 4 TLB 内容：里面有什么？\n\n让我们详细了解一下硬件 TLB 的内容。典型的 TLB 可能有 32、64 或 128 个条目，并且被称为全关联。基本上，这意味着任何给定的转换都可以在 TLB 的任何位置，硬件将并行搜索整个 TLB 以找到所需的转换。一个 TLB 条目可能是这样的：\n\n\n\n请注意，VPN 和 PFN 都存在于每个条目中，因为转换可能最终位于这些位置中的任何一个（在硬件术语中，TLB 称为全关联缓存）。硬件并行搜索条目以查看是否存在匹配。\n\n更有趣的是“其他位”。例如，TLB通常有一个有效位，它表示该条目是否具有有效的转换。同样常见的是保护位，它决定如何访问页面（如在页表中）。例如，代码页可能被标记为读取和执行，而堆页可能被标记为读取和写入。还可能有一些其他字段，包括地址空间标识符、脏位等。\n\n\n# 5 TLB 问题：上下文切换\n\n对于 TLB，在进程（以及地址空间）之间切换时会出现一些新问题。具体来说，TLB 包含仅对当前运行的进程有效的虚拟到物理的转换；这些转换对于其他进程没有意义。因此，当从一个进程切换到另一个进程时，硬件或操作系统（或两者）必须小心，以确保即将运行的进程不会意外使用某些先前运行的进程的转换。\n\n为了更好地理解这种情况，让我们看一个例子。当一个进程 (P1) 运行时，它假设 TLB 可能正在缓存对其有效的转换，即来自 P1 的页表的转换。对于此示例，假设 P1 的第 10 个虚拟页映射到物理页 100。\n\n在此示例中，假设存在另一个进程 (P2)，并且操作系统很快可能决定执行上下文切换并运行它。这里假设 P2 的第 10 个虚拟页映射到物理页 170。如果两个进程的条目都在 TLB 中，则 TLB 的内容将为：\n\n\n\n在上面的 TLB 中，我们显然遇到了一个问题：VPN 10 转换为 PFN 100 (P1) 或 PFN 170 (P2)，但硬件无法区分哪个条目适用于哪个进程。因此，为了让TLB能够正确、高效地支持跨多进程的虚拟化，我们还需要做更多的工作。因此，关键在于：当在进程之间进行上下文切换时，最后一个进程的 TLB 中的转换对于即将运行的进程没有意义。为了解决这个问题，硬件或操作系统应该做什么？\n\n对于这个问题有多种可能的解决方案。一种方法是简单地在上下文切换时刷新 TLB，从而在运行下一个进程之前清空它。在基于软件的系统上，这可以通过显式（且特权）的硬件指令来完成；使用硬件管理的 TLB，当页表基址寄存器更改时可以执行刷新（请注意，操作系统无论如何都必须在上下文切换时更改 PTBR）。无论哪种情况，刷新操作都只是将所有有效位设置为 0，本质上是清除 TLB 的内容。\n\n通过在每次上下文切换时刷新 TLB，我们现在有了一个可行的解决方案，因为进程永远不会意外地遇到 TLB 中的错误转换。然而，这是有代价的：每次进程运行时，它在接触其数据和代码页时都必须导致 TLB 未命中。如果操作系统频繁地在进程之间切换，这个成本可能会很高。\n\n为了减少这种开销，一些系统添加了硬件支持以实现跨上下文切换的 TLB 共享。特别地，一些硬件系统在TLB中提供地址空间标识符(ASID)字段。您可以将 ASID 视为进程标识符 (PID)，但通常它的位数较少（例如，ASID 为 8 位，而 PID 为 32 位）。\n\n如果我们采用上面的示例 TLB 并添加 ASID，很明显进程可以轻松共享 TLB：仅需要 ASID 字段来区分其他相同的转换。以下是添加了 ASID 字段的 TLB 的描述：\n\n因此，利用地址空间标识符，TLB 可以同时保存来自不同进程的转换，而不会产生任何混淆。当然，硬件还需要知道当前正在运行哪个进程才能执行转换，因此操作系统必须在上下文切换时将某些特权寄存器设置为当前进程的 ASID。\n\n您可能还想到了另一种情况，其中 TLB 的两个条目非常相似。在此示例中，两个不同进程的两个条目具有指向同一物理页面的两个不同 VPN：例如，当两个进程共享一个页面（例如代码页）时，可能会出现这种情况。\n\n在上面的示例中，进程 1 与进程 2 共享物理页 101； P1 将此页映射到其地址空间的第 10 页，而 P2 将此页映射到其地址空间的第 50 页。共享代码页（在二进制文件或共享库中）很有用，因为它减少了使用的物理页数量，从而减少了内存开销。\n\n\n# 6 TLB 替换策略\n\n与任何缓存一样，对于 TLB 来说也是如此，我们必须考虑的另一个问题是缓存替换。具体来说，当我们在 TLB 中安装新条目时，我们必须替换旧条目，因此问题的关键是：要替换哪一个？如何设计 TLB 替换策略？ 当我们添加新的 TLB 条目时，应该替换哪个 TLB 条目？当然，目标是最大限度地减少未命中率（或提高命中率），从而提高性能。\n\n当我们解决将页面交换到磁盘的问题时，我们将详细研究这些策略；这里我们只重点介绍一些典型的政策。\n\n * 一种常见的方法是逐出最近最少使用的条目或 LRU 条目。 LRU 尝试利用内存引用流中的局部性，假设最近未使用的条目可能是驱逐的良好候选者。\n * 另一种典型的方法是使用随机策略，随机驱逐 TLB 映射。这种策略非常有用，因为它简单并且能够避免极端情况行为；例如，当程序在 TLB 大小为 n 的 n + 1 个页面上循环时，诸如 LRU 之类的“合理”策略就会表现得非常不合理；在这种情况下，LRU 会错过每次访问，而随机则做得更好。\n\n\n# 7 实际系统里的TLB\n\n最后，让我们简单看一下真正的TLB。此示例来自 MIPS R4000 ，这是一个使用软件管理的 TLB 的现代系统；如下图所示，可以看到稍微简化的 MIPS TLB 条目。\n\nMIPS R4000 支持具有 4KB 页的 32 位地址空间。因此，我们期望在我们的经典虚拟地址中有 20 位 VPN 和 12 位偏移量。然而，正如您在 TLB 中看到的，VPN 只有 19 位；事实证明，用户地址仅来自一半的地址空间（其余部分为内核保留），因此只需要 19 位的 VPN。 VPN 最多可转换为 24 位物理页号 (PFN)，因此可以支持具有高达 64GB（物理）主内存（224 个 4KB 页）的系统。\n\nMIPS TLB 中还有一些其他有趣的位。我们看到一个全局位（G），它用于在进程之间全局共享的页面。因此，如果设置了全局位，则 ASID 将被忽略。我们还看到 8 位 ASID，操作系统可以使用它来区分地址空间（如上所述）。最后，我们看到 3 个 Coherence (C) 位，它们决定硬件如何缓存页面；当页面被写入时标记的脏位；一个有效位，告诉硬件条目中是否存在有效的转换。还有一个页面掩码字段（未显示），支持多种页面大小；稍后我们会看到为什么更大的页面可能有用。最后，还有部分未使用。\n\nFLAG               CONTENT\n19-bit VPN         剩余部分保留给内核。\n24-bit PFN         系统支持最多64GB的主存储（224×4KB pages2^{24}\\times 4\\text{KB\n                   pages}224×4KB pages页面）。\nGlobal bit(G)      用于在进程间共享的页面（忽略ASID）。\nASID               操作系统用于区分地址空间的标识。\nCoherence bit(C)   确定页面如何被硬件缓存\nDirty bit(D)       标记页面是否已被写入\nValid bit(V)       告诉硬件条目中是否存在有效的转换\n\nMIPS TLB 通常有 32 或 64 个这样的条目，其中大部分由用户进程在运行时使用。然而，有一些是为操作系统保留的。操作系统可以设置一个有线寄存器来告诉硬件TLB要为操作系统保留多少个插槽；操作系统将这些保留的映射用于它想要在关键时刻访问的代码和数据，此时 TLB 未命中会出现问题（例如，在 TLB 未命中处理程序中）。\n\n由于 MIPS TLB 是由软件管理的，因此需要有更新 TLB 的指令。 MIPS 提供了四种这样的指令：\n\n * TLBP：它探测 TLB 以查看其中是否存在特定的转换；\n * TLBR：将 TLB 条目的内容读入寄存器；\n * TLBWI：替换特定的 TLB 条目；\n * TLBWR：它替换随机 TLB 条目。操作系统使用这些指令来管理 TLB 的内容。\n\n当然，至关重要的是这些指令具有特权；想象一下，如果用户进程可以修改 TLB 的内容，它会做什么（提示：几乎任何事情，包括接管机器、运行自己的恶意“操作系统”，甚至让 Sun 消失）。\n\n\n# 8 总结\n\n我们已经看到硬件如何帮助我们更快地进行地址转换。通过提供小型专用片上 TLB 作为地址转换缓存，大多数内存引用有望在无需访问主内存中的页表的情况下得到处理。因此，在常见情况下，程序的性能几乎就像内存根本没有被虚拟化一样，这对于操作系统来说是一项出色的成就，并且对于现代系统中分页的使用当然至关重要。\n\n然而，TLB 并没有让每个现有的程序都变得美好。特别是，如果程序在短时间内访问的页数超过了TLB所能容纳的页数，则程序将产生大量的TLB未命中，从而运行速度会变得相当慢。我们将这种现象称为超出 TLB 覆盖范围，对于某些程序来说这可能是一个很大的问题。一个解决方案是支持更大的页面大小；通过将关键数据结构映射到程序地址空间中由较大页面映射的区域，可以增加 TLB 的有效覆盖范围。对大页面的支持通常由诸如数据库管理系统（DBMS）之类的程序利用，这些程序具有某些既大又随机访问的数据结构。\n\n另一个值得一提的 TLB 问题是：TLB 访问很容易成为 CPU 管道中的瓶颈，特别是对于所谓的物理索引缓存。对于这样的缓存，必须在访问缓存之前进行地址转换，这会大大减慢速度。由于这个潜在的问题，人们研究了各种巧妙的方法来使用虚拟地址访问缓存，从而避免缓存命中时昂贵的转换步骤。这种虚拟索引缓存解决了一些性能问题，但也给硬件设计带来了新问题。\n\n * 巨型页面（2MB 页面）\n\n * 千兆页面（1GB 页面）\n\n * 最先进的 TLB（AMD Zen4）",normalizedContent:"使用分页作为支持虚拟内存的核心机制可能会导致较高的性能开销。通过将地址空间分割成小的、固定大小的单元（即页），分页需要大量的映射信息。由于映射信息通常存储在物理内存中，因此分页逻辑上需要对程序生成的每个虚拟地址进行额外的内存查找。在每次取指令或显式加载或存储之前访问内存以获取地址转换信息的速度非常慢。\n\n因此我们的问题关键是：我们如何才能加快地址转换，并从总体上避免分页似乎需要的额外内存引用？需要什么硬件支持？需要什么操作系统参与？\n\n当我们想让事情变得更快时，操作系统通常需要一些帮助。帮助通常来自操作系统的老朋友：硬件。为了加速地址转换，我们将添加一个叫做快表（translation-lookaside buffer, tlb）的硬件缓存。 tlb 是芯片内存管理单元 (mmu) 的一部分，只是常用的虚拟到物理地址转换的硬件缓存；因此，更好的名称是地址转换缓存（address-translation cache）。在每次虚拟内存引用时，硬件首先检查 tlb 以查看其中是否保存了所需的转换；如果是这样，则（快速）执行转换，而无需查阅页表（其中包含所有转换）。由于其巨大的性能影响，tlb 真正意义上使虚拟内存成为可能。\n\n\n# 1 tlb基本算法\n\n下段代码粗略显示了硬件如何处理虚拟地址转换，假定有一个简单的线性页表（即页表是一个数组）和一个硬件管理的 tlb（即硬件处理页表访问的大部分责任）。\n\n1:  vpn = (virtualaddress & vpn_mask) >> shift\n2:  (success, tlbentry) = tlb_lookup(vpn)\n3:  if (success == true) // tlb hit\n4:      if (canaccess(tlbentry.protectbits) == true)\n5:          offset = virtualaddress & offset_mask\n6:          physaddr = (tlbentry.pfn << shift) | offset\n7:          register = accessmemory(physaddr)\n8:      else\n9:          raiseexception(protection_fault)\n10: else // tlb miss\n11:     pteaddr = ptbr + (vpn * sizeof(pte))\n12:     pte = accessmemory(pteaddr)\n13:     if (pte.valid == false)\n14:         raiseexception(segmentation_fault)\n15:     else if (canaccess(pte.protectbits) == false)\n16:         raiseexception(protection_fault)\n17:     else\n18:         tlb_insert(vpn, pte.pfn, pte.protectbits)\n19:         retryinstruction()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n硬件遵循的算法是这样工作的：首先，从虚拟地址中提取虚拟页码（vpn）（第一行），然后检查 tlb 是否持有该 vpn 的转换（第 2 行）。如果是，我们就有一个 tlb 命中，这意味着 tlb 保留了转换。成功！现在我们可以从相关的 tlb 条目中提取物理页码 (pfn)，将其与原始虚拟地址的偏移量连接起来，形成所需的物理地址 (pa)，然后访问内存（第 5-7 行），前提是保护检查没有失败（第 4 行）。\n\n如果 cpu 在 tlb 中没有找到转换（tlb 未命中），我们还需要做一些工作。在此示例中，硬件会访问页表以查找转换（第 11-12 行），并假设进程生成的虚拟内存引用有效且可访问（第 13、15 行），然后用转换更新 tlb（第 18 行）。这一系列操作代价高昂，主要是因为访问页表需要额外的内存引用（第 12 行）。最后，一旦更新了 tlb，硬件就会重试指令；这一次，转换可以在 tlb 中找到，内存引用也会得到快速处理。\n\ntlb 和所有缓存一样，其建立的前提是在一般情况下，转换都能在缓存中找到（即命中）。在这种情况下，由于 tlb 位于处理核心附近，而且设计得相当快，因此几乎不会增加开销。当出现未命中时，就会产生高昂的分页成本；必须访问页表才能找到转换，这就会产生额外的内存引用（或更多，如果页表更复杂）。如果这种情况经常发生，程序的运行速度可能会明显变慢；相对于大多数 cpu 指令而言，内存访问的成本相当高，而 tlb 未命中会导致更多的内存访问。因此，我们希望尽可能避免 tlb 未命中。\n\n\n# 2 示例：访问数组\n\n为了弄清楚 tlb 的操作，让我们研究一个简单的虚拟地址跟踪，看看 tlb 如何提高其性能。在此示例中，假设内存中有一个由 10 个 4 字节整数组成的数组，从虚拟地址 100 开始。进一步假设我们有一个小的 8 位虚拟地址空间，具有 16 字节大小的页面；因此，虚拟地址分为 4 位 vpn（有 16 个虚拟页面）和 4 位偏移量（每个页面有 16 个字节）。\n\n下图显示了系统 16 个 16 字节页面上的布局。如图所示，数组的第一个条目（a[0]）开始于（vpn=06，偏移量=04）；在这一页上只能容纳三个 4 字节的整数。数组继续进入下一页（vpn=07），在这一页上找到接下来四个条目（a[3] ... a[6]）。最后，10 个条目数组的最后三个条目（a[7] ... a[9]）位于地址空间的下一页（vpn=08）。\n\n现在让我们考虑一个访问每个数组元素的简单循环，在 c 中看起来像这样：\n\nint sum = 0;\nfor (i = 0; i < 10; i++) {\n\tsum += a[i];\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n为了简单起见，我们假设循环生成的唯一内存访问是数组（忽略变量 i 和 sum，以及指令本身）。当访问第一个数组元素 (a[0]) 时，cpu 将看到对虚拟地址 100 的加载。硬件从中提取 vpn (vpn=06)，并使用它来检查 tlb 的有效转换。假设这是程序第一次访问数组，结果将是 tlb 未命中。\n\n下一次访问是 a[1]，这里有一个好消息：tlb 命中！因为数组的第二个元素紧挨着第一个元素，所以它位于同一个页面上；因为我们在访问数组的第一个元素时已经访问了这个页面，所以转换已经加载到tlb中。这就是我们成功的原因。访问 a[2] 会遇到类似的成功（另一个命中），因为它也与 a[0] 和 a[1] 位于同一页面上。\n\n不幸的是，当程序访问a[3]时，我们遇到了另一个tlb未命中。然而，下一个条目 (a[4] ... a[6]) 将再次命中 tlb，因为它们都驻留在内存中的同一页上。\n\n最后，访问 a[7] 会导致最后一次 tlb 未命中。硬件再次查询页表以找出该虚拟页在物理内存中的位置，并相应地更新tlb。最后两次访问（a[8] 和 a[9]）受益于该 tlb 更新；当硬件在 tlb 中查找转换时，会产生另外两次命中。\n\n让我们总结一下在对数组进行十次访问期间 tlb 的活动：miss、hit、hit、miss、hit、hit、hit、miss、hit、hit。因此，我们的 tlb 命中率（即命中次数除以总访问次数）为 70%。虽然这不是太高（事实上，我们希望命中率接近 100%），但它是非零的，这可能会令人惊讶。尽管这是程序第一次访问数组，但 tlb 由于空间局部性而提高了性能。数组的元素被紧密地打包到页面中（即，它们在空间上彼此靠近），因此只有第一次访问页面上的元素才会产生 tlb 未命中。\n\n\n\n还要注意页面大小在本例中的作用。如果页面大小是原来的两倍（32 字节，而不是 16 字节），那么阵列访问的未命中次数就会更少。由于典型的页面大小更接近 4kb，这些类型的密集、基于数组的访问实现了出色的 tlb 性能，每页访问只出现一次未命中。\n\n关于 tlb 性能的最后一点：如果程序在循环结束后不久再次访问数组，我们很可能会看到更好的结果，前提是我们有足够大的 tlb 来缓存所需的转换：hit、hit、hit、hit、hit、hit、hit、hit、hit、hit。在这种情况下，tlb 命中率会很高，这是因为时间局部性，即在时间上快速重新引用内存项。与其他高速缓存一样，tlb 的成功依赖于空间和时间的局部性，而空间和时间的局部性是程序的属性。如果相关程序具有这种局部性（许多程序都具有这种局部性），那么 tlb 的命中率很可能会很高。\n\n\n\n\n# 3 谁处理tlb未命中？\n\n我们必须回答一个问题：谁来处理 tlb 未命中？有两个可能的答案：硬件或软件（操作系统）。在过去，硬件具有复杂的指令集（有时称为cisc，用于复杂指令集计算机），而构建硬件的人不太信任那些鬼鬼祟祟的操作系统人员。因此，硬件将完全处理 tlb 未命中。为此，硬件必须确切地知道页表在内存中的位置（通过页表基址寄存器），以及它们的确切格式；如果未命中，硬件将“遍历”页表，找到正确的页表条目并提取所需的转换，用转换更新 tlb，然后重试指令。具有硬件管理 tlb 的“旧”架构的一个示例是 intel x86 架构，它使用固定的多级页表；当前页表由cr3寄存器指向。\n\n更现代的架构（例如，mips r10k 或 sun 的 sparc v9，risc 或精简指令集计算机）具有所谓的软件管理 tlb。当 tlb 未命中时，硬件只会引发异常，该异常会暂停当前指令流，将特权级别提升到内核模式，并跳转到中断处理程序。您可能会猜到，此中断处理程序是操作系统中的代码，其编写的明确目的是处理 tlb 未命中。运行时，代码将在页表中查找转换，使用特殊的“特权”指令来更新tlb，然后从中断返回；此时，硬件会重试该指令（导致 tlb 命中）。\n\n让我们讨论几个重要的细节。首先，从中断返回指令需要与我们之前在服务系统调用时看到的从中断返回指令略有不同。在后一种情况下，从中断返回应该在中断进入操作系统后的指令处恢复执行，就像从过程调用返回到紧随过程调用之后的指令一样。在前一种情况下，当从 tlb 未命中处理中断返回时，硬件必须在导致中断的指令处恢复执行；因此，此重试让指令再次运行，这一次导致 tlb 命中。因此，根据中断或异常的引发方式，硬件在中断进入操作系统时必须保存不同的 pc，以便在时间到来时正确恢复。\n\n其次，当运行 tlb 未命中处理代码时，操作系统需要格外小心，不要导致发生无限的 tlb 未命中链。存在许多解决方案；例如，您可以将 tlb 未命中处理程序保留在物理内存中（它们未映射且不受地址转换影响），或者在 tlb 中保留一些条目以进行永久有效的转换，并将其中一些永久转换槽用于处理程序代码本身;这些有线转换总是命中 tlb。\n\n软件管理方法的主要优点是灵活性：操作系统可以使用它想要实现页表的任何数据结构，而无需更改硬件。另一个优点是简单。如下面这段代码所示，硬件在未命中时不会做太多事情：只是引发异常，然后让操作系统 tlb 未命中处理程序完成其余的工作。\n\n1: vpn = (virtualaddress & vpn_mask) >> shift\n2: (success, tlbentry) = tlb_lookup(vpn)\n3: if (success == true) // tlb hit\n4:     if (canaccess(tlbentry.protectbits) == true)\n5:         offset = virtualaddress & offset_mask\n6:         physaddr = (tlbentry.pfn << shift) | offset\n7:         register = accessmemory(physaddr)\n8:     else\n9:         raiseexception(protection_fault)\n10: else // tlb miss\n11:     raiseexception(tlb_miss)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 4 tlb 内容：里面有什么？\n\n让我们详细了解一下硬件 tlb 的内容。典型的 tlb 可能有 32、64 或 128 个条目，并且被称为全关联。基本上，这意味着任何给定的转换都可以在 tlb 的任何位置，硬件将并行搜索整个 tlb 以找到所需的转换。一个 tlb 条目可能是这样的：\n\n\n\n请注意，vpn 和 pfn 都存在于每个条目中，因为转换可能最终位于这些位置中的任何一个（在硬件术语中，tlb 称为全关联缓存）。硬件并行搜索条目以查看是否存在匹配。\n\n更有趣的是“其他位”。例如，tlb通常有一个有效位，它表示该条目是否具有有效的转换。同样常见的是保护位，它决定如何访问页面（如在页表中）。例如，代码页可能被标记为读取和执行，而堆页可能被标记为读取和写入。还可能有一些其他字段，包括地址空间标识符、脏位等。\n\n\n# 5 tlb 问题：上下文切换\n\n对于 tlb，在进程（以及地址空间）之间切换时会出现一些新问题。具体来说，tlb 包含仅对当前运行的进程有效的虚拟到物理的转换；这些转换对于其他进程没有意义。因此，当从一个进程切换到另一个进程时，硬件或操作系统（或两者）必须小心，以确保即将运行的进程不会意外使用某些先前运行的进程的转换。\n\n为了更好地理解这种情况，让我们看一个例子。当一个进程 (p1) 运行时，它假设 tlb 可能正在缓存对其有效的转换，即来自 p1 的页表的转换。对于此示例，假设 p1 的第 10 个虚拟页映射到物理页 100。\n\n在此示例中，假设存在另一个进程 (p2)，并且操作系统很快可能决定执行上下文切换并运行它。这里假设 p2 的第 10 个虚拟页映射到物理页 170。如果两个进程的条目都在 tlb 中，则 tlb 的内容将为：\n\n\n\n在上面的 tlb 中，我们显然遇到了一个问题：vpn 10 转换为 pfn 100 (p1) 或 pfn 170 (p2)，但硬件无法区分哪个条目适用于哪个进程。因此，为了让tlb能够正确、高效地支持跨多进程的虚拟化，我们还需要做更多的工作。因此，关键在于：当在进程之间进行上下文切换时，最后一个进程的 tlb 中的转换对于即将运行的进程没有意义。为了解决这个问题，硬件或操作系统应该做什么？\n\n对于这个问题有多种可能的解决方案。一种方法是简单地在上下文切换时刷新 tlb，从而在运行下一个进程之前清空它。在基于软件的系统上，这可以通过显式（且特权）的硬件指令来完成；使用硬件管理的 tlb，当页表基址寄存器更改时可以执行刷新（请注意，操作系统无论如何都必须在上下文切换时更改 ptbr）。无论哪种情况，刷新操作都只是将所有有效位设置为 0，本质上是清除 tlb 的内容。\n\n通过在每次上下文切换时刷新 tlb，我们现在有了一个可行的解决方案，因为进程永远不会意外地遇到 tlb 中的错误转换。然而，这是有代价的：每次进程运行时，它在接触其数据和代码页时都必须导致 tlb 未命中。如果操作系统频繁地在进程之间切换，这个成本可能会很高。\n\n为了减少这种开销，一些系统添加了硬件支持以实现跨上下文切换的 tlb 共享。特别地，一些硬件系统在tlb中提供地址空间标识符(asid)字段。您可以将 asid 视为进程标识符 (pid)，但通常它的位数较少（例如，asid 为 8 位，而 pid 为 32 位）。\n\n如果我们采用上面的示例 tlb 并添加 asid，很明显进程可以轻松共享 tlb：仅需要 asid 字段来区分其他相同的转换。以下是添加了 asid 字段的 tlb 的描述：\n\n因此，利用地址空间标识符，tlb 可以同时保存来自不同进程的转换，而不会产生任何混淆。当然，硬件还需要知道当前正在运行哪个进程才能执行转换，因此操作系统必须在上下文切换时将某些特权寄存器设置为当前进程的 asid。\n\n您可能还想到了另一种情况，其中 tlb 的两个条目非常相似。在此示例中，两个不同进程的两个条目具有指向同一物理页面的两个不同 vpn：例如，当两个进程共享一个页面（例如代码页）时，可能会出现这种情况。\n\n在上面的示例中，进程 1 与进程 2 共享物理页 101； p1 将此页映射到其地址空间的第 10 页，而 p2 将此页映射到其地址空间的第 50 页。共享代码页（在二进制文件或共享库中）很有用，因为它减少了使用的物理页数量，从而减少了内存开销。\n\n\n# 6 tlb 替换策略\n\n与任何缓存一样，对于 tlb 来说也是如此，我们必须考虑的另一个问题是缓存替换。具体来说，当我们在 tlb 中安装新条目时，我们必须替换旧条目，因此问题的关键是：要替换哪一个？如何设计 tlb 替换策略？ 当我们添加新的 tlb 条目时，应该替换哪个 tlb 条目？当然，目标是最大限度地减少未命中率（或提高命中率），从而提高性能。\n\n当我们解决将页面交换到磁盘的问题时，我们将详细研究这些策略；这里我们只重点介绍一些典型的政策。\n\n * 一种常见的方法是逐出最近最少使用的条目或 lru 条目。 lru 尝试利用内存引用流中的局部性，假设最近未使用的条目可能是驱逐的良好候选者。\n * 另一种典型的方法是使用随机策略，随机驱逐 tlb 映射。这种策略非常有用，因为它简单并且能够避免极端情况行为；例如，当程序在 tlb 大小为 n 的 n + 1 个页面上循环时，诸如 lru 之类的“合理”策略就会表现得非常不合理；在这种情况下，lru 会错过每次访问，而随机则做得更好。\n\n\n# 7 实际系统里的tlb\n\n最后，让我们简单看一下真正的tlb。此示例来自 mips r4000 ，这是一个使用软件管理的 tlb 的现代系统；如下图所示，可以看到稍微简化的 mips tlb 条目。\n\nmips r4000 支持具有 4kb 页的 32 位地址空间。因此，我们期望在我们的经典虚拟地址中有 20 位 vpn 和 12 位偏移量。然而，正如您在 tlb 中看到的，vpn 只有 19 位；事实证明，用户地址仅来自一半的地址空间（其余部分为内核保留），因此只需要 19 位的 vpn。 vpn 最多可转换为 24 位物理页号 (pfn)，因此可以支持具有高达 64gb（物理）主内存（224 个 4kb 页）的系统。\n\nmips tlb 中还有一些其他有趣的位。我们看到一个全局位（g），它用于在进程之间全局共享的页面。因此，如果设置了全局位，则 asid 将被忽略。我们还看到 8 位 asid，操作系统可以使用它来区分地址空间（如上所述）。最后，我们看到 3 个 coherence (c) 位，它们决定硬件如何缓存页面；当页面被写入时标记的脏位；一个有效位，告诉硬件条目中是否存在有效的转换。还有一个页面掩码字段（未显示），支持多种页面大小；稍后我们会看到为什么更大的页面可能有用。最后，还有部分未使用。\n\nflag               content\n19-bit vpn         剩余部分保留给内核。\n24-bit pfn         系统支持最多64gb的主存储（224×4kb pages2^{24}\\times 4\\text{kb\n                   pages}224×4kb pages页面）。\nglobal bit(g)      用于在进程间共享的页面（忽略asid）。\nasid               操作系统用于区分地址空间的标识。\ncoherence bit(c)   确定页面如何被硬件缓存\ndirty bit(d)       标记页面是否已被写入\nvalid bit(v)       告诉硬件条目中是否存在有效的转换\n\nmips tlb 通常有 32 或 64 个这样的条目，其中大部分由用户进程在运行时使用。然而，有一些是为操作系统保留的。操作系统可以设置一个有线寄存器来告诉硬件tlb要为操作系统保留多少个插槽；操作系统将这些保留的映射用于它想要在关键时刻访问的代码和数据，此时 tlb 未命中会出现问题（例如，在 tlb 未命中处理程序中）。\n\n由于 mips tlb 是由软件管理的，因此需要有更新 tlb 的指令。 mips 提供了四种这样的指令：\n\n * tlbp：它探测 tlb 以查看其中是否存在特定的转换；\n * tlbr：将 tlb 条目的内容读入寄存器；\n * tlbwi：替换特定的 tlb 条目；\n * tlbwr：它替换随机 tlb 条目。操作系统使用这些指令来管理 tlb 的内容。\n\n当然，至关重要的是这些指令具有特权；想象一下，如果用户进程可以修改 tlb 的内容，它会做什么（提示：几乎任何事情，包括接管机器、运行自己的恶意“操作系统”，甚至让 sun 消失）。\n\n\n# 8 总结\n\n我们已经看到硬件如何帮助我们更快地进行地址转换。通过提供小型专用片上 tlb 作为地址转换缓存，大多数内存引用有望在无需访问主内存中的页表的情况下得到处理。因此，在常见情况下，程序的性能几乎就像内存根本没有被虚拟化一样，这对于操作系统来说是一项出色的成就，并且对于现代系统中分页的使用当然至关重要。\n\n然而，tlb 并没有让每个现有的程序都变得美好。特别是，如果程序在短时间内访问的页数超过了tlb所能容纳的页数，则程序将产生大量的tlb未命中，从而运行速度会变得相当慢。我们将这种现象称为超出 tlb 覆盖范围，对于某些程序来说这可能是一个很大的问题。一个解决方案是支持更大的页面大小；通过将关键数据结构映射到程序地址空间中由较大页面映射的区域，可以增加 tlb 的有效覆盖范围。对大页面的支持通常由诸如数据库管理系统（dbms）之类的程序利用，这些程序具有某些既大又随机访问的数据结构。\n\n另一个值得一提的 tlb 问题是：tlb 访问很容易成为 cpu 管道中的瓶颈，特别是对于所谓的物理索引缓存。对于这样的缓存，必须在访问缓存之前进行地址转换，这会大大减慢速度。由于这个潜在的问题，人们研究了各种巧妙的方法来使用虚拟地址访问缓存，从而避免缓存命中时昂贵的转换步骤。这种虚拟索引缓存解决了一些性能问题，但也给硬件设计带来了新问题。\n\n * 巨型页面（2mb 页面）\n\n * 千兆页面（1gb 页面）\n\n * 最先进的 tlb（amd zen4）",charsets:{cjk:!0},lastUpdated:"2024/05/11, 20:33:38",lastUpdatedTimestamp:1715430818e3},{title:"地址空间",frontmatter:{title:"地址空间",tags:["OS"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},date:"2024-04-25T22:37:08.000Z",permalink:"/pages/23b20c/",categories:["开发","系统架构","操作系统","虚拟化"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/02.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/08.%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.html",relativePath:"01.开发/05.系统架构/02.操作系统/08.地址空间.md",key:"v-170e5b70",path:"/pages/23b20c/",headers:[{level:2,title:"1 早期操作系统",slug:"_1-早期操作系统",normalizedTitle:"1 早期操作系统",charIndex:154},{level:2,title:"2 多道程序设计和分时",slug:"_2-多道程序设计和分时",normalizedTitle:"2 多道程序设计和分时",charIndex:325},{level:2,title:"3 地址空间",slug:"_3-地址空间",normalizedTitle:"3 地址空间",charIndex:1034},{level:2,title:"4 目标",slug:"_4-目标",normalizedTitle:"4 目标",charIndex:2420},{level:2,title:"5 虚拟地址",slug:"_5-虚拟地址",normalizedTitle:"5 虚拟地址",charIndex:2944},{level:2,title:"6 总结",slug:"_6-总结",normalizedTitle:"6 总结",charIndex:4122}],headersStr:"1 早期操作系统 2 多道程序设计和分时 3 地址空间 4 目标 5 虚拟地址 6 总结",content:' * 什么是内存虚拟化？\n   * 操作系统虚拟其物理内存。\n   * 操作系统为每个进程提供一个虚拟内存空间。\n   * 看起来每个进程都使用整个内存。\n * 内存虚拟化的好处\n   * 易于编程\n   * 在时间和空间方面提高内存效率\n   * 保证进程和操作系统的隔离，防止其他进程的错误访问\n\n\n# 1 早期操作系统\n\n从内存的角度来看，早期的机器并没有为用户提供太多的抽象概念。基本上，机器的物理内存如下图所示。\n\n操作系统是一组位于内存（本例中从物理地址 0 开始）中的例程（实际上是一个库），而当前位于物理内存（本例中从物理地址 64k 开始）中的一个正在运行的程序（进程）则使用内存的其余部分。用户对操作系统的期望值并不高。\n\n\n# 2 多道程序设计和分时\n\n一段时间后，由于机器价格昂贵，人们开始更有效地共享机器。因此，多道程序设计的时代诞生了，其中多个进程准备在给定时间运行，并且操作系统将在它们之间切换，例如当一个进程决定执行 I/O 时。这样做提高了 CPU 的有效利用率。在当时每台机器的成本高达数十万甚至数百万美元（而且您认为您的 Mac 很昂贵！），这种效率的提高尤其重要。\n\n然而，很快，人们开始对机器提出更多要求，分时时代诞生了。具体来说，许多人意识到批处理计算的局限性，特别是对程序员本身而言，他们厌倦了长的程序调试周期。交互性的概念变得很重要，因为许多用户可能同时使用一台机器，每个用户都等待（或希望）当前正在执行的任务及时响应。实现分时的一种方法是运行一个进程一小会儿，赋予它对所有内存的完全访问权限，然后停止它，将其所有状态保存到某种磁盘（包括所有物理内存），加载其他进程的状态，运行一段时间，从而实现某种机器的粗略共享。\n\n但这种方法有一个大问题：它太慢了，尤其是当内存增长时。虽然保存和恢复寄存器级状态（PC、通用寄存器等）相对较快，但将内存的全部内容保存到磁盘的性能却非常低。因此，我们宁愿做的是将进程留在内存中，同时在它们之间切换，从而允许操作系统有效地实现时间共享，如下图所示。\n\n图中，有三个进程（A、B 和 C），每个进程都有为其分配的 512KB 物理内存的一小部分。假设只有一个 CPU，操作系统选择运行其中一个进程（例如 A），而其他进程（B 和 C）则位于就绪队列中等待运行。但允许多个程序同时驻留在内存中使得保护成为一个重要问题；你不希望一个进程能够读取，或者更糟糕的是，写入其他进程的内存。\n\n\n# 3 地址空间\n\n这样就需要操作系统创建一个易于使用的物理内存抽象。我们将这种抽象称为地址空间，它是正在运行的程序对系统中内存的视图。了解操作系统对内存的基本抽象是理解内存如何虚拟化的关键。\n\n进程的地址空间包含正在运行的程序的所有内存状态。例如，程序的代码（指令）必须位于内存中的某个位置，因此它们位于地址空间中。程序在运行时使用栈来跟踪它在函数调用链中的位置，以及分配局部变量和向例程传递参数和返回值。最后，堆用于动态分配、用户管理的内存，例如您可能从 C 中调用 malloc() 或面向对象语言（例如 C++ 或 Java）中的 new 调用中接收到的内存。当然，其中还有其他东西（例如静态初始化变量），但现在我们只假设这三个组件：代码、栈和堆。\n\n在上图的示例中，我们有一个很小的地址空间（只有 16KB）。程序代码位于地址空间的顶部（在本例中从 0 开始，并被打包到地址空间的前 1KB 中）。代码是静态的（因此很容易放置在内存中），因此我们可以将其放置在地址空间的顶部，并且知道程序运行时它不会需要更多空间。\n\n接下来，我们有两个在程序运行时可能会增长（和收缩）的地址空间区域。这些是堆（在顶部）和栈（在底部）。我们这样放置它们是因为每个都希望能够增长，并且通过将它们放在地址空间的两端，我们可以允许这样的增长：它们只需要向相反的方向增长即可。因此，堆在代码之后开始（1KB）并向下增长（例如，当用户通过 malloc() 请求更多内存时）；堆栈从 16KB 开始并向上增长（例如当用户进行过程调用时）。然而，栈和堆的这种放置只是一种约定；如果您愿意，可以以不同的方式安排地址空间（正如我们稍后将看到的，当多个线程共存于一个地址空间中时，没有像这样划分地址空间的好方法了）。\n\n当然，当我们描述地址空间时，我们描述的是操作系统为正在运行的程序提供的抽象。该程序实际上并不位于物理地址 0 到 16KB 的内存中；相反，它被加载到某个任意的物理地址。我们可以看到上图 中的进程 A、B 和 C，每个进程如何加载到不同地址的内存中。因此出现了问题：怎么虚拟化内存？操作系统如何在单个物理内存之上为多个正在运行的进程（所有共享内存）构建私有的、可能很大的地址空间的抽象？\n\n当操作系统执行此操作时，我们说操作系统正在虚拟化内存，因为正在运行的程序认为它已加载到内存中的特定地址（例如 0），并且具有潜在的非常大的地址空间（例如 32 位或 64 位） ，但现实却截然不同。\n\n例如，当上图的进程 A 尝试在地址 0（我们将其称为虚拟地址）处执行加载时，操作系统与某些硬件支持相结合，必须确保加载实际上不是到物理地址 0，而是转到物理地址 320KB（A 被加载到内存中）。这是内存虚拟化的关键，内存虚拟化是世界上每个现代计算机系统的基础。\n\n> TIP 隔离原则\n> \n> 隔离是构建可靠系统的关键原则。如果两个实体适当地相互隔离，这意味着其中一个实体发生故障时不会影响到另一个实体。操作系统努力将进程相互隔离，从而防止一个进程损害另一个进程。\n> \n> 通过使用内存隔离，操作系统进一步确保运行中的程序不会影响底层操作系统的运行。一些现代操作系统甚至更进一步，将操作系统的各个部分与操作系统的其他部分隔离开来。因此，这种微内核比典型的单片内核设计更可靠。\n\n\n# 4 目标\n\n因此，我们在这组笔记中找到了操作系统的工作：虚拟化内存。不过，操作系统不仅会虚拟化内存；它会很有风格地做到这一点。为了确保操作系统做到这一点，我们需要一些目标来指导我们。\n\n虚拟内存 (VM) 系统的主要目标之一是透明度。操作系统应该以对正在运行的程序不可见的方式实现虚拟内存。因此，程序不应该意识到内存是虚拟化的；相反，程序的行为就好像它有自己的私有物理内存一样。操作系统（和硬件）在背后完成了在许多不同作业之间复用内存的所有工作，从而实现了这种错觉。\n\nVM的另一个目标是效率。操作系统应努力使虚拟化尽可能高效，无论是在时间（即不使程序运行得更慢）还是在空间（即不为支持虚拟化所需的结构使用太多内存）方面。在实现高效虚拟化时，操作系统必须依赖硬件支持，包括TLB等硬件功能。\n\n最后，第三个VM目标是保护。操作系统应确保进程免受其他进程的影响以及操作系统本身免受进程的影响。当一个进程执行加载、存储或取指令时，它不应该能够以任何方式访问或影响任何其他进程或操作系统本身的内存内容（即其地址空间之外的任何内容）。因此，保护使我们能够提供进程之间的隔离特性；每个进程都应该在自己隔离的茧中运行，免受其他错误甚至恶意进程的破坏。\n\n\n# 5 虚拟地址\n\n事实上，作为用户级程序的程序员，你能看到的任何地址都是虚拟地址。只有操作系统通过其巧妙的虚拟内存技术，才能知道这些指令和数据值在机器物理内存中的位置。因此，千万不要忘记：如果你在程序中打印出一个地址，那只是一个虚拟地址，是内存中事物布局的假象；只有操作系统（和硬件）才知道真正的真相。下面是一个小程序 (va.c)，它可以打印出 main() 例程（代码所在位置）的位置、全局变量的位置、malloc() 返回的堆分配值以及堆栈中整数的位置：\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint global = 1;\n\nint main(int argc, char *argv[]) {\n    // Declaring a variable x on the stack\n    int x = 3;\n\n    // Printing the location of the code\n    printf("location of code : %p\\n", (void *) main);\n    // Printing the location of global variable\n    printf("location of data : %p\\n", (void *) &global);\n    // Printing the location of heap memory\n    printf("location of heap : %p\\n", (void *) malloc(1));\n    // Printing the location of stack variable x\n    printf("location of stack : %p\\n", (void *) &x);\n    \n    return x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n当运行在64位的Linux，我们得到如下输出：\n\n> location of code: 0x40057d\n> \n> location of data : 0x401010\n> \n> location of heap : 0xcf2010\n> \n> location of stack : 0x7fff9ca45fcc\n\n如下图所示，可以看到代码首先出现在地址空间中，其次是静态数据，然后是堆，而栈一直位于这个大虚拟空间的另一端。所有这些地址都是虚拟的，并且将由操作系统和硬件进行转换，以便从其真实的物理位置获取值。\n\n\n# 6 总结\n\n我们已经看到了一个主要操作系统子系统的引入：虚拟内存。 VM系统负责为程序提供一个大的、稀疏的、私有的地址空间的假象，其中保存了它们的所有指令和数据。在一些硬件的帮助下，操作系统将获取每个虚拟内存引用，并将它们转换为物理地址，可以将其呈现给物理内存以获取所需的信息。操作系统将同时对许多进程执行此操作，确保保护程序免受彼此的侵害，并保护操作系统。\n\nVM的目标如下：\n\n * 透明度\n   \n   VM 对于正在运行的程序应该是不可见的\n\n * 效率\n   \n   最小化时间和空间方面的开销\n\n * 保护\n   \n   隔离进程（和操作系统本身）[但允许选择性“通信”]',normalizedContent:' * 什么是内存虚拟化？\n   * 操作系统虚拟其物理内存。\n   * 操作系统为每个进程提供一个虚拟内存空间。\n   * 看起来每个进程都使用整个内存。\n * 内存虚拟化的好处\n   * 易于编程\n   * 在时间和空间方面提高内存效率\n   * 保证进程和操作系统的隔离，防止其他进程的错误访问\n\n\n# 1 早期操作系统\n\n从内存的角度来看，早期的机器并没有为用户提供太多的抽象概念。基本上，机器的物理内存如下图所示。\n\n操作系统是一组位于内存（本例中从物理地址 0 开始）中的例程（实际上是一个库），而当前位于物理内存（本例中从物理地址 64k 开始）中的一个正在运行的程序（进程）则使用内存的其余部分。用户对操作系统的期望值并不高。\n\n\n# 2 多道程序设计和分时\n\n一段时间后，由于机器价格昂贵，人们开始更有效地共享机器。因此，多道程序设计的时代诞生了，其中多个进程准备在给定时间运行，并且操作系统将在它们之间切换，例如当一个进程决定执行 i/o 时。这样做提高了 cpu 的有效利用率。在当时每台机器的成本高达数十万甚至数百万美元（而且您认为您的 mac 很昂贵！），这种效率的提高尤其重要。\n\n然而，很快，人们开始对机器提出更多要求，分时时代诞生了。具体来说，许多人意识到批处理计算的局限性，特别是对程序员本身而言，他们厌倦了长的程序调试周期。交互性的概念变得很重要，因为许多用户可能同时使用一台机器，每个用户都等待（或希望）当前正在执行的任务及时响应。实现分时的一种方法是运行一个进程一小会儿，赋予它对所有内存的完全访问权限，然后停止它，将其所有状态保存到某种磁盘（包括所有物理内存），加载其他进程的状态，运行一段时间，从而实现某种机器的粗略共享。\n\n但这种方法有一个大问题：它太慢了，尤其是当内存增长时。虽然保存和恢复寄存器级状态（pc、通用寄存器等）相对较快，但将内存的全部内容保存到磁盘的性能却非常低。因此，我们宁愿做的是将进程留在内存中，同时在它们之间切换，从而允许操作系统有效地实现时间共享，如下图所示。\n\n图中，有三个进程（a、b 和 c），每个进程都有为其分配的 512kb 物理内存的一小部分。假设只有一个 cpu，操作系统选择运行其中一个进程（例如 a），而其他进程（b 和 c）则位于就绪队列中等待运行。但允许多个程序同时驻留在内存中使得保护成为一个重要问题；你不希望一个进程能够读取，或者更糟糕的是，写入其他进程的内存。\n\n\n# 3 地址空间\n\n这样就需要操作系统创建一个易于使用的物理内存抽象。我们将这种抽象称为地址空间，它是正在运行的程序对系统中内存的视图。了解操作系统对内存的基本抽象是理解内存如何虚拟化的关键。\n\n进程的地址空间包含正在运行的程序的所有内存状态。例如，程序的代码（指令）必须位于内存中的某个位置，因此它们位于地址空间中。程序在运行时使用栈来跟踪它在函数调用链中的位置，以及分配局部变量和向例程传递参数和返回值。最后，堆用于动态分配、用户管理的内存，例如您可能从 c 中调用 malloc() 或面向对象语言（例如 c++ 或 java）中的 new 调用中接收到的内存。当然，其中还有其他东西（例如静态初始化变量），但现在我们只假设这三个组件：代码、栈和堆。\n\n在上图的示例中，我们有一个很小的地址空间（只有 16kb）。程序代码位于地址空间的顶部（在本例中从 0 开始，并被打包到地址空间的前 1kb 中）。代码是静态的（因此很容易放置在内存中），因此我们可以将其放置在地址空间的顶部，并且知道程序运行时它不会需要更多空间。\n\n接下来，我们有两个在程序运行时可能会增长（和收缩）的地址空间区域。这些是堆（在顶部）和栈（在底部）。我们这样放置它们是因为每个都希望能够增长，并且通过将它们放在地址空间的两端，我们可以允许这样的增长：它们只需要向相反的方向增长即可。因此，堆在代码之后开始（1kb）并向下增长（例如，当用户通过 malloc() 请求更多内存时）；堆栈从 16kb 开始并向上增长（例如当用户进行过程调用时）。然而，栈和堆的这种放置只是一种约定；如果您愿意，可以以不同的方式安排地址空间（正如我们稍后将看到的，当多个线程共存于一个地址空间中时，没有像这样划分地址空间的好方法了）。\n\n当然，当我们描述地址空间时，我们描述的是操作系统为正在运行的程序提供的抽象。该程序实际上并不位于物理地址 0 到 16kb 的内存中；相反，它被加载到某个任意的物理地址。我们可以看到上图 中的进程 a、b 和 c，每个进程如何加载到不同地址的内存中。因此出现了问题：怎么虚拟化内存？操作系统如何在单个物理内存之上为多个正在运行的进程（所有共享内存）构建私有的、可能很大的地址空间的抽象？\n\n当操作系统执行此操作时，我们说操作系统正在虚拟化内存，因为正在运行的程序认为它已加载到内存中的特定地址（例如 0），并且具有潜在的非常大的地址空间（例如 32 位或 64 位） ，但现实却截然不同。\n\n例如，当上图的进程 a 尝试在地址 0（我们将其称为虚拟地址）处执行加载时，操作系统与某些硬件支持相结合，必须确保加载实际上不是到物理地址 0，而是转到物理地址 320kb（a 被加载到内存中）。这是内存虚拟化的关键，内存虚拟化是世界上每个现代计算机系统的基础。\n\n> tip 隔离原则\n> \n> 隔离是构建可靠系统的关键原则。如果两个实体适当地相互隔离，这意味着其中一个实体发生故障时不会影响到另一个实体。操作系统努力将进程相互隔离，从而防止一个进程损害另一个进程。\n> \n> 通过使用内存隔离，操作系统进一步确保运行中的程序不会影响底层操作系统的运行。一些现代操作系统甚至更进一步，将操作系统的各个部分与操作系统的其他部分隔离开来。因此，这种微内核比典型的单片内核设计更可靠。\n\n\n# 4 目标\n\n因此，我们在这组笔记中找到了操作系统的工作：虚拟化内存。不过，操作系统不仅会虚拟化内存；它会很有风格地做到这一点。为了确保操作系统做到这一点，我们需要一些目标来指导我们。\n\n虚拟内存 (vm) 系统的主要目标之一是透明度。操作系统应该以对正在运行的程序不可见的方式实现虚拟内存。因此，程序不应该意识到内存是虚拟化的；相反，程序的行为就好像它有自己的私有物理内存一样。操作系统（和硬件）在背后完成了在许多不同作业之间复用内存的所有工作，从而实现了这种错觉。\n\nvm的另一个目标是效率。操作系统应努力使虚拟化尽可能高效，无论是在时间（即不使程序运行得更慢）还是在空间（即不为支持虚拟化所需的结构使用太多内存）方面。在实现高效虚拟化时，操作系统必须依赖硬件支持，包括tlb等硬件功能。\n\n最后，第三个vm目标是保护。操作系统应确保进程免受其他进程的影响以及操作系统本身免受进程的影响。当一个进程执行加载、存储或取指令时，它不应该能够以任何方式访问或影响任何其他进程或操作系统本身的内存内容（即其地址空间之外的任何内容）。因此，保护使我们能够提供进程之间的隔离特性；每个进程都应该在自己隔离的茧中运行，免受其他错误甚至恶意进程的破坏。\n\n\n# 5 虚拟地址\n\n事实上，作为用户级程序的程序员，你能看到的任何地址都是虚拟地址。只有操作系统通过其巧妙的虚拟内存技术，才能知道这些指令和数据值在机器物理内存中的位置。因此，千万不要忘记：如果你在程序中打印出一个地址，那只是一个虚拟地址，是内存中事物布局的假象；只有操作系统（和硬件）才知道真正的真相。下面是一个小程序 (va.c)，它可以打印出 main() 例程（代码所在位置）的位置、全局变量的位置、malloc() 返回的堆分配值以及堆栈中整数的位置：\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint global = 1;\n\nint main(int argc, char *argv[]) {\n    // declaring a variable x on the stack\n    int x = 3;\n\n    // printing the location of the code\n    printf("location of code : %p\\n", (void *) main);\n    // printing the location of global variable\n    printf("location of data : %p\\n", (void *) &global);\n    // printing the location of heap memory\n    printf("location of heap : %p\\n", (void *) malloc(1));\n    // printing the location of stack variable x\n    printf("location of stack : %p\\n", (void *) &x);\n    \n    return x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n当运行在64位的linux，我们得到如下输出：\n\n> location of code: 0x40057d\n> \n> location of data : 0x401010\n> \n> location of heap : 0xcf2010\n> \n> location of stack : 0x7fff9ca45fcc\n\n如下图所示，可以看到代码首先出现在地址空间中，其次是静态数据，然后是堆，而栈一直位于这个大虚拟空间的另一端。所有这些地址都是虚拟的，并且将由操作系统和硬件进行转换，以便从其真实的物理位置获取值。\n\n\n# 6 总结\n\n我们已经看到了一个主要操作系统子系统的引入：虚拟内存。 vm系统负责为程序提供一个大的、稀疏的、私有的地址空间的假象，其中保存了它们的所有指令和数据。在一些硬件的帮助下，操作系统将获取每个虚拟内存引用，并将它们转换为物理地址，可以将其呈现给物理内存以获取所需的信息。操作系统将同时对许多进程执行此操作，确保保护程序免受彼此的侵害，并保护操作系统。\n\nvm的目标如下：\n\n * 透明度\n   \n   vm 对于正在运行的程序应该是不可见的\n\n * 效率\n   \n   最小化时间和空间方面的开销\n\n * 保护\n   \n   隔离进程（和操作系统本身）[但允许选择性“通信”]',charsets:{cjk:!0},lastUpdated:"2024/05/11, 20:33:38",lastUpdatedTimestamp:1715430818e3},{title:"页面交换",frontmatter:{title:"页面交换",tags:["OS"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},date:"2024-04-25T22:40:12.000Z",permalink:"/pages/65f57a/",categories:["开发","系统架构","操作系统","虚拟化"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/02.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/16.%E9%A1%B5%E9%9D%A2%E4%BA%A4%E6%8D%A2.html",relativePath:"01.开发/05.系统架构/02.操作系统/16.页面交换.md",key:"v-4bf70beb",path:"/pages/65f57a/",headers:[{level:2,title:"1 交换空间",slug:"_1-交换空间",normalizedTitle:"1 交换空间",charIndex:777},{level:2,title:"2 存在位",slug:"_2-存在位",normalizedTitle:"2 存在位",charIndex:1425},{level:2,title:"3 页面错误",slug:"_3-页面错误",normalizedTitle:"3 页面错误",charIndex:2147},{level:2,title:"4 如果内存已满怎么办？",slug:"_4-如果内存已满怎么办",normalizedTitle:"4 如果内存已满怎么办？",charIndex:2846},{level:2,title:"5 页面错误控制流",slug:"_5-页面错误控制流",normalizedTitle:"5 页面错误控制流",charIndex:3200},{level:2,title:"6 当替换真正发生时",slug:"_6-当替换真正发生时",normalizedTitle:"6 当替换真正发生时",charIndex:5411}],headersStr:"1 交换空间 2 存在位 3 页面错误 4 如果内存已满怎么办？ 5 页面错误控制流 6 当替换真正发生时",content:'到目前为止，我们假设地址空间小得不切实际，并且适合物理内存。事实上，我们一直假设每个正在运行的进程的每个地址空间都适合内存。现在，我们将放宽这些重大假设，并假设我们希望支持许多并发运行的大型地址空间。\n\n为此，我们需要在内存层次结构中增加一个级别。到目前为止，我们假设所有页面都驻留在物理内存中。然而，为了支持大地址空间，操作系统需要一个地方来存放当前需求不大的部分地址空间。一般来说，这样的位置的特点是容量要大于内存；因此，它通常会比较慢（如果它更快，我们就会将它用作内存，不是吗？）。在现代系统中，此角色通常由硬盘驱动器担任。因此，在我们的内存层次结构中，大而慢的硬盘驱动器位于底部，内存位于上面。\n\n\n\n因此，我们找到了问题的关键： 如何超越物理内存？操作系统如何利用更大、更慢的设备来透明地提供大虚拟地址空间的假象？\n\n您可能有一个问题：为什么我们要为进程支持单个大地址空间？答案再次是方便和易用。有了大的地址空间，您就不必担心内存中是否有足够的空间来容纳程序的数据结构；相反，您只需自然地编写程序，根据需要分配内存即可。这是操作系统提供的强大幻觉，使您的生活变得更加简单。与此形成鲜明对比的是使用内存覆盖的旧系统，它要求程序员在需要时手动将代码或数据移入或移出内存。试着想象一下这将会是什么样子：在调用函数或访问某些数据之前，你需要首先安排代码或数据进入内存。\n\n除了单个进程之外，添加交换空间还允许操作系统为多个并发运行的进程提供大虚拟内存的假象。多道程序设计（“同时”运行多个程序，以更好地利用机器）的发明几乎需要交换某些页面的能力，因为早期的机器显然无法同时容纳所有进程所需的所有页面。因此，多道程序设计和易用性的结合使我们希望支持使用比物理可用内存更多的内存。这是所有现代 VM 系统都会做的事情；现在我们将进一步了解这一点。\n\n\n# 1 交换空间\n\n我们需要做的第一件事是在磁盘上保留一些空间用于来回移动页面。在操作系统中，我们通常将此类空间称为交换空间，因为我们将内存中的页面交换出来，又将内存中的页面交换进去。因此，我们简单地假设操作系统可以以页面大小为单位读取和写入交换空间。为此，操作系统需要记住给定页面的磁盘地址。\n\n交换空间的大小很重要，因为它最终决定了系统在给定时间可以使用的最大内存页数。为了简单起见，我们假设它现在非常大。\n\n如下图所示，，您可以看到一个 4 页物理内存和 8 页交换空间的小例子。在示例中，三个进程（Proc 0、Proc 1 和 Proc 2）正在主动共享物理内存；然而，这三个页面中的每一个都只有一些有效页面位于内存中，其余部分位于磁盘上的交换空间中。第四个进程 (Proc 3) 已将其所有页面换出到磁盘，因此显然当前未运行。一区块的交换仍然是空闲的。即使从这个小例子中，希望您可以看到使用交换空间如何让系统假装内存比实际更大。\n\n\n\n我们应该注意，交换空间并不是交换流量的唯一磁盘位置。例如，假设您正在运行一个程序二进制文件（例如 ls 或您自己编译的主程序）。该二进制文件中的代码页最初在磁盘上找到，当程序运行时，它们被加载到内存中（或者在程序开始执行时一次全部加载，或者像在现代系统中一样，在需要时一次加载一页）。但是，如果系统需要在物理内存中腾出空间来满足其他需求，它可以安全地重新使用这些代码页的内存空间，因为它知道以后可以从文件系统中的磁盘二进制文件中再次交换它们。\n\n\n# 2 存在位\n\n现在我们在磁盘上有了一些空间，我们需要在系统中添加一些更高级别的机器，以支持与磁盘之间的页面交换。为简单起见，我们假设我们有一个带有硬件管理的 TLB 的系统。\n\n首先回想一下内存引用上发生的情况。运行的进程生成虚拟内存引用（用于指令获取或数据访问），在这种情况下，硬件在从内存中获取所需数据之前将它们转换为物理地址。\n\n请记住，硬件首先从虚拟地址中提取 VPN，检查 TLB 是否匹配（TLB 命中），如果命中，则生成结果物理地址并从内存中获取它。这希望是常见情况，因为它速度很快（不需要额外的内存访问）。\n\n如果在 TLB 中未找到 VPN（即 TLB 未命中），硬件将在内存中定位页表（使用页表基址寄存器），并使用 VPN 查找该页的页表条目 (PTE)：一个索引。如果该页有效并且存在于物理内存中，则硬件从 PTE 中提取 PFN，将其安装到 TLB 中，并重试该指令，这次生成 TLB 命中；到目前为止，一切都很好。\n\n然而，如果我们希望允许页面交换到磁盘，我们必须添加更多的机器。具体来说，当硬件查看PTE时，它可能会发现物理内存中不存在该页。硬件（或操作系统，在软件管理的 TLB 方法中）确定这一点的方式是通过每个页表条目中的一条新信息（称为存在位，the present bit）。如果存在位设置为 1，则意味着该页存在于物理内存中，并且一切按上述进行；如果它设置为零，则该页面不在内存中，而是在磁盘上的某个位置。访问不在物理内存中的页面的行为通常称为页面错误。\n\n出现页面错误时，将调用操作系统来处理页面错误。正如我们现在所描述的，运行一段称为页面错误处理程序的特定代码，并且必须为页面错误提供服务。\n\n\n# 3 页面错误\n\n回想一下，对于 TLB 未命中，我们有两种类型的系统：硬件管理的 TLB（硬件在页表中查找所需的转换）和软件管理的 TLB（操作系统执行的操作）。在任一类型的系统中，如果页面不存在，操作系统将负责处理页面错误。操作系统页面错误处理程序将运行以确定要做什么。几乎所有系统都通过软件来处理页面错误；即使使用硬件管理的 TLB，硬件也会信任操作系统来管理这项重要职责。\n\n如果页面不存在并且已交换到磁盘，操作系统将需要将该页面交换到内存中以解决页面错误。因此，出现了一个问题：操作系统如何知道在哪里可以找到所需的页面？在许多系统中，页表是存储此类信息的自然位置。因此，操作系统可以使用 PTE 中通常用于数据的位，例如磁盘地址页面的 PFN。当操作系统收到页面的缺页错误时，它会在 PTE 中查找地址，并向磁盘发出请求以将该页面提取到内存中。\n\n当磁盘 I/O 完成时，操作系统将更新页表以将页面标记为存在，更新页表项 (PTE) 的 PFN 字段以记录新获取的页面在内存中的位置，并重试该指令。下一次尝试可能会生成 TLB 未命中，然后将对其进行处理并通过转换更新 TLB（可以在处理页错误时交替更新 TLB，以避免此步骤）。最后，最后一次重新启动将在 TLB 中找到转换，从而继续从内存中转换后的物理地址获取所需的数据或指令。\n\n请注意，当 I/O 正在进行时，进程将处于阻塞状态。因此，在处理页面错误时，操作系统将可以自由地运行其他就绪进程。由于 I/O 的成本很高，因此一个进程的 I/O（页面错误）与另一个进程的执行的重叠是多道程序系统最有效地利用其硬件的另一种方式。\n\n\n# 4 如果内存已满怎么办？\n\n在上述过程中，您可能会注意到，我们假设有足够的可用内存可从交换空间调入页面。当然，情况也可能并非如此；内存可能已满（或接近满）。因此，操作系统可能希望首先调出一个或多个页面，以便为操作系统即将引入的新页面腾出空间。选择要踢出或替换的页面的过程称为页面替换策略。\n\n事实证明，我们在创建良好的页面替换策略时花费了很多心思，因为踢出错误的页面可能会给程序性能带来巨大的损失。做出错误的决定可能会导致程序以类似磁盘的速度而不是类似内存的速度运行；在当前技术中，这意味着程序的运行速度可能会慢 10,000 或 100,000 倍。所以，这样的策略是值得我们仔细研究的。事实上，这正是我们在下一章中要做的事情。现在，只要理解这样的政策的存在就足够了，它建立在此处描述的机制之上。\n\n\n# 5 页面错误控制流\n\n有了这些知识，我们现在就可以大致勾勒出内存访问的完整控制流程，如下图所示。\n\n\n\n换句话说，当有人问你 "当程序从内存中获取一些数据时会发生什么？"时，你应该对所有不同的可能性有一个相当好的概念，如下面两段代码所示。\n\n// Page-Fault Control Flow Algorithm (Hardware)\n1 VPN = (VirtualAddress & VPN_MASK) >> SHIFT\n2 (Success, TlbEntry) = TLB_Lookup(VPN)\n3 if (Success == True) // TLB Hit\n4     if (CanAccess(TlbEntry.ProtectBits) == True)\n5         Offset = VirtualAddress & OFFSET_MASK\n6         PhysAddr = (TlbEntry.PFN << SHIFT) | Offset\n7         Register = AccessMemory(PhysAddr)\n8     else\n9         RaiseException(PROTECTION_FAULT)\n10 else // TLB Miss\n11    PTEAddr = PTBR + (VPN * sizeof(PTE))\n12    PTE = AccessMemory(PTEAddr)\n13    if (PTE.Valid == False)\n14        RaiseException(SEGMENTATION_FAULT)\n15    else\n16        if (CanAccess(PTE.ProtectBits) == False)\n17            RaiseException(PROTECTION_FAULT)\n18        else if (PTE.Present == True)\n19            // assuming hardware-managed TLB\n20            TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits)\n21            RetryInstruction()\n22        else if (PTE.Present == False)\n23            RaiseException(PAGE_FAULT)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n// Page-Fault Control Flow Algorithm (Software)\n1 PFN = FindFreePhysicalPage()\n2 if (PFN == -1) // no free page found\n3     PFN = EvictPage() // run replacement algorithm\n4     DiskRead(PTE.DiskAddr, PFN) // sleep (waiting for I/O)\n5     PTE.present = True // update page table with present bit\n6     PTE.PFN = PFN // and translation (PFN)\n7     RetryInstruction() // retry instruction\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n第一段代码显示了硬件在转换过程中的操作，第二段代码显示了操作系统在发生页面错误时的操作。\n\n从第一段代码中的硬件控制流程可以看出，当发生 TLB 未命中时，有三种重要情况需要了解。第一种情况是页面既存在又有效（第 18-21 行）；在这种情况下，TLB 未命中处理程序可以简单地从 PTE 中获取 PFN，重试指令（这次会导致 TLB 命中），然后继续之前（多次）描述的操作。在第二种情况下（第 22-23 行），必须运行页面错误处理程序；虽然进程访问的页面是合法的（毕竟是有效的），但它不在物理内存中。第三种（也是最后一种）情况是访问的页面无效，例如由于程序中的错误（第 13-14 行）。在这种情况下，PTE 中的其他位都不重要；硬件会捕获这种无效访问，操作系统中断处理程序也会运行，从而终止违规进程。\n\n从第二段代码的软件控制流中我们可以看到操作系统处理页面错误的大致步骤。首先，操作系统必须为即将发生错误的页面找到一个物理页号；如果没有这样的页面，我们就必须等待替换算法运行，将一些页面踢出内存，从而释放出这些页面供此处使用。有了物理页，处理程序就会发出 I/O 请求以从交换空间读入页面。最后，当缓慢的操作完成时，操作系统会更新页表并重试该指令。重试将导致 TLB 未命中，然后，在另一次重试时，TLB 命中，此时硬件将能够访问所需的项。\n\n\n# 6 当替换真正发生时\n\n到目前为止，我们描述替换如何发生的方式是假设操作系统等待内存完全满，然后才替换（逐出）页面为其他页面腾出空间。正如您可以想象的那样，这有点不现实，操作系统主动保留一小部分内存的原因有很多。\n\n为了保持少量内存空闲，大多数操作系统都有某种高水位线（HW）和低水位线（LW）来帮助决定何时开始从内存中逐出页面。其工作原理如下：当操作系统注意到可用的 LW 页数较少时，负责释放内存的后台线程就会运行。该线程逐出页面，直到有可用的硬件页面。**后台线程（有时称为交换守护程序或页面守护程序）**然后进入睡眠状态，很高兴它释放了一些内存供正在运行的进程和操作系统使用。\n\n通过同时执行多个替换，新的性能优化成为可能。例如，许多系统会将多个页面聚集或分组并立即将它们写入交换分区，从而提高磁盘的效率；正如我们稍后更详细地讨论磁盘时将看到的那样，这种集群减少了磁盘的查找和旋转开销，从而显着提高了性能。\n\n为了与后台分页线程一起工作，上面的第二段代码控制流应该稍微修改一下；该算法不会直接执行替换，而是简单地检查是否有可用的空闲页面。如果没有，它会通知后台分页线程需要空闲页面；当线程释放一些页面时，它会重新唤醒原始线程，然后原始线程可以调入所需的页面并继续其工作。',normalizedContent:'到目前为止，我们假设地址空间小得不切实际，并且适合物理内存。事实上，我们一直假设每个正在运行的进程的每个地址空间都适合内存。现在，我们将放宽这些重大假设，并假设我们希望支持许多并发运行的大型地址空间。\n\n为此，我们需要在内存层次结构中增加一个级别。到目前为止，我们假设所有页面都驻留在物理内存中。然而，为了支持大地址空间，操作系统需要一个地方来存放当前需求不大的部分地址空间。一般来说，这样的位置的特点是容量要大于内存；因此，它通常会比较慢（如果它更快，我们就会将它用作内存，不是吗？）。在现代系统中，此角色通常由硬盘驱动器担任。因此，在我们的内存层次结构中，大而慢的硬盘驱动器位于底部，内存位于上面。\n\n\n\n因此，我们找到了问题的关键： 如何超越物理内存？操作系统如何利用更大、更慢的设备来透明地提供大虚拟地址空间的假象？\n\n您可能有一个问题：为什么我们要为进程支持单个大地址空间？答案再次是方便和易用。有了大的地址空间，您就不必担心内存中是否有足够的空间来容纳程序的数据结构；相反，您只需自然地编写程序，根据需要分配内存即可。这是操作系统提供的强大幻觉，使您的生活变得更加简单。与此形成鲜明对比的是使用内存覆盖的旧系统，它要求程序员在需要时手动将代码或数据移入或移出内存。试着想象一下这将会是什么样子：在调用函数或访问某些数据之前，你需要首先安排代码或数据进入内存。\n\n除了单个进程之外，添加交换空间还允许操作系统为多个并发运行的进程提供大虚拟内存的假象。多道程序设计（“同时”运行多个程序，以更好地利用机器）的发明几乎需要交换某些页面的能力，因为早期的机器显然无法同时容纳所有进程所需的所有页面。因此，多道程序设计和易用性的结合使我们希望支持使用比物理可用内存更多的内存。这是所有现代 vm 系统都会做的事情；现在我们将进一步了解这一点。\n\n\n# 1 交换空间\n\n我们需要做的第一件事是在磁盘上保留一些空间用于来回移动页面。在操作系统中，我们通常将此类空间称为交换空间，因为我们将内存中的页面交换出来，又将内存中的页面交换进去。因此，我们简单地假设操作系统可以以页面大小为单位读取和写入交换空间。为此，操作系统需要记住给定页面的磁盘地址。\n\n交换空间的大小很重要，因为它最终决定了系统在给定时间可以使用的最大内存页数。为了简单起见，我们假设它现在非常大。\n\n如下图所示，，您可以看到一个 4 页物理内存和 8 页交换空间的小例子。在示例中，三个进程（proc 0、proc 1 和 proc 2）正在主动共享物理内存；然而，这三个页面中的每一个都只有一些有效页面位于内存中，其余部分位于磁盘上的交换空间中。第四个进程 (proc 3) 已将其所有页面换出到磁盘，因此显然当前未运行。一区块的交换仍然是空闲的。即使从这个小例子中，希望您可以看到使用交换空间如何让系统假装内存比实际更大。\n\n\n\n我们应该注意，交换空间并不是交换流量的唯一磁盘位置。例如，假设您正在运行一个程序二进制文件（例如 ls 或您自己编译的主程序）。该二进制文件中的代码页最初在磁盘上找到，当程序运行时，它们被加载到内存中（或者在程序开始执行时一次全部加载，或者像在现代系统中一样，在需要时一次加载一页）。但是，如果系统需要在物理内存中腾出空间来满足其他需求，它可以安全地重新使用这些代码页的内存空间，因为它知道以后可以从文件系统中的磁盘二进制文件中再次交换它们。\n\n\n# 2 存在位\n\n现在我们在磁盘上有了一些空间，我们需要在系统中添加一些更高级别的机器，以支持与磁盘之间的页面交换。为简单起见，我们假设我们有一个带有硬件管理的 tlb 的系统。\n\n首先回想一下内存引用上发生的情况。运行的进程生成虚拟内存引用（用于指令获取或数据访问），在这种情况下，硬件在从内存中获取所需数据之前将它们转换为物理地址。\n\n请记住，硬件首先从虚拟地址中提取 vpn，检查 tlb 是否匹配（tlb 命中），如果命中，则生成结果物理地址并从内存中获取它。这希望是常见情况，因为它速度很快（不需要额外的内存访问）。\n\n如果在 tlb 中未找到 vpn（即 tlb 未命中），硬件将在内存中定位页表（使用页表基址寄存器），并使用 vpn 查找该页的页表条目 (pte)：一个索引。如果该页有效并且存在于物理内存中，则硬件从 pte 中提取 pfn，将其安装到 tlb 中，并重试该指令，这次生成 tlb 命中；到目前为止，一切都很好。\n\n然而，如果我们希望允许页面交换到磁盘，我们必须添加更多的机器。具体来说，当硬件查看pte时，它可能会发现物理内存中不存在该页。硬件（或操作系统，在软件管理的 tlb 方法中）确定这一点的方式是通过每个页表条目中的一条新信息（称为存在位，the present bit）。如果存在位设置为 1，则意味着该页存在于物理内存中，并且一切按上述进行；如果它设置为零，则该页面不在内存中，而是在磁盘上的某个位置。访问不在物理内存中的页面的行为通常称为页面错误。\n\n出现页面错误时，将调用操作系统来处理页面错误。正如我们现在所描述的，运行一段称为页面错误处理程序的特定代码，并且必须为页面错误提供服务。\n\n\n# 3 页面错误\n\n回想一下，对于 tlb 未命中，我们有两种类型的系统：硬件管理的 tlb（硬件在页表中查找所需的转换）和软件管理的 tlb（操作系统执行的操作）。在任一类型的系统中，如果页面不存在，操作系统将负责处理页面错误。操作系统页面错误处理程序将运行以确定要做什么。几乎所有系统都通过软件来处理页面错误；即使使用硬件管理的 tlb，硬件也会信任操作系统来管理这项重要职责。\n\n如果页面不存在并且已交换到磁盘，操作系统将需要将该页面交换到内存中以解决页面错误。因此，出现了一个问题：操作系统如何知道在哪里可以找到所需的页面？在许多系统中，页表是存储此类信息的自然位置。因此，操作系统可以使用 pte 中通常用于数据的位，例如磁盘地址页面的 pfn。当操作系统收到页面的缺页错误时，它会在 pte 中查找地址，并向磁盘发出请求以将该页面提取到内存中。\n\n当磁盘 i/o 完成时，操作系统将更新页表以将页面标记为存在，更新页表项 (pte) 的 pfn 字段以记录新获取的页面在内存中的位置，并重试该指令。下一次尝试可能会生成 tlb 未命中，然后将对其进行处理并通过转换更新 tlb（可以在处理页错误时交替更新 tlb，以避免此步骤）。最后，最后一次重新启动将在 tlb 中找到转换，从而继续从内存中转换后的物理地址获取所需的数据或指令。\n\n请注意，当 i/o 正在进行时，进程将处于阻塞状态。因此，在处理页面错误时，操作系统将可以自由地运行其他就绪进程。由于 i/o 的成本很高，因此一个进程的 i/o（页面错误）与另一个进程的执行的重叠是多道程序系统最有效地利用其硬件的另一种方式。\n\n\n# 4 如果内存已满怎么办？\n\n在上述过程中，您可能会注意到，我们假设有足够的可用内存可从交换空间调入页面。当然，情况也可能并非如此；内存可能已满（或接近满）。因此，操作系统可能希望首先调出一个或多个页面，以便为操作系统即将引入的新页面腾出空间。选择要踢出或替换的页面的过程称为页面替换策略。\n\n事实证明，我们在创建良好的页面替换策略时花费了很多心思，因为踢出错误的页面可能会给程序性能带来巨大的损失。做出错误的决定可能会导致程序以类似磁盘的速度而不是类似内存的速度运行；在当前技术中，这意味着程序的运行速度可能会慢 10,000 或 100,000 倍。所以，这样的策略是值得我们仔细研究的。事实上，这正是我们在下一章中要做的事情。现在，只要理解这样的政策的存在就足够了，它建立在此处描述的机制之上。\n\n\n# 5 页面错误控制流\n\n有了这些知识，我们现在就可以大致勾勒出内存访问的完整控制流程，如下图所示。\n\n\n\n换句话说，当有人问你 "当程序从内存中获取一些数据时会发生什么？"时，你应该对所有不同的可能性有一个相当好的概念，如下面两段代码所示。\n\n// page-fault control flow algorithm (hardware)\n1 vpn = (virtualaddress & vpn_mask) >> shift\n2 (success, tlbentry) = tlb_lookup(vpn)\n3 if (success == true) // tlb hit\n4     if (canaccess(tlbentry.protectbits) == true)\n5         offset = virtualaddress & offset_mask\n6         physaddr = (tlbentry.pfn << shift) | offset\n7         register = accessmemory(physaddr)\n8     else\n9         raiseexception(protection_fault)\n10 else // tlb miss\n11    pteaddr = ptbr + (vpn * sizeof(pte))\n12    pte = accessmemory(pteaddr)\n13    if (pte.valid == false)\n14        raiseexception(segmentation_fault)\n15    else\n16        if (canaccess(pte.protectbits) == false)\n17            raiseexception(protection_fault)\n18        else if (pte.present == true)\n19            // assuming hardware-managed tlb\n20            tlb_insert(vpn, pte.pfn, pte.protectbits)\n21            retryinstruction()\n22        else if (pte.present == false)\n23            raiseexception(page_fault)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n// page-fault control flow algorithm (software)\n1 pfn = findfreephysicalpage()\n2 if (pfn == -1) // no free page found\n3     pfn = evictpage() // run replacement algorithm\n4     diskread(pte.diskaddr, pfn) // sleep (waiting for i/o)\n5     pte.present = true // update page table with present bit\n6     pte.pfn = pfn // and translation (pfn)\n7     retryinstruction() // retry instruction\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n第一段代码显示了硬件在转换过程中的操作，第二段代码显示了操作系统在发生页面错误时的操作。\n\n从第一段代码中的硬件控制流程可以看出，当发生 tlb 未命中时，有三种重要情况需要了解。第一种情况是页面既存在又有效（第 18-21 行）；在这种情况下，tlb 未命中处理程序可以简单地从 pte 中获取 pfn，重试指令（这次会导致 tlb 命中），然后继续之前（多次）描述的操作。在第二种情况下（第 22-23 行），必须运行页面错误处理程序；虽然进程访问的页面是合法的（毕竟是有效的），但它不在物理内存中。第三种（也是最后一种）情况是访问的页面无效，例如由于程序中的错误（第 13-14 行）。在这种情况下，pte 中的其他位都不重要；硬件会捕获这种无效访问，操作系统中断处理程序也会运行，从而终止违规进程。\n\n从第二段代码的软件控制流中我们可以看到操作系统处理页面错误的大致步骤。首先，操作系统必须为即将发生错误的页面找到一个物理页号；如果没有这样的页面，我们就必须等待替换算法运行，将一些页面踢出内存，从而释放出这些页面供此处使用。有了物理页，处理程序就会发出 i/o 请求以从交换空间读入页面。最后，当缓慢的操作完成时，操作系统会更新页表并重试该指令。重试将导致 tlb 未命中，然后，在另一次重试时，tlb 命中，此时硬件将能够访问所需的项。\n\n\n# 6 当替换真正发生时\n\n到目前为止，我们描述替换如何发生的方式是假设操作系统等待内存完全满，然后才替换（逐出）页面为其他页面腾出空间。正如您可以想象的那样，这有点不现实，操作系统主动保留一小部分内存的原因有很多。\n\n为了保持少量内存空闲，大多数操作系统都有某种高水位线（hw）和低水位线（lw）来帮助决定何时开始从内存中逐出页面。其工作原理如下：当操作系统注意到可用的 lw 页数较少时，负责释放内存的后台线程就会运行。该线程逐出页面，直到有可用的硬件页面。**后台线程（有时称为交换守护程序或页面守护程序）**然后进入睡眠状态，很高兴它释放了一些内存供正在运行的进程和操作系统使用。\n\n通过同时执行多个替换，新的性能优化成为可能。例如，许多系统会将多个页面聚集或分组并立即将它们写入交换分区，从而提高磁盘的效率；正如我们稍后更详细地讨论磁盘时将看到的那样，这种集群减少了磁盘的查找和旋转开销，从而显着提高了性能。\n\n为了与后台分页线程一起工作，上面的第二段代码控制流应该稍微修改一下；该算法不会直接执行替换，而是简单地检查是否有可用的空闲页面。如果没有，它会通知后台分页线程需要空闲页面；当线程释放一些页面时，它会重新唤醒原始线程，然后原始线程可以调入所需的页面并继续其工作。',charsets:{cjk:!0},lastUpdated:"2024/05/11, 20:33:38",lastUpdatedTimestamp:1715430818e3},{title:"交换策略",frontmatter:{title:"交换策略",tags:["OS"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},date:"2024-04-25T22:40:25.000Z",permalink:"/pages/aeb7cb/",categories:["开发","系统架构","操作系统","虚拟化"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/02.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/17.%E4%BA%A4%E6%8D%A2%E7%AD%96%E7%95%A5.html",relativePath:"01.开发/05.系统架构/02.操作系统/17.交换策略.md",key:"v-5b71b852",path:"/pages/aeb7cb/",headers:[{level:2,title:"1  缓存管理",slug:"_1-缓存管理",normalizedTitle:"1  缓存管理",charIndex:null},{level:2,title:"2 最佳替换策略",slug:"_2-最佳替换策略",normalizedTitle:"2 最佳替换策略",charIndex:1933},{level:2,title:"3 FIFO（先进先出策略）",slug:"_3-fifo-先进先出策略",normalizedTitle:"3 fifo（先进先出策略）",charIndex:3596},{level:2,title:"4 随机策略",slug:"_4-随机策略",normalizedTitle:"4 随机策略",charIndex:4465},{level:2,title:"5 使用历史记录：LRU",slug:"_5-使用历史记录-lru",normalizedTitle:"5 使用历史记录：lru",charIndex:4859},{level:2,title:"6 工作负载实例",slug:"_6-工作负载实例",normalizedTitle:"6 工作负载实例",charIndex:6204},{level:2,title:"7 实现历史算法",slug:"_7-实现历史算法",normalizedTitle:"7 实现历史算法",charIndex:7554},{level:2,title:"8 近似LRU",slug:"_8-近似lru",normalizedTitle:"8 近似lru",charIndex:8231},{level:2,title:"9 考虑脏位（在时钟算法中）",slug:"_9-考虑脏位-在时钟算法中",normalizedTitle:"9 考虑脏位（在时钟算法中）",charIndex:9075},{level:2,title:"10 其他VM策略",slug:"_10-其他vm策略",normalizedTitle:"10 其他vm策略",charIndex:9376},{level:2,title:"11 抖动",slug:"_11-抖动",normalizedTitle:"11 抖动",charIndex:9788}],headersStr:"1  缓存管理 2 最佳替换策略 3 FIFO（先进先出策略） 4 随机策略 5 使用历史记录：LRU 6 工作负载实例 7 实现历史算法 8 近似LRU 9 考虑脏位（在时钟算法中） 10 其他VM策略 11 抖动",content:'在虚拟内存管理器中，当您拥有大量可用内存时，生活会很容易。发生页面错误时，您在空闲页面列表中找到一个空闲页面，并将其分配给发生错误的页面。嘿，操作系统，恭喜！你又这么做了。\n\n不幸的是，当空闲内存很少时，事情就会变得更有趣。在这种情况下，这种内存压力会迫使操作系统开始调出页面，为主动使用的页面腾出空间。决定调出哪个页面（或哪些页面）封装在操作系统的替换策略中；从历史上看，这是早期虚拟内存系统做出的最重要的决定之一，因为较旧的系统几乎没有物理内存。至少，这是一套值得更多了解的有趣政策。因此我们的问题关键是：操作系统如何决定从内存中驱逐哪一页（或多页）？这一决定是由系统的替换策略做出的，该策略通常遵循一些一般原则（如下所述），但也包括某些调整以避免极端情况行为。\n\n\n# 1 缓存管理\n\n在深入讨论策略之前，我们首先更详细地描述我们试图解决的问题。鉴于主内存保存系统中所有页面的某些子集，它可以正确地被视为系统中虚拟内存页面的缓存。因此，我们为此缓存选择替换策略的目标是最小化缓存未命中的次数，即最小化我们必须从磁盘获取页面的次数。或者，我们的目标可以视为最大化缓存命中数，即在内存中找到被访问页面的次数。\n\n了解缓存命中和未命中的次数后，我们可以计算程序的平均内存访问时间 (average memory access time, AMAT)（计算机架构师计算硬件缓存的度量标准]）。具体来说，给定这些值，我们可以计算程序的 AMAT，如下所示：\n\nAMAT=TM+PMiss⋅TD\\text{AMAT}=\\text{T}_M+\\text{P}_{Miss}\\cdot\\text{T}_\\text{D} AMAT=TM +PMiss ⋅TD\n\n其中TM\\text{T}_MTM 表示访问内存的成本，TD\\text{T}_DTD 表示访问磁盘的成本，TMiss\\text{T}_\\text{Miss}TMiss 是在缓存中找不到数据的概率（未命中）； TMiss\\text{T}_\\text{Miss}TMiss 从 0.0 到 1.0 不等，有时我们指的是丢失率百分比而不是概率（例如，10% 的丢失率意味着 TMiss=0.10\\text{T}_\\text{Miss}=0.10TMiss =0.10）。请注意，您总是要为访问内存中的数据付出代价；然而，当您未命中时，您必须额外支付从磁盘获取数据的成本。\n\n例如，让我们想象一台具有（微小）地址空间的机器：4KB，具有 256 字节页面。因此，虚拟地址有两个组成部分：4 位 VPN（最高有效位）和 8 位偏移量（最低有效位）。因此，该示例中的进程总共可以访问 242^424 或 16 个虚拟页。在此示例中，进程生成以下内存引用（即虚拟地址）：0x000、0x100、0x200、0x300、0x400、0x500、0x600、0x700、0x800、0x900。这些虚拟地址指的是地址空间前十页中每一页的第一个字节（页号是每个虚拟地址的第一个十六进制数字）。\n\n让我们进一步假设除虚拟页 3 之外的所有页都已在内存中。因此，我们的内存引用序列将遇到以下行为：命中，命中，命中，未命中，命中，命中，命中，命中，命中，命中。我们可以计算命中率（在内存中找到的引用的百分比）：90%，因为十分之九的引用在内存中。因此，为命中率率为 10%（PMiss=0.10\\text{P}_\\text{Miss}=0.10PMiss =0.10）。一般情况下，PHit+PMiss=0.10=1.0\\text{P}_\\text{Hit}+\\text{P}_\\text{Miss}=0.10=1.0PHit +PMiss =0.10=1.0；命中率加上未命中率之和为 100%。\n\n为了计算AMAT，我们需要知道访问内存的成本和访问磁盘的成本。假设访问内存的成本 (TM ) 约为 100 纳秒，访问磁盘的成本 (TD ) 约为 10 毫秒，则我们有以下 AMAT：100ns + 0.1 · 10ms，即 100ns + 1ms，即 1.0001 ms，或大约1毫秒。如果我们的命中率为 99.9%（Pmiss = 0.001），结果就完全不同：AMAT 为 10.1 微秒，或者大约快 100 倍。当命中率接近 100% 时，AMAT 接近 100 纳秒。\n\n不幸的是，正如您在此示例中所看到的，现代系统中磁盘访问的成本非常高，即使很小的未命中率也会很快主导正在运行的程序的整体 AMAT。显然，我们需要尽可能避免未命中或以磁盘速率缓慢运行。解决这个问题的一种方法是仔细制定明智的策略，就像我们现在所做的那样。\n\n\n# 2 最佳替换策略\n\n为了更好地理解特定替换策略的工作原理，最好将其与最佳替换策略进行比较。事实证明，Belady多年前就提出了这样一种最佳策略（他最初称之为 MIN）。最佳替换策略会导致总体未命中次数最少。Belady 证明了一种简单（但不幸的是，很难实现！）的方法，即替换未来访问距离最远的页面是最佳策略，它能带来尽可能少的缓存缺失。\n\n> TIP：与最优算法进行比较是有用的\n> \n> 虽然最优算法作为实际策略并不实用，但在模拟或其他研究中作为比较点却非常有用。如果说你的新算法有 80% 的命中率，这并没有任何意义；如果说最优算法有 82% 的命中率（因此你的新方法非常接近最优算法），这将使结果更有意义，并赋予其背景。因此，在你进行的任何研究中，知道最佳值是什么可以让你进行更好的比较，显示还有多少改进的可能，以及什么时候你可以停止改进你的策略，因为它已经足够接近理想值了。\n\n希望最优策略背后的直觉是有道理的。你可以这样想：如果你必须扔掉某个页面，为什么不扔掉离现在最远的那个页面呢？这样做实质上是在说，缓存中的所有其他页面都比最远的那一页更重要。原因很简单：在访问最远的那一页之前，你会先访问其他页面。\n\n让我们通过一个简单的例子来了解最优策略的决策。假设一个程序访问以下虚拟页面流：0, 1, 2, 0, 1, 3, 0, 3, 1, 2, 1。下图显示了最优策略的行为，假设缓存可以容纳三个页面。\n\n\n\n从图中可以看到以下操作。毫不奇怪，前三次访问都是未命中，因为高速缓存一开始是空的；这种未命中有时被称为冷启动未命中（或强制未命中）。然后我们再次访问第 0 页和第 1 页，它们都在缓存中被命中。最后，我们又发生了一次缺失（第 3 页），但这次缓存已满，必须进行替换！这就引出了一个问题：我们应该替换哪一页？根据最优策略，我们可以检查当前缓存中每个页面（0、1 和 2）的未来访问情况，发现 0 页面几乎会立即被访问，1 页面会稍后被访问，而 2 页面在未来会被访问得最远。因此，最优策略很容易做出选择：删除第 2 页，这样缓存中就有了第 0、1 和 3 页。接下来的三个引用都是命中的，但我们到了 2 页时，却又遭遇了一次未命中。在这里，最优策略再次检查了缓存中每个页面（0、1 和 3）的未来访问情况，发现只要不驱逐第 1 页（即将被访问），我们就不会有问题。示例显示第 3 页被驱逐，尽管第 0 页也可以被驱逐。最后，我们命中了第 1 页，跟踪完成。\n\n我们还可以计算缓存的命中率：在 6 次命中和 5 次未命中的情况下，命中率为HitsHits+Misses\\frac{\\text{Hits}}{\\text{Hits+Misses}}Hits+MissesHits 命中+未命中，即 66+5\\frac{6}{6+5}6+56 或 54.5%。我们还可以计算强制未命中的命中率（即忽略对给定页面的第一次未命中），结果是命中率为 85.7%。\n\n遗憾的是，正如我们之前在开发调度策略时所看到的，未来并不普遍为人所知；你不可能为通用操作系统构建最优策略。因此，在开发真正的、可部署的策略时，我们将重点关注那些能找到其他方法来决定驱逐哪个页面的方法。因此，最佳策略只能作为一个比较点，以了解我们离 "完美 "还有多远。\n\n> 缓存未命中的类型\n> \n> 在计算机体系结构领域，架构师有时发现按类型将未命中特征分为以下三类之一很有用：强制、容量和冲突未命中，有时称为 3 C。发生强制未命中（或冷启动未命中）是因为缓存一开始就是空的，并且这是对该项目的第一次引用；相反，由于缓存空间不足，必须逐出一个项目才能将新项目放入缓存，因此会发生容量未命中。第三种类型的未命中（冲突未命中）出现在硬件中，因为由于所谓的“组关联性”（setassociativity），项目可以放置在硬件缓存中的位置受到限制。它不会出现在操作系统页面缓存中，因为此类缓存始终是完全关联的，即页面可以放置在内存中的位置没有限制。\n\n\n# 3 FIFO（先进先出策略）\n\n许多早期系统避免了尝试接近最优的复杂性，而是采用了非常简单的替换策略。例如，一些系统使用 FIFO（先进先出）替换，其中页面在进入系统时被简单地放置在队列中；当发生替换时，队列尾部的页面（“先入”页面）将被逐出。 FIFO 有一个很大的优点：实现起来非常简单。\n\n如下图所示，为 FIFO 在我们的示例引用流上的表现。我们再次以对页面 0、1 和 2 的三个强制未命中开始跟踪，然后命中 0 和 1。接下来，引用第 3 页，导致未命中；使用 FIFO 进行替换决策很容易：选择第一个页面（图中的缓存状态按 FIFO 顺序保存，第一个页面位于左侧），即第 0 页。不幸的是，我们的下一个访问是页 0，导致另一次丢失和替换（页 1）。然后我们命中了第 3 页，但第 1 和第 2 页未命中，最后命中了第 1 页。\n\n将 FIFO 与最佳值相比，FIFO 的命中率明显更差：36.4% 的命中率（或 57.1%，不包括强制命中率）。 FIFO 根本无法确定块的重要性：即使页 0 已被访问多次，FIFO 仍然会将其踢出，仅仅因为它是第一个进入内存的块。\n\n\n\n> BELADY 的异常\n> \n> Belady（最优策略提出者）和同事发现了一个有趣的引用流，其行为有点出乎意料。内存引用流：1,2,3,4,1,2,5,1,2,3,4,5。他们研究的替换策略是先进先出。有趣的部分是：当缓存大小从 3 页移动到 4 页时，缓存命中率如何变化。一般来说，当缓存变大时，您会期望缓存命中率会增加（变得更好）。但在这种情况下，如果使用 FIFO，情况会变得更糟！这种奇怪的行为通常被称为BELADY 的异常。其他一些策略，例如 LRU，不会遇到这个问题。事实证明，LRU 具有所谓的堆栈属性 。对于具有此属性的算法，大小为 N + 1 的缓存自然包含大小为 N 的缓存的内容。因此，当增加缓存大小时，命中率将保持不变或提高。 FIFO 和 Random（以及其他）显然不遵守堆栈属性，因此容易受到异常行为的影响。\n\n\n# 4 随机策略\n\n另一种类似的替换策略是随机策略，它只是在内存压力下选择随机页面进行替换。 Random 具有与 FIFO 类似的属性；它实现起来很简单，但它并没有真正尝试太智能地选择要驱逐的块。如下图所示，让我们看看 Random 在我们著名的示例引用流上的表现如何。\n\n\n\n当然，Random 的表现完全取决于 Random 在其选择中的幸运（或不幸）程度。在上面的例子中，Random 的表现比 FIFO 好一点，比最优的差一点。事实上，我们可以运行随机实验数千次并确定它的总体表现。\n\n下图显示了 Random 在 10,000 多次试验中实现了多少次命中，每次试验都有不同的随机种子。正如您所看到的，有时（仅超过 40% 的时间），Random 与最佳效果一样好，在示例跟踪上实现了 6 个命中；有时效果更糟，达到 2 次或更少。随机抽奖的效果如何取决于抽奖的运气。\n\n\n\n\n# 5 使用历史记录：LRU\n\n不幸的是，任何像 FIFO 或 Random 这样简单的策略都可能存在一个常见问题：它可能会踢出一个重要的页面，而该页面将被再次引用。 FIFO踢出最先带入的页面；如果这恰好是一个带有重要代码或数据结构的页面，那么它无论如何都会被丢弃，即使它很快就会被分页回来。因此，FIFO、Random和类似的策略不太可能达到最佳效果；需要更智能的东西。\n\n正如我们对调度策略所做的那样，为了改善我们对未来的猜测，我们再次依靠过去并以历史为指导。例如，如果一个程序在不久的过去访问过一个页面，那么它很可能在不久的将来再次访问它。\n\n页面替换策略可以使用的一类历史信息是频率。如果一个页面已被访问多次，也许它不应该被替换，因为它显然具有某些价值。页面的一个更常用的属性是访问时间；页面被访问的时间越近，也许就越有可能被再次访问。\n\n这一系列策略基于人们所说的局部性原则 ，这基本上只是对程序及其行为的观察。这个原则的意思很简单，就是程序倾向于非常频繁地访问某些代码序列（例如，在循环中）和数据结构（例如，循环访问的数组）；因此，我们应该尝试使用历史记录来找出哪些页面是重要的，并在驱逐时将这些页面保留在内存中。\n\n因此，一系列简单的基于历史的算法诞生了。当必须进行逐出时，最不常用 (LFU) 策略会替换最不常用的页面。类似地，最近最少使用（LRU）策略替换最近最少使用的页面。这些算法很容易记住：一旦您知道名称，您就确切地知道它的作用，这是名称的一个极好的属性。\n\n为了更好地理解 LRU，我们来看看 LRU 在示例引用流上的表现，如下图所示。\n\n\n\n从图中，您可以看到 LRU 如何利用历史记录比 Random 或 FIFO 等无状态策略做得更好。在示例中，LRU 在第一次必须替换页面时会逐出页面 2，因为最近访问过页面 0 和 1。然后它会替换第 0 页，因为最近访问了第 1 页和第 3 页。在这两种情况下，LRU 基于历史的决定都被证明是正确的，因此下一个引用会被命中。因此，在我们的示例中，LRU 表现得尽可能好，其性能达到最佳水平。\n\n我们还应该注意到，这些算法存在相反的情况：最常用（MFU）和最近使用（MRU）。在大多数情况下（不是全部！），这些策略效果不佳，因为它们忽略了大多数程序所展示的局部性，而不是利用它。\n\n> 局部性的类型\n> \n> 程序往往会表现出两种局部性。第一种是空间局部性，即如果一个页面 P 被访问，那么它周围的页面（如 P - 1 或 P + 1）也很可能被访问。第二种是时间局部性，即在不久的将来，在过去被访问过的页面很可能会再次被访问。存在这些类型的局部性的假设在硬件系统的缓存层次结构中发挥着重要作用，硬件系统部署多个级别的指令、数据和地址转换缓存，以帮助程序在存在此类局部性时快速运行。\n> \n> 当然，通常所说的局部性原则并不是所有程序都必须遵守的硬性规定。事实上，有些程序以相当随机的方式访问内存（或磁盘），在其访问流中并不表现出太多或任何局部性。因此，在设计任何类型的缓存（硬件或软件）时，虽然局部性是一个值得牢记的好东西，但它并不能保证成功。相反，它是一种启发式方法，在计算机系统设计中经常被证明是有用的。\n\n\n# 6 工作负载实例\n\n让我们再看几个例子，以便更好地理解其中一些策略的行为方式。在这里，我们将检查更复杂的工作负载而不是小跟踪。然而，即使是这些工作负载也被大大简化了；更好的研究将包括应用程序跟踪。\n\n我们的第一个工作负载没有局部性，这意味着每个引用都是对访问页面集中的随机页面。在这个简单的示例中，工作负载随着时间的推移访问 100 个唯一页面，随机选择下一个页面进行引用；总共访问了 10,000 个页面。在实验中，我们将缓存大小从非常小（1 页）更改为足以容纳所有唯一页面（100 页），以便了解每个策略在缓存大小范围内的行为方式。\n\n下图绘制了最优、LRU、随机和 FIFO 的实验结果。图中的y轴表示每个策略达到的命中率； x 轴改变缓存大小。\n\n\n\n我们可以从图中得出许多结论。首先，当工作负载不存在局部性时，您使用哪种实际策略并不重要； LRU、FIFO 和 Random 的执行方式都是相同的，命中率完全由缓存的大小决定。其次，当缓存足够大以适应整个工作负载时，使用哪种策略也并不重要；当所有引用的块都适合缓存时，所有策略（甚至随机）都会收敛到 100% 命中率。最后，您可以看到最优策略的性能明显优于现实策略；如果可能的话，展望未来可以更好地进行替代。\n\n我们研究的下一个工作负载称为“80-20”工作负载，它表现出局部性：80% 的引用是针对 20% 的页面（“热门”页面）；其余 20% 的引用是针对其余 80% 的页面（“冷”页面）。在我们的工作负载中，总共有 100 个不同的页面；因此，大部分时间都引用“热”页面，其余时间引用“冷”页面。下图显示了策略如何在此工作负载下执行。\n\n\n\n从图中可以看出，虽然随机和 FIFO 都表现得相当好，但 LRU 表现更好，因为它更有可能保留热点页；由于这些页面过去曾被频繁引用，因此很可能在不久的将来再次被引用。 Optimal 再次表现更好，说明 LRU 的历史信息并不完美。\n\n您现在可能想知道：LRU 相对于 Random 和 FIFO 的改进真的有那么大吗？答案是“视情况而定”。如果每次未命中的成本都非常高（并不罕见），那么即使命中率小幅增加（为命中率降低）也会对性能产生巨大影响。如果未命中的代价不那么高，那么 LRU 可能带来的好处当然就不那么重要了。\n\n让我们看一下最终的工作负载。我们将其称为“循环顺序”工作负载，因为在其中，我们按顺序引用 50 个页面，从 0 开始，然后是 1，...，直到第 49 页，然后我们循环，重复这些访问，以获得对 50 个唯一页面的总共 10,000 次访问。下图显示了该工作负载下策略的行为。\n\n\n\n这种工作负载在许多应用程序（包括重要的商业应用程序，例如数据库）中很常见，代表了 LRU 和 FIFO 的最坏情况。这些算法在循环顺序工作负载下会踢出旧页面；不幸的是，由于工作负载的循环性质，这些较旧的页面将比策略希望保留在缓存中的页面更早被访问。事实上，即使缓存大小为 49，50 页的循环顺序工作负载也会导致 0% 的命中率。有趣的是，随机的效果明显更好，虽然还没有完全接近最佳，但至少实现了非零命中率。事实证明随机有一些很好的特性；其中一个属性就是没有奇怪的极端行为。\n\n\n# 7 实现历史算法\n\n正如您所看到的，LRU 等算法通常比 FIFO 或随机等简单策略做得更好，后者可能会丢弃重要的页面。不幸的是，历史策略给我们带来了新的挑战：我们如何实现它们？\n\n我们以 LRU 为例。为了完美地实现它，我们需要做大量的工作。具体来说，在每次页面访问（即每次内存访问，无论是指令提取还是加载或存储）时，我们必须更新某些数据结构以将此页面移动到列表的前面（即 MRU 侧）。与 FIFO 相比，只有当页面被逐出（通过删除最先进入的页面）或将新页面添加到列表（最后进入的一侧）时，才会访问 FIFO 页面列表。为了跟踪哪些页面被最少和最近使用，系统必须在每次内存引用上进行一些统计工作。显然，如果不小心处理，这种统计工作可能会大大降低性能。\n\n一种有助于加快速度的方法是添加一点硬件支持。例如，机器可以在每次页面访问时更新内存中的时间字段（例如，这可能位于每个进程的页表中，或者仅位于内存中的某个单独的数组中，系统中的每个物理页有一个条目）。因此，当访问页面时，时间字段将由硬件设置为当前时间。然后，当替换页面时，操作系统可以简单地扫描系统中的所有时间字段以找到最近最少使用的页面。\n\n不幸的是，随着系统中页面数量的增长，扫描大量的时间只是为了找到绝对最近最少使用的页面是非常昂贵的。想象一下一台具有 4GB 内存的现代机器，被分成 4KB 页面。这台机器有 100 万个页面，因此即使在现代 CPU 速度下，找到 LRU 页面也需要很长时间。这就引出了一个问题：我们真的需要找到绝对最旧的页面来替换吗？我们可以通过近似来代替吗？\n\n\n# 8 近似LRU\n\n事实证明，答案是肯定的：从计算开销的角度来看，近似 LRU 更可行，而且实际上许多现代系统都是这么做的。这个想法需要一些硬件支持，以使用位（有时称为引用位）的形式，其中第一个是在第一个具有分页的系统，Atlas one-level store中实现的。系统的每一页都有一个使用位，并且使用位存在于内存中的某个位置（例如，它们可能位于每个进程的页表中，或者只是位于某个数组中）。每当引用页面（即读取或写入）时，硬件都会将使用位设置为 1。不过，硬件永远不会清除该位（即将其设置为 0）；这是操作系统的责任。\n\n操作系统如何利用使用位位来近似LRU？嗯，可能有很多方法，但时钟算法提出了一种简单的方法。想象一下系统的所有页面排列在一个循环列表中。时钟指针首先指向某个特定的页面（哪一页并不重要）。当必须进行替换时，操作系统会检查当前指向的页面 P 的使用位是否为 1 或 0。如果为 1，则意味着页面 P 最近被使用过，因此不是替换的良好候选者。因此，P 的使用位设置为 0（清除），并且时钟指针递增到下一页 (P + 1)。该算法继续进行，直到找到一个设置为 0 的使用位，这意味着该页面最近没有被使用过（或者，在最坏的情况下，所有页面都已被使用过，并且我们现在已经搜索了整个页面集，从而清除了所有位）。\n\n\n\n请注意，此方法并不是使用使用位来近似 LRU 的唯一方法。事实上，任何定期清除使用位，然后区分哪些页面使用 1 与 0 的位来决定替换哪个的方法都可以。 Corbato 的时钟算法只是一种早期方法，它取得了一些成功，并且具有不重复扫描所有内存寻找未使用页面的良好特性。\n\n时钟算法变体的行为如下图所示。\n\n\n\n该变体在进行替换时随机扫描页面；当它遇到引用位设置为 1 的页面时，它会清除该位（即将其设置为 0）；当它发现引用位设置为 0 的页面时，它会选择它作为受害者。正如您所看到的，虽然它的表现不如完美的 LRU，但它比根本不考虑历史的方法要好。\n\n\n# 9 考虑脏位（在时钟算法中）\n\n对时钟算法（最初也是由 Corbato提出的）的一个小修改是，在内存中额外考虑页面是否被修改。这样做的原因是：如果一个页面被修改过，因而是脏的，就必须将其写回磁盘以将其剔除，而这是很昂贵的。如果页面未被修改（因此是干净的），则剔除是免费的；物理页可以简单地重新用于其他目的，而无需额外的 I/O。因此，一些虚拟机系统更倾向于驱逐干净的页面，而不是脏页面。\n\n为支持这种行为，硬件应包含一个修改位（又称脏位）。该位在任何页面被写入时都会被设置，因此可被纳入页面替换算法中。例如，时钟算法可以修改为首先扫描未使用且干净的页面，然后再扫描未使用且脏的页面，以此类推。\n\n\n# 10 其他VM策略\n\n页面替换并不是VM子系统采用的唯一策略（尽管它可能是最重要的）。例如，操作系统还必须决定何时将页面放入内存。该策略有时称为页面选择策略，为操作系统提供了一些不同的选项。\n\n对于大多数页面，操作系统仅使用按需分页，这意味着操作系统在访问页面时将页面调入内存，可以说是“按需”。当然，操作系统可以猜测某个页面即将被使用，从而提前将其引入；这种行为称为预取，只有在有合理的成功机会时才应执行。例如，某些系统会假设如果将代码页 P 放入内存中，则该代码页 P+1 可能很快就会被访问，因此也应该放入内存中。\n\n\n\n另一个策略决定操作系统如何将页面写入磁盘。当然，它们可以简单地一次写出一个；然而，许多系统反而将大量待处理的写入集中在内存中，并通过一次（更有效的）写入将它们写入磁盘。这种行为通常称为集群或简单的写入分组，并且由于磁盘驱动器的性质而有效，磁盘驱动器执行单个大写操作比许多小写操作更有效。\n\n\n# 11 抖动\n\n当内存被过度占用，运行进程的内存需求超过了可用的物理内存时，操作系统该怎么办？在这种情况下，系统会不断地分页，这种情况有时被称为 “抖动”（thrashing）。\n\n\n\n一些早期的操作系统有一套相当复杂的机制，可以检测并处理发生的抖动。例如，在给定一组进程的情况下，系统可以决定不运行其中的一个子进程集，希望减少的进程集的工作集（它们正在积极使用的页面）能够适合内存，从而取得进展。这种方法通常被称为 "准入控制"（acmission control），它指出，有时少做一点工作比什么都做不好要好，这是我们在现实生活和现代计算机系统中经常遇到的情况。\n\n当前的一些系统对内存超载采取了更为严厉的措施。例如，某些版本的 Linux 会在内存被超量占用时运行一个 "内存不足杀手"；这个守护进程会选择一个内存密集型进程并将其杀死，从而以一种不太明显的方式减少内存。这种方法虽然能成功减少内存压力，但也会带来一些问题，例如，它可能会杀死 X 服务器，从而导致任何需要显示的应用程序无法使用。',normalizedContent:'在虚拟内存管理器中，当您拥有大量可用内存时，生活会很容易。发生页面错误时，您在空闲页面列表中找到一个空闲页面，并将其分配给发生错误的页面。嘿，操作系统，恭喜！你又这么做了。\n\n不幸的是，当空闲内存很少时，事情就会变得更有趣。在这种情况下，这种内存压力会迫使操作系统开始调出页面，为主动使用的页面腾出空间。决定调出哪个页面（或哪些页面）封装在操作系统的替换策略中；从历史上看，这是早期虚拟内存系统做出的最重要的决定之一，因为较旧的系统几乎没有物理内存。至少，这是一套值得更多了解的有趣政策。因此我们的问题关键是：操作系统如何决定从内存中驱逐哪一页（或多页）？这一决定是由系统的替换策略做出的，该策略通常遵循一些一般原则（如下所述），但也包括某些调整以避免极端情况行为。\n\n\n# 1 缓存管理\n\n在深入讨论策略之前，我们首先更详细地描述我们试图解决的问题。鉴于主内存保存系统中所有页面的某些子集，它可以正确地被视为系统中虚拟内存页面的缓存。因此，我们为此缓存选择替换策略的目标是最小化缓存未命中的次数，即最小化我们必须从磁盘获取页面的次数。或者，我们的目标可以视为最大化缓存命中数，即在内存中找到被访问页面的次数。\n\n了解缓存命中和未命中的次数后，我们可以计算程序的平均内存访问时间 (average memory access time, amat)（计算机架构师计算硬件缓存的度量标准]）。具体来说，给定这些值，我们可以计算程序的 amat，如下所示：\n\namat=tm+pmiss⋅td\\text{amat}=\\text{t}_m+\\text{p}_{miss}\\cdot\\text{t}_\\text{d} amat=tm +pmiss ⋅td\n\n其中tm\\text{t}_mtm 表示访问内存的成本，td\\text{t}_dtd 表示访问磁盘的成本，tmiss\\text{t}_\\text{miss}tmiss 是在缓存中找不到数据的概率（未命中）； tmiss\\text{t}_\\text{miss}tmiss 从 0.0 到 1.0 不等，有时我们指的是丢失率百分比而不是概率（例如，10% 的丢失率意味着 tmiss=0.10\\text{t}_\\text{miss}=0.10tmiss =0.10）。请注意，您总是要为访问内存中的数据付出代价；然而，当您未命中时，您必须额外支付从磁盘获取数据的成本。\n\n例如，让我们想象一台具有（微小）地址空间的机器：4kb，具有 256 字节页面。因此，虚拟地址有两个组成部分：4 位 vpn（最高有效位）和 8 位偏移量（最低有效位）。因此，该示例中的进程总共可以访问 242^424 或 16 个虚拟页。在此示例中，进程生成以下内存引用（即虚拟地址）：0x000、0x100、0x200、0x300、0x400、0x500、0x600、0x700、0x800、0x900。这些虚拟地址指的是地址空间前十页中每一页的第一个字节（页号是每个虚拟地址的第一个十六进制数字）。\n\n让我们进一步假设除虚拟页 3 之外的所有页都已在内存中。因此，我们的内存引用序列将遇到以下行为：命中，命中，命中，未命中，命中，命中，命中，命中，命中，命中。我们可以计算命中率（在内存中找到的引用的百分比）：90%，因为十分之九的引用在内存中。因此，为命中率率为 10%（pmiss=0.10\\text{p}_\\text{miss}=0.10pmiss =0.10）。一般情况下，phit+pmiss=0.10=1.0\\text{p}_\\text{hit}+\\text{p}_\\text{miss}=0.10=1.0phit +pmiss =0.10=1.0；命中率加上未命中率之和为 100%。\n\n为了计算amat，我们需要知道访问内存的成本和访问磁盘的成本。假设访问内存的成本 (tm ) 约为 100 纳秒，访问磁盘的成本 (td ) 约为 10 毫秒，则我们有以下 amat：100ns + 0.1 · 10ms，即 100ns + 1ms，即 1.0001 ms，或大约1毫秒。如果我们的命中率为 99.9%（pmiss = 0.001），结果就完全不同：amat 为 10.1 微秒，或者大约快 100 倍。当命中率接近 100% 时，amat 接近 100 纳秒。\n\n不幸的是，正如您在此示例中所看到的，现代系统中磁盘访问的成本非常高，即使很小的未命中率也会很快主导正在运行的程序的整体 amat。显然，我们需要尽可能避免未命中或以磁盘速率缓慢运行。解决这个问题的一种方法是仔细制定明智的策略，就像我们现在所做的那样。\n\n\n# 2 最佳替换策略\n\n为了更好地理解特定替换策略的工作原理，最好将其与最佳替换策略进行比较。事实证明，belady多年前就提出了这样一种最佳策略（他最初称之为 min）。最佳替换策略会导致总体未命中次数最少。belady 证明了一种简单（但不幸的是，很难实现！）的方法，即替换未来访问距离最远的页面是最佳策略，它能带来尽可能少的缓存缺失。\n\n> tip：与最优算法进行比较是有用的\n> \n> 虽然最优算法作为实际策略并不实用，但在模拟或其他研究中作为比较点却非常有用。如果说你的新算法有 80% 的命中率，这并没有任何意义；如果说最优算法有 82% 的命中率（因此你的新方法非常接近最优算法），这将使结果更有意义，并赋予其背景。因此，在你进行的任何研究中，知道最佳值是什么可以让你进行更好的比较，显示还有多少改进的可能，以及什么时候你可以停止改进你的策略，因为它已经足够接近理想值了。\n\n希望最优策略背后的直觉是有道理的。你可以这样想：如果你必须扔掉某个页面，为什么不扔掉离现在最远的那个页面呢？这样做实质上是在说，缓存中的所有其他页面都比最远的那一页更重要。原因很简单：在访问最远的那一页之前，你会先访问其他页面。\n\n让我们通过一个简单的例子来了解最优策略的决策。假设一个程序访问以下虚拟页面流：0, 1, 2, 0, 1, 3, 0, 3, 1, 2, 1。下图显示了最优策略的行为，假设缓存可以容纳三个页面。\n\n\n\n从图中可以看到以下操作。毫不奇怪，前三次访问都是未命中，因为高速缓存一开始是空的；这种未命中有时被称为冷启动未命中（或强制未命中）。然后我们再次访问第 0 页和第 1 页，它们都在缓存中被命中。最后，我们又发生了一次缺失（第 3 页），但这次缓存已满，必须进行替换！这就引出了一个问题：我们应该替换哪一页？根据最优策略，我们可以检查当前缓存中每个页面（0、1 和 2）的未来访问情况，发现 0 页面几乎会立即被访问，1 页面会稍后被访问，而 2 页面在未来会被访问得最远。因此，最优策略很容易做出选择：删除第 2 页，这样缓存中就有了第 0、1 和 3 页。接下来的三个引用都是命中的，但我们到了 2 页时，却又遭遇了一次未命中。在这里，最优策略再次检查了缓存中每个页面（0、1 和 3）的未来访问情况，发现只要不驱逐第 1 页（即将被访问），我们就不会有问题。示例显示第 3 页被驱逐，尽管第 0 页也可以被驱逐。最后，我们命中了第 1 页，跟踪完成。\n\n我们还可以计算缓存的命中率：在 6 次命中和 5 次未命中的情况下，命中率为hitshits+misses\\frac{\\text{hits}}{\\text{hits+misses}}hits+misseshits 命中+未命中，即 66+5\\frac{6}{6+5}6+56 或 54.5%。我们还可以计算强制未命中的命中率（即忽略对给定页面的第一次未命中），结果是命中率为 85.7%。\n\n遗憾的是，正如我们之前在开发调度策略时所看到的，未来并不普遍为人所知；你不可能为通用操作系统构建最优策略。因此，在开发真正的、可部署的策略时，我们将重点关注那些能找到其他方法来决定驱逐哪个页面的方法。因此，最佳策略只能作为一个比较点，以了解我们离 "完美 "还有多远。\n\n> 缓存未命中的类型\n> \n> 在计算机体系结构领域，架构师有时发现按类型将未命中特征分为以下三类之一很有用：强制、容量和冲突未命中，有时称为 3 c。发生强制未命中（或冷启动未命中）是因为缓存一开始就是空的，并且这是对该项目的第一次引用；相反，由于缓存空间不足，必须逐出一个项目才能将新项目放入缓存，因此会发生容量未命中。第三种类型的未命中（冲突未命中）出现在硬件中，因为由于所谓的“组关联性”（setassociativity），项目可以放置在硬件缓存中的位置受到限制。它不会出现在操作系统页面缓存中，因为此类缓存始终是完全关联的，即页面可以放置在内存中的位置没有限制。\n\n\n# 3 fifo（先进先出策略）\n\n许多早期系统避免了尝试接近最优的复杂性，而是采用了非常简单的替换策略。例如，一些系统使用 fifo（先进先出）替换，其中页面在进入系统时被简单地放置在队列中；当发生替换时，队列尾部的页面（“先入”页面）将被逐出。 fifo 有一个很大的优点：实现起来非常简单。\n\n如下图所示，为 fifo 在我们的示例引用流上的表现。我们再次以对页面 0、1 和 2 的三个强制未命中开始跟踪，然后命中 0 和 1。接下来，引用第 3 页，导致未命中；使用 fifo 进行替换决策很容易：选择第一个页面（图中的缓存状态按 fifo 顺序保存，第一个页面位于左侧），即第 0 页。不幸的是，我们的下一个访问是页 0，导致另一次丢失和替换（页 1）。然后我们命中了第 3 页，但第 1 和第 2 页未命中，最后命中了第 1 页。\n\n将 fifo 与最佳值相比，fifo 的命中率明显更差：36.4% 的命中率（或 57.1%，不包括强制命中率）。 fifo 根本无法确定块的重要性：即使页 0 已被访问多次，fifo 仍然会将其踢出，仅仅因为它是第一个进入内存的块。\n\n\n\n> belady 的异常\n> \n> belady（最优策略提出者）和同事发现了一个有趣的引用流，其行为有点出乎意料。内存引用流：1,2,3,4,1,2,5,1,2,3,4,5。他们研究的替换策略是先进先出。有趣的部分是：当缓存大小从 3 页移动到 4 页时，缓存命中率如何变化。一般来说，当缓存变大时，您会期望缓存命中率会增加（变得更好）。但在这种情况下，如果使用 fifo，情况会变得更糟！这种奇怪的行为通常被称为belady 的异常。其他一些策略，例如 lru，不会遇到这个问题。事实证明，lru 具有所谓的堆栈属性 。对于具有此属性的算法，大小为 n + 1 的缓存自然包含大小为 n 的缓存的内容。因此，当增加缓存大小时，命中率将保持不变或提高。 fifo 和 random（以及其他）显然不遵守堆栈属性，因此容易受到异常行为的影响。\n\n\n# 4 随机策略\n\n另一种类似的替换策略是随机策略，它只是在内存压力下选择随机页面进行替换。 random 具有与 fifo 类似的属性；它实现起来很简单，但它并没有真正尝试太智能地选择要驱逐的块。如下图所示，让我们看看 random 在我们著名的示例引用流上的表现如何。\n\n\n\n当然，random 的表现完全取决于 random 在其选择中的幸运（或不幸）程度。在上面的例子中，random 的表现比 fifo 好一点，比最优的差一点。事实上，我们可以运行随机实验数千次并确定它的总体表现。\n\n下图显示了 random 在 10,000 多次试验中实现了多少次命中，每次试验都有不同的随机种子。正如您所看到的，有时（仅超过 40% 的时间），random 与最佳效果一样好，在示例跟踪上实现了 6 个命中；有时效果更糟，达到 2 次或更少。随机抽奖的效果如何取决于抽奖的运气。\n\n\n\n\n# 5 使用历史记录：lru\n\n不幸的是，任何像 fifo 或 random 这样简单的策略都可能存在一个常见问题：它可能会踢出一个重要的页面，而该页面将被再次引用。 fifo踢出最先带入的页面；如果这恰好是一个带有重要代码或数据结构的页面，那么它无论如何都会被丢弃，即使它很快就会被分页回来。因此，fifo、random和类似的策略不太可能达到最佳效果；需要更智能的东西。\n\n正如我们对调度策略所做的那样，为了改善我们对未来的猜测，我们再次依靠过去并以历史为指导。例如，如果一个程序在不久的过去访问过一个页面，那么它很可能在不久的将来再次访问它。\n\n页面替换策略可以使用的一类历史信息是频率。如果一个页面已被访问多次，也许它不应该被替换，因为它显然具有某些价值。页面的一个更常用的属性是访问时间；页面被访问的时间越近，也许就越有可能被再次访问。\n\n这一系列策略基于人们所说的局部性原则 ，这基本上只是对程序及其行为的观察。这个原则的意思很简单，就是程序倾向于非常频繁地访问某些代码序列（例如，在循环中）和数据结构（例如，循环访问的数组）；因此，我们应该尝试使用历史记录来找出哪些页面是重要的，并在驱逐时将这些页面保留在内存中。\n\n因此，一系列简单的基于历史的算法诞生了。当必须进行逐出时，最不常用 (lfu) 策略会替换最不常用的页面。类似地，最近最少使用（lru）策略替换最近最少使用的页面。这些算法很容易记住：一旦您知道名称，您就确切地知道它的作用，这是名称的一个极好的属性。\n\n为了更好地理解 lru，我们来看看 lru 在示例引用流上的表现，如下图所示。\n\n\n\n从图中，您可以看到 lru 如何利用历史记录比 random 或 fifo 等无状态策略做得更好。在示例中，lru 在第一次必须替换页面时会逐出页面 2，因为最近访问过页面 0 和 1。然后它会替换第 0 页，因为最近访问了第 1 页和第 3 页。在这两种情况下，lru 基于历史的决定都被证明是正确的，因此下一个引用会被命中。因此，在我们的示例中，lru 表现得尽可能好，其性能达到最佳水平。\n\n我们还应该注意到，这些算法存在相反的情况：最常用（mfu）和最近使用（mru）。在大多数情况下（不是全部！），这些策略效果不佳，因为它们忽略了大多数程序所展示的局部性，而不是利用它。\n\n> 局部性的类型\n> \n> 程序往往会表现出两种局部性。第一种是空间局部性，即如果一个页面 p 被访问，那么它周围的页面（如 p - 1 或 p + 1）也很可能被访问。第二种是时间局部性，即在不久的将来，在过去被访问过的页面很可能会再次被访问。存在这些类型的局部性的假设在硬件系统的缓存层次结构中发挥着重要作用，硬件系统部署多个级别的指令、数据和地址转换缓存，以帮助程序在存在此类局部性时快速运行。\n> \n> 当然，通常所说的局部性原则并不是所有程序都必须遵守的硬性规定。事实上，有些程序以相当随机的方式访问内存（或磁盘），在其访问流中并不表现出太多或任何局部性。因此，在设计任何类型的缓存（硬件或软件）时，虽然局部性是一个值得牢记的好东西，但它并不能保证成功。相反，它是一种启发式方法，在计算机系统设计中经常被证明是有用的。\n\n\n# 6 工作负载实例\n\n让我们再看几个例子，以便更好地理解其中一些策略的行为方式。在这里，我们将检查更复杂的工作负载而不是小跟踪。然而，即使是这些工作负载也被大大简化了；更好的研究将包括应用程序跟踪。\n\n我们的第一个工作负载没有局部性，这意味着每个引用都是对访问页面集中的随机页面。在这个简单的示例中，工作负载随着时间的推移访问 100 个唯一页面，随机选择下一个页面进行引用；总共访问了 10,000 个页面。在实验中，我们将缓存大小从非常小（1 页）更改为足以容纳所有唯一页面（100 页），以便了解每个策略在缓存大小范围内的行为方式。\n\n下图绘制了最优、lru、随机和 fifo 的实验结果。图中的y轴表示每个策略达到的命中率； x 轴改变缓存大小。\n\n\n\n我们可以从图中得出许多结论。首先，当工作负载不存在局部性时，您使用哪种实际策略并不重要； lru、fifo 和 random 的执行方式都是相同的，命中率完全由缓存的大小决定。其次，当缓存足够大以适应整个工作负载时，使用哪种策略也并不重要；当所有引用的块都适合缓存时，所有策略（甚至随机）都会收敛到 100% 命中率。最后，您可以看到最优策略的性能明显优于现实策略；如果可能的话，展望未来可以更好地进行替代。\n\n我们研究的下一个工作负载称为“80-20”工作负载，它表现出局部性：80% 的引用是针对 20% 的页面（“热门”页面）；其余 20% 的引用是针对其余 80% 的页面（“冷”页面）。在我们的工作负载中，总共有 100 个不同的页面；因此，大部分时间都引用“热”页面，其余时间引用“冷”页面。下图显示了策略如何在此工作负载下执行。\n\n\n\n从图中可以看出，虽然随机和 fifo 都表现得相当好，但 lru 表现更好，因为它更有可能保留热点页；由于这些页面过去曾被频繁引用，因此很可能在不久的将来再次被引用。 optimal 再次表现更好，说明 lru 的历史信息并不完美。\n\n您现在可能想知道：lru 相对于 random 和 fifo 的改进真的有那么大吗？答案是“视情况而定”。如果每次未命中的成本都非常高（并不罕见），那么即使命中率小幅增加（为命中率降低）也会对性能产生巨大影响。如果未命中的代价不那么高，那么 lru 可能带来的好处当然就不那么重要了。\n\n让我们看一下最终的工作负载。我们将其称为“循环顺序”工作负载，因为在其中，我们按顺序引用 50 个页面，从 0 开始，然后是 1，...，直到第 49 页，然后我们循环，重复这些访问，以获得对 50 个唯一页面的总共 10,000 次访问。下图显示了该工作负载下策略的行为。\n\n\n\n这种工作负载在许多应用程序（包括重要的商业应用程序，例如数据库）中很常见，代表了 lru 和 fifo 的最坏情况。这些算法在循环顺序工作负载下会踢出旧页面；不幸的是，由于工作负载的循环性质，这些较旧的页面将比策略希望保留在缓存中的页面更早被访问。事实上，即使缓存大小为 49，50 页的循环顺序工作负载也会导致 0% 的命中率。有趣的是，随机的效果明显更好，虽然还没有完全接近最佳，但至少实现了非零命中率。事实证明随机有一些很好的特性；其中一个属性就是没有奇怪的极端行为。\n\n\n# 7 实现历史算法\n\n正如您所看到的，lru 等算法通常比 fifo 或随机等简单策略做得更好，后者可能会丢弃重要的页面。不幸的是，历史策略给我们带来了新的挑战：我们如何实现它们？\n\n我们以 lru 为例。为了完美地实现它，我们需要做大量的工作。具体来说，在每次页面访问（即每次内存访问，无论是指令提取还是加载或存储）时，我们必须更新某些数据结构以将此页面移动到列表的前面（即 mru 侧）。与 fifo 相比，只有当页面被逐出（通过删除最先进入的页面）或将新页面添加到列表（最后进入的一侧）时，才会访问 fifo 页面列表。为了跟踪哪些页面被最少和最近使用，系统必须在每次内存引用上进行一些统计工作。显然，如果不小心处理，这种统计工作可能会大大降低性能。\n\n一种有助于加快速度的方法是添加一点硬件支持。例如，机器可以在每次页面访问时更新内存中的时间字段（例如，这可能位于每个进程的页表中，或者仅位于内存中的某个单独的数组中，系统中的每个物理页有一个条目）。因此，当访问页面时，时间字段将由硬件设置为当前时间。然后，当替换页面时，操作系统可以简单地扫描系统中的所有时间字段以找到最近最少使用的页面。\n\n不幸的是，随着系统中页面数量的增长，扫描大量的时间只是为了找到绝对最近最少使用的页面是非常昂贵的。想象一下一台具有 4gb 内存的现代机器，被分成 4kb 页面。这台机器有 100 万个页面，因此即使在现代 cpu 速度下，找到 lru 页面也需要很长时间。这就引出了一个问题：我们真的需要找到绝对最旧的页面来替换吗？我们可以通过近似来代替吗？\n\n\n# 8 近似lru\n\n事实证明，答案是肯定的：从计算开销的角度来看，近似 lru 更可行，而且实际上许多现代系统都是这么做的。这个想法需要一些硬件支持，以使用位（有时称为引用位）的形式，其中第一个是在第一个具有分页的系统，atlas one-level store中实现的。系统的每一页都有一个使用位，并且使用位存在于内存中的某个位置（例如，它们可能位于每个进程的页表中，或者只是位于某个数组中）。每当引用页面（即读取或写入）时，硬件都会将使用位设置为 1。不过，硬件永远不会清除该位（即将其设置为 0）；这是操作系统的责任。\n\n操作系统如何利用使用位位来近似lru？嗯，可能有很多方法，但时钟算法提出了一种简单的方法。想象一下系统的所有页面排列在一个循环列表中。时钟指针首先指向某个特定的页面（哪一页并不重要）。当必须进行替换时，操作系统会检查当前指向的页面 p 的使用位是否为 1 或 0。如果为 1，则意味着页面 p 最近被使用过，因此不是替换的良好候选者。因此，p 的使用位设置为 0（清除），并且时钟指针递增到下一页 (p + 1)。该算法继续进行，直到找到一个设置为 0 的使用位，这意味着该页面最近没有被使用过（或者，在最坏的情况下，所有页面都已被使用过，并且我们现在已经搜索了整个页面集，从而清除了所有位）。\n\n\n\n请注意，此方法并不是使用使用位来近似 lru 的唯一方法。事实上，任何定期清除使用位，然后区分哪些页面使用 1 与 0 的位来决定替换哪个的方法都可以。 corbato 的时钟算法只是一种早期方法，它取得了一些成功，并且具有不重复扫描所有内存寻找未使用页面的良好特性。\n\n时钟算法变体的行为如下图所示。\n\n\n\n该变体在进行替换时随机扫描页面；当它遇到引用位设置为 1 的页面时，它会清除该位（即将其设置为 0）；当它发现引用位设置为 0 的页面时，它会选择它作为受害者。正如您所看到的，虽然它的表现不如完美的 lru，但它比根本不考虑历史的方法要好。\n\n\n# 9 考虑脏位（在时钟算法中）\n\n对时钟算法（最初也是由 corbato提出的）的一个小修改是，在内存中额外考虑页面是否被修改。这样做的原因是：如果一个页面被修改过，因而是脏的，就必须将其写回磁盘以将其剔除，而这是很昂贵的。如果页面未被修改（因此是干净的），则剔除是免费的；物理页可以简单地重新用于其他目的，而无需额外的 i/o。因此，一些虚拟机系统更倾向于驱逐干净的页面，而不是脏页面。\n\n为支持这种行为，硬件应包含一个修改位（又称脏位）。该位在任何页面被写入时都会被设置，因此可被纳入页面替换算法中。例如，时钟算法可以修改为首先扫描未使用且干净的页面，然后再扫描未使用且脏的页面，以此类推。\n\n\n# 10 其他vm策略\n\n页面替换并不是vm子系统采用的唯一策略（尽管它可能是最重要的）。例如，操作系统还必须决定何时将页面放入内存。该策略有时称为页面选择策略，为操作系统提供了一些不同的选项。\n\n对于大多数页面，操作系统仅使用按需分页，这意味着操作系统在访问页面时将页面调入内存，可以说是“按需”。当然，操作系统可以猜测某个页面即将被使用，从而提前将其引入；这种行为称为预取，只有在有合理的成功机会时才应执行。例如，某些系统会假设如果将代码页 p 放入内存中，则该代码页 p+1 可能很快就会被访问，因此也应该放入内存中。\n\n\n\n另一个策略决定操作系统如何将页面写入磁盘。当然，它们可以简单地一次写出一个；然而，许多系统反而将大量待处理的写入集中在内存中，并通过一次（更有效的）写入将它们写入磁盘。这种行为通常称为集群或简单的写入分组，并且由于磁盘驱动器的性质而有效，磁盘驱动器执行单个大写操作比许多小写操作更有效。\n\n\n# 11 抖动\n\n当内存被过度占用，运行进程的内存需求超过了可用的物理内存时，操作系统该怎么办？在这种情况下，系统会不断地分页，这种情况有时被称为 “抖动”（thrashing）。\n\n\n\n一些早期的操作系统有一套相当复杂的机制，可以检测并处理发生的抖动。例如，在给定一组进程的情况下，系统可以决定不运行其中的一个子进程集，希望减少的进程集的工作集（它们正在积极使用的页面）能够适合内存，从而取得进展。这种方法通常被称为 "准入控制"（acmission control），它指出，有时少做一点工作比什么都做不好要好，这是我们在现实生活和现代计算机系统中经常遇到的情况。\n\n当前的一些系统对内存超载采取了更为严厉的措施。例如，某些版本的 linux 会在内存被超量占用时运行一个 "内存不足杀手"；这个守护进程会选择一个内存密集型进程并将其杀死，从而以一种不太明显的方式减少内存。这种方法虽然能成功减少内存压力，但也会带来一些问题，例如，它可能会杀死 x 服务器，从而导致任何需要显示的应用程序无法使用。',charsets:{cjk:!0},lastUpdated:"2024/05/11, 20:33:38",lastUpdatedTimestamp:1715430818e3},{title:"完整VM系统",frontmatter:{title:"完整VM系统",tags:["OS"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},date:"2024-04-25T22:40:44.000Z",permalink:"/pages/9f0f28/",categories:["开发","系统架构","操作系统","虚拟化"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/02.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/18.%E5%AE%8C%E6%95%B4VM%E7%B3%BB%E7%BB%9F.html",relativePath:"01.开发/05.系统架构/02.操作系统/18.完整VM系统.md",key:"v-4e18d034",path:"/pages/9f0f28/",headers:[{level:2,title:"1 VAX/VMS 虚拟内存",slug:"_1-vax-vms-虚拟内存",normalizedTitle:"1 vax/vms 虚拟内存",charIndex:538},{level:3,title:"1.1 内存管理硬件",slug:"_1-1-内存管理硬件",normalizedTitle:"1.1 内存管理硬件",charIndex:1076},{level:2,title:"1.2 真实的地址空间",slug:"_1-2-真实的地址空间",normalizedTitle:"1.2 真实的地址空间",charIndex:1983},{level:3,title:"1.3 页面替换",slug:"_1-3-页面替换",normalizedTitle:"1.3 页面替换",charIndex:3094},{level:3,title:"1.4 其他妙招",slug:"_1-4-其他妙招",normalizedTitle:"1.4 其他妙招",charIndex:4519},{level:2,title:"2 Lnux 虚拟内存系统",slug:"_2-lnux-虚拟内存系统",normalizedTitle:"2 lnux 虚拟内存系统",charIndex:5628},{level:3,title:"2.1 Linux 地址空间",slug:"_2-1-linux-地址空间",normalizedTitle:"2.1 linux 地址空间",charIndex:5948},{level:3,title:"2.2 页表结构",slug:"_2-2-页表结构",normalizedTitle:"2.2 页表结构",charIndex:7185},{level:3,title:"2.3 大页面支持",slug:"_2-3-大页面支持",normalizedTitle:"2.3 大页面支持",charIndex:7937},{level:3,title:"2.4 页面缓存",slug:"_2-4-页面缓存",normalizedTitle:"2.4 页面缓存",charIndex:9024},{level:3,title:"2.5 安全和缓冲区溢出",slug:"_2-5-安全和缓冲区溢出",normalizedTitle:"2.5 安全和缓冲区溢出",charIndex:11043},{level:3,title:"2.6 其他安全问题：熔断漏洞和幽灵漏洞",slug:"_2-6-其他安全问题-熔断漏洞和幽灵漏洞",normalizedTitle:"2.6 其他安全问题：熔断漏洞和幽灵漏洞",charIndex:12822}],headersStr:"1 VAX/VMS 虚拟内存 1.1 内存管理硬件 1.2 真实的地址空间 1.3 页面替换 1.4 其他妙招 2 Lnux 虚拟内存系统 2.1 Linux 地址空间 2.2 页表结构 2.3 大页面支持 2.4 页面缓存 2.5 安全和缓冲区溢出 2.6 其他安全问题：熔断漏洞和幽灵漏洞",content:'在结束对虚拟内存的研究之前，让我们仔细看看整个虚拟内存系统是如何组合起来的。我们已经看到了此类系统的关键要素，包括大量页表设计、与 TLB 的交互（有时甚至由操作系统本身处理），以及决定将哪些页保留在内存中、将哪些页踢出内存的策略。然而，还有许多其他特性构成了一个完整的虚拟内存系统，其中包括许多性能、功能和安全特性。这就是我们的关键所在：如何构建完整的虚拟内存系统？实现完整的虚拟内存系统需要哪些功能？它们如何提高性能、增强安全性或改进系统？\n\n为此，我们将介绍两个系统。第一个系统是 "现代 "虚拟内存管理器的最早范例之一，即 20 世纪 70 年代和 80 年代初开发的 VAX/VMS 操作系统 。有些想法，即使是 50 年前的想法，仍然值得了解，这种想法对于大多数其他领域（如物理学）的人来说是众所周知的，但在技术驱动型学科（如计算机科学）中却不得不说。\n\n其次是 Linux，原因显而易见。Linux 是一种广泛使用的系统，可以在小到功率不足的手机系统，大到现代数据中心中最具扩展性的多核系统上有效运行。因此，其虚拟机系统必须足够灵活，以便在所有这些场景中成功运行。我们将对每个系统进行讨论，以说明如何将前面章节中提出的概念整合到一个完整的内存管理器中。\n\n\n# 1 VAX/VMS 虚拟内存\n\nVAX-11 微型计算机体系结构由Digital Equipment Corporation (DEC) 于 20 世纪 70 年代末推出。在微型计算机时代，DEC 是计算机行业的巨头；不幸的是，一系列错误的决策和 PC 的出现慢慢地（但肯定地）导致了它们的消亡，。该架构有多种实现形式，包括 VAX-11/780 和功能较弱的 VAX-11/750。\n\n该系统的操作系统被称为 VAX/VMS（或简称 VMS），其主要设计者之一是 Dave Cutler，他后来领导开发了微软的 Windows NT [C93]。VMS 存在一个普遍的问题，即它可以在各种机器上运行，包括非常便宜的 VAXen（是的，这是正确的复数）到同一架构系列中的极其高端和强大的机器。因此，操作系统必须拥有能够在如此广泛的系统中发挥作用（并且运作良好）的机制和策略。\n\n另外一个问题是，VMS 是利用软件创新来掩盖体系结构固有缺陷的一个极好例子。尽管操作系统经常依赖硬件来构建有效的抽象和幻象，但有时硬件设计者并不能完全做到万无一失；在 VAX 硬件中，我们将看到一些这样的例子，以及 VMS 操作系统是如何克服这些硬件缺陷来构建一个有效的、可运行的系统的。\n\n\n# 1.1 内存管理硬件\n\nVAX-11 为每个进程提供 32 位虚拟地址空间，分为 512 字节页。因此，虚拟地址由 23 位 VPN 和 9 位偏移量组成。此外，VPN 的上两位用于区分页面所在的分段；因此，如前所述，该系统是分页和分段的混合体。\n\n地址空间的下半部分被称为 "进程空间"，每个进程都是唯一的。在进程空间的前半部分（称为 P0），可以找到用户程序以及向下增长的堆。在进程空间的后半部（P1），我们可以找到向上生长的栈。地址空间的上半部分称为系统空间（S），但只有一半被使用。受保护的操作系统代码和数据存放在这里，操作系统以这种方式在各进程间共享。\n\nVMS 设计人员的一个主要顾虑是，VAX 硬件中的页面大小（512 字节）小得令人难以置信。由于历史原因而选择的这种大小存在一个基本问题，即简单的线性页表过于庞大。因此，VMS 设计人员的首要目标之一就是确保 VMS 不会因为页表而使内存不堪重负。系统通过两种方式减轻了页表对内存的压力。首先，VAX-11 将用户地址空间划分为两个区域，VAX-11为每个进程的每个区域（P0 和 P1）提供一个页表；因此，栈和堆之间未使用的地址空间部分不需要页表空间。基址寄存器和边界寄存器的使用正如你所期望的那样；基址寄存器保存该段的页表地址，边界寄存器保存其大小（即页表条目数）。\n\n其次，操作系统将用户页表（P0 和 P1，每个进程两个）置于内核虚拟内存中，从而进一步降低了内存压力。因此，在分配或增长页表时，内核会从自己的虚拟内存 S 段中分配空间。如果内存压力过大，内核可以将这些页表的页交换到磁盘，从而将物理内存用于其他用途。\n\n将页表放在内核虚拟内存中意味着地址转换变得更加复杂。例如，要转换 P0 或 P1 中的虚拟地址，硬件必须首先尝试在其页表（该进程的 P0 或 P1 页表）中查找该页的页表条目；但在此过程中，硬件可能必须首先查阅系统页表（位于物理内存中）；完成转换后，硬件才能了解页表中的页面地址，然后最终了解所需内存访问的地址。幸运的是，VAX 硬件管理的 TLB 使所有这一切都变得更快，通常（希望）可以避免这种费力的查找。\n\n\n# 1.2 真实的地址空间\n\n研究 VMS 的一个好处是，我们可以看到真实地址空间是如何构建的，如下图所示。\n\n\n\n到目前为止，我们假设的地址空间很简单，只有用户代码、用户数据和用户堆，但正如上文所述，真实的地址空间要复杂得多。例如，代码段永远不会从第 0 页开始，而是标记为不可访问，以便为检测空指针访问提供一些支持。因此，在设计地址空间时，需要考虑的一个问题就是对调试的支持，而不可访问的 0 页在某种程度上提供了这种支持。\n\n> 为什么空指针访问会导致 SEG 错误？\n> \n> 你现在应该对解引用空指针时发生的情况有了很好的了解。一个进程生成了一个虚拟地址 0，具体方法如下：\n> \n> int *p = NULL; // set p = 0 \n> *p = 10; // try to store 10 to virtual addr 0\n> \n> \n> 1\n> 2\n> \n> 1\n> 2\n> \n> \n> 硬件尝试在 TLB 中查找 VPN（此处也是 0），结果导致 TLB 未命中。查阅页表后发现，VPN 0 的条目被标记为无效。这样，我们就有了一个无效访问，它将控制权转移到操作系统，而操作系统可能会终止进程（在 UNIX 系统中，进程会收到一个信号，允许它们对此类故障做出反应；但如果未被捕获，进程就会被杀死）。\n\n也许更重要的是，内核虚拟地址空间（即其数据结构和代码）是每个用户地址空间的一部分。在上下文切换时，操作系统会更改 P0 和 P1 寄存器，使其指向即将运行的进程的相应页表；但不会更改 S 基寄存器和边界寄存器，因此 "相同的 "内核结构会映射到每个用户地址空间。\n\n内核被映射到每个地址空间的原因有很多。举例来说，当操作系统从用户程序（例如在 write() 系统调用中）得到一个指针时，很容易将指针中的数据复制到自己的结构中。操作系统是自然编写和编译的，无需担心访问的数据来自何处。相反，如果内核完全位于物理内存中，就很难做到将页表中的页面交换到磁盘这样的事情；如果内核有自己的地址空间，在用户应用程序和内核之间移动数据又会变得复杂而痛苦。有了这种结构（现在被广泛使用），内核几乎就成了应用程序的一个库，尽管是受保护的库。\n\n关于这个地址空间的最后一点与保护有关。显然，操作系统不希望用户应用程序读写操作系统的数据或代码。因此，硬件必须为页面提供不同的保护级别。VAX 就是这样做的，它在页表的保护位中规定了 CPU 访问特定页面必须达到的权限级别。因此，系统数据和代码的保护级别要高于用户数据和代码；如果试图从用户代码访问此类信息，就会向操作系统发出中断，违规进程很可能会被终止。\n\n\n# 1.3 页面替换\n\nVAX 中的页表项 (PTE) 包含以下位：一个有效位、一个保护字段（4 位）、一个修改（或脏）位、一个保留给操作系统使用的字段（5 位），最后是一个物理页号（PFN），用于存储页在物理内存中的位置。精明的读者可能会注意到：没有引用位！因此，VMS 替换算法必须在没有硬件支持的情况下确定哪些页面处于活动状态。\n\n> 模拟参考位\n> \n> 事实证明，你并不需要硬件引用位来获得系统中正在使用的页面的概念。事实上，早在 20 世纪 80 年代初，Babaoglu 和 Joy 就证明 VAX 的保护位可以用来模拟参考位。基本原理：如果想了解系统中哪些页面正在被活跃使用，可将页表中的所有页面标记为不可访问（但保留进程真正可访问的页面信息，可能在页表条目的 "保留操作系统字段 "部分）。当进程访问页面时，它将向操作系统发出一个中断；然后操作系统将检查该页面是否真的应该被访问，如果是，则将该页面恢复到正常的保护状态（如只读或读写）。在替换时，操作系统可以检查哪些页面仍然标记为不可访问，从而了解哪些页面最近没有被使用过。这种引用位 "仿真 "的关键在于减少开销，同时还能很好地了解页面的使用情况。操作系统在标记页面不可访问时不能过于激进，否则开销会过高。操作系统在标记页面时也不能太被动，否则所有页面最终都会被引用；操作系统也无法很好地知道应该驱逐哪个页面。\n\n开发人员还担心内存占用者，即占用大量内存并导致其他程序难以运行的程序。迄今为止，我们已经研究过的大多数策略都很容易出现这种占用内存的情况；例如，LRU 是一种全局策略，不能在进程之间公平地共享内存。\n\n为了解决这两个问题，开发人员提出了分段 FIFO 替换策略。这种策略的思路很简单：每个进程在内存中可保留的最大页数，即常驻集大小（RSS）。每个页面都保存在一个先进先出列表中；当一个进程超过其 RSS 时，"先进 "的页面就会被驱逐。FIFO 显然不需要任何硬件支持，因此很容易实现。\n\n当然，正如我们前面所看到的，纯粹的 FIFO 性能并不是特别好。为了提高 FIFO 的性能，VMS 引入了两个二次机会列表，即全局的干净页面列表和 脏页面 列表，用于放置从内存中驱逐前的页面。当进程 P 超过其 RSS 时，会从其每个进程的 FIFO 中移除一个页面；如果是干净页面（未修改），则将其放在干净页面列表的末尾；如果是脏页面（已修改），则将其放在脏页面列表的末尾。\n\n如果另一个进程 Q 需要一个空闲页面，它会从全局干净页面列表中获取第一个空闲页面。但是，如果原进程 P 在该页被回收前发生错误，P 会从空闲（或脏页）列表中回收该页，从而避免了代价高昂的磁盘访问。这些全局二次机会列表越大，分段 FIFO 算法的性能就越接近 LRU。\n\nVMS 中使用的另一种优化方法也有助于克服 VMS 中的小页面问题。具体来说，由于页面太小，磁盘在交换过程中的 I/O 效率会非常低，因为磁盘在进行大容量传输时效率更高。为了提高交换 I/O 的效率，VMS 增加了许多优化功能，其中最重要的是集群功能。通过集群，VMS 将全局脏页面列表中的大批量页面集中在一起，然后一次性将它们写入磁盘（从而使它们变得干净）。集群技术在大多数现代系统中都得到了应用，因为可以自由地将页面放置在交换空间的任何位置，这使得操作系统可以对页面进行分组，执行更少、更大的写入操作，从而提高性能。\n\n\n# 1.4 其他妙招\n\nVMS 还有两个现在已成为标准的技巧：需求清零和写时复制。现在我们就来介绍一下这些懒惰优化。VMS（以及大多数现代系统）中的一种懒惰形式是页面的需求清零。为了更好地理解这一点，让我们以在地址空间（比如在堆中）中添加一个页面为例。在最简单的实现中，操作系统会在物理内存中找到一个页面，将其清零（这是为了安全起见，否则你就能看到其他进程使用该页面时页面上的内容了！），然后将其映射到地址空间（即设置页表，以便根据需要引用该物理页面），以此来响应向堆中添加页面的请求。但这种天真的实现方式代价高昂，尤其是当该页面未被进程使用时。\n\n通过需求清零，当页面被添加到地址空间时，操作系统只需做很少的工作；它会在页表中添加一个条目，标记该页面不可访问。如果进程读取或写入该页面，操作系统就会收到一个中断。在处理中断时，操作系统会注意到（通常是通过在页表项的 "为操作系统保留 "部分标记的某些位）这实际上是一个需要清零的页面；此时，操作系统会进行必要的工作，找到一个物理页，将其清零，并映射到进程的地址空间中。如果进程从不访问该页，所有这些工作都可以避免，这就是需求清零的优点。\n\nVMS 中另一个很酷的优化（同样，几乎所有现代操作系统中都有这种优化）是写时复制（简称 COW）。这个概念至少可以追溯到 TENEX 操作系统，它的原理很简单：当操作系统需要将一个页面从一个地址空间复制到另一个地址空间时，它可以不复制该页面，而是将其映射到目标地址空间，并在两个地址空间中都标记为只读。如果两个地址空间都只读取该页面，则不会采取进一步的操作，这样操作系统就实现了快速复制，而实际上没有移动任何数据。\n\n但是，如果其中一个地址空间确实尝试向该页面写入数据，则会向操作系统发出中断。操作系统会注意到该页是 COW 页，从而（懒散地）分配一个新页，将数据填入其中，并将这个新页映射到故障进程的地址空间。然后该进程继续运行，现在它拥有自己的页面私有副本。\n\n由于多种原因，COW 非常有用。当然，任何类型的共享库都可以通过写时复制映射到许多进程的地址空间，从而节省宝贵的内存空间。在 UNIX 系统中，由于 fork() 和 exec() 的语义，COW 甚至更为重要。你可能还记得，fork() 会创建一个调用者地址空间的精确副本；如果地址空间很大，创建这样的副本既慢又耗费数据。更糟糕的是，大部分地址空间会立即被后续的 exec() 调用所覆盖，这将使调用进程的地址空间与即将执行的程序的地址空间重叠。通过执行写入时复制 fork()，操作系统避免了大部分不必要的复制，从而在提高性能的同时保留了正确的语义。\n\n\n# 2 Lnux 虚拟内存系统\n\n现在我们将讨论 Linux VM 系统的一些更有趣的方面。 Linux 的发展是由真正的工程师解决生产中遇到的实际问题推动的，因此大量的功能已经慢慢地融入到现在功能齐全、功能齐全的虚拟内存系统中。\n\n虽然我们无法讨论 Linux VM 的各个方面，但我们将讨论最重要的方面，特别是它超出了 VAX/VMS 等经典 VM 系统中的范围。我们还将尝试强调 Linux 和旧系统之间的共性。\n\n在本次讨论中，我们将重点关注适用于 Intel x86 的 Linux。虽然 Linux 可以而且确实在许多不同的处理器架构上运行，但 x86 上的 Linux 是其最主要和最重要的部署，因此也是我们关注的焦点。\n\n\n# 2.1 Linux 地址空间\n\n与其他现代操作系统和 VAX/VMS 一样，Linux 虚拟地址空间由用户部分（用户程序代码、栈、堆和其他部分所在）和内核部分（内核代码、栈、堆和其他部分所在）组成。与其他系统一样，在上下文切换时，当前运行的地址空间的用户部分会发生变化；而内核部分则在不同进程中保持不变。与其他系统一样，在用户模式下运行的程序也无法访问内核虚拟页；只有进入内核并转换到特权模式，才能访问这些内存。\n\n在经典的 32 位 Linux（即具有 32 位虚拟地址空间的 Linux）中，用户和内核地址空间的分割发生在地址 0xC0000000，即地址空间的四分之三处。因此，虚拟地址 0 到 0xBFFFFFFF 是用户虚拟地址；其余的虚拟地址（0xC0000000 到 0xFFFFFFFF）属于内核虚拟地址空间。64 位 Linux 也有类似的分割，但分割点略有不同。\n\n下图 显示了典型（简化）地址空间的描述。\n\n\n\nLinux 的一个有趣之处在于它包含两种内核虚拟地址。第一种称为内核逻辑地址 。内核代码只需调用 kmalloc 即可获得更多此类内存。大多数内核数据结构都在这里，如页表、每个进程的内核栈等。与系统中的大多数其他内存不同，内核逻辑内存不能交换到磁盘。\n\n内核逻辑地址最有趣的地方在于它们与物理内存的联系。具体来说，内核逻辑地址与物理内存的第一部分之间存在直接映射关系。因此，内核逻辑地址 0xC0000000 相当于物理地址 0x00000000，0xC0000FFF 相当于 0x00000FFF，以此类推。这种直接映射有两个意义。首先，在内核逻辑地址和物理地址之间来回转换非常简单；因此，这些地址通常被当作物理地址来处理。其次，如果一块内存在内核逻辑地址空间中是连续的，那么它在物理内存中也是连续的。这使得在内核地址空间的这一部分分配的内存适用于需要连续物理内存才能正常工作的操作，例如通过目录内存访问 (DMA) 进行设备间的 I/O 传输。\n\n另一种内核地址是内核虚拟地址。要获取这种类型的内存，内核代码会调用不同的分配器 vmalloc，该分配器会返回一个指向所需大小的虚拟连续区域的指针。与内核逻辑内存不同，内核虚拟内存通常不是连续的；每个内核虚拟页都可能映射到非连续的物理页（因此不适合 DMA）。不过，这样的内存更容易分配，因此可用于大型缓冲区，而要在这些缓冲区中找到连续的大块物理内存则非常困难。\n\n在 32 位 Linux 中，内核虚拟地址存在的另一个原因是，它们能让内核寻址超过（大约）1 GB 的内存。多年前，机器的内存比现在少得多，因此访问超过 1 GB 的内存不是问题。然而，随着技术的进步，很快就需要让内核使用更大的内存。内核虚拟地址和它们与物理内存一对一的严格映射关系使这成为可能。不过，随着向 64 位 Linux 迁移，这种需求就不那么迫切了，因为内核不再局限于最后 1 GB 的虚拟地址空间。\n\n\n# 2.2 页表结构\n\n由于我们关注的是 x86 的 Linux，因此我们的讨论将围绕 x86 提供的页表结构类型展开，因为它决定了 Linux 能做什么、不能做什么。如上所述，x86 提供了一种硬件管理的多级页表结构，每个进程有一个页表；操作系统只需在内存中设置映射，将特权寄存器指向页目录的起始位置，剩下的就交给硬件处理了。操作系统会在进程创建、删除和上下文切换时参与其中，确保硬件 MMU 在每种情况下都使用正确的页表进行转换。\n\n近年来最大的变化可能就是从 32 位 x86 迁移到 64 位 x86（如上文所述）。正如在 VAX/VMS 系统中看到的那样，32 位地址空间已经存在了很长时间，随着技术的变化，它们终于开始成为程序的真正限制。虚拟内存使系统编程变得容易，但由于现代系统包含许多 GB 内存，32 位已不足以引用每个内存。因此，下一次飞跃成为必要。\n\n迁移到 64 位地址会以预期的方式影响 x86 中的页表结构。因为 x86 使用的是多级页表，而当前的 64 位系统使用的是四级页表。不过，虚拟地址空间的全部 64 位尚未使用，而仅使用了最下面的 48 位。因此，虚拟地址可以这样理解：\n\n\n\n如图所示，虚拟地址的前 16 位未使用（因此在转换中不起作用），后 12 位（由于 4 KB 页面大小）用作偏移量（因此直接使用，没有转换），留下虚拟地址的中间36位参与转换。地址的 P1 部分用于索引最顶层的页目录，并且从那里开始进行转换，一次一层，直到页表的实际页被 P4 索引，产生所需的页表条目。\n\n随着系统内存变得更大，这个庞大的地址空间的更多部分将被启用，从而导致五级和最终六级页表树结构。想象一下：一个简单的页表查找需要六级转换，只是为了找出某个数据在内存中的位置。\n\n\n# 2.3 大页面支持\n\nIntel x86 允许使用多种页面大小，而不仅仅是标准的 4 KB 页面。具体来说，最近的设计在硬件中支持 2 MB 甚至 1 GB 页面。因此，随着时间的推移，Linux 已经发展到允许应用程序利用这些大页面。正如前面所暗示的，使用大页面会带来很多好处。正如 VAX/VMS 中所见，这样做可以减少页表中所需的映射数量；页面越大，映射越少。然而，较少的页表条目并不是大页面背后的驱动力；相反，它是更好的 TLB 行为和相关的性能提升。\n\n当进程主动使用大量内存时，它会很快用转换填满 TLB。如果这些转换针对 4 KB 页面，则只能访问少量的总内存，而不会导致 TLB 未命中。其结果是，对于在具有许多GB内存的机器上运行的现代“大内存”工作负载来说，会带来显著的性能成本；最近的研究表明，一些应用程序将其周期的10%用于服务TLB未命中。\n\n大页面允许进程通过使用 TLB 中较少的槽来访问大片内存而不会发生 TLB 未命中，因此这是主要优点。然而，大页面还有其他好处：TLB 未命中路径较短，这意味着当发生 TLB 未命中时，可以更快地对其进行处理。此外，分配可以非常快（在某些情况下），这是一个很小但有时很重要的好处。\n\nLinux 对大页面的支持的一个有趣的方面是它是如何逐步实现的。起初，Linux 开发人员知道这种支持仅对少数应用程序很重要，例如具有严格性能要求的大型数据库。因此，决定允许应用程序显式请求大页面内存分配（通过 mmap() 或 shmget() 调用）。这样，大多数应用程序将不受影响（并且继续仅使用 4 KB 页面；一些要求较高的应用程序将不得不更改为使用这些接口，但对它们来说这是值得的。\n\n最近，由于许多应用程序对更好的 TLB 行为的需求更加普遍，Linux 开发人员添加了透明大页面支持。启用此功能后，操作系统会自动寻找机会分配大页面（通常为 2 MB，但在某些系统上为 1 GB），而无需修改应用程序。\n\n大页面并非没有代价。最大的潜在成本是内部碎片，即页面很大但很少使用。这种形式的浪费可能会用大量但很少使用的页面填充内存。交换（如果启用）也不能很好地处理大页面，有时会大大增加系统的 I/O 量。分配的开销也可能很糟糕（在某些其他情况下）。总的来说，有一件事是明确的：多年来为系统提供良好服务的 4 KB 页面大小不再像以前那样是通用解决方案；不断增长的内存大小要求我们将大页面和其他解决方案视为虚拟内存系统必要发展的一部分。 Linux 对这种基于硬件的技术的缓慢采用证明了即将发生的变化。\n\n\n# 2.4 页面缓存\n\n为了降低访问持久存储的成本，大多数系统使用积极的缓存子系统将常用的数据项保留在内存中。在这方面，Linux 与传统操作系统没有什么不同。\n\nLinux 页面缓存是统一的，将来自三个主要来源的页面保留在内存中：内存映射文件、来自设备的文件数据和元数据（通常通过直接对文件系统进行 read() 和 write() 调用来访问）以及堆和栈组成每个进程的页面（有时称为匿名内存，因为它下面没有命名文件，而是交换空间）。这些实体保存在页面缓存哈希表中，以便在需要所述数据时可以快速查找。\n\n> 内存映射的普遍性\n> \n> 内存映射早于 Linux 出现了好几年，并在 Linux 和其他现代系统中的许多地方使用。这个想法很简单：通过在已经打开的文件描述符上调用 mmap()，进程将返回一个指向文件内容似乎所在的虚拟内存区域开头的指针。然后，通过使用该指针，进程可以通过简单的指针解引用来访问文件的任何部分。\n> \n> 对内存映射文件中尚未进入内存的部分的访问会触发页面错误，此时操作系统将分页相关数据，并通过相应地更新进程的页表来使其可访问（即，请求分页） ）。\n> \n> 每个常规 Linux 进程都使用内存映射文件，即使 main() 中的代码也不会直接调用 mmap()，因为 Linux 将代码从可执行文件和共享库代码加载到内存中。下面是 pmap 命令行工具的（高度缩写）输出，它显示了哪些不同的映射构成了正在运行的程序（shell，在本例中为 tcsh）的虚拟地址空间。输出显示四列：映射的虚拟地址、其大小、区域的保护位以及映射源：\n> \n> 映射的虚拟地址            大小      区域的保护位   映射源\n> 0000000000400000   372K    r-x--    tcsh\n> 00000000019d5000   1780K   rw---    [anon]\n> 00007f4e7cf06000   1792K   r-x--    libc-2.23.so\n> 00007f4e7d2d0000   36K     r-x--    libcrypt-2.23.so\n> 00007f4e7d508000   148K    r-x--    libtinfo.so.5.9\n> 00007f4e7d731000   152K    r-x--    ld-2.23.so\n> 00007f4e7d932000   16K     rw---    [stack]\n> \n> 正如你可以看到的输出中，来自 tcsh 二进制文件的代码以及来自 libc、libcrypt、libtinfo 的代码以及来自动态链接器本身 (ld.so) 的代码都映射到地址空间。还存在两个匿名区域：堆（第二个条目，标记为 anon）和栈（标记为 stack）。内存映射文件为操作系统构建现代地址空间提供了一种简单有效的方法\n\n页面缓存会跟踪条目是否干净（读取但未更新）或脏（又称修改）。脏数据由后台线程（称为 pdflush）定期写入后备存储（即，写入文件数据的特定文件，或交换匿名区域的空间），从而确保修改后的数据最终被写回持久存储。此后台活动要么在特定时间段后发生，要么在太多页面被视为脏页时发生（均为可配置参数）。\n\n在某些情况下，系统运行时内存不足，Linux 必须决定从内存中剔除哪些页面以释放空间。为此，Linux 使用 2Q 替换的改进形式，我们在此进行描述。\n\n基本思想很简单：标准 LRU 替换是有效的，但可能会被某些常见的访问模式颠覆。例如，如果一个进程重复访问一个大文件（尤其是接近内存大小或更大的文件），LRU 会将所有其他文件踢出内存。更糟糕的是：将该文件的部分内容保留在内存中没有用，因为它们在被踢出内存之前永远不会被重新引用。\n\nLinux 版本的 2Q 替换算法通过保留两个列表并在它们之间划分内存来解决这个问题。第一次访问时，一个页面被放入一个队列（原论文中称为A1，但Linux中为非活动列表）；当它被重新引用时，该页面会被提升到另一个队列（原来称为Aq，但在Linux中称为活动列表）。当需要进行替换时，从非活动列表中取出替换候选者。 Linux 还定期将页面从活动列表底部移动到非活动列表，使活动列表保持在总页面缓存大小的三分之二左右。\n\n理想情况下，Linux 会以完美的 LRU 顺序管理这些列表，但是，正如前面章节中所讨论的，这样做的成本很高。因此，与许多操作系统一样，使用 LRU 的近似值（类似于时钟替换）。\n\n这种 2Q 方法的行为通常与 LRU 非常相似，但在处理循环访问大文件的情况时，其显著特点是将循环访问的页面限制在非活动列表中。由于这些页面在被踢出内存之前从未被重新引用过，因此它们不会冲掉活动列表中的其他有用页面。\n\n\n# 2.5 安全和缓冲区溢出\n\n现代 VM 系统（Linux、Solaris 或 BSD 变体之一）与古代 VM 系统（VAX/VMS）之间的最大区别可能是现代对安全性的重视。保护一直是操作系统的一个严重问题，但随着机器的互联程度比以往任何时候都更加紧密，开发人员实施了各种防御对策来阻止那些狡猾的黑客获得系统控制权也就不足为奇了。\n\n缓冲区溢出攻击是一种主要威胁，它可以针对普通用户程序甚至内核本身。这些攻击的目的是找到目标系统中的错误，使攻击者可以将任意数据注入目标的地址空间。有时会出现此类漏洞，因为开发人员（错误地）假设输入不会太长，因此（可信地）将输入复制到缓冲区中；因为输入实际上太长，所以它会溢出缓冲区，从而覆盖目标的内存。像下面这样无辜的代码可能是问题的根源：\n\nint some_function(char *input) {\n\tchar dest_buffer[100];\n\tstrcpy(dest_buffer, input); // oops, unbounded copy!\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n在许多情况下，这种溢出并不会造成灾难性后果，例如，无意地向用户程序甚至操作系统提供不良输入可能会导致系统崩溃，但不会更糟。然而，恶意程序员可以精心设计使缓冲区溢出的输入，以便将自己的代码注入目标系统，从而接管系统并为所欲为。如果攻击网络连接的用户程序成功，攻击者就可以在被攻击的系统上运行任意计算，甚至出租计算资源；如果攻击操作系统本身成功，攻击者就可以访问更多资源，这就是所谓的权限升级（即用户代码获得内核访问权限）。\n\n防止缓冲区溢出的第一道也是最简单的一道防线就是防止在地址空间的特定区域（如栈内）执行任何代码。AMD 在其 x86 版本中引入的 NX 位（No-eXecute 的缩写）（英特尔版本中也有类似的 XD 位）就是这样一种防御措施；它只需阻止在相应页表条目中设置了该位的任何页面的执行。这种方法可以防止攻击者注入目标栈的代码被执行，从而减轻了问题。\n\n然而，聪明的攻击者是......聪明的，即使攻击者不能显示添加注入的代码，恶意代码也能执行任意代码序列。这种想法以其最普遍的形式被称为返回导向编程（return-oriented programming, ROP）[S07]，它确实非常出色。ROP 背后的原理是，任何程序的地址空间中都有大量的代码位（用 ROP 术语来说就是小工具），尤其是与庞大的 C 库链接的 C 程序。因此，攻击者可以覆盖栈，使当前执行函数中的返回地址指向所需的恶意指令（或一系列指令），然后再返回指令。通过串联大量小工具（即确保每次返回都跳转到下一个小工具），攻击者可以执行任意代码。\n\n为了抵御 ROP（包括其早期形式，返回到库攻击（return-to-libc 攻击）），Linux（和其他系统）增加了另一种防御手段，即地址空间布局随机化（ASLR）。操作系统不是将代码、栈和堆放在虚拟地址空间内的固定位置，而是将它们的位置随机化，从而使实现这类攻击所需的复杂代码序列变得相当具有挑战性。因此，针对易受攻击的用户程序的大多数攻击都会导致程序崩溃，但无法控制运行中的程序。\n\n有趣的是，在实践中可以很容易地观察到这种随机性。下面是一段在现代 Linux 系统上演示的代码：\n\nint main(int argc, char *argv[]) {\n\tint stack = 0;\n\tprintf("%p\\n", &stack);\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n这段代码只是打印出堆栈中变量的（虚拟）地址。在较早的非 ASLR 系统中，该值每次都是相同的。但如下所示，每次运行时，该值都会发生变化：\n\n> ./random\n0x7ffd3e55d2b4\n> ./random\n0x7ffe1033b8f4\n> ./random\n0x7ffe45522e94\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\nASLR 对于用户级程序来说是一种非常有用的防御手段，因此它也被纳入了内核，并被称为内核地址空间布局随机化（KASLR）。然而，事实证明，内核可能有更大的问题需要处理，正如我们接下来要讨论的那样。\n\n\n# 2.6 其他安全问题：熔断漏洞和幽灵漏洞\n\n系统安全世界已经被两个新的相关攻击颠覆了。第一个叫做 "熔毁"（Meltdown），第二个叫做 "幽灵"（Spectre）。它们是由四组不同的研究人员/工程师在差不多同一时间发现的，并引发了对计算机硬件和上述操作系统所提供的基本保护措施的深刻质疑。有关每种攻击的详细描述，请参见 meltdownattack.com 和 spectreattack.com。幽灵被认为是这两种攻击中问题较多的一种。\n\n这些攻击所利用的一般弱点是，现代系统中的 CPU 会在幕后执行各种疯狂的技巧来提高性能。其中一类技术是问题的核心，被称为 "预测执行"，即 CPU 猜测哪些指令将在未来执行，并提前开始执行。如果猜测正确，程序运行速度就会加快；如果猜测不正确，CPU就会撤消这些指令对架构状态（如寄存器）的影响，并再次尝试执行，这一次会沿着正确的路径运行。\n\n预测的问题在于，它往往会在系统的各个部分（如处理器缓存、分支预测器等）留下执行痕迹。因此，问题就出现了：正如攻击事件的作者所展示的，这种状态会使内存内容变得脆弱，甚至是我们认为受到 MMU 保护的内存。\n\n因此，加强内核保护的一个途径就是尽可能地将内核地址空间从每个用户进程中移除，转而为大多数内核数据建立一个独立的内核页表（称为内核页表隔离，或 KPTI）[G+17]。这样，内核的代码和数据结构就不再映射到每个进程中，而是只保留最基本的部分；当切换到内核时，就需要切换到内核页表。这样做提高了安全性，避免了一些攻击向量，但也付出了代价：性能。切换页表的代价很高。安全的代价：方便和性能。\n\n不幸的是，KPTI 并不能解决上述所有安全问题，只能解决部分问题。而简单的解决方案，如关闭预测功能，也没有多大意义，因为系统运行速度会降低数千倍。',normalizedContent:'在结束对虚拟内存的研究之前，让我们仔细看看整个虚拟内存系统是如何组合起来的。我们已经看到了此类系统的关键要素，包括大量页表设计、与 tlb 的交互（有时甚至由操作系统本身处理），以及决定将哪些页保留在内存中、将哪些页踢出内存的策略。然而，还有许多其他特性构成了一个完整的虚拟内存系统，其中包括许多性能、功能和安全特性。这就是我们的关键所在：如何构建完整的虚拟内存系统？实现完整的虚拟内存系统需要哪些功能？它们如何提高性能、增强安全性或改进系统？\n\n为此，我们将介绍两个系统。第一个系统是 "现代 "虚拟内存管理器的最早范例之一，即 20 世纪 70 年代和 80 年代初开发的 vax/vms 操作系统 。有些想法，即使是 50 年前的想法，仍然值得了解，这种想法对于大多数其他领域（如物理学）的人来说是众所周知的，但在技术驱动型学科（如计算机科学）中却不得不说。\n\n其次是 linux，原因显而易见。linux 是一种广泛使用的系统，可以在小到功率不足的手机系统，大到现代数据中心中最具扩展性的多核系统上有效运行。因此，其虚拟机系统必须足够灵活，以便在所有这些场景中成功运行。我们将对每个系统进行讨论，以说明如何将前面章节中提出的概念整合到一个完整的内存管理器中。\n\n\n# 1 vax/vms 虚拟内存\n\nvax-11 微型计算机体系结构由digital equipment corporation (dec) 于 20 世纪 70 年代末推出。在微型计算机时代，dec 是计算机行业的巨头；不幸的是，一系列错误的决策和 pc 的出现慢慢地（但肯定地）导致了它们的消亡，。该架构有多种实现形式，包括 vax-11/780 和功能较弱的 vax-11/750。\n\n该系统的操作系统被称为 vax/vms（或简称 vms），其主要设计者之一是 dave cutler，他后来领导开发了微软的 windows nt [c93]。vms 存在一个普遍的问题，即它可以在各种机器上运行，包括非常便宜的 vaxen（是的，这是正确的复数）到同一架构系列中的极其高端和强大的机器。因此，操作系统必须拥有能够在如此广泛的系统中发挥作用（并且运作良好）的机制和策略。\n\n另外一个问题是，vms 是利用软件创新来掩盖体系结构固有缺陷的一个极好例子。尽管操作系统经常依赖硬件来构建有效的抽象和幻象，但有时硬件设计者并不能完全做到万无一失；在 vax 硬件中，我们将看到一些这样的例子，以及 vms 操作系统是如何克服这些硬件缺陷来构建一个有效的、可运行的系统的。\n\n\n# 1.1 内存管理硬件\n\nvax-11 为每个进程提供 32 位虚拟地址空间，分为 512 字节页。因此，虚拟地址由 23 位 vpn 和 9 位偏移量组成。此外，vpn 的上两位用于区分页面所在的分段；因此，如前所述，该系统是分页和分段的混合体。\n\n地址空间的下半部分被称为 "进程空间"，每个进程都是唯一的。在进程空间的前半部分（称为 p0），可以找到用户程序以及向下增长的堆。在进程空间的后半部（p1），我们可以找到向上生长的栈。地址空间的上半部分称为系统空间（s），但只有一半被使用。受保护的操作系统代码和数据存放在这里，操作系统以这种方式在各进程间共享。\n\nvms 设计人员的一个主要顾虑是，vax 硬件中的页面大小（512 字节）小得令人难以置信。由于历史原因而选择的这种大小存在一个基本问题，即简单的线性页表过于庞大。因此，vms 设计人员的首要目标之一就是确保 vms 不会因为页表而使内存不堪重负。系统通过两种方式减轻了页表对内存的压力。首先，vax-11 将用户地址空间划分为两个区域，vax-11为每个进程的每个区域（p0 和 p1）提供一个页表；因此，栈和堆之间未使用的地址空间部分不需要页表空间。基址寄存器和边界寄存器的使用正如你所期望的那样；基址寄存器保存该段的页表地址，边界寄存器保存其大小（即页表条目数）。\n\n其次，操作系统将用户页表（p0 和 p1，每个进程两个）置于内核虚拟内存中，从而进一步降低了内存压力。因此，在分配或增长页表时，内核会从自己的虚拟内存 s 段中分配空间。如果内存压力过大，内核可以将这些页表的页交换到磁盘，从而将物理内存用于其他用途。\n\n将页表放在内核虚拟内存中意味着地址转换变得更加复杂。例如，要转换 p0 或 p1 中的虚拟地址，硬件必须首先尝试在其页表（该进程的 p0 或 p1 页表）中查找该页的页表条目；但在此过程中，硬件可能必须首先查阅系统页表（位于物理内存中）；完成转换后，硬件才能了解页表中的页面地址，然后最终了解所需内存访问的地址。幸运的是，vax 硬件管理的 tlb 使所有这一切都变得更快，通常（希望）可以避免这种费力的查找。\n\n\n# 1.2 真实的地址空间\n\n研究 vms 的一个好处是，我们可以看到真实地址空间是如何构建的，如下图所示。\n\n\n\n到目前为止，我们假设的地址空间很简单，只有用户代码、用户数据和用户堆，但正如上文所述，真实的地址空间要复杂得多。例如，代码段永远不会从第 0 页开始，而是标记为不可访问，以便为检测空指针访问提供一些支持。因此，在设计地址空间时，需要考虑的一个问题就是对调试的支持，而不可访问的 0 页在某种程度上提供了这种支持。\n\n> 为什么空指针访问会导致 seg 错误？\n> \n> 你现在应该对解引用空指针时发生的情况有了很好的了解。一个进程生成了一个虚拟地址 0，具体方法如下：\n> \n> int *p = null; // set p = 0 \n> *p = 10; // try to store 10 to virtual addr 0\n> \n> \n> 1\n> 2\n> \n> 1\n> 2\n> \n> \n> 硬件尝试在 tlb 中查找 vpn（此处也是 0），结果导致 tlb 未命中。查阅页表后发现，vpn 0 的条目被标记为无效。这样，我们就有了一个无效访问，它将控制权转移到操作系统，而操作系统可能会终止进程（在 unix 系统中，进程会收到一个信号，允许它们对此类故障做出反应；但如果未被捕获，进程就会被杀死）。\n\n也许更重要的是，内核虚拟地址空间（即其数据结构和代码）是每个用户地址空间的一部分。在上下文切换时，操作系统会更改 p0 和 p1 寄存器，使其指向即将运行的进程的相应页表；但不会更改 s 基寄存器和边界寄存器，因此 "相同的 "内核结构会映射到每个用户地址空间。\n\n内核被映射到每个地址空间的原因有很多。举例来说，当操作系统从用户程序（例如在 write() 系统调用中）得到一个指针时，很容易将指针中的数据复制到自己的结构中。操作系统是自然编写和编译的，无需担心访问的数据来自何处。相反，如果内核完全位于物理内存中，就很难做到将页表中的页面交换到磁盘这样的事情；如果内核有自己的地址空间，在用户应用程序和内核之间移动数据又会变得复杂而痛苦。有了这种结构（现在被广泛使用），内核几乎就成了应用程序的一个库，尽管是受保护的库。\n\n关于这个地址空间的最后一点与保护有关。显然，操作系统不希望用户应用程序读写操作系统的数据或代码。因此，硬件必须为页面提供不同的保护级别。vax 就是这样做的，它在页表的保护位中规定了 cpu 访问特定页面必须达到的权限级别。因此，系统数据和代码的保护级别要高于用户数据和代码；如果试图从用户代码访问此类信息，就会向操作系统发出中断，违规进程很可能会被终止。\n\n\n# 1.3 页面替换\n\nvax 中的页表项 (pte) 包含以下位：一个有效位、一个保护字段（4 位）、一个修改（或脏）位、一个保留给操作系统使用的字段（5 位），最后是一个物理页号（pfn），用于存储页在物理内存中的位置。精明的读者可能会注意到：没有引用位！因此，vms 替换算法必须在没有硬件支持的情况下确定哪些页面处于活动状态。\n\n> 模拟参考位\n> \n> 事实证明，你并不需要硬件引用位来获得系统中正在使用的页面的概念。事实上，早在 20 世纪 80 年代初，babaoglu 和 joy 就证明 vax 的保护位可以用来模拟参考位。基本原理：如果想了解系统中哪些页面正在被活跃使用，可将页表中的所有页面标记为不可访问（但保留进程真正可访问的页面信息，可能在页表条目的 "保留操作系统字段 "部分）。当进程访问页面时，它将向操作系统发出一个中断；然后操作系统将检查该页面是否真的应该被访问，如果是，则将该页面恢复到正常的保护状态（如只读或读写）。在替换时，操作系统可以检查哪些页面仍然标记为不可访问，从而了解哪些页面最近没有被使用过。这种引用位 "仿真 "的关键在于减少开销，同时还能很好地了解页面的使用情况。操作系统在标记页面不可访问时不能过于激进，否则开销会过高。操作系统在标记页面时也不能太被动，否则所有页面最终都会被引用；操作系统也无法很好地知道应该驱逐哪个页面。\n\n开发人员还担心内存占用者，即占用大量内存并导致其他程序难以运行的程序。迄今为止，我们已经研究过的大多数策略都很容易出现这种占用内存的情况；例如，lru 是一种全局策略，不能在进程之间公平地共享内存。\n\n为了解决这两个问题，开发人员提出了分段 fifo 替换策略。这种策略的思路很简单：每个进程在内存中可保留的最大页数，即常驻集大小（rss）。每个页面都保存在一个先进先出列表中；当一个进程超过其 rss 时，"先进 "的页面就会被驱逐。fifo 显然不需要任何硬件支持，因此很容易实现。\n\n当然，正如我们前面所看到的，纯粹的 fifo 性能并不是特别好。为了提高 fifo 的性能，vms 引入了两个二次机会列表，即全局的干净页面列表和 脏页面 列表，用于放置从内存中驱逐前的页面。当进程 p 超过其 rss 时，会从其每个进程的 fifo 中移除一个页面；如果是干净页面（未修改），则将其放在干净页面列表的末尾；如果是脏页面（已修改），则将其放在脏页面列表的末尾。\n\n如果另一个进程 q 需要一个空闲页面，它会从全局干净页面列表中获取第一个空闲页面。但是，如果原进程 p 在该页被回收前发生错误，p 会从空闲（或脏页）列表中回收该页，从而避免了代价高昂的磁盘访问。这些全局二次机会列表越大，分段 fifo 算法的性能就越接近 lru。\n\nvms 中使用的另一种优化方法也有助于克服 vms 中的小页面问题。具体来说，由于页面太小，磁盘在交换过程中的 i/o 效率会非常低，因为磁盘在进行大容量传输时效率更高。为了提高交换 i/o 的效率，vms 增加了许多优化功能，其中最重要的是集群功能。通过集群，vms 将全局脏页面列表中的大批量页面集中在一起，然后一次性将它们写入磁盘（从而使它们变得干净）。集群技术在大多数现代系统中都得到了应用，因为可以自由地将页面放置在交换空间的任何位置，这使得操作系统可以对页面进行分组，执行更少、更大的写入操作，从而提高性能。\n\n\n# 1.4 其他妙招\n\nvms 还有两个现在已成为标准的技巧：需求清零和写时复制。现在我们就来介绍一下这些懒惰优化。vms（以及大多数现代系统）中的一种懒惰形式是页面的需求清零。为了更好地理解这一点，让我们以在地址空间（比如在堆中）中添加一个页面为例。在最简单的实现中，操作系统会在物理内存中找到一个页面，将其清零（这是为了安全起见，否则你就能看到其他进程使用该页面时页面上的内容了！），然后将其映射到地址空间（即设置页表，以便根据需要引用该物理页面），以此来响应向堆中添加页面的请求。但这种天真的实现方式代价高昂，尤其是当该页面未被进程使用时。\n\n通过需求清零，当页面被添加到地址空间时，操作系统只需做很少的工作；它会在页表中添加一个条目，标记该页面不可访问。如果进程读取或写入该页面，操作系统就会收到一个中断。在处理中断时，操作系统会注意到（通常是通过在页表项的 "为操作系统保留 "部分标记的某些位）这实际上是一个需要清零的页面；此时，操作系统会进行必要的工作，找到一个物理页，将其清零，并映射到进程的地址空间中。如果进程从不访问该页，所有这些工作都可以避免，这就是需求清零的优点。\n\nvms 中另一个很酷的优化（同样，几乎所有现代操作系统中都有这种优化）是写时复制（简称 cow）。这个概念至少可以追溯到 tenex 操作系统，它的原理很简单：当操作系统需要将一个页面从一个地址空间复制到另一个地址空间时，它可以不复制该页面，而是将其映射到目标地址空间，并在两个地址空间中都标记为只读。如果两个地址空间都只读取该页面，则不会采取进一步的操作，这样操作系统就实现了快速复制，而实际上没有移动任何数据。\n\n但是，如果其中一个地址空间确实尝试向该页面写入数据，则会向操作系统发出中断。操作系统会注意到该页是 cow 页，从而（懒散地）分配一个新页，将数据填入其中，并将这个新页映射到故障进程的地址空间。然后该进程继续运行，现在它拥有自己的页面私有副本。\n\n由于多种原因，cow 非常有用。当然，任何类型的共享库都可以通过写时复制映射到许多进程的地址空间，从而节省宝贵的内存空间。在 unix 系统中，由于 fork() 和 exec() 的语义，cow 甚至更为重要。你可能还记得，fork() 会创建一个调用者地址空间的精确副本；如果地址空间很大，创建这样的副本既慢又耗费数据。更糟糕的是，大部分地址空间会立即被后续的 exec() 调用所覆盖，这将使调用进程的地址空间与即将执行的程序的地址空间重叠。通过执行写入时复制 fork()，操作系统避免了大部分不必要的复制，从而在提高性能的同时保留了正确的语义。\n\n\n# 2 lnux 虚拟内存系统\n\n现在我们将讨论 linux vm 系统的一些更有趣的方面。 linux 的发展是由真正的工程师解决生产中遇到的实际问题推动的，因此大量的功能已经慢慢地融入到现在功能齐全、功能齐全的虚拟内存系统中。\n\n虽然我们无法讨论 linux vm 的各个方面，但我们将讨论最重要的方面，特别是它超出了 vax/vms 等经典 vm 系统中的范围。我们还将尝试强调 linux 和旧系统之间的共性。\n\n在本次讨论中，我们将重点关注适用于 intel x86 的 linux。虽然 linux 可以而且确实在许多不同的处理器架构上运行，但 x86 上的 linux 是其最主要和最重要的部署，因此也是我们关注的焦点。\n\n\n# 2.1 linux 地址空间\n\n与其他现代操作系统和 vax/vms 一样，linux 虚拟地址空间由用户部分（用户程序代码、栈、堆和其他部分所在）和内核部分（内核代码、栈、堆和其他部分所在）组成。与其他系统一样，在上下文切换时，当前运行的地址空间的用户部分会发生变化；而内核部分则在不同进程中保持不变。与其他系统一样，在用户模式下运行的程序也无法访问内核虚拟页；只有进入内核并转换到特权模式，才能访问这些内存。\n\n在经典的 32 位 linux（即具有 32 位虚拟地址空间的 linux）中，用户和内核地址空间的分割发生在地址 0xc0000000，即地址空间的四分之三处。因此，虚拟地址 0 到 0xbfffffff 是用户虚拟地址；其余的虚拟地址（0xc0000000 到 0xffffffff）属于内核虚拟地址空间。64 位 linux 也有类似的分割，但分割点略有不同。\n\n下图 显示了典型（简化）地址空间的描述。\n\n\n\nlinux 的一个有趣之处在于它包含两种内核虚拟地址。第一种称为内核逻辑地址 。内核代码只需调用 kmalloc 即可获得更多此类内存。大多数内核数据结构都在这里，如页表、每个进程的内核栈等。与系统中的大多数其他内存不同，内核逻辑内存不能交换到磁盘。\n\n内核逻辑地址最有趣的地方在于它们与物理内存的联系。具体来说，内核逻辑地址与物理内存的第一部分之间存在直接映射关系。因此，内核逻辑地址 0xc0000000 相当于物理地址 0x00000000，0xc0000fff 相当于 0x00000fff，以此类推。这种直接映射有两个意义。首先，在内核逻辑地址和物理地址之间来回转换非常简单；因此，这些地址通常被当作物理地址来处理。其次，如果一块内存在内核逻辑地址空间中是连续的，那么它在物理内存中也是连续的。这使得在内核地址空间的这一部分分配的内存适用于需要连续物理内存才能正常工作的操作，例如通过目录内存访问 (dma) 进行设备间的 i/o 传输。\n\n另一种内核地址是内核虚拟地址。要获取这种类型的内存，内核代码会调用不同的分配器 vmalloc，该分配器会返回一个指向所需大小的虚拟连续区域的指针。与内核逻辑内存不同，内核虚拟内存通常不是连续的；每个内核虚拟页都可能映射到非连续的物理页（因此不适合 dma）。不过，这样的内存更容易分配，因此可用于大型缓冲区，而要在这些缓冲区中找到连续的大块物理内存则非常困难。\n\n在 32 位 linux 中，内核虚拟地址存在的另一个原因是，它们能让内核寻址超过（大约）1 gb 的内存。多年前，机器的内存比现在少得多，因此访问超过 1 gb 的内存不是问题。然而，随着技术的进步，很快就需要让内核使用更大的内存。内核虚拟地址和它们与物理内存一对一的严格映射关系使这成为可能。不过，随着向 64 位 linux 迁移，这种需求就不那么迫切了，因为内核不再局限于最后 1 gb 的虚拟地址空间。\n\n\n# 2.2 页表结构\n\n由于我们关注的是 x86 的 linux，因此我们的讨论将围绕 x86 提供的页表结构类型展开，因为它决定了 linux 能做什么、不能做什么。如上所述，x86 提供了一种硬件管理的多级页表结构，每个进程有一个页表；操作系统只需在内存中设置映射，将特权寄存器指向页目录的起始位置，剩下的就交给硬件处理了。操作系统会在进程创建、删除和上下文切换时参与其中，确保硬件 mmu 在每种情况下都使用正确的页表进行转换。\n\n近年来最大的变化可能就是从 32 位 x86 迁移到 64 位 x86（如上文所述）。正如在 vax/vms 系统中看到的那样，32 位地址空间已经存在了很长时间，随着技术的变化，它们终于开始成为程序的真正限制。虚拟内存使系统编程变得容易，但由于现代系统包含许多 gb 内存，32 位已不足以引用每个内存。因此，下一次飞跃成为必要。\n\n迁移到 64 位地址会以预期的方式影响 x86 中的页表结构。因为 x86 使用的是多级页表，而当前的 64 位系统使用的是四级页表。不过，虚拟地址空间的全部 64 位尚未使用，而仅使用了最下面的 48 位。因此，虚拟地址可以这样理解：\n\n\n\n如图所示，虚拟地址的前 16 位未使用（因此在转换中不起作用），后 12 位（由于 4 kb 页面大小）用作偏移量（因此直接使用，没有转换），留下虚拟地址的中间36位参与转换。地址的 p1 部分用于索引最顶层的页目录，并且从那里开始进行转换，一次一层，直到页表的实际页被 p4 索引，产生所需的页表条目。\n\n随着系统内存变得更大，这个庞大的地址空间的更多部分将被启用，从而导致五级和最终六级页表树结构。想象一下：一个简单的页表查找需要六级转换，只是为了找出某个数据在内存中的位置。\n\n\n# 2.3 大页面支持\n\nintel x86 允许使用多种页面大小，而不仅仅是标准的 4 kb 页面。具体来说，最近的设计在硬件中支持 2 mb 甚至 1 gb 页面。因此，随着时间的推移，linux 已经发展到允许应用程序利用这些大页面。正如前面所暗示的，使用大页面会带来很多好处。正如 vax/vms 中所见，这样做可以减少页表中所需的映射数量；页面越大，映射越少。然而，较少的页表条目并不是大页面背后的驱动力；相反，它是更好的 tlb 行为和相关的性能提升。\n\n当进程主动使用大量内存时，它会很快用转换填满 tlb。如果这些转换针对 4 kb 页面，则只能访问少量的总内存，而不会导致 tlb 未命中。其结果是，对于在具有许多gb内存的机器上运行的现代“大内存”工作负载来说，会带来显著的性能成本；最近的研究表明，一些应用程序将其周期的10%用于服务tlb未命中。\n\n大页面允许进程通过使用 tlb 中较少的槽来访问大片内存而不会发生 tlb 未命中，因此这是主要优点。然而，大页面还有其他好处：tlb 未命中路径较短，这意味着当发生 tlb 未命中时，可以更快地对其进行处理。此外，分配可以非常快（在某些情况下），这是一个很小但有时很重要的好处。\n\nlinux 对大页面的支持的一个有趣的方面是它是如何逐步实现的。起初，linux 开发人员知道这种支持仅对少数应用程序很重要，例如具有严格性能要求的大型数据库。因此，决定允许应用程序显式请求大页面内存分配（通过 mmap() 或 shmget() 调用）。这样，大多数应用程序将不受影响（并且继续仅使用 4 kb 页面；一些要求较高的应用程序将不得不更改为使用这些接口，但对它们来说这是值得的。\n\n最近，由于许多应用程序对更好的 tlb 行为的需求更加普遍，linux 开发人员添加了透明大页面支持。启用此功能后，操作系统会自动寻找机会分配大页面（通常为 2 mb，但在某些系统上为 1 gb），而无需修改应用程序。\n\n大页面并非没有代价。最大的潜在成本是内部碎片，即页面很大但很少使用。这种形式的浪费可能会用大量但很少使用的页面填充内存。交换（如果启用）也不能很好地处理大页面，有时会大大增加系统的 i/o 量。分配的开销也可能很糟糕（在某些其他情况下）。总的来说，有一件事是明确的：多年来为系统提供良好服务的 4 kb 页面大小不再像以前那样是通用解决方案；不断增长的内存大小要求我们将大页面和其他解决方案视为虚拟内存系统必要发展的一部分。 linux 对这种基于硬件的技术的缓慢采用证明了即将发生的变化。\n\n\n# 2.4 页面缓存\n\n为了降低访问持久存储的成本，大多数系统使用积极的缓存子系统将常用的数据项保留在内存中。在这方面，linux 与传统操作系统没有什么不同。\n\nlinux 页面缓存是统一的，将来自三个主要来源的页面保留在内存中：内存映射文件、来自设备的文件数据和元数据（通常通过直接对文件系统进行 read() 和 write() 调用来访问）以及堆和栈组成每个进程的页面（有时称为匿名内存，因为它下面没有命名文件，而是交换空间）。这些实体保存在页面缓存哈希表中，以便在需要所述数据时可以快速查找。\n\n> 内存映射的普遍性\n> \n> 内存映射早于 linux 出现了好几年，并在 linux 和其他现代系统中的许多地方使用。这个想法很简单：通过在已经打开的文件描述符上调用 mmap()，进程将返回一个指向文件内容似乎所在的虚拟内存区域开头的指针。然后，通过使用该指针，进程可以通过简单的指针解引用来访问文件的任何部分。\n> \n> 对内存映射文件中尚未进入内存的部分的访问会触发页面错误，此时操作系统将分页相关数据，并通过相应地更新进程的页表来使其可访问（即，请求分页） ）。\n> \n> 每个常规 linux 进程都使用内存映射文件，即使 main() 中的代码也不会直接调用 mmap()，因为 linux 将代码从可执行文件和共享库代码加载到内存中。下面是 pmap 命令行工具的（高度缩写）输出，它显示了哪些不同的映射构成了正在运行的程序（shell，在本例中为 tcsh）的虚拟地址空间。输出显示四列：映射的虚拟地址、其大小、区域的保护位以及映射源：\n> \n> 映射的虚拟地址            大小      区域的保护位   映射源\n> 0000000000400000   372k    r-x--    tcsh\n> 00000000019d5000   1780k   rw---    [anon]\n> 00007f4e7cf06000   1792k   r-x--    libc-2.23.so\n> 00007f4e7d2d0000   36k     r-x--    libcrypt-2.23.so\n> 00007f4e7d508000   148k    r-x--    libtinfo.so.5.9\n> 00007f4e7d731000   152k    r-x--    ld-2.23.so\n> 00007f4e7d932000   16k     rw---    [stack]\n> \n> 正如你可以看到的输出中，来自 tcsh 二进制文件的代码以及来自 libc、libcrypt、libtinfo 的代码以及来自动态链接器本身 (ld.so) 的代码都映射到地址空间。还存在两个匿名区域：堆（第二个条目，标记为 anon）和栈（标记为 stack）。内存映射文件为操作系统构建现代地址空间提供了一种简单有效的方法\n\n页面缓存会跟踪条目是否干净（读取但未更新）或脏（又称修改）。脏数据由后台线程（称为 pdflush）定期写入后备存储（即，写入文件数据的特定文件，或交换匿名区域的空间），从而确保修改后的数据最终被写回持久存储。此后台活动要么在特定时间段后发生，要么在太多页面被视为脏页时发生（均为可配置参数）。\n\n在某些情况下，系统运行时内存不足，linux 必须决定从内存中剔除哪些页面以释放空间。为此，linux 使用 2q 替换的改进形式，我们在此进行描述。\n\n基本思想很简单：标准 lru 替换是有效的，但可能会被某些常见的访问模式颠覆。例如，如果一个进程重复访问一个大文件（尤其是接近内存大小或更大的文件），lru 会将所有其他文件踢出内存。更糟糕的是：将该文件的部分内容保留在内存中没有用，因为它们在被踢出内存之前永远不会被重新引用。\n\nlinux 版本的 2q 替换算法通过保留两个列表并在它们之间划分内存来解决这个问题。第一次访问时，一个页面被放入一个队列（原论文中称为a1，但linux中为非活动列表）；当它被重新引用时，该页面会被提升到另一个队列（原来称为aq，但在linux中称为活动列表）。当需要进行替换时，从非活动列表中取出替换候选者。 linux 还定期将页面从活动列表底部移动到非活动列表，使活动列表保持在总页面缓存大小的三分之二左右。\n\n理想情况下，linux 会以完美的 lru 顺序管理这些列表，但是，正如前面章节中所讨论的，这样做的成本很高。因此，与许多操作系统一样，使用 lru 的近似值（类似于时钟替换）。\n\n这种 2q 方法的行为通常与 lru 非常相似，但在处理循环访问大文件的情况时，其显著特点是将循环访问的页面限制在非活动列表中。由于这些页面在被踢出内存之前从未被重新引用过，因此它们不会冲掉活动列表中的其他有用页面。\n\n\n# 2.5 安全和缓冲区溢出\n\n现代 vm 系统（linux、solaris 或 bsd 变体之一）与古代 vm 系统（vax/vms）之间的最大区别可能是现代对安全性的重视。保护一直是操作系统的一个严重问题，但随着机器的互联程度比以往任何时候都更加紧密，开发人员实施了各种防御对策来阻止那些狡猾的黑客获得系统控制权也就不足为奇了。\n\n缓冲区溢出攻击是一种主要威胁，它可以针对普通用户程序甚至内核本身。这些攻击的目的是找到目标系统中的错误，使攻击者可以将任意数据注入目标的地址空间。有时会出现此类漏洞，因为开发人员（错误地）假设输入不会太长，因此（可信地）将输入复制到缓冲区中；因为输入实际上太长，所以它会溢出缓冲区，从而覆盖目标的内存。像下面这样无辜的代码可能是问题的根源：\n\nint some_function(char *input) {\n\tchar dest_buffer[100];\n\tstrcpy(dest_buffer, input); // oops, unbounded copy!\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n在许多情况下，这种溢出并不会造成灾难性后果，例如，无意地向用户程序甚至操作系统提供不良输入可能会导致系统崩溃，但不会更糟。然而，恶意程序员可以精心设计使缓冲区溢出的输入，以便将自己的代码注入目标系统，从而接管系统并为所欲为。如果攻击网络连接的用户程序成功，攻击者就可以在被攻击的系统上运行任意计算，甚至出租计算资源；如果攻击操作系统本身成功，攻击者就可以访问更多资源，这就是所谓的权限升级（即用户代码获得内核访问权限）。\n\n防止缓冲区溢出的第一道也是最简单的一道防线就是防止在地址空间的特定区域（如栈内）执行任何代码。amd 在其 x86 版本中引入的 nx 位（no-execute 的缩写）（英特尔版本中也有类似的 xd 位）就是这样一种防御措施；它只需阻止在相应页表条目中设置了该位的任何页面的执行。这种方法可以防止攻击者注入目标栈的代码被执行，从而减轻了问题。\n\n然而，聪明的攻击者是......聪明的，即使攻击者不能显示添加注入的代码，恶意代码也能执行任意代码序列。这种想法以其最普遍的形式被称为返回导向编程（return-oriented programming, rop）[s07]，它确实非常出色。rop 背后的原理是，任何程序的地址空间中都有大量的代码位（用 rop 术语来说就是小工具），尤其是与庞大的 c 库链接的 c 程序。因此，攻击者可以覆盖栈，使当前执行函数中的返回地址指向所需的恶意指令（或一系列指令），然后再返回指令。通过串联大量小工具（即确保每次返回都跳转到下一个小工具），攻击者可以执行任意代码。\n\n为了抵御 rop（包括其早期形式，返回到库攻击（return-to-libc 攻击）），linux（和其他系统）增加了另一种防御手段，即地址空间布局随机化（aslr）。操作系统不是将代码、栈和堆放在虚拟地址空间内的固定位置，而是将它们的位置随机化，从而使实现这类攻击所需的复杂代码序列变得相当具有挑战性。因此，针对易受攻击的用户程序的大多数攻击都会导致程序崩溃，但无法控制运行中的程序。\n\n有趣的是，在实践中可以很容易地观察到这种随机性。下面是一段在现代 linux 系统上演示的代码：\n\nint main(int argc, char *argv[]) {\n\tint stack = 0;\n\tprintf("%p\\n", &stack);\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n这段代码只是打印出堆栈中变量的（虚拟）地址。在较早的非 aslr 系统中，该值每次都是相同的。但如下所示，每次运行时，该值都会发生变化：\n\n> ./random\n0x7ffd3e55d2b4\n> ./random\n0x7ffe1033b8f4\n> ./random\n0x7ffe45522e94\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\naslr 对于用户级程序来说是一种非常有用的防御手段，因此它也被纳入了内核，并被称为内核地址空间布局随机化（kaslr）。然而，事实证明，内核可能有更大的问题需要处理，正如我们接下来要讨论的那样。\n\n\n# 2.6 其他安全问题：熔断漏洞和幽灵漏洞\n\n系统安全世界已经被两个新的相关攻击颠覆了。第一个叫做 "熔毁"（meltdown），第二个叫做 "幽灵"（spectre）。它们是由四组不同的研究人员/工程师在差不多同一时间发现的，并引发了对计算机硬件和上述操作系统所提供的基本保护措施的深刻质疑。有关每种攻击的详细描述，请参见 meltdownattack.com 和 spectreattack.com。幽灵被认为是这两种攻击中问题较多的一种。\n\n这些攻击所利用的一般弱点是，现代系统中的 cpu 会在幕后执行各种疯狂的技巧来提高性能。其中一类技术是问题的核心，被称为 "预测执行"，即 cpu 猜测哪些指令将在未来执行，并提前开始执行。如果猜测正确，程序运行速度就会加快；如果猜测不正确，cpu就会撤消这些指令对架构状态（如寄存器）的影响，并再次尝试执行，这一次会沿着正确的路径运行。\n\n预测的问题在于，它往往会在系统的各个部分（如处理器缓存、分支预测器等）留下执行痕迹。因此，问题就出现了：正如攻击事件的作者所展示的，这种状态会使内存内容变得脆弱，甚至是我们认为受到 mmu 保护的内存。\n\n因此，加强内核保护的一个途径就是尽可能地将内核地址空间从每个用户进程中移除，转而为大多数内核数据建立一个独立的内核页表（称为内核页表隔离，或 kpti）[g+17]。这样，内核的代码和数据结构就不再映射到每个进程中，而是只保留最基本的部分；当切换到内核时，就需要切换到内核页表。这样做提高了安全性，避免了一些攻击向量，但也付出了代价：性能。切换页表的代价很高。安全的代价：方便和性能。\n\n不幸的是，kpti 并不能解决上述所有安全问题，只能解决部分问题。而简单的解决方案，如关闭预测功能，也没有多大意义，因为系统运行速度会降低数千倍。',charsets:{cjk:!0},lastUpdated:"2024/05/11, 20:33:38",lastUpdatedTimestamp:1715430818e3},{title:"Docker入门教程",frontmatter:{title:"Docker入门教程",date:"2022-02-13T00:00:00.000Z",tags:["Docker"],author:{name:"Pursuit"},link:"https://github.com/unique-pure",permalink:"/pages/12de46/",categories:["开发","云原生","容器化技术"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/07.%E4%BA%91%E5%8E%9F%E7%94%9F/01.%E5%AE%B9%E5%99%A8%E5%8C%96%E6%8A%80%E6%9C%AF/01.Docker%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B.html",relativePath:"01.开发/07.云原生/01.容器化技术/01.Docker入门教程.md",key:"v-7f9d059f",path:"/pages/12de46/",headers:[{level:2,title:"1 初识Docker",slug:"_1-初识docker",normalizedTitle:"1 初识docker",charIndex:2},{level:3,title:"1.1 Docker开源项目",slug:"_1-1-docker开源项目",normalizedTitle:"1.1 docker开源项目",charIndex:17},{level:3,title:"1.2 Linux容器技术",slug:"_1-2-linux容器技术",normalizedTitle:"1.2 linux容器技术",charIndex:252},{level:3,title:"1.3 为什么要使用Docker",slug:"_1-3-为什么要使用docker",normalizedTitle:"1.3 为什么要使用docker",charIndex:700},{level:3,title:"1.4 Docker的核心概念",slug:"_1-4-docker的核心概念",normalizedTitle:"1.4 docker的核心概念",charIndex:1328},{level:3,title:"1.5 Docker安装（Linux）",slug:"_1-5-docker安装-linux",normalizedTitle:"1.5 docker安装（linux）",charIndex:2449},{level:2,title:"2 镜像具体操作",slug:"_2-镜像具体操作",normalizedTitle:"2 镜像具体操作",charIndex:2479},{level:3,title:"2.1 获取镜像",slug:"_2-1-获取镜像",normalizedTitle:"2.1 获取镜像",charIndex:2492},{level:3,title:"2.2 查看镜像信息",slug:"_2-2-查看镜像信息",normalizedTitle:"2.2 查看镜像信息",charIndex:3051},{level:3,title:"2.3 搜寻镜像",slug:"_2-3-搜寻镜像",normalizedTitle:"2.3 搜寻镜像",charIndex:3694},{level:3,title:"2.4 删除镜像",slug:"_2-4-删除镜像",normalizedTitle:"2.4 删除镜像",charIndex:3931},{level:3,title:"2.5 创建镜像",slug:"_2-5-创建镜像",normalizedTitle:"2.5 创建镜像",charIndex:4229},{level:4,title:"2.5.1 基于已有镜像的容器创建",slug:"_2-5-1-基于已有镜像的容器创建",normalizedTitle:"2.5.1 基于已有镜像的容器创建",charIndex:4290},{level:4,title:"2.5.2 基于本地模板导入",slug:"_2-5-2-基于本地模板导入",normalizedTitle:"2.5.2 基于本地模板导入",charIndex:4611},{level:4,title:"2.5.3 基于Dockerfile创建",slug:"_2-5-3-基于dockerfile创建",normalizedTitle:"2.5.3 基于dockerfile创建",charIndex:4887},{level:3,title:"2.6 存出和载入镜像",slug:"_2-6-存出和载入镜像",normalizedTitle:"2.6 存出和载入镜像",charIndex:5668},{level:3,title:"2.7 修改镜像",slug:"_2-7-修改镜像",normalizedTitle:"2.7 修改镜像",charIndex:6096},{level:3,title:"2.8 上传镜像",slug:"_2-8-上传镜像",normalizedTitle:"2.8 上传镜像",charIndex:6270},{level:2,title:"3 容器具体操作",slug:"_3-容器具体操作",normalizedTitle:"3 容器具体操作",charIndex:6514},{level:3,title:"3.1 查看容器",slug:"_3-1-查看容器",normalizedTitle:"3.1 查看容器",charIndex:6527},{level:3,title:"3.2 创建容器",slug:"_3-2-创建容器",normalizedTitle:"3.2 创建容器",charIndex:7025},{level:3,title:"3.3 启动终止容器",slug:"_3-3-启动终止容器",normalizedTitle:"3.3 启动终止容器",charIndex:7800},{level:3,title:"3.4 获取容器的日志",slug:"_3-4-获取容器的日志",normalizedTitle:"3.4 获取容器的日志",charIndex:8016},{level:3,title:"3.5 进入容器",slug:"_3-5-进入容器",normalizedTitle:"3.5 进入容器",charIndex:8193},{level:3,title:"3.6 删除容器",slug:"_3-6-删除容器",normalizedTitle:"3.6 删除容器",charIndex:8627},{level:3,title:"3.7 在本地和容器之间复制文件",slug:"_3-7-在本地和容器之间复制文件",normalizedTitle:"3.7 在本地和容器之间复制文件",charIndex:8875},{level:3,title:"3.8 修改容器",slug:"_3-8-修改容器",normalizedTitle:"3.8 修改容器",charIndex:9049},{level:3,title:"3.9 导入和导出容器",slug:"_3-9-导入和导出容器",normalizedTitle:"3.9 导入和导出容器",charIndex:9278},{level:4,title:"3.9.1 导出容器",slug:"_3-9-1-导出容器",normalizedTitle:"3.9.1 导出容器",charIndex:9293},{level:4,title:"3.9.2 导入容器",slug:"_3-9-2-导入容器",normalizedTitle:"3.9.2 导入容器",charIndex:9591},{level:2,title:"4 仓库",slug:"_4-仓库",normalizedTitle:"4 仓库",charIndex:9981},{level:3,title:"4.1 Docker Hub",slug:"_4-1-docker-hub",normalizedTitle:"4.1 docker hub",charIndex:9990},{level:4,title:"4.1.1 Linux登录登出DockerHub",slug:"_4-1-1-linux登录登出dockerhub",normalizedTitle:"4.1.1 linux登录登出dockerhub",charIndex:10008},{level:4,title:"4.1.2 基本操作",slug:"_4-1-2-基本操作",normalizedTitle:"4.1.2 基本操作",charIndex:10107},{level:4,title:"4.1.3 自动创建",slug:"_4-1-3-自动创建",normalizedTitle:"4.1.3 自动创建",charIndex:10417},{level:2,title:"5 网络基础配置",slug:"_5-网络基础配置",normalizedTitle:"5 网络基础配置",charIndex:10781},{level:3,title:"5.1 端口映射实现访问容器",slug:"_5-1-端口映射实现访问容器",normalizedTitle:"5.1 端口映射实现访问容器",charIndex:10794}],headersStr:"1 初识Docker 1.1 Docker开源项目 1.2 Linux容器技术 1.3 为什么要使用Docker 1.4 Docker的核心概念 1.5 Docker安装（Linux） 2 镜像具体操作 2.1 获取镜像 2.2 查看镜像信息 2.3 搜寻镜像 2.4 删除镜像 2.5 创建镜像 2.5.1 基于已有镜像的容器创建 2.5.2 基于本地模板导入 2.5.3 基于Dockerfile创建 2.6 存出和载入镜像 2.7 修改镜像 2.8 上传镜像 3 容器具体操作 3.1 查看容器 3.2 创建容器 3.3 启动终止容器 3.4 获取容器的日志 3.5 进入容器 3.6 删除容器 3.7 在本地和容器之间复制文件 3.8 修改容器 3.9 导入和导出容器 3.9.1 导出容器 3.9.2 导入容器 4 仓库 4.1 Docker Hub 4.1.1 Linux登录登出DockerHub 4.1.2 基本操作 4.1.3 自动创建 5 网络基础配置 5.1 端口映射实现访问容器",content:'# 1 初识Docker\n\n\n# 1.1 Docker开源项目\n\nDocker是基于Go语言实现的云开源项目，诞生于2013年初，用于支持创建和使用 Linux容器。它的主要目标是“Build, Ship and Run Any App, Anywhere”，即通过对应用封装（Packaging）、分发（Deployment）、运行（Runtime）等生命管理，达到应用组件级别的 “一次封装、到处运行” 。这里的应用组件既可以是一个应用，也可以是一套数据库服务，甚至是一个操作系统或编译器。\n\n\n# 1.2 Linux容器技术\n\nDocker引擎的基础是Linux容器（Linux Containers，LXC）技术。容器则是有效地将由单个操作系统管理的资源划分到孤立的组中，以便更好地在孤立间平衡有冲突的资源使用需求，而LXC项目则是借助容器设计理念，并基于一系列新的内核特性实现了更具有扩展性的虚拟化容器方案。更关键的是，LXC被集成到了主流Linux内核中，进而成为Linux系统轻量级容器技术的事实标准。 那么在LXC的基础上，Docker进一步优化了容器的使用体验。Docker提供了各种容器管理工具（如分发、版本、移植等）让用户无需关注底层的操作，可以简单明了管理和使用容器。用户操作Docker容器就像操作一个轻量级的虚拟机那样简单。\n\n我们可以将Docker容器理解为一种沙盒，每个容器运行一个应用，不同的容器相互隔离，容器之间也可以建立通信机制。容器的创建和停止都十分迅速，容器自身对资源的需求也十分有限，远远低于虚拟机。很多时候，甚至将容器比作是应用本身也没有问题。\n\n\n# 1.3 为什么要使用Docker\n\n * Docker容器虚拟化 举个简单的应用场景的例子，假设用户试图基于最常用的LAMP（Linux+Apache+MySQL+PHP）组合来运维一个网站。按照最传统的做法，首先需要安装Apache、Mysql和PHP以及它们各自运行所依赖的环境；之后分别对它们进行配置。经过大量操作后，然后还需要进行功能测试，看是否工作正常；如果不正常，则意味着更多的时间代价和不可控的风险。可以想象，如果再加上更多的应用，事情会变得更加难以处理。更为可怕的是，如果需要进行服务器迁移，如从腾讯云迁移到阿里云，往往需要重新部署和调试。而Docker提供了一种更为聪明的方式，通过容器来打包应用，意味着迁移只需要再服务器上启动需要的容器就可以了，节约大量的宝贵时间，并降低部署过程中出现问题的风险。\n * Docker在开发和运维的优势 Docker可以在任何环境、任意时间让应用正常运行。在开发和运维中有4大优势：更快速的交付和部署；更高效的资源利用；更轻松的迁移和扩展；更简单的更新管理。\n * Docker与虚拟机的比较\n\n特性      容器          虚拟机\n启动速度    秒级          分钟级\n硬盘使用    一般为MB       一般为GB\n性能      接近原生        弱于\n系统支持量   单机支持上千个容器   一般为几十个\n隔离性     安全隔离        完全隔离\n\n\n# 1.4 Docker的核心概念\n\nDocker有三大核心概念，如果我们理解了这三个核心概念，就能顺利理解Docker的整个生命周期。\n\n * 镜像（Image） Docker镜像（Image）类似于虚拟机镜像，可以理解为一个面向Docker引擎的只读模板，包含了文件系统。例如一个镜像可以只包含一个完整的Ubuntu操作系统环境，可以把它称为一个Ubuntu镜像。镜像也可以安装了Apache应用程序，可以把它称为一个Apache镜像。 镜像是创建Docker容器的基础。通过版本管理和增量的文件系统，Docker提供了一套十分简单的机制来创建和更新现有的镜像，用户甚至可以从网上下载一个已经做好的应用镜像，并通过简单的命令就可以直接使用。\n * 容器（Container） Docker容器（Container）类似于一个轻量级的沙箱，Docker利用容器来运行和隔离应用。容器是从镜像创建的应用运行实例，可以将其启动、开始、停止、删除，而这些容器都是相互隔离、互不可见的。我们实际是可以将容器看作是一个简易版的Linux系统环境（包括root用户权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序打包而成的应用盒子。 镜像自身是只读的。容器从镜像启动的时候，Docker会在镜像的最上层创建一个可写层，镜像本身将保持不变。如果认为虚拟机是模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用，那么Docker容器就是独立运行的一个或一组应用，以及它们的必需运行环境。\n * 仓库（Repository） Docker仓库（Repository）类似于代码仓库，是Docker集中存放镜像文件的场所。而注册服务器（Registry）是存放仓库的地方，其上往往存放着多个仓库。每个仓库集中存放某一类镜像，往往包括多个镜像文件，通过不同的标签（tag）来进行区分。例如存放Ubuntu操作系统镜像的仓库，称为Ubuntu仓库，其中可能包括20.04等不同版本的镜像。根据所存储的镜像公开分享与否，Docker仓库可以分为公开仓库（Public）和私有仓库（Private）两种形式。目前，最大的公开仓库是Docker Hub，存放着数量庞大的镜像供用户下载，国内的公开仓库包括Docker Pool等，可提供稳定的国内访问。 当然，用户如果不希望公开分享自己的镜像文件，Docker也支持用户在本地网络内创建一个只能自己访问的私有仓库。当用户创建了自己的镜像之后就可以使用push命令将它上传到指定的公有或者私有仓库。这样用户下次在另外一台机器上使用该镜像时，只需将其从仓库上pull下来就可以了。\n\n\n# 1.5 Docker安装（Linux）\n\n安装教程\n\n\n# 2 镜像具体操作\n\n\n# 2.1 获取镜像\n\n镜像是Docker运行容器的前提。使用docker pull命令即可从镜像仓库上下载指定镜像到本地。命令格式如下： docker pull [options] NAME[:TAG] options参数说明：\n\n * -a：拉取所有tagged镜像\n\n例如从Docker Hub的Ubuntu仓库下载一个最新版的Ubuntu操作系统的镜像\n\ndocker pull ubuntu:20.04 # 指定版本号，目前最新为20.04\ndocker pull ubuntu #该命令实际上下载的就是ubuntu:latest镜像。\n\n\n1\n2\n\n1\n2\n\n\n\n\n上面这两条命令实际上相当于docker pull registry.hub.docker.com/ubuntu:latest命令，即从默认的注册服务器registry.hub.docker.com中的ubuntu仓库来下载标记为latest的镜像。 我们也可以选择其他注册服务器的仓库下载。那么这个时候我们需要在仓库前指定完整的仓库注册服务器地址。例如从Docker Pool社区的镜像源d1.dockerpool.com下载最新的ubuntu镜像。 docker pull d1.dockerpool.com:5000/ubuntu\n\n\n# 2.2 查看镜像信息\n\n使用docker images命令可以列出本地主机上的所有镜像。命令格式如下： docker images [options] [repository:[tag]] options参数说明：\n\n * -a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；\n * -f :显示满足条件的镜像；\n * -q :只显示镜像ID。\n\n如果没有给出仓库名，那么默认列出本地主机上已有的镜像。我们使用docker images可以查看到如下信息： 可以看到几个字段信息：\n\n * repository：来自于哪个仓库，比如ubuntu仓库。\n * tag：镜像的标签信息，比如20.04或latest。用于标记来自同一个仓库的不同镜像。\n * image id：镜像的ID号，这个特别重要，唯一标识镜像。\n * created：镜像创建时间。\n * size：镜像大小。\n\n我们从图中可以发现，20.04和latest标签的镜像ID是完全一致的，说明它们实际上指向了同一个镜像文件，只是别名不同而已。标签在这里起到了引用或者快捷方式的作用。 我们使用docker inpsect NAME|ID即可查看该镜像的详细信息，为json格式。 我们还可以使用docker history命令查看指定镜像的创建历史，命令格式如下： docker history [options] IMAGE options说明：\n\n * -q :仅列出提交记录ID。\n\n\n# 2.3 搜寻镜像\n\n使用docker search命令可以搜索云端仓库中共享的镜像，默认搜寻Docker Hub官方仓库的镜像。命令格式如下： docker search [options] TERM options说明：\n\n * --automated :只列出 automated build类型的镜像；\n * --no-trunc :显示完整的镜像描述；\n * -f <过滤条件>:例如列出收藏数不小于指定值的镜像。\n\n例如搜寻带mysql关键字的镜像如下：\n\n\n# 2.4 删除镜像\n\n使用docker rmi命令可以删除镜像，命令格式如下： docker rmi IMAGE [IMAGE...] 其中IMAGE可以为镜像标签或者镜像ID，这ID可以为能进行区分的部分前缀串。 需要注意的是，当有该镜像创建的容器存在时，镜像文件时默认无法删除的，若想要强行删除文件则需要加入-f参数来强制删除一个存在容器依赖的镜像，但这样往往会造成一些遗留问题。正确的做法应该是先删除依赖该镜像的所有容器，再来删除镜像。 若要删除所有镜像，可用docker images -q列出所有的ID，正确命令为：docker rmi $(docker images -q)。\n\n\n# 2.5 创建镜像\n\n创建镜像的方法有三种：基于已有镜像的容器创建、基于本地模板导入、基于Dockerfile创建。\n\n# 2.5.1 基于已有镜像的容器创建\n\n使用docker commit命令即可从容器创建一个镜像，命令格式如下： docker commit [options] CONTAINER [REPOSITORY[:TAG]] options说明：\n\n * -a :提交的镜像作者；\n * -c :使用Dockerfile指令来创建镜像；\n * -m :提交时的说明文字；\n * -p :在commit时，将容器暂停。\n\nCONTAINER为容器ID。 顺利的话，命令会返回新创建的镜像的ID信息。 实例如下： docker commit -a "pursuit" -m "my ubuntu" 3c61e963210c myubuntu:v1\n\n# 2.5.2 基于本地模板导入\n\n可以从一个操作系统模板文件导入一个镜像，也可以从网上下载一个模板。一般使用OpenVZ提供的模板来创建。OpenVZ下载地址。 首先下载一个，命令如下： wget https://download.openvz.org/template/precreated/contrib/arch-20161108-x86_64.tar.gz\n\n然后将导入该镜像： cat arch-20161108-x86_64.tar.gz | docker import - arch:x86_64 查看新导入的镜像，已经本地存在了：\n\n# 2.5.3 基于Dockerfile创建\n\n其中Dockerfile是一个文本格式的配置文件，用户可以使用 Dockerfile 快速创建自定义的镜像。 Dockerfile由一行行命令语句组成，并且支持以#开头的注释。Dockerfile分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。例如下面的文件模板：\n\n# This dockerfile user the ubuntu image\n# VERSION 2 - EDITON 1\n# Author: docker_user\n# Command format: Instruction [arguments / command] ..\n\n# 第一行必须指定基于的基础镜像\nFROM ubuntu\n\n# 维护者信息\n# 例如MAINTAINER  docker_user docker_user@email.com\nMAINTAINER pursuit unique.hzf@gmail.com\n\n# 镜像的操作指令\n# RUN <command>，当命令较长，可以用\\来换行。\nRUN echo "Hello, World!"\n\n# 容器启动时执行指令\nCMD /bin/bash\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n创建好Dockerfile后，我们利用docker build命令，命令格式如下： docker build -t PATH|URL repository:tag 如，我们利用Dockerfile生成镜像 sudo docker build . -t arch:x86_64_01 查看本地镜像如下：\n\n\n# 2.6 存出和载入镜像\n\n我们可以使用docker save和docker load命令来存出和载入镜像。 存出即将镜像保存成tar归档文件，载入即将使用docker save命令导出的tar归档文件载入称为镜像文件。 命令格式如下：\n\ndocker save -o filename IMAGE\n或者\ndocker save IMAGE>filename\n\ndocker load --input filename\n或者\ndocker load <filename\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n实例： docker save -o files/ubuntu_20_04.tar ubuntu:20.04 然后我们需要删除ubuntu:20.04镜像，再导入。\n\ndocker rmi ubuntu:20.04\ndocker load <ubuntu_20_04.tar\n\n\n1\n2\n\n1\n2\n\n\n\n\n\n# 2.7 修改镜像\n\n使用docker tag命令可以标记本地镜像，将其归入某一仓库。命令格式如下： docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG] 实例： docker tag ubuntu:20.04 myubuntu/ubuntu:20.04\n\n\n# 2.8 上传镜像\n\n使用docker push命令将本地的镜像上传到镜像仓库，默认上传到DockerHub官方仓库。要先登陆到镜像仓库。命令格式如下： docker push NAME[:TAG] 例如用户user上传自己的本地镜像ubuntu:20.04，需要注意的是我们需要添加新的标签user/ubuntu:20.04（其中user一定要和我们的dockerhub中用户名同名，否则会报错）然后再上传。 之后，我们即可在DockerHub官网看到自己的仓库和上传的镜像了。\n\n\n# 3 容器具体操作\n\n\n# 3.1 查看容器\n\n使用docker ps命令即可列出容器，命令格式如下： docker ps [OPTIONS] 其中options说明：\n\n * -a :显示所有的容器，包括未运行的。\n * -f :根据条件过滤显示的内容。\n * -q :静默模式，只显示容器编号。\n\n我们运行docker ps -a可以得到如图： 其中输出字段说明如下：\n\n * CONTAINER ID: 容器 ID。\n * IMAGE: 使用的镜像。\n * COMMAND: 启动容器时运行的命令。\n * CREATED: 容器的创建时间。\n * STATUS: 容器状态。\n * PORTS: 容器的端口信息和使用的连接类型（tcp\\udp）。\n * NAMES: 自动分配的容器名称。\n\n我们也可以使用docker inspect命令列出容器的元信息，输出格式为json格式，这个命令在查看镜像章节已经说明了，用法相同，这里不再叙述。\n\n使用docker stats可以查看所有容器的统计信息，包括CPU、内存、存储、网络等信息。 使用docker top CONTAINER可查看某个容器内的所有进程。\n\n\n# 3.2 创建容器\n\nDocker的容器十分轻量级，用户可以随时创建或删除容器。\n\n * 新建容器 可以使用docker create命令新建一个容器，例如： docker create -it ubuntu:20.04 即利用镜像ubuntu:20.04创建容器。\n * 新建并启动一个容器 使用docker run命令创建并启动容器。其命令格式如下： docker run [OPTIONS] IMAGE [COMMAND] [ARG...] 其中options说明： 1.--name：为容器指定一个名称； 2.-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； 3.-d: 后台运行容器，并返回容器ID。 4.-i: 以交互模式运行容器，通常与 -t 同时使用。 当使用docker创建并启动容器时，Docker在后台运行的标准操作如下： 1.检查本地是否有指定的镜像，不存在就从公有仓库下载; 2.利用镜像创建并启动一个容器； 3.分配一个文件系统，并在只读的镜像层外面挂载一层可读写层； 4.从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去； 5.从地址池配置一个IP地址给容器； 6.执行用户指定的应用程序； 7.执行完毕后容器被终止。 下面这个实例将启动一个bash终端，允许用户进行交互，可以使用Linux命令。 docker run -it ubuntu:20.04 /bin/bash 其中root为用户名，@后面的为容器ID。我们用ps命令查看进程发现只运行了bash应用，并没有运行其他不需要的进程。可以使用Ctrl+d或输入exit命令来退出容器。当退出容器之后，该容器就自动处于终止状态了。 这是因为对于Docker容器来说，当运行的应用（此例子中为bash）退出后，容器也就没有再运行的必要了。\n\n\n# 3.3 启动终止容器\n\n * 启动容器 使用docker start可以启动一个已存在的容器。命令格式如下： docker start CONTAINER\n * 终止容器 使用docker stop可以启动一个已存在的容器。命令格式如下： docker stop CONTAINER\n * 重启容器 使用docker restart可以启动一个已存在的容器。命令格式如下： docker restart CONTAINER\n\n\n# 3.4 获取容器的日志\n\n使用docker logs即可获取容器的日志。命令格式如下： docker logs [OPTIONS] CONTAINER 其中OPTIONS说明：\n\n * -f : 跟踪日志输出\n * --since :显示某个开始时间的所有日志\n * -t : 显示时间戳\n * --tail :仅列出最新N条容器日志\n\n实例：\n\n\n# 3.5 进入容器\n\n在使用-d参数后，容器启动后会自动进入后台，用户无法看到容器中的信息。我们如果需要进入容器进行操作，有多种方法，这里介绍两种。\n\n * 使用docker attach 命令格式为：docker attach CONTAINER 在容器中，我们可以先按Ctrl-p，再按Ctrl-q可以挂起容器。 但是使用attach命令有时候并不方便。当多个窗口同时attach到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞后，其他窗口也无法执行操作了。\n * 使用docker exec命令 Docker自1.3版本起，提供了一个更方便的工具exec，该命令可以在运行的容器中执行命令，命令格式如下： docker exec [OPTIONS] CONTAINER COMMAND [ARG...] 其中OPTIONS说明： 1.-d :分离模式: 在后台运行 2.-i :即使没有附加也保持STDIN 打开 3.-t :分配一个伪终端\n\n\n# 3.6 删除容器\n\n可以使用docker rm命令来删除==处于终止状态的容器==，命令格式如下： docker rm [OPTIONS] CONTAINER [CONTAINER...] 其中OPTIONS说明：\n\n * -f :通过 SIGKILL 信号强制删除一个运行中的容器。\n * -l:移除容器间的网络连接，而非容器本身。即删除容器的连接，但保留容器。\n * -v :删除与容器关联的卷。\n\n如果需要删除所有容器，可使用docker rm $(docker ps -aq)。\n\n\n# 3.7 在本地和容器之间复制文件\n\n使用docker cp命令用于主机和容器之间的数据拷贝，命令格式如下：\n\ndocker cp xxx CONTAINER:xxx \ndocker cp CONTAINER:xxx xxx\n\n\n1\n2\n\n1\n2\n\n\n实例： docker cp data.txt 3c61e963210c:data.txt\n\n\n# 3.8 修改容器\n\n使用docker rename可以重命名容器，命令格式如下： docker rename CONTAINER1 CONTAINER2 使用docker update可以修改容器配置，命令格式如下： docker update CONTAINER [options] 其中OPTIONS参数过多，使用的时候可以自行百度，例如我们修改容器的内存限制： docker update 3c61e963210 --memory 500MB\n\n\n# 3.9 导入和导出容器\n\n# 3.9.1 导出容器\n\n导出容器是指导出一个已经创建的容器到一个文件，不管此时这个容器是否处于运行状态，可以使用docker export命令导出容器。该命令格式如下：\n\ndocker export [options] xxx.tar CONTAINER \n或者\ndocker export [options] CONTAINER>xxx.tar\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n其中options说明：\n\n * -o :将输入内容写到文件。\n\n例如将id为3c61e963210的容器按日期保存为tar文件： 可以将这些文件传输到其他的机器上，在其他机器上通过导入命令实现容器的迁移。\n\n# 3.9.2 导入容器\n\n导出的文件又可以使用docker import命令导入，成为镜像，命令格式如下： docker import [OPTIONS] xxx.tar image_name:tag 其中OPTIONS说明：\n\n * -c :应用docker 指令创建镜像；\n * -m :提交时的说明文字。\n\n实例： docker import ubuntu-20220212.tar myubunt:latest 我们知道，前面我们学习过docker load命令来导入一个镜像文件。实际上，既可以使用docker load命令来导入镜像存储文件到本地的镜像库，也可以使用docker import命令来导入一个容器快照到本地镜像库。 这两者的区别在于容器快照文件将丢弃所有的历史记录和元信息（仅保存容器当时的快照状态)，，而镜像存储文件将保存完整记录，体积也要大。\n\n\n# 4 仓库\n\n\n# 4.1 Docker Hub\n\n# 4.1.1 Linux登录登出DockerHub\n\n首先在dockerhub官网注册一个账号，然后使用docker login即可登录。登出则直接输入docker logout即可。 实例：\n\n# 4.1.2 基本操作\n\n用户无需登录即可通过docker search命令来查找官网仓库的镜像，并利用docker pull命令来将它下载到本地。 根据是否为官方提供， 可将这些镜像资源分为两类。一种类似ubuntu这样的基础镜像，称为基础或根镜像。这些镜像是由Docker公司创建、验证、支持、提供的。这样的镜像往往使用单个单词作为名字。还有一种类型，比如pursuit/ubuntu镜像，它是由DockerHub用户pursuit创建并维护的，带有用户名称为前缀，表明是某用户的某仓库。可通过用户名称前缀user_name/ 来指定使用某个用户提供的镜像，比如pursuit用户的镜像前缀为pursuit/。\n\n# 4.1.3 自动创建\n\n自动创建（Automated Builds）功能对于需要经常升级镜像内程序来说十分方便。有时候，用户创建了镜像，安装了某个软件，如果软件发布新版本则需要手动更新镜像。 而自动创建功能使得用户通过DockerHub指定追踪一个目标网站（目前支持Github或BitBucket）上的项目，一但发现项目新的提交，则自动执行创建。 要配置自动创建，有如下步骤： 1）创建并登录Docker Hub，以及目标网站； * 在目标网站中连接账户到Docker Hub。 2）在Docker Hub中配置一个自动创建。 3）选取一个目标网站中的项目（需要含Dockerfile）和分支。 4）指定Dockerfile的位置，并提交创建。 之后，就可以在DockerHub的”自动创建“页面跟踪每次创建的状态。\n\n\n# 5 网络基础配置\n\n\n# 5.1 端口映射实现访问容器\n\n大量的互联网应用服务包括多个服务组件，这往往需要多个容器之间通过网络通信进行相互配合。Docker目前提供了映射容器端口到宿主主机和容器互联机制来为容器提供互联网服务。\n\n在启动容器时，如果不指定对应参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。当容器中运行一些应用，要让外部访问这些应用时，可以通过-p参数来指定端口映射，并且，在一个指定的端口上只可以绑定一个容器。支持的格式有ip:hostPort:containerPort、ip::containerPort、hostPort:containerPort。\n\n * 映射所有接口地址 使用hostPort:containerPort格式将本地的4000端口映射到容器的4000端口，可以执行如下命令： docker run -itd -p 4000:4000 --name my_docker_ubuntu ubuntu:20.04 我们可以看到，已经实现了端口映射。多次使用-p标记可以绑定多个端口。例如： docker run -itd -p 4000:4000 -p 3000:3000 --name my_docker_ubuntu ubuntu:20.04\n * 映射到指定地址的指定端口 可以使用ip:hostPort:containerPort格式指定映射使用一个特定地址，比如localhost地址127.0.0.1： docker run -itd -p 127.0.0.1:3000:3000 --name my_docker_ubuntu ubuntu:20.04\n * 映射到指定地址的任意端口 使用ip::containerPort绑定localhost的任意端口到容器的5000端口，本地主机会自动分配一个端口： docker run -itd -p 127.0.0.1::5000 --name my_docker_ubuntu ubuntu:20.04\n * 查看映射端口配置 可以使用docker port container命令来查看当前映射的端口配置，也可以查看到绑定的地址。',normalizedContent:'# 1 初识docker\n\n\n# 1.1 docker开源项目\n\ndocker是基于go语言实现的云开源项目，诞生于2013年初，用于支持创建和使用 linux容器。它的主要目标是“build, ship and run any app, anywhere”，即通过对应用封装（packaging）、分发（deployment）、运行（runtime）等生命管理，达到应用组件级别的 “一次封装、到处运行” 。这里的应用组件既可以是一个应用，也可以是一套数据库服务，甚至是一个操作系统或编译器。\n\n\n# 1.2 linux容器技术\n\ndocker引擎的基础是linux容器（linux containers，lxc）技术。容器则是有效地将由单个操作系统管理的资源划分到孤立的组中，以便更好地在孤立间平衡有冲突的资源使用需求，而lxc项目则是借助容器设计理念，并基于一系列新的内核特性实现了更具有扩展性的虚拟化容器方案。更关键的是，lxc被集成到了主流linux内核中，进而成为linux系统轻量级容器技术的事实标准。 那么在lxc的基础上，docker进一步优化了容器的使用体验。docker提供了各种容器管理工具（如分发、版本、移植等）让用户无需关注底层的操作，可以简单明了管理和使用容器。用户操作docker容器就像操作一个轻量级的虚拟机那样简单。\n\n我们可以将docker容器理解为一种沙盒，每个容器运行一个应用，不同的容器相互隔离，容器之间也可以建立通信机制。容器的创建和停止都十分迅速，容器自身对资源的需求也十分有限，远远低于虚拟机。很多时候，甚至将容器比作是应用本身也没有问题。\n\n\n# 1.3 为什么要使用docker\n\n * docker容器虚拟化 举个简单的应用场景的例子，假设用户试图基于最常用的lamp（linux+apache+mysql+php）组合来运维一个网站。按照最传统的做法，首先需要安装apache、mysql和php以及它们各自运行所依赖的环境；之后分别对它们进行配置。经过大量操作后，然后还需要进行功能测试，看是否工作正常；如果不正常，则意味着更多的时间代价和不可控的风险。可以想象，如果再加上更多的应用，事情会变得更加难以处理。更为可怕的是，如果需要进行服务器迁移，如从腾讯云迁移到阿里云，往往需要重新部署和调试。而docker提供了一种更为聪明的方式，通过容器来打包应用，意味着迁移只需要再服务器上启动需要的容器就可以了，节约大量的宝贵时间，并降低部署过程中出现问题的风险。\n * docker在开发和运维的优势 docker可以在任何环境、任意时间让应用正常运行。在开发和运维中有4大优势：更快速的交付和部署；更高效的资源利用；更轻松的迁移和扩展；更简单的更新管理。\n * docker与虚拟机的比较\n\n特性      容器          虚拟机\n启动速度    秒级          分钟级\n硬盘使用    一般为mb       一般为gb\n性能      接近原生        弱于\n系统支持量   单机支持上千个容器   一般为几十个\n隔离性     安全隔离        完全隔离\n\n\n# 1.4 docker的核心概念\n\ndocker有三大核心概念，如果我们理解了这三个核心概念，就能顺利理解docker的整个生命周期。\n\n * 镜像（image） docker镜像（image）类似于虚拟机镜像，可以理解为一个面向docker引擎的只读模板，包含了文件系统。例如一个镜像可以只包含一个完整的ubuntu操作系统环境，可以把它称为一个ubuntu镜像。镜像也可以安装了apache应用程序，可以把它称为一个apache镜像。 镜像是创建docker容器的基础。通过版本管理和增量的文件系统，docker提供了一套十分简单的机制来创建和更新现有的镜像，用户甚至可以从网上下载一个已经做好的应用镜像，并通过简单的命令就可以直接使用。\n * 容器（container） docker容器（container）类似于一个轻量级的沙箱，docker利用容器来运行和隔离应用。容器是从镜像创建的应用运行实例，可以将其启动、开始、停止、删除，而这些容器都是相互隔离、互不可见的。我们实际是可以将容器看作是一个简易版的linux系统环境（包括root用户权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序打包而成的应用盒子。 镜像自身是只读的。容器从镜像启动的时候，docker会在镜像的最上层创建一个可写层，镜像本身将保持不变。如果认为虚拟机是模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用，那么docker容器就是独立运行的一个或一组应用，以及它们的必需运行环境。\n * 仓库（repository） docker仓库（repository）类似于代码仓库，是docker集中存放镜像文件的场所。而注册服务器（registry）是存放仓库的地方，其上往往存放着多个仓库。每个仓库集中存放某一类镜像，往往包括多个镜像文件，通过不同的标签（tag）来进行区分。例如存放ubuntu操作系统镜像的仓库，称为ubuntu仓库，其中可能包括20.04等不同版本的镜像。根据所存储的镜像公开分享与否，docker仓库可以分为公开仓库（public）和私有仓库（private）两种形式。目前，最大的公开仓库是docker hub，存放着数量庞大的镜像供用户下载，国内的公开仓库包括docker pool等，可提供稳定的国内访问。 当然，用户如果不希望公开分享自己的镜像文件，docker也支持用户在本地网络内创建一个只能自己访问的私有仓库。当用户创建了自己的镜像之后就可以使用push命令将它上传到指定的公有或者私有仓库。这样用户下次在另外一台机器上使用该镜像时，只需将其从仓库上pull下来就可以了。\n\n\n# 1.5 docker安装（linux）\n\n安装教程\n\n\n# 2 镜像具体操作\n\n\n# 2.1 获取镜像\n\n镜像是docker运行容器的前提。使用docker pull命令即可从镜像仓库上下载指定镜像到本地。命令格式如下： docker pull [options] name[:tag] options参数说明：\n\n * -a：拉取所有tagged镜像\n\n例如从docker hub的ubuntu仓库下载一个最新版的ubuntu操作系统的镜像\n\ndocker pull ubuntu:20.04 # 指定版本号，目前最新为20.04\ndocker pull ubuntu #该命令实际上下载的就是ubuntu:latest镜像。\n\n\n1\n2\n\n1\n2\n\n\n\n\n上面这两条命令实际上相当于docker pull registry.hub.docker.com/ubuntu:latest命令，即从默认的注册服务器registry.hub.docker.com中的ubuntu仓库来下载标记为latest的镜像。 我们也可以选择其他注册服务器的仓库下载。那么这个时候我们需要在仓库前指定完整的仓库注册服务器地址。例如从docker pool社区的镜像源d1.dockerpool.com下载最新的ubuntu镜像。 docker pull d1.dockerpool.com:5000/ubuntu\n\n\n# 2.2 查看镜像信息\n\n使用docker images命令可以列出本地主机上的所有镜像。命令格式如下： docker images [options] [repository:[tag]] options参数说明：\n\n * -a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；\n * -f :显示满足条件的镜像；\n * -q :只显示镜像id。\n\n如果没有给出仓库名，那么默认列出本地主机上已有的镜像。我们使用docker images可以查看到如下信息： 可以看到几个字段信息：\n\n * repository：来自于哪个仓库，比如ubuntu仓库。\n * tag：镜像的标签信息，比如20.04或latest。用于标记来自同一个仓库的不同镜像。\n * image id：镜像的id号，这个特别重要，唯一标识镜像。\n * created：镜像创建时间。\n * size：镜像大小。\n\n我们从图中可以发现，20.04和latest标签的镜像id是完全一致的，说明它们实际上指向了同一个镜像文件，只是别名不同而已。标签在这里起到了引用或者快捷方式的作用。 我们使用docker inpsect name|id即可查看该镜像的详细信息，为json格式。 我们还可以使用docker history命令查看指定镜像的创建历史，命令格式如下： docker history [options] image options说明：\n\n * -q :仅列出提交记录id。\n\n\n# 2.3 搜寻镜像\n\n使用docker search命令可以搜索云端仓库中共享的镜像，默认搜寻docker hub官方仓库的镜像。命令格式如下： docker search [options] term options说明：\n\n * --automated :只列出 automated build类型的镜像；\n * --no-trunc :显示完整的镜像描述；\n * -f <过滤条件>:例如列出收藏数不小于指定值的镜像。\n\n例如搜寻带mysql关键字的镜像如下：\n\n\n# 2.4 删除镜像\n\n使用docker rmi命令可以删除镜像，命令格式如下： docker rmi image [image...] 其中image可以为镜像标签或者镜像id，这id可以为能进行区分的部分前缀串。 需要注意的是，当有该镜像创建的容器存在时，镜像文件时默认无法删除的，若想要强行删除文件则需要加入-f参数来强制删除一个存在容器依赖的镜像，但这样往往会造成一些遗留问题。正确的做法应该是先删除依赖该镜像的所有容器，再来删除镜像。 若要删除所有镜像，可用docker images -q列出所有的id，正确命令为：docker rmi $(docker images -q)。\n\n\n# 2.5 创建镜像\n\n创建镜像的方法有三种：基于已有镜像的容器创建、基于本地模板导入、基于dockerfile创建。\n\n# 2.5.1 基于已有镜像的容器创建\n\n使用docker commit命令即可从容器创建一个镜像，命令格式如下： docker commit [options] container [repository[:tag]] options说明：\n\n * -a :提交的镜像作者；\n * -c :使用dockerfile指令来创建镜像；\n * -m :提交时的说明文字；\n * -p :在commit时，将容器暂停。\n\ncontainer为容器id。 顺利的话，命令会返回新创建的镜像的id信息。 实例如下： docker commit -a "pursuit" -m "my ubuntu" 3c61e963210c myubuntu:v1\n\n# 2.5.2 基于本地模板导入\n\n可以从一个操作系统模板文件导入一个镜像，也可以从网上下载一个模板。一般使用openvz提供的模板来创建。openvz下载地址。 首先下载一个，命令如下： wget https://download.openvz.org/template/precreated/contrib/arch-20161108-x86_64.tar.gz\n\n然后将导入该镜像： cat arch-20161108-x86_64.tar.gz | docker import - arch:x86_64 查看新导入的镜像，已经本地存在了：\n\n# 2.5.3 基于dockerfile创建\n\n其中dockerfile是一个文本格式的配置文件，用户可以使用 dockerfile 快速创建自定义的镜像。 dockerfile由一行行命令语句组成，并且支持以#开头的注释。dockerfile分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。例如下面的文件模板：\n\n# this dockerfile user the ubuntu image\n# version 2 - editon 1\n# author: docker_user\n# command format: instruction [arguments / command] ..\n\n# 第一行必须指定基于的基础镜像\nfrom ubuntu\n\n# 维护者信息\n# 例如maintainer  docker_user docker_user@email.com\nmaintainer pursuit unique.hzf@gmail.com\n\n# 镜像的操作指令\n# run <command>，当命令较长，可以用\\来换行。\nrun echo "hello, world!"\n\n# 容器启动时执行指令\ncmd /bin/bash\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n创建好dockerfile后，我们利用docker build命令，命令格式如下： docker build -t path|url repository:tag 如，我们利用dockerfile生成镜像 sudo docker build . -t arch:x86_64_01 查看本地镜像如下：\n\n\n# 2.6 存出和载入镜像\n\n我们可以使用docker save和docker load命令来存出和载入镜像。 存出即将镜像保存成tar归档文件，载入即将使用docker save命令导出的tar归档文件载入称为镜像文件。 命令格式如下：\n\ndocker save -o filename image\n或者\ndocker save image>filename\n\ndocker load --input filename\n或者\ndocker load <filename\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n实例： docker save -o files/ubuntu_20_04.tar ubuntu:20.04 然后我们需要删除ubuntu:20.04镜像，再导入。\n\ndocker rmi ubuntu:20.04\ndocker load <ubuntu_20_04.tar\n\n\n1\n2\n\n1\n2\n\n\n\n\n\n# 2.7 修改镜像\n\n使用docker tag命令可以标记本地镜像，将其归入某一仓库。命令格式如下： docker tag [options] image[:tag] [registryhost/][username/]name[:tag] 实例： docker tag ubuntu:20.04 myubuntu/ubuntu:20.04\n\n\n# 2.8 上传镜像\n\n使用docker push命令将本地的镜像上传到镜像仓库，默认上传到dockerhub官方仓库。要先登陆到镜像仓库。命令格式如下： docker push name[:tag] 例如用户user上传自己的本地镜像ubuntu:20.04，需要注意的是我们需要添加新的标签user/ubuntu:20.04（其中user一定要和我们的dockerhub中用户名同名，否则会报错）然后再上传。 之后，我们即可在dockerhub官网看到自己的仓库和上传的镜像了。\n\n\n# 3 容器具体操作\n\n\n# 3.1 查看容器\n\n使用docker ps命令即可列出容器，命令格式如下： docker ps [options] 其中options说明：\n\n * -a :显示所有的容器，包括未运行的。\n * -f :根据条件过滤显示的内容。\n * -q :静默模式，只显示容器编号。\n\n我们运行docker ps -a可以得到如图： 其中输出字段说明如下：\n\n * container id: 容器 id。\n * image: 使用的镜像。\n * command: 启动容器时运行的命令。\n * created: 容器的创建时间。\n * status: 容器状态。\n * ports: 容器的端口信息和使用的连接类型（tcp\\udp）。\n * names: 自动分配的容器名称。\n\n我们也可以使用docker inspect命令列出容器的元信息，输出格式为json格式，这个命令在查看镜像章节已经说明了，用法相同，这里不再叙述。\n\n使用docker stats可以查看所有容器的统计信息，包括cpu、内存、存储、网络等信息。 使用docker top container可查看某个容器内的所有进程。\n\n\n# 3.2 创建容器\n\ndocker的容器十分轻量级，用户可以随时创建或删除容器。\n\n * 新建容器 可以使用docker create命令新建一个容器，例如： docker create -it ubuntu:20.04 即利用镜像ubuntu:20.04创建容器。\n * 新建并启动一个容器 使用docker run命令创建并启动容器。其命令格式如下： docker run [options] image [command] [arg...] 其中options说明： 1.--name：为容器指定一个名称； 2.-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； 3.-d: 后台运行容器，并返回容器id。 4.-i: 以交互模式运行容器，通常与 -t 同时使用。 当使用docker创建并启动容器时，docker在后台运行的标准操作如下： 1.检查本地是否有指定的镜像，不存在就从公有仓库下载; 2.利用镜像创建并启动一个容器； 3.分配一个文件系统，并在只读的镜像层外面挂载一层可读写层； 4.从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去； 5.从地址池配置一个ip地址给容器； 6.执行用户指定的应用程序； 7.执行完毕后容器被终止。 下面这个实例将启动一个bash终端，允许用户进行交互，可以使用linux命令。 docker run -it ubuntu:20.04 /bin/bash 其中root为用户名，@后面的为容器id。我们用ps命令查看进程发现只运行了bash应用，并没有运行其他不需要的进程。可以使用ctrl+d或输入exit命令来退出容器。当退出容器之后，该容器就自动处于终止状态了。 这是因为对于docker容器来说，当运行的应用（此例子中为bash）退出后，容器也就没有再运行的必要了。\n\n\n# 3.3 启动终止容器\n\n * 启动容器 使用docker start可以启动一个已存在的容器。命令格式如下： docker start container\n * 终止容器 使用docker stop可以启动一个已存在的容器。命令格式如下： docker stop container\n * 重启容器 使用docker restart可以启动一个已存在的容器。命令格式如下： docker restart container\n\n\n# 3.4 获取容器的日志\n\n使用docker logs即可获取容器的日志。命令格式如下： docker logs [options] container 其中options说明：\n\n * -f : 跟踪日志输出\n * --since :显示某个开始时间的所有日志\n * -t : 显示时间戳\n * --tail :仅列出最新n条容器日志\n\n实例：\n\n\n# 3.5 进入容器\n\n在使用-d参数后，容器启动后会自动进入后台，用户无法看到容器中的信息。我们如果需要进入容器进行操作，有多种方法，这里介绍两种。\n\n * 使用docker attach 命令格式为：docker attach container 在容器中，我们可以先按ctrl-p，再按ctrl-q可以挂起容器。 但是使用attach命令有时候并不方便。当多个窗口同时attach到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞后，其他窗口也无法执行操作了。\n * 使用docker exec命令 docker自1.3版本起，提供了一个更方便的工具exec，该命令可以在运行的容器中执行命令，命令格式如下： docker exec [options] container command [arg...] 其中options说明： 1.-d :分离模式: 在后台运行 2.-i :即使没有附加也保持stdin 打开 3.-t :分配一个伪终端\n\n\n# 3.6 删除容器\n\n可以使用docker rm命令来删除==处于终止状态的容器==，命令格式如下： docker rm [options] container [container...] 其中options说明：\n\n * -f :通过 sigkill 信号强制删除一个运行中的容器。\n * -l:移除容器间的网络连接，而非容器本身。即删除容器的连接，但保留容器。\n * -v :删除与容器关联的卷。\n\n如果需要删除所有容器，可使用docker rm $(docker ps -aq)。\n\n\n# 3.7 在本地和容器之间复制文件\n\n使用docker cp命令用于主机和容器之间的数据拷贝，命令格式如下：\n\ndocker cp xxx container:xxx \ndocker cp container:xxx xxx\n\n\n1\n2\n\n1\n2\n\n\n实例： docker cp data.txt 3c61e963210c:data.txt\n\n\n# 3.8 修改容器\n\n使用docker rename可以重命名容器，命令格式如下： docker rename container1 container2 使用docker update可以修改容器配置，命令格式如下： docker update container [options] 其中options参数过多，使用的时候可以自行百度，例如我们修改容器的内存限制： docker update 3c61e963210 --memory 500mb\n\n\n# 3.9 导入和导出容器\n\n# 3.9.1 导出容器\n\n导出容器是指导出一个已经创建的容器到一个文件，不管此时这个容器是否处于运行状态，可以使用docker export命令导出容器。该命令格式如下：\n\ndocker export [options] xxx.tar container \n或者\ndocker export [options] container>xxx.tar\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n其中options说明：\n\n * -o :将输入内容写到文件。\n\n例如将id为3c61e963210的容器按日期保存为tar文件： 可以将这些文件传输到其他的机器上，在其他机器上通过导入命令实现容器的迁移。\n\n# 3.9.2 导入容器\n\n导出的文件又可以使用docker import命令导入，成为镜像，命令格式如下： docker import [options] xxx.tar image_name:tag 其中options说明：\n\n * -c :应用docker 指令创建镜像；\n * -m :提交时的说明文字。\n\n实例： docker import ubuntu-20220212.tar myubunt:latest 我们知道，前面我们学习过docker load命令来导入一个镜像文件。实际上，既可以使用docker load命令来导入镜像存储文件到本地的镜像库，也可以使用docker import命令来导入一个容器快照到本地镜像库。 这两者的区别在于容器快照文件将丢弃所有的历史记录和元信息（仅保存容器当时的快照状态)，，而镜像存储文件将保存完整记录，体积也要大。\n\n\n# 4 仓库\n\n\n# 4.1 docker hub\n\n# 4.1.1 linux登录登出dockerhub\n\n首先在dockerhub官网注册一个账号，然后使用docker login即可登录。登出则直接输入docker logout即可。 实例：\n\n# 4.1.2 基本操作\n\n用户无需登录即可通过docker search命令来查找官网仓库的镜像，并利用docker pull命令来将它下载到本地。 根据是否为官方提供， 可将这些镜像资源分为两类。一种类似ubuntu这样的基础镜像，称为基础或根镜像。这些镜像是由docker公司创建、验证、支持、提供的。这样的镜像往往使用单个单词作为名字。还有一种类型，比如pursuit/ubuntu镜像，它是由dockerhub用户pursuit创建并维护的，带有用户名称为前缀，表明是某用户的某仓库。可通过用户名称前缀user_name/ 来指定使用某个用户提供的镜像，比如pursuit用户的镜像前缀为pursuit/。\n\n# 4.1.3 自动创建\n\n自动创建（automated builds）功能对于需要经常升级镜像内程序来说十分方便。有时候，用户创建了镜像，安装了某个软件，如果软件发布新版本则需要手动更新镜像。 而自动创建功能使得用户通过dockerhub指定追踪一个目标网站（目前支持github或bitbucket）上的项目，一但发现项目新的提交，则自动执行创建。 要配置自动创建，有如下步骤： 1）创建并登录docker hub，以及目标网站； * 在目标网站中连接账户到docker hub。 2）在docker hub中配置一个自动创建。 3）选取一个目标网站中的项目（需要含dockerfile）和分支。 4）指定dockerfile的位置，并提交创建。 之后，就可以在dockerhub的”自动创建“页面跟踪每次创建的状态。\n\n\n# 5 网络基础配置\n\n\n# 5.1 端口映射实现访问容器\n\n大量的互联网应用服务包括多个服务组件，这往往需要多个容器之间通过网络通信进行相互配合。docker目前提供了映射容器端口到宿主主机和容器互联机制来为容器提供互联网服务。\n\n在启动容器时，如果不指定对应参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。当容器中运行一些应用，要让外部访问这些应用时，可以通过-p参数来指定端口映射，并且，在一个指定的端口上只可以绑定一个容器。支持的格式有ip:hostport:containerport、ip::containerport、hostport:containerport。\n\n * 映射所有接口地址 使用hostport:containerport格式将本地的4000端口映射到容器的4000端口，可以执行如下命令： docker run -itd -p 4000:4000 --name my_docker_ubuntu ubuntu:20.04 我们可以看到，已经实现了端口映射。多次使用-p标记可以绑定多个端口。例如： docker run -itd -p 4000:4000 -p 3000:3000 --name my_docker_ubuntu ubuntu:20.04\n * 映射到指定地址的指定端口 可以使用ip:hostport:containerport格式指定映射使用一个特定地址，比如localhost地址127.0.0.1： docker run -itd -p 127.0.0.1:3000:3000 --name my_docker_ubuntu ubuntu:20.04\n * 映射到指定地址的任意端口 使用ip::containerport绑定localhost的任意端口到容器的5000端口，本地主机会自动分配一个端口： docker run -itd -p 127.0.0.1::5000 --name my_docker_ubuntu ubuntu:20.04\n * 查看映射端口配置 可以使用docker port container命令来查看当前映射的端口配置，也可以查看到绑定的地址。',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"Git Commit 之道：规范化 Commit Message 写作指南",frontmatter:{title:"Git Commit 之道：规范化 Commit Message 写作指南",date:"2023-11-12T22:32:20.000Z",tags:["Git"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/4f7ea8/",categories:["工具","版本控制"],readingShow:"top"},regularPath:"/02.%E5%B7%A5%E5%85%B7/01.%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/01.Git%20Commit%20%E4%B9%8B%E9%81%93%EF%BC%9A%E8%A7%84%E8%8C%83%E5%8C%96%20Commit%20Message%20%E5%86%99%E4%BD%9C%E6%8C%87%E5%8D%97.html",relativePath:"02.工具/01.版本控制/01.Git Commit 之道：规范化 Commit Message 写作指南.md",key:"v-476ed16d",path:"/pages/4f7ea8/",headers:[{level:2,title:"1 commit message 规范",slug:"_1-commit-message-规范",normalizedTitle:"1 commit message 规范",charIndex:2},{level:3,title:"1.1 Header",slug:"_1-1-header",normalizedTitle:"1.1 header",charIndex:168},{level:3,title:"1.2 Body",slug:"_1-2-body",normalizedTitle:"1.2 body",charIndex:2552},{level:3,title:"1.3 Footer",slug:"_1-3-footer",normalizedTitle:"1.3 footer",charIndex:2790},{level:3,title:"1.4 示例",slug:"_1-4-示例",normalizedTitle:"1.4 示例",charIndex:3145},{level:2,title:"2 git commit 工具",slug:"_2-git-commit-工具",normalizedTitle:"2 git commit 工具",charIndex:6685},{level:3,title:"2.1 commitizen",slug:"_2-1-commitizen",normalizedTitle:"2.1 commitizen",charIndex:6705},{level:3,title:"2.2 commitlint",slug:"_2-2-commitlint",normalizedTitle:"2.2 commitlint",charIndex:7377},{level:2,title:"3 生成Change log",slug:"_3-生成change-log",normalizedTitle:"3 生成change log",charIndex:8618},{level:2,title:"4 参考资料",slug:"_4-参考资料",normalizedTitle:"4 参考资料",charIndex:9710}],headersStr:"1 commit message 规范 1.1 Header 1.2 Body 1.3 Footer 1.4 示例 2 git commit 工具 2.1 commitizen 2.2 commitlint 3 生成Change log 4 参考资料",content:'# 1 commit message 规范\n\ncommit message格式都包括三部分：Header，Body和Footer\n\n<type>(<scope>): <subject>\n\n<body>\n\n<footer>\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\nHeader是必需的，Body和Footer则可以省略\n\n\n# 1.1 Header\n\n 1. Type（必需）\n    \n    type用于说明git commit的类别，允许使用下面几个标识。\n    \n    >  * feat：新功能（Feature）\n    >    \n    >    "feat"用于表示引入新功能或特性的变动。这种变动通常是在代码库中新增的功能，而不仅仅是修复错误或进行代码重构。\n    > \n    >  * fix/to：修复bug。这些bug可能由QA团队发现，或由开发人员在开发过程中识别。\n    >    \n    >    * fix关键字用于那些直接解决问题的提交。当创建一个包含必要更改的提交，并且这些更改能够直接修复已识别的bug时，应使用fix。这表明提交的代码引入了解决方案，并且问题已被立即解决。\n    >    * to关键字则用于那些部分处理问题的提交。在一些复杂的修复过程中，可能需要多个步骤或多次提交来完全解决问题。在这种情况下，初始和中间的提交应使用to标记，表示它们为最终解决方案做出了贡献，但并未完全解决问题。最终解决问题的提交应使用fix标记，以表明问题已被彻底修复。\n    > \n    >  * docs：文档（Documentation）\n    >    \n    >    "docs" 表示对文档的变动，这包括对代码库中的注释、README 文件或其他文档的修改。这个前缀的提交通常用于更新文档以反映代码的变更，或者提供更好的代码理解和使用说明。\n    > \n    >  * style: 格式（Format）\n    >    \n    >    "style" 用于表示对代码格式的变动，这些变动不影响代码的运行。通常包括空格、缩进、换行等风格调整。\n    > \n    >  * refactor：重构（即不是新增功能，也不是修改bug的代码变动）\n    >    \n    >    "refactor" 表示对代码的重构，即修改代码的结构和实现方式，但不影响其外部行为。重构的目的是改进代码的可读性、可维护性和性能，而不是引入新功能或修复错误。\n    > \n    >  * perf: 优化相关，比如提升性能、体验\n    >    \n    >    "perf" 表示与性能优化相关的变动。这可能包括对算法、数据结构或代码实现的修改，以提高代码的执行效率和用户体验。\n    > \n    >  * test：增加测试\n    >    \n    >    "test" 表示增加测试，包括单元测试、集成测试或其他类型的测试。\n    > \n    >  * chore：构建过程或辅助工具的变动\n    >    \n    >    "chore" 表示对构建过程或辅助工具的变动。这可能包括更新构建脚本、配置文件或其他与构建和工具相关的内容。\n    > \n    >  * revert：回滚到上一个版本\n    >    \n    >    "revert" 用于回滚到以前的版本，撤销之前的提交。\n    > \n    >  * merge：代码合并\n    >    \n    >    "merge" 表示进行代码合并，通常是在分支开发完成后将代码合并回主线。\n    > \n    >  * sync：同步主线或分支的Bug\n    >    \n    >    "sync" 表示同步主线或分支的 Bug，通常用于解决因为合并而引入的问题。\n\n 2. Scope（可选）\n    \n    scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。\n    \n    例如修改了Dao或者Controller，则可以添加表示这些范围受到影响，这有助于更清晰地理解提交的变更影响范围。例如：\n    \n    feat(Controller): 添加用户登录功能\n    \n    \n    1\n    \n    1\n    \n    \n    这个提交消息中，Controller 是 scope，表示这次提交影响了控制层。\n    \n    fix(DataAccess): 修复数据查询逻辑\n    \n    \n    1\n    \n    1\n    \n    \n    这个提交消息中，DataAccess 是 scope，表示这次提交影响了数据访问层。\n    \n    如果你的修改影响了不止一个scope，你可以使用*代替。\n\n 3. Subject（必需）\n    \n    subject是 commit 目的的简短描述，不超过50个字符。规范如下：\n    \n    >  * 以动词开头，使用第一人称现在时，比如change，而不是changed或changes\n    >  * 第一个字母小写\n    >  * 结尾不加句号（.）\n    \n    例如：\n    \n    feat(UserAuth): implement user authentication\n    \n    \n    1\n    \n    1\n    \n    \n    这个提交消息中，implement user authentication 是 subject，简洁明了地描述了引入用户认证功能的目的。\n    \n    fix(Validation): correct input validation logic\n    \n    \n    1\n    \n    1\n    \n    \n    这个提交消息中，correct input validation logic 是 subject，清晰地说明了修复输入验证逻辑的目的。\n\n\n# 1.2 Body\n\nBody 部分是对本次 commit 的详细描述，可以分成多行。Body编写有两个注意点。\n\n>  1. 使用第一人称现在时，比如使用change而不是changed或changes。这有助于使描述更加直观和连贯，增强可读性。\n>  2. 应该说明代码变动的动机，以及与以前行为的对比。 Body 部分不仅仅是描述代码的变动，还应该解释为什么进行这个变动，以及与之前的代码行为相比有哪些改进。这有助于其他开发者更好地理解代码变更的背后动机和意图。\n\n\n# 1.3 Footer\n\nFooter 部分只用于两种情况。\n\n 1. 不兼容变动\n    \n    如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。\n\n 2. 关闭 Issue\n    \n    如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。\n    \n    > Closes #234\n    > \n    > \n    > 1\n    > \n    > 1\n    \n    也可以一次关闭多个 issue 。\n    \n    > Closes #123, #245, #992\n    > \n    > \n    > 1\n    > \n    > 1\n\n\n# 1.4 示例\n\n * 添加用户配置文件编辑功能\n   \n   > feat(UserProfile): add user profile editing feature\n   > \n   > This commit introduces a new feature that allows users to edit their profiles\n   > directly from the user interface. The motivation behind this change is to\n   > enhance user interaction and provide a more seamless experience.\n   > \n   > Previously, users had to navigate to a separate editing page to update their\n   > profile information. With this new feature, users can now make changes\n   > efficiently from their profile page, eliminating unnecessary steps in the\n   > workflow.\n   > \n   > Changes included in this commit:\n   > - Added a new \'Edit Profile\' button on the user profile page.\n   > - Implemented frontend components for profile editing.\n   > - Updated backend API to handle profile updates securely.\n   > \n   > By streamlining the profile editing process, we aim to improve overall user\n   > satisfaction and make our application more user-friendly. This enhancement is\n   > in response to user feedback, addressing the need for a more intuitive and\n   > accessible way to modify profile details.\n   > \n   > Closes #234\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n   > 16\n   > 17\n   > 18\n   > 19\n   > 20\n   > 21\n   > 22\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n   > 16\n   > 17\n   > 18\n   > 19\n   > 20\n   > 21\n   > 22\n\n * 纠正输入验证逻辑\n   \n   > fix(Validation): correct input validation logic\n   > \n   > This commit addresses an issue related to input validation logic in the\n   > application. Previously, the validation process was not handling certain edge\n   > cases correctly, leading to unexpected behavior in specific scenarios.\n   > \n   > To resolve this issue, the validation logic has been revised to properly\n   > handle various input scenarios. This ensures that user input is thoroughly\n   > validated, reducing the likelihood of errors in the application.\n   > \n   > The changes made in this commit include:\n   > - Correcting boundary checks for user input.\n   > - Improving error messages for better user guidance.\n   > \n   > These adjustments align with our commitment to delivering a robust and\n   > reliable application experience.\n   > \n   > Closes #123\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n   > 16\n   > 17\n   > 18\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n   > 16\n   > 17\n   > 18\n\n * 优化数据库查询\n   \n   > refactor(DataAccess): optimize database queries\n   > \n   > In this commit, we have refactored the data access layer to optimize database\n   > queries and improve overall system performance. The existing query structure\n   > was identified as a bottleneck during performance testing, leading to longer\n   > response times.\n   > \n   > Changes made in this commit:\n   > - Reorganized database queries to reduce redundant operations.\n   > - Utilized database indexing for faster data retrieval.\n   > \n   > By optimizing database queries, we expect to see a significant improvement in\n   > system responsiveness and user experience.\n   > \n   > Closes #456\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n\n\n# 2 git commit 工具\n\n\n# 2.1 commitizen\n\nCommitizen是一个强大的工具，用于撰写合格的 Git 提交消息。使用 Commitizen 可以帮助团队遵循统一的提交消息规范，使提交历史更加清晰和易读。\n\n首先，通过以下命令全局安装 Commitizen：\n\n> npm install -g commitizen\n> \n> \n> 1\n> \n> 1\n\n然后，在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。\n\n> commitizen init cz-conventional-changelog --save --save-exact\n> \n> \n> 1\n> \n> 1\n\n这个命令会配置项目，使其支持 Angular 规范的 Commit Message。在执行命令时，你可以选择其他预定义的规范或者创建自定义规范。\n\n之后，当你执行 git commit 命令时，将其替换为 git cz。此时，Commitizen 将引导你通过一个交互式的界面，以生成符合规范的 Commit Message。\n\n在这个交互式界面中，你可以选择提交的类型（feat、fix、docs 等）、影响的范围（scope）、简短的描述（subject）以及其他相关信息。通过这种方式，可以确保提交消息符合规范，并提供了更多的上下文信息，便于他人理解变更的目的。\n\n使用 Commitizen 和规范化的提交消息格式，有助于提高代码库的可读性，方便生成自动化的变更日志，并促使开发者更注重写出清晰、明确的提交消息。\n\n\n# 2.2 commitlint\n\ncommitlint是一个用于检查提交消息是否符合指定规范的工具。它可以帮助团队确保 Git 提交消息的一致性和规范性，尤其是当项目采用类似 Angular Commit Message Conventions 的规范时。\n\n 1. 安装 Commitlint\n    \n    > 首先，你需要安装 commitlint 及其相关的配置和规则。通常，@commitlint/config-conventional 是与 Angular 规范兼容的配置。\n    > \n    > npm install --save-dev @commitlint/config-conventional @commitlint/cli\n    > \n    > \n    > 1\n    > \n    > 1\n\n 2. 配置 Commitlint\n    \n    > 在项目根目录下创建 commitlint.config.js 文件，并添加如下内容：\n    > \n    > module.exports = {\n    >   extends: [\'@commitlint/config-conventional\'],\n    > };\n    > \n    > \n    > 1\n    > 2\n    > 3\n    > \n    > 1\n    > 2\n    > 3\n    > \n    > \n    > 这个配置文件使用了 @commitlint/config-conventional 中预定义的规则，确保符合常见的提交规范。\n\n 3. 配置Git钩子\n    \n    > 你可以使用 Husky 钩子工具来在提交前运行 commitlint。首先，安装 Husky：\n    > \n    > bashCopy code\n    > npm install --save-dev husky\n    > \n    > \n    > 1\n    > 2\n    > \n    > 1\n    > 2\n    > \n    > \n    > 然后，在 package.json 中添加以下配置：\n    > \n    > jsonCopy code\n    > "husky": {\n    >   "hooks": {\n    >     "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"\n    >   }\n    > }\n    > \n    > \n    > 1\n    > 2\n    > 3\n    > 4\n    > 5\n    > 6\n    > \n    > 1\n    > 2\n    > 3\n    > 4\n    > 5\n    > 6\n    > \n    > \n    > 这样配置后，每次提交前都会自动运行 commitlint 检查提交消息是否符合规范。\n\n\n# 3 生成Change log\n\n如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成（例1，例2）。\n\n![image-20231112222340929](/Users/zfhe/Library/Application Support/typora-user-images/image-20231112222340929.png)\n\n生成的文档包括以下三个部分。\n\n>  * New features（新特性）\n>  * Bug fixes（bug修复）\n>  * Breaking changes（重大变更）\n\n每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。\n\nconventional-changelog 就是生成 Change log 的工具，运行下面的命令即可。\n\n> npm install -g conventional-changelog\n> cd my-project\n> conventional-changelog -p angular -i CHANGELOG.md -w\n> \n> \n> 1\n> 2\n> 3\n> \n> 1\n> 2\n> 3\n\n上面命令不会覆盖以前的 Change log，只会在CHANGELOG.md的头部加上自从上次发布以来的变动。\n\n如果你想生成所有发布的 Change log，要改为运行下面的命令。\n\n> $ conventional-changelog -p angular -i CHANGELOG.md -w -r 0\n> \n> \n> 1\n> \n> 1\n\n为了方便使用，可以将其写入package.json的scripts字段。\n\n> {\n>   "scripts": {\n>     "changelog": "conventional-changelog -p angular -i CHANGELOG.md -w -r 0"\n>   }\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n以后，直接运行下面的命令即可。\n\n> $ npm run changelog\n> \n> \n> 1\n> \n> 1\n\n这个自动化流程不仅简化了 Change log 的生成过程，还确保了记录项目变更的一致性和准确性。生成的文档会按照新特性、bug 修复和重大变更等分类，方便用户快速了解每个版本的变更情况。\n\n\n# 4 参考资料\n\n 1. 如何规范你的Git commit？—阿里云开发者\n 2. Commit message 和 Change log 编写指南—阮一峰的网络日志',normalizedContent:'# 1 commit message 规范\n\ncommit message格式都包括三部分：header，body和footer\n\n<type>(<scope>): <subject>\n\n<body>\n\n<footer>\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\nheader是必需的，body和footer则可以省略\n\n\n# 1.1 header\n\n 1. type（必需）\n    \n    type用于说明git commit的类别，允许使用下面几个标识。\n    \n    >  * feat：新功能（feature）\n    >    \n    >    "feat"用于表示引入新功能或特性的变动。这种变动通常是在代码库中新增的功能，而不仅仅是修复错误或进行代码重构。\n    > \n    >  * fix/to：修复bug。这些bug可能由qa团队发现，或由开发人员在开发过程中识别。\n    >    \n    >    * fix关键字用于那些直接解决问题的提交。当创建一个包含必要更改的提交，并且这些更改能够直接修复已识别的bug时，应使用fix。这表明提交的代码引入了解决方案，并且问题已被立即解决。\n    >    * to关键字则用于那些部分处理问题的提交。在一些复杂的修复过程中，可能需要多个步骤或多次提交来完全解决问题。在这种情况下，初始和中间的提交应使用to标记，表示它们为最终解决方案做出了贡献，但并未完全解决问题。最终解决问题的提交应使用fix标记，以表明问题已被彻底修复。\n    > \n    >  * docs：文档（documentation）\n    >    \n    >    "docs" 表示对文档的变动，这包括对代码库中的注释、readme 文件或其他文档的修改。这个前缀的提交通常用于更新文档以反映代码的变更，或者提供更好的代码理解和使用说明。\n    > \n    >  * style: 格式（format）\n    >    \n    >    "style" 用于表示对代码格式的变动，这些变动不影响代码的运行。通常包括空格、缩进、换行等风格调整。\n    > \n    >  * refactor：重构（即不是新增功能，也不是修改bug的代码变动）\n    >    \n    >    "refactor" 表示对代码的重构，即修改代码的结构和实现方式，但不影响其外部行为。重构的目的是改进代码的可读性、可维护性和性能，而不是引入新功能或修复错误。\n    > \n    >  * perf: 优化相关，比如提升性能、体验\n    >    \n    >    "perf" 表示与性能优化相关的变动。这可能包括对算法、数据结构或代码实现的修改，以提高代码的执行效率和用户体验。\n    > \n    >  * test：增加测试\n    >    \n    >    "test" 表示增加测试，包括单元测试、集成测试或其他类型的测试。\n    > \n    >  * chore：构建过程或辅助工具的变动\n    >    \n    >    "chore" 表示对构建过程或辅助工具的变动。这可能包括更新构建脚本、配置文件或其他与构建和工具相关的内容。\n    > \n    >  * revert：回滚到上一个版本\n    >    \n    >    "revert" 用于回滚到以前的版本，撤销之前的提交。\n    > \n    >  * merge：代码合并\n    >    \n    >    "merge" 表示进行代码合并，通常是在分支开发完成后将代码合并回主线。\n    > \n    >  * sync：同步主线或分支的bug\n    >    \n    >    "sync" 表示同步主线或分支的 bug，通常用于解决因为合并而引入的问题。\n\n 2. scope（可选）\n    \n    scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。\n    \n    例如修改了dao或者controller，则可以添加表示这些范围受到影响，这有助于更清晰地理解提交的变更影响范围。例如：\n    \n    feat(controller): 添加用户登录功能\n    \n    \n    1\n    \n    1\n    \n    \n    这个提交消息中，controller 是 scope，表示这次提交影响了控制层。\n    \n    fix(dataaccess): 修复数据查询逻辑\n    \n    \n    1\n    \n    1\n    \n    \n    这个提交消息中，dataaccess 是 scope，表示这次提交影响了数据访问层。\n    \n    如果你的修改影响了不止一个scope，你可以使用*代替。\n\n 3. subject（必需）\n    \n    subject是 commit 目的的简短描述，不超过50个字符。规范如下：\n    \n    >  * 以动词开头，使用第一人称现在时，比如change，而不是changed或changes\n    >  * 第一个字母小写\n    >  * 结尾不加句号（.）\n    \n    例如：\n    \n    feat(userauth): implement user authentication\n    \n    \n    1\n    \n    1\n    \n    \n    这个提交消息中，implement user authentication 是 subject，简洁明了地描述了引入用户认证功能的目的。\n    \n    fix(validation): correct input validation logic\n    \n    \n    1\n    \n    1\n    \n    \n    这个提交消息中，correct input validation logic 是 subject，清晰地说明了修复输入验证逻辑的目的。\n\n\n# 1.2 body\n\nbody 部分是对本次 commit 的详细描述，可以分成多行。body编写有两个注意点。\n\n>  1. 使用第一人称现在时，比如使用change而不是changed或changes。这有助于使描述更加直观和连贯，增强可读性。\n>  2. 应该说明代码变动的动机，以及与以前行为的对比。 body 部分不仅仅是描述代码的变动，还应该解释为什么进行这个变动，以及与之前的代码行为相比有哪些改进。这有助于其他开发者更好地理解代码变更的背后动机和意图。\n\n\n# 1.3 footer\n\nfooter 部分只用于两种情况。\n\n 1. 不兼容变动\n    \n    如果当前代码与上一个版本不兼容，则 footer 部分以breaking change开头，后面是对变动的描述、以及变动理由和迁移方法。\n\n 2. 关闭 issue\n    \n    如果当前 commit 针对某个issue，那么可以在 footer 部分关闭这个 issue 。\n    \n    > closes #234\n    > \n    > \n    > 1\n    > \n    > 1\n    \n    也可以一次关闭多个 issue 。\n    \n    > closes #123, #245, #992\n    > \n    > \n    > 1\n    > \n    > 1\n\n\n# 1.4 示例\n\n * 添加用户配置文件编辑功能\n   \n   > feat(userprofile): add user profile editing feature\n   > \n   > this commit introduces a new feature that allows users to edit their profiles\n   > directly from the user interface. the motivation behind this change is to\n   > enhance user interaction and provide a more seamless experience.\n   > \n   > previously, users had to navigate to a separate editing page to update their\n   > profile information. with this new feature, users can now make changes\n   > efficiently from their profile page, eliminating unnecessary steps in the\n   > workflow.\n   > \n   > changes included in this commit:\n   > - added a new \'edit profile\' button on the user profile page.\n   > - implemented frontend components for profile editing.\n   > - updated backend api to handle profile updates securely.\n   > \n   > by streamlining the profile editing process, we aim to improve overall user\n   > satisfaction and make our application more user-friendly. this enhancement is\n   > in response to user feedback, addressing the need for a more intuitive and\n   > accessible way to modify profile details.\n   > \n   > closes #234\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n   > 16\n   > 17\n   > 18\n   > 19\n   > 20\n   > 21\n   > 22\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n   > 16\n   > 17\n   > 18\n   > 19\n   > 20\n   > 21\n   > 22\n\n * 纠正输入验证逻辑\n   \n   > fix(validation): correct input validation logic\n   > \n   > this commit addresses an issue related to input validation logic in the\n   > application. previously, the validation process was not handling certain edge\n   > cases correctly, leading to unexpected behavior in specific scenarios.\n   > \n   > to resolve this issue, the validation logic has been revised to properly\n   > handle various input scenarios. this ensures that user input is thoroughly\n   > validated, reducing the likelihood of errors in the application.\n   > \n   > the changes made in this commit include:\n   > - correcting boundary checks for user input.\n   > - improving error messages for better user guidance.\n   > \n   > these adjustments align with our commitment to delivering a robust and\n   > reliable application experience.\n   > \n   > closes #123\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n   > 16\n   > 17\n   > 18\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n   > 16\n   > 17\n   > 18\n\n * 优化数据库查询\n   \n   > refactor(dataaccess): optimize database queries\n   > \n   > in this commit, we have refactored the data access layer to optimize database\n   > queries and improve overall system performance. the existing query structure\n   > was identified as a bottleneck during performance testing, leading to longer\n   > response times.\n   > \n   > changes made in this commit:\n   > - reorganized database queries to reduce redundant operations.\n   > - utilized database indexing for faster data retrieval.\n   > \n   > by optimizing database queries, we expect to see a significant improvement in\n   > system responsiveness and user experience.\n   > \n   > closes #456\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n\n\n# 2 git commit 工具\n\n\n# 2.1 commitizen\n\ncommitizen是一个强大的工具，用于撰写合格的 git 提交消息。使用 commitizen 可以帮助团队遵循统一的提交消息规范，使提交历史更加清晰和易读。\n\n首先，通过以下命令全局安装 commitizen：\n\n> npm install -g commitizen\n> \n> \n> 1\n> \n> 1\n\n然后，在项目目录里，运行下面的命令，使其支持 angular 的 commit message 格式。\n\n> commitizen init cz-conventional-changelog --save --save-exact\n> \n> \n> 1\n> \n> 1\n\n这个命令会配置项目，使其支持 angular 规范的 commit message。在执行命令时，你可以选择其他预定义的规范或者创建自定义规范。\n\n之后，当你执行 git commit 命令时，将其替换为 git cz。此时，commitizen 将引导你通过一个交互式的界面，以生成符合规范的 commit message。\n\n在这个交互式界面中，你可以选择提交的类型（feat、fix、docs 等）、影响的范围（scope）、简短的描述（subject）以及其他相关信息。通过这种方式，可以确保提交消息符合规范，并提供了更多的上下文信息，便于他人理解变更的目的。\n\n使用 commitizen 和规范化的提交消息格式，有助于提高代码库的可读性，方便生成自动化的变更日志，并促使开发者更注重写出清晰、明确的提交消息。\n\n\n# 2.2 commitlint\n\ncommitlint是一个用于检查提交消息是否符合指定规范的工具。它可以帮助团队确保 git 提交消息的一致性和规范性，尤其是当项目采用类似 angular commit message conventions 的规范时。\n\n 1. 安装 commitlint\n    \n    > 首先，你需要安装 commitlint 及其相关的配置和规则。通常，@commitlint/config-conventional 是与 angular 规范兼容的配置。\n    > \n    > npm install --save-dev @commitlint/config-conventional @commitlint/cli\n    > \n    > \n    > 1\n    > \n    > 1\n\n 2. 配置 commitlint\n    \n    > 在项目根目录下创建 commitlint.config.js 文件，并添加如下内容：\n    > \n    > module.exports = {\n    >   extends: [\'@commitlint/config-conventional\'],\n    > };\n    > \n    > \n    > 1\n    > 2\n    > 3\n    > \n    > 1\n    > 2\n    > 3\n    > \n    > \n    > 这个配置文件使用了 @commitlint/config-conventional 中预定义的规则，确保符合常见的提交规范。\n\n 3. 配置git钩子\n    \n    > 你可以使用 husky 钩子工具来在提交前运行 commitlint。首先，安装 husky：\n    > \n    > bashcopy code\n    > npm install --save-dev husky\n    > \n    > \n    > 1\n    > 2\n    > \n    > 1\n    > 2\n    > \n    > \n    > 然后，在 package.json 中添加以下配置：\n    > \n    > jsoncopy code\n    > "husky": {\n    >   "hooks": {\n    >     "commit-msg": "commitlint -e husky_git_params"\n    >   }\n    > }\n    > \n    > \n    > 1\n    > 2\n    > 3\n    > 4\n    > 5\n    > 6\n    > \n    > 1\n    > 2\n    > 3\n    > 4\n    > 5\n    > 6\n    > \n    > \n    > 这样配置后，每次提交前都会自动运行 commitlint 检查提交消息是否符合规范。\n\n\n# 3 生成change log\n\n如果你的所有 commit 都符合 angular 格式，那么发布新版本时， change log 就可以用脚本自动生成（例1，例2）。\n\n![image-20231112222340929](/users/zfhe/library/application support/typora-user-images/image-20231112222340929.png)\n\n生成的文档包括以下三个部分。\n\n>  * new features（新特性）\n>  * bug fixes（bug修复）\n>  * breaking changes（重大变更）\n\n每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。\n\nconventional-changelog 就是生成 change log 的工具，运行下面的命令即可。\n\n> npm install -g conventional-changelog\n> cd my-project\n> conventional-changelog -p angular -i changelog.md -w\n> \n> \n> 1\n> 2\n> 3\n> \n> 1\n> 2\n> 3\n\n上面命令不会覆盖以前的 change log，只会在changelog.md的头部加上自从上次发布以来的变动。\n\n如果你想生成所有发布的 change log，要改为运行下面的命令。\n\n> $ conventional-changelog -p angular -i changelog.md -w -r 0\n> \n> \n> 1\n> \n> 1\n\n为了方便使用，可以将其写入package.json的scripts字段。\n\n> {\n>   "scripts": {\n>     "changelog": "conventional-changelog -p angular -i changelog.md -w -r 0"\n>   }\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n以后，直接运行下面的命令即可。\n\n> $ npm run changelog\n> \n> \n> 1\n> \n> 1\n\n这个自动化流程不仅简化了 change log 的生成过程，还确保了记录项目变更的一致性和准确性。生成的文档会按照新特性、bug 修复和重大变更等分类，方便用户快速了解每个版本的变更情况。\n\n\n# 4 参考资料\n\n 1. 如何规范你的git commit？—阿里云开发者\n 2. commit message 和 change log 编写指南—阮一峰的网络日志',charsets:{cjk:!0},lastUpdated:"2023/11/25, 12:26:00",lastUpdatedTimestamp:170088636e4},{title:"Git教程",frontmatter:{title:"Git教程",date:"2022-01-26T16:15:34.000Z",tags:["Git"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/992deb/",categories:["工具","版本控制"],readingShow:"top"},regularPath:"/02.%E5%B7%A5%E5%85%B7/01.%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/02.Git%E6%95%99%E7%A8%8B.html",relativePath:"02.工具/01.版本控制/02.Git教程.md",key:"v-3a3276c2",path:"/pages/992deb/",headers:[{level:2,title:"1 git简介",slug:"_1-git简介",normalizedTitle:"1 git简介",charIndex:2},{level:3,title:"1.1 什么是版本控制",slug:"_1-1-什么是版本控制",normalizedTitle:"1.1 什么是版本控制",charIndex:14},{level:3,title:"1.2 什么是git",slug:"_1-2-什么是git",normalizedTitle:"1.2 什么是git",charIndex:1018},{level:3,title:"1.3 git的几个核心概念",slug:"_1-3-git的几个核心概念",normalizedTitle:"1.3 git的几个核心概念",charIndex:1385},{level:3,title:"1.4 git工作流程",slug:"_1-4-git工作流程",normalizedTitle:"1.4 git工作流程",charIndex:1800},{level:2,title:"2 git安装配置",slug:"_2-git安装配置",normalizedTitle:"2 git安装配置",charIndex:1975},{level:3,title:"2.1 windows平台安装",slug:"_2-1-windows平台安装",normalizedTitle:"2.1 windows平台安装",charIndex:1989},{level:3,title:"2.2 Linux平台安装",slug:"_2-2-linux平台安装",normalizedTitle:"2.2 linux平台安装",charIndex:2049},{level:3,title:"2.3 Mac平台安装",slug:"_2-3-mac平台安装",normalizedTitle:"2.3 mac平台安装",charIndex:2320},{level:3,title:"2.4 配置",slug:"_2-4-配置",normalizedTitle:"2.4 配置",charIndex:2376},{level:2,title:"3 git基本命令",slug:"_3-git基本命令",normalizedTitle:"3 git基本命令",charIndex:2576},{level:3,title:"3.1 建立本地仓库",slug:"_3-1-建立本地仓库",normalizedTitle:"3.1 建立本地仓库",charIndex:2590},{level:3,title:"3.2 提交、修改和删除",slug:"_3-2-提交、修改和删除",normalizedTitle:"3.2 提交、修改和删除",charIndex:2935},{level:3,title:"3.3 查看日志",slug:"_3-3-查看日志",normalizedTitle:"3.3 查看日志",charIndex:4582},{level:3,title:"3.4 分支管理",slug:"_3-4-分支管理",normalizedTitle:"3.4 分支管理",charIndex:4851},{level:3,title:"3.5 远程操作",slug:"_3-5-远程操作",normalizedTitle:"3.5 远程操作",charIndex:5389},{level:3,title:"3.6 保存和恢复进度",slug:"_3-6-保存和恢复进度",normalizedTitle:"3.6 保存和恢复进度",charIndex:6361},{level:2,title:"4 Git用法思维导图",slug:"_4-git用法思维导图",normalizedTitle:"4 git用法思维导图",charIndex:6967}],headersStr:"1 git简介 1.1 什么是版本控制 1.2 什么是git 1.3 git的几个核心概念 1.4 git工作流程 2 git安装配置 2.1 windows平台安装 2.2 Linux平台安装 2.3 Mac平台安装 2.4 配置 3 git基本命令 3.1 建立本地仓库 3.2 提交、修改和删除 3.3 查看日志 3.4 分支管理 3.5 远程操作 3.6 保存和恢复进度 4 Git用法思维导图",content:'# 1 git简介\n\n\n# 1.1 什么是版本控制\n\n版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 除了项目源代码，你可以对任何类型的文件进行版本控制。 有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。 而版本控制系统（VCS）则是一种软件，可以帮助软件团队的开发人员协同工作，并存档他们工作的完整历史记录。 目前版本控制系统有如下三种：\n\n * 本地版本控制系统：即通过用文件目录形式保存每个项目版本，其中目录名会备注一些版本信息、修改时间等。其最大的好处就是简单，但特别容易犯错，不利于管理，容易覆盖重要的文件，而且不适合协同工作。\n\n * 集中式版本控制系统（Centralized Version Control Systems，CVCS）：集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。这么做虽然解决了本地版本控制系统无法让在不同系统上的开发者协同工作的诟病，但也还是存在下面的问题：如果中央服务器宕机，则其他人无法使用；必须联网才能工作。\n\n * 分布式版本控制系统（Distributed Version Control Systems，DVCS）：在这类系统中，像 Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。 分布式版本控制系统可以不用联网就可以工作，因为每个人的电脑上都是完整的版本库，当你修改了某个文件后，你只需要将自己的修改推送给别人就可以了。但是，在实际使用分布式版本控制系统的时候，很少会直接进行推送修改，而是使用一台充当“中央服务器”的东西。这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 分布式版本控制系统的优势不单是不必联网这么简单，后面我们还会看到 Git 极其强大的分支管理等功能。\n\n\n# 1.2 什么是git\n\nGit是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。其是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 官网地址为：https://git-scm.com/，在上面有权威的git介绍以及git下载地址。 SVN是集中式版本控制系统，而Git是分布式版本控制系统，Git与SVN的区别可参考Git与SVN的区别。 git有以下优点：\n\n * 适合分布式开发，强调个体；公共服务器压力和数据量都不会太大；\n\n * 速度快、灵活；\n\n * 任意两个开发者之间可以很容易的解决冲突；\n\n * 离线工作。\n\n\n# 1.3 git的几个核心概念\n\n * 工作区（workspace）：仓库的目录。工作区是独立于各个分支的。在当前仓库中，新增，更改，删除文件这些动作，都发生在工作区里面。\n * 暂存区（index/stage）：数据暂时存放的区域，类似于工作区写入版本库前的缓存区。暂存区是独立于各个分支的。一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。\n * 版本库（Repository）：也可以叫仓库区，实际上就是我们的本地仓库。就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本\n * 版本结构：树结构，树中每个节点代表一个代码版本。\n * 远程仓库（Remote Repository）： 托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换。目前流行的远程仓库有：Github、Gitee。\n\n\n# 1.4 git工作流程\n\n一般工作流程如下：\n\n * 从远程仓库中克隆 Git 资源作为本地仓库；\n * 从本地仓库中checkout代码然后进行代码修改；\n * 在提交本地仓库前先将代码提交到暂存区；\n * 提交修改，提交到本地仓库；本地仓库中保存修改的各个历史版本；\n * 在需要和团队成员共享代码时，可以将修改代码push到远程仓库。\n\n\n# 2 git安装配置\n\n\n# 2.1 windows平台安装\n\n主要学linux，这里列出其他blog的windows平台安装教程：安装教程\n\n\n# 2.2 Linux平台安装\n\n首先，我们可以尝试着输入git，看看系统有没有安装Git：\n\n$ git\nThe program \'git\' is currently not installed. You can install it by typing:\nsudo apt-get install git\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n如果出现这个，则说明Git还没有安装，如果我们使用得是Debian或者Ubuntu Linux，通过命令：sudo apt-get install git就可以直接完成Git的安装，非常简单。\n\n\n# 2.3 Mac平台安装\n\n主要学linux，这里列出其他blog的Mac平台安装配置教程：安装配置教程\n\n\n# 2.4 配置\n\n安装好git之后，就需要对git进行配置操作了，需要配置自己的用户名和Email。配置的命令如下：\n\n$ git config --global user.name "用户名"\n$ git config --global user.email "邮箱"\n\n\n1\n2\n\n1\n2\n\n\n如果你需要检查你的配置信息，可以使用git config --list命令来列出所有配置信息：\n\n\n# 3 git基本命令\n\n\n# 3.1 建立本地仓库\n\n(1). 创建一个目录，并将其初始化为本地仓库 git init 本地仓库名 (2). 使用当前目录作为本地仓库 git init (3). 将远程仓库克隆下来作为本地仓库 此命令支持多种协议，但我一般是通过SSH协议，其内部实现是通过SSH，所以进行这步操作之前我们需要确保在远程仓库添加了SSH公钥，如果没有添加需要在本地主机通过ssh-keygen，然后会生成ssh公钥和密钥，我们将公钥添加到远程仓库即可。 git clone git@服务器名:仓库路径 该格式和scp命令一致，@前面表示用户名，这个一般都是git，后面表示服务器名，可以是IP地址，也可以是域名，例如github.com，:后面表示仓库路径。不过不需要担心，这个远程仓库会给出。\n\n\n# 3.2 提交、修改和删除\n\n(1). 将文件提交到暂存区\n\n# 将指定文件添加到暂存区\ngit add file1 file2 ... fileN \n# 将指定目录添加到暂存区\ngit add dir1 dir2 ... dirN\n# 添加当前目录下的所有文件到暂存区\ngit add .\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n(2). 将文件从暂存区中撤出，但不会撤销文件的更改 git restore --staged (3). 将不在暂存区的文件撤销更改，需要和(2)作区分，两者作用完全不一样。\n\ngit restore file\n或\ngit checkout -- file\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n(4). 比较暂存区和工作区文件之间的差异\n\n# 显示暂存区和工作区之间的差异\ngit diff [file]\n# 显示暂存区和上一次提交的差异\ngit diff --cached [file]\n或\ngit diff --staged [file]\n# 显示两次提交的差异\n \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n该file可以省略，如果省略，则是比较暂存区中的所有文件。注意，如果暂存区没有内容，则是比较HEAD指针指向的版本库内容。 (5). 查看仓库状态 git status 该命令用于查看在你上次提交之后是否有对文件进行再次修改，如果我们需要获取简短的输出结果，可添加-s参数来实现。 (6). 提交暂存区内容到本地仓库 暂存区的内容可以通过git commit来提交到本地仓库。 git commit [file1] [file2]...[fileN] -m [备注信息] 其中file1等是可以直接省略的，如果意味着提交所有信息，而-m是参数，后面接备注信息。当然，在进行git commit之前，我们需要通过git add命令将修改添加到暂存区。 (7). 回退版本 我们可以通过git reset命令来回退版本，可以指定退回某一次提交的版本。具体如下：\n\n# 将代码库回退到上一个版本\ngit reset --hard HEAD^ \n或\ngit reset --hard HEAD~\n# 向上回滚两次，一次类推\ngit reset --hard HEAD^^\n# 向上回滚n次。\ngit rest --hard HEAD~n\n# 回滚到某一特定版本，用版本号实现，版本号唯一标识一个版本\ngit reset --hard 版本号\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n(8). 删除文件 在Git中，删除文件也是一种修改操作，删除文件有三种形式：\n\n> 利用rm file实现删除，此形式只是会删除工作区的文件，并没有删除版本库的文件，如果还需要删除版本库的文件还需要执行下列命令，这样就可以实现工作区和版本库的文件：\n\ngit add file # 加入暂存区\ngit commit -m  "delete file"\n\n\n1\n2\n\n1\n2\n\n\n> 利用git rm file实现删除，会删除工作区的文件，并且将此次删除加入暂存区。但需要注意要删除的文件是没有修改过的，如果需要删除修改过的，需要加入-f，当然，这个时候我们也还没有删除版本库的文件，只是我们只需要执行git commit -m "delete file"就可以。\n\n利用git rm --cached file实现删除，只会删除暂存区的文件，但会保留工作区的文件，并且会将这次删除放入暂存区，然后我们执行git commit -m "delete file"就可以实现删除暂存区和版本库的文件。 (9). 移动或者重命名文件 git mv [file] [newFile]可以用来移动或者重命名一个文件、目录或者软连接。如果新文件名已经存在，还需要添加-f参数。\n\n\n# 3.3 查看日志\n\n(1). 查看当前分支的所有版本 git log，我们可以用这个命令历史提交记录，当然这个命令还有许多参数供我们使用：\n\n * --oneline：查看历史记录的简洁版本。\n * --graph：查看历史中什么时候出现了分支、合并。开启拓扑图选项。\n * --reverse：逆向显示所有日志。\n * --author=user：指定查看user提交的部分。\n * --since、--before、--after等：指定日期。 (2). 查看HEAD指针的移动历史（包括被回滚的版本） git reflog\n\n\n# 3.4 分支管理\n\n几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。 有人把 Git 的分支模型称为必杀技特性，而正是因为它，将 Git 从版本控制系统家族里区分出来。 (1). 创建分支 git branch (branchName) (2). 切换分支 git checkout (branchName) 当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。 添加-b参数可以创建并切换分支。 (3). 合并分支 git merge (branchName) 将branch_name合并到当前分支上。 (4) 删除分支 git branch -d (branchName) 删除本地仓库的branchName分支。 (5). 列出分支 git branch 没有参数时，git branch会列出你在本地的分支。 (6). 合并冲突 合并并不仅仅是简单的文件添加、移除的操作。Git也会合并修改，当两个分支对同一个文件都进行了修改，那么就会产生合并冲突，我们需要去手动修改它。然后需要使用git add命令来告诉Git冲突已经解决了。\n\n\n# 3.5 远程操作\n\n(1). 将本地仓库关联到远程仓库 git remote add [short-name] [url] 其中short-name指定一个方便使用的简写，为远程仓库的别名。例如git remote add origin git@git.acwing.com:unique_pursuit/test.git即可添加远程仓库。 (2). 查看当前配置有哪些远程库 git remote 执行时添加上-v参数可查看到每个别名的实际链接地址。 (3). 删除远程仓库 git remote rm name 其中name为仓库的别名。 (4). 修改仓库名 git remote rename old_name new_name (5). 查看主机的详细信息 git remote show <主机名> (6) 设置本地分支与远程仓库分支对应 git push --set-upstream <远程主机名> <branchName> 设置本地的branchName分支对应远程仓库的branchName分支，远程主机名为git clone设置的仓库别名。 git branch --set-upstream-to=origin/branchName1 branchName2 将远程仓库的branchName1分支与本地的branchName2分支对应。 (7). 将本地当前分支推送到远程主机 git push <远程主机名> <本地分支名>:<远程分支名> 如果本地分支名和远程分支名相同，则可以直接使用下面的命令。 git push <远程主机名> <branchName> 将本地的branchName分支推到远程仓库，在此之前需要先设置与远程仓库对应分支。 如果当前分支与多个主机存在追踪关系，需要使用-u参数指定一个默认主机，这样后面可以不加任何参数使用git push。 (8). 删除远程仓库的branchName分支 git push -d <远程主机名> branchName (9). 将远程仓库的分支与本地仓库的分支合并 git pull <远程主机名> <远程分支名>:<本地分支名> 如果本地分支名和远程分支名相同，则可以使用下面的命令。 git push <远程分支名> <branchName>\n\n\n# 3.6 保存和恢复进度\n\n我们有时会遇到这样的情况，正在dev分支开发新功能，做到一半时有人过来反馈一个bug，让马上解决，但是新功能做到了一半你又不想提交，又想保存它，这个时候就可以使用git stash命令先把进度保存起来。 (1). 保存当前工作进度 git stash 将工作区和暂存区尚未提交的修改存入栈中。再运行git status可以发现是一个干净的工作区，没有任何改动。使用git stash save \'message\'可以添加一些注释 (2). 恢复工作进度 恢复最新的进度到工作区。git会默认把工作区和暂存区的改动都恢复到工作区。 git stash pop 恢复最新的进度到工作区和暂存区。 git stash pop --index 恢复指定的进度到工作区。 git stash pop stash_id 其中stash_id是通过git stash list获取的。 通过git stash pop恢复进度后，会删除当前进度。 还有一个git stash apply命令除了不删除进度，其他和git stash pop一样。 (3). 显示保存进度的列表 git stash list (4) 删除进度 删除所有进度 git stash clear 删除一个存储的进度，如果不指定stash_id，则默认删除最新的进度。 git stash drop [stash_id]\n\n\n# 4 Git用法思维导图\n\n',normalizedContent:'# 1 git简介\n\n\n# 1.1 什么是版本控制\n\n版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 除了项目源代码，你可以对任何类型的文件进行版本控制。 有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。 而版本控制系统（vcs）则是一种软件，可以帮助软件团队的开发人员协同工作，并存档他们工作的完整历史记录。 目前版本控制系统有如下三种：\n\n * 本地版本控制系统：即通过用文件目录形式保存每个项目版本，其中目录名会备注一些版本信息、修改时间等。其最大的好处就是简单，但特别容易犯错，不利于管理，容易覆盖重要的文件，而且不适合协同工作。\n\n * 集中式版本控制系统（centralized version control systems，cvcs）：集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。这么做虽然解决了本地版本控制系统无法让在不同系统上的开发者协同工作的诟病，但也还是存在下面的问题：如果中央服务器宕机，则其他人无法使用；必须联网才能工作。\n\n * 分布式版本控制系统（distributed version control systems，dvcs）：在这类系统中，像 git、mercurial、bazaar 以及 darcs 等，客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。 分布式版本控制系统可以不用联网就可以工作，因为每个人的电脑上都是完整的版本库，当你修改了某个文件后，你只需要将自己的修改推送给别人就可以了。但是，在实际使用分布式版本控制系统的时候，很少会直接进行推送修改，而是使用一台充当“中央服务器”的东西。这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 分布式版本控制系统的优势不单是不必联网这么简单，后面我们还会看到 git 极其强大的分支管理等功能。\n\n\n# 1.2 什么是git\n\ngit是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。其是 linus torvalds 为了帮助管理 linux 内核开发而开发的一个开放源码的版本控制软件。git 与常用的版本控制工具 cvs, subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 官网地址为：https://git-scm.com/，在上面有权威的git介绍以及git下载地址。 svn是集中式版本控制系统，而git是分布式版本控制系统，git与svn的区别可参考git与svn的区别。 git有以下优点：\n\n * 适合分布式开发，强调个体；公共服务器压力和数据量都不会太大；\n\n * 速度快、灵活；\n\n * 任意两个开发者之间可以很容易的解决冲突；\n\n * 离线工作。\n\n\n# 1.3 git的几个核心概念\n\n * 工作区（workspace）：仓库的目录。工作区是独立于各个分支的。在当前仓库中，新增，更改，删除文件这些动作，都发生在工作区里面。\n * 暂存区（index/stage）：数据暂时存放的区域，类似于工作区写入版本库前的缓存区。暂存区是独立于各个分支的。一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。\n * 版本库（repository）：也可以叫仓库区，实际上就是我们的本地仓库。就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中head指向最新放入仓库的版本\n * 版本结构：树结构，树中每个节点代表一个代码版本。\n * 远程仓库（remote repository）： 托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换。目前流行的远程仓库有：github、gitee。\n\n\n# 1.4 git工作流程\n\n一般工作流程如下：\n\n * 从远程仓库中克隆 git 资源作为本地仓库；\n * 从本地仓库中checkout代码然后进行代码修改；\n * 在提交本地仓库前先将代码提交到暂存区；\n * 提交修改，提交到本地仓库；本地仓库中保存修改的各个历史版本；\n * 在需要和团队成员共享代码时，可以将修改代码push到远程仓库。\n\n\n# 2 git安装配置\n\n\n# 2.1 windows平台安装\n\n主要学linux，这里列出其他blog的windows平台安装教程：安装教程\n\n\n# 2.2 linux平台安装\n\n首先，我们可以尝试着输入git，看看系统有没有安装git：\n\n$ git\nthe program \'git\' is currently not installed. you can install it by typing:\nsudo apt-get install git\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n如果出现这个，则说明git还没有安装，如果我们使用得是debian或者ubuntu linux，通过命令：sudo apt-get install git就可以直接完成git的安装，非常简单。\n\n\n# 2.3 mac平台安装\n\n主要学linux，这里列出其他blog的mac平台安装配置教程：安装配置教程\n\n\n# 2.4 配置\n\n安装好git之后，就需要对git进行配置操作了，需要配置自己的用户名和email。配置的命令如下：\n\n$ git config --global user.name "用户名"\n$ git config --global user.email "邮箱"\n\n\n1\n2\n\n1\n2\n\n\n如果你需要检查你的配置信息，可以使用git config --list命令来列出所有配置信息：\n\n\n# 3 git基本命令\n\n\n# 3.1 建立本地仓库\n\n(1). 创建一个目录，并将其初始化为本地仓库 git init 本地仓库名 (2). 使用当前目录作为本地仓库 git init (3). 将远程仓库克隆下来作为本地仓库 此命令支持多种协议，但我一般是通过ssh协议，其内部实现是通过ssh，所以进行这步操作之前我们需要确保在远程仓库添加了ssh公钥，如果没有添加需要在本地主机通过ssh-keygen，然后会生成ssh公钥和密钥，我们将公钥添加到远程仓库即可。 git clone git@服务器名:仓库路径 该格式和scp命令一致，@前面表示用户名，这个一般都是git，后面表示服务器名，可以是ip地址，也可以是域名，例如github.com，:后面表示仓库路径。不过不需要担心，这个远程仓库会给出。\n\n\n# 3.2 提交、修改和删除\n\n(1). 将文件提交到暂存区\n\n# 将指定文件添加到暂存区\ngit add file1 file2 ... filen \n# 将指定目录添加到暂存区\ngit add dir1 dir2 ... dirn\n# 添加当前目录下的所有文件到暂存区\ngit add .\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n(2). 将文件从暂存区中撤出，但不会撤销文件的更改 git restore --staged (3). 将不在暂存区的文件撤销更改，需要和(2)作区分，两者作用完全不一样。\n\ngit restore file\n或\ngit checkout -- file\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n(4). 比较暂存区和工作区文件之间的差异\n\n# 显示暂存区和工作区之间的差异\ngit diff [file]\n# 显示暂存区和上一次提交的差异\ngit diff --cached [file]\n或\ngit diff --staged [file]\n# 显示两次提交的差异\n \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n该file可以省略，如果省略，则是比较暂存区中的所有文件。注意，如果暂存区没有内容，则是比较head指针指向的版本库内容。 (5). 查看仓库状态 git status 该命令用于查看在你上次提交之后是否有对文件进行再次修改，如果我们需要获取简短的输出结果，可添加-s参数来实现。 (6). 提交暂存区内容到本地仓库 暂存区的内容可以通过git commit来提交到本地仓库。 git commit [file1] [file2]...[filen] -m [备注信息] 其中file1等是可以直接省略的，如果意味着提交所有信息，而-m是参数，后面接备注信息。当然，在进行git commit之前，我们需要通过git add命令将修改添加到暂存区。 (7). 回退版本 我们可以通过git reset命令来回退版本，可以指定退回某一次提交的版本。具体如下：\n\n# 将代码库回退到上一个版本\ngit reset --hard head^ \n或\ngit reset --hard head~\n# 向上回滚两次，一次类推\ngit reset --hard head^^\n# 向上回滚n次。\ngit rest --hard head~n\n# 回滚到某一特定版本，用版本号实现，版本号唯一标识一个版本\ngit reset --hard 版本号\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n(8). 删除文件 在git中，删除文件也是一种修改操作，删除文件有三种形式：\n\n> 利用rm file实现删除，此形式只是会删除工作区的文件，并没有删除版本库的文件，如果还需要删除版本库的文件还需要执行下列命令，这样就可以实现工作区和版本库的文件：\n\ngit add file # 加入暂存区\ngit commit -m  "delete file"\n\n\n1\n2\n\n1\n2\n\n\n> 利用git rm file实现删除，会删除工作区的文件，并且将此次删除加入暂存区。但需要注意要删除的文件是没有修改过的，如果需要删除修改过的，需要加入-f，当然，这个时候我们也还没有删除版本库的文件，只是我们只需要执行git commit -m "delete file"就可以。\n\n利用git rm --cached file实现删除，只会删除暂存区的文件，但会保留工作区的文件，并且会将这次删除放入暂存区，然后我们执行git commit -m "delete file"就可以实现删除暂存区和版本库的文件。 (9). 移动或者重命名文件 git mv [file] [newfile]可以用来移动或者重命名一个文件、目录或者软连接。如果新文件名已经存在，还需要添加-f参数。\n\n\n# 3.3 查看日志\n\n(1). 查看当前分支的所有版本 git log，我们可以用这个命令历史提交记录，当然这个命令还有许多参数供我们使用：\n\n * --oneline：查看历史记录的简洁版本。\n * --graph：查看历史中什么时候出现了分支、合并。开启拓扑图选项。\n * --reverse：逆向显示所有日志。\n * --author=user：指定查看user提交的部分。\n * --since、--before、--after等：指定日期。 (2). 查看head指针的移动历史（包括被回滚的版本） git reflog\n\n\n# 3.4 分支管理\n\n几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。 有人把 git 的分支模型称为必杀技特性，而正是因为它，将 git 从版本控制系统家族里区分出来。 (1). 创建分支 git branch (branchname) (2). 切换分支 git checkout (branchname) 当你切换分支的时候，git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。 添加-b参数可以创建并切换分支。 (3). 合并分支 git merge (branchname) 将branch_name合并到当前分支上。 (4) 删除分支 git branch -d (branchname) 删除本地仓库的branchname分支。 (5). 列出分支 git branch 没有参数时，git branch会列出你在本地的分支。 (6). 合并冲突 合并并不仅仅是简单的文件添加、移除的操作。git也会合并修改，当两个分支对同一个文件都进行了修改，那么就会产生合并冲突，我们需要去手动修改它。然后需要使用git add命令来告诉git冲突已经解决了。\n\n\n# 3.5 远程操作\n\n(1). 将本地仓库关联到远程仓库 git remote add [short-name] [url] 其中short-name指定一个方便使用的简写，为远程仓库的别名。例如git remote add origin git@git.acwing.com:unique_pursuit/test.git即可添加远程仓库。 (2). 查看当前配置有哪些远程库 git remote 执行时添加上-v参数可查看到每个别名的实际链接地址。 (3). 删除远程仓库 git remote rm name 其中name为仓库的别名。 (4). 修改仓库名 git remote rename old_name new_name (5). 查看主机的详细信息 git remote show <主机名> (6) 设置本地分支与远程仓库分支对应 git push --set-upstream <远程主机名> <branchname> 设置本地的branchname分支对应远程仓库的branchname分支，远程主机名为git clone设置的仓库别名。 git branch --set-upstream-to=origin/branchname1 branchname2 将远程仓库的branchname1分支与本地的branchname2分支对应。 (7). 将本地当前分支推送到远程主机 git push <远程主机名> <本地分支名>:<远程分支名> 如果本地分支名和远程分支名相同，则可以直接使用下面的命令。 git push <远程主机名> <branchname> 将本地的branchname分支推到远程仓库，在此之前需要先设置与远程仓库对应分支。 如果当前分支与多个主机存在追踪关系，需要使用-u参数指定一个默认主机，这样后面可以不加任何参数使用git push。 (8). 删除远程仓库的branchname分支 git push -d <远程主机名> branchname (9). 将远程仓库的分支与本地仓库的分支合并 git pull <远程主机名> <远程分支名>:<本地分支名> 如果本地分支名和远程分支名相同，则可以使用下面的命令。 git push <远程分支名> <branchname>\n\n\n# 3.6 保存和恢复进度\n\n我们有时会遇到这样的情况，正在dev分支开发新功能，做到一半时有人过来反馈一个bug，让马上解决，但是新功能做到了一半你又不想提交，又想保存它，这个时候就可以使用git stash命令先把进度保存起来。 (1). 保存当前工作进度 git stash 将工作区和暂存区尚未提交的修改存入栈中。再运行git status可以发现是一个干净的工作区，没有任何改动。使用git stash save \'message\'可以添加一些注释 (2). 恢复工作进度 恢复最新的进度到工作区。git会默认把工作区和暂存区的改动都恢复到工作区。 git stash pop 恢复最新的进度到工作区和暂存区。 git stash pop --index 恢复指定的进度到工作区。 git stash pop stash_id 其中stash_id是通过git stash list获取的。 通过git stash pop恢复进度后，会删除当前进度。 还有一个git stash apply命令除了不删除进度，其他和git stash pop一样。 (3). 显示保存进度的列表 git stash list (4) 删除进度 删除所有进度 git stash clear 删除一个存储的进度，如果不指定stash_id，则默认删除最新的进度。 git stash drop [stash_id]\n\n\n# 4 git用法思维导图\n\n',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"Github搜索技巧",frontmatter:{title:"Github搜索技巧",date:"2023-11-21T11:14:47.000Z",tags:["Github"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/031ffb/",categories:["工具","版本控制"],readingShow:"top"},regularPath:"/02.%E5%B7%A5%E5%85%B7/01.%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/03.Github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7.html",relativePath:"02.工具/01.版本控制/03.Github搜索技巧.md",key:"v-279b57f8",path:"/pages/031ffb/",headers:[{level:2,title:"1 普通搜索",slug:"_1-普通搜索",normalizedTitle:"1 普通搜索",charIndex:2},{level:2,title:"2 高级搜索技巧",slug:"_2-高级搜索技巧",normalizedTitle:"2 高级搜索技巧",charIndex:127},{level:2,title:"3 github advance查找工具",slug:"_3-github-advance查找工具",normalizedTitle:"3 github advance查找工具",charIndex:868}],headersStr:"1 普通搜索 2 高级搜索技巧 3 github advance查找工具",content:"# 1 普通搜索\n\n我们一般在github搜索项目，都是直接在根据仓库关键字搜索项目，可能还会用到图中的匹配条件进行筛选。\n\n\n\n这样虽然能实现我们的大部分需求，但还不足实现精确查找。而github有自己的一套搜索语法，能帮助我们实现精确查找。\n\n\n# 2 高级搜索技巧\n\nin:name <关键字> 根据仓库名称搜索仓库。\n\nin:description <关键字>：根据仓库描述搜索仓库。\n\nin:readme <关键字>：根据 README 文件内容搜索仓库。\n\nstars(fork): >(=) <数字> <关键字>：搜索 star 或 fork 数大于（或等于）指定数字的仓库，并包含关键字。\n\nstars(fork): 10..20 <关键词>：搜索 star 或 fork 数在 10 到 20 之间的仓库，并包含关键字。\n\nsize:>=5000 <关键词>：搜索仓库大小≥\\geq≥ 5000KB，并包含关键字。\n\npushed(created):>2023-7-1 <关键字>：搜索更新或创建日期在 2023 年 7 月 1 日之后的仓库，并包含关键字。\n\nlicense:mit <关键字>：搜索 LICENSE 为 MIT 的仓库，并包含关键字。\n\nlanguage:Go <关键字>：搜索仓库语言为 Go 的仓库，并包含关键字。\n\nuser:<用户名> <关键字>：查询某个用户的项目，并包含关键字。\n\norg:<组织名> <关键字>：查询某个组织的项目，并包含关键字。\n\nrepo:owner/name： 匹配特定仓库名称，例如repo:unique-pure/unique-pure.github.io\n\nis:public/private <关键字>：根据公有或私有仓库搜索，并包含关键字。当然，只有你具有访问权限的私有仓库才可以搜索到。\n\ntopic:<关键字>：根据主题搜索仓库。\n\ntopics:>5：搜索具有3个以上主题的仓库。\n\nfollowers:n：根据仓库关注者数量搜索仓库。\n\n\n# 3 github advance查找工具\n\ngithub开发了一套查找工具，非常全面，也可以使用这个工具进行精确查找。\n\nhttps://github.com/search/advanced",normalizedContent:"# 1 普通搜索\n\n我们一般在github搜索项目，都是直接在根据仓库关键字搜索项目，可能还会用到图中的匹配条件进行筛选。\n\n\n\n这样虽然能实现我们的大部分需求，但还不足实现精确查找。而github有自己的一套搜索语法，能帮助我们实现精确查找。\n\n\n# 2 高级搜索技巧\n\nin:name <关键字> 根据仓库名称搜索仓库。\n\nin:description <关键字>：根据仓库描述搜索仓库。\n\nin:readme <关键字>：根据 readme 文件内容搜索仓库。\n\nstars(fork): >(=) <数字> <关键字>：搜索 star 或 fork 数大于（或等于）指定数字的仓库，并包含关键字。\n\nstars(fork): 10..20 <关键词>：搜索 star 或 fork 数在 10 到 20 之间的仓库，并包含关键字。\n\nsize:>=5000 <关键词>：搜索仓库大小≥\\geq≥ 5000kb，并包含关键字。\n\npushed(created):>2023-7-1 <关键字>：搜索更新或创建日期在 2023 年 7 月 1 日之后的仓库，并包含关键字。\n\nlicense:mit <关键字>：搜索 license 为 mit 的仓库，并包含关键字。\n\nlanguage:go <关键字>：搜索仓库语言为 go 的仓库，并包含关键字。\n\nuser:<用户名> <关键字>：查询某个用户的项目，并包含关键字。\n\norg:<组织名> <关键字>：查询某个组织的项目，并包含关键字。\n\nrepo:owner/name： 匹配特定仓库名称，例如repo:unique-pure/unique-pure.github.io\n\nis:public/private <关键字>：根据公有或私有仓库搜索，并包含关键字。当然，只有你具有访问权限的私有仓库才可以搜索到。\n\ntopic:<关键字>：根据主题搜索仓库。\n\ntopics:>5：搜索具有3个以上主题的仓库。\n\nfollowers:n：根据仓库关注者数量搜索仓库。\n\n\n# 3 github advance查找工具\n\ngithub开发了一套查找工具，非常全面，也可以使用这个工具进行精确查找。\n\nhttps://github.com/search/advanced",charsets:{cjk:!0},lastUpdated:"2023/11/25, 14:50:49",lastUpdatedTimestamp:1700895049e3},{title:"WireGuard组网教程",frontmatter:{title:"WireGuard组网教程",date:"2023-11-16T09:50:44.000Z",permalink:"/pages/50ca39/",tags:["VPN"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},categories:["工具","网络工具"],readingShow:"top"},regularPath:"/02.%E5%B7%A5%E5%85%B7/02.%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/01.WireGuard%E7%BB%84%E7%BD%91%E6%95%99%E7%A8%8B.html",relativePath:"02.工具/02.网络工具/01.WireGuard组网教程.md",key:"v-0c700bb1",path:"/pages/50ca39/",headers:[{level:2,title:"1 引言",slug:"_1-引言",normalizedTitle:"1 引言",charIndex:2},{level:3,title:"1.1 什么是WireGuard",slug:"_1-1-什么是wireguard",normalizedTitle:"1.1 什么是wireguard",charIndex:11},{level:3,title:"1.2 WireGuard可以用来做什么",slug:"_1-2-wireguard可以用来做什么",normalizedTitle:"1.2 wireguard可以用来做什么",charIndex:650},{level:3,title:"1.3 WireGuard原理",slug:"_1-3-wireguard原理",normalizedTitle:"1.3 wireguard原理",charIndex:1459},{level:3,title:"1.4 WireGuard安装",slug:"_1-4-wireguard安装",normalizedTitle:"1.4 wireguard安装",charIndex:3674},{level:2,title:"2 WireGuard组网实现内网穿透",slug:"_2-wireguard组网实现内网穿透",normalizedTitle:"2 wireguard组网实现内网穿透",charIndex:3711},{level:3,title:"2.1 前提条件",slug:"_2-1-前提条件",normalizedTitle:"2.1 前提条件",charIndex:3735},{level:3,title:"2.2 网络拓扑结构",slug:"_2-2-网络拓扑结构",normalizedTitle:"2.2 网络拓扑结构",charIndex:4122},{level:3,title:"2.3 具体步骤",slug:"_2-3-具体步骤",normalizedTitle:"2.3 具体步骤",charIndex:4139},{level:4,title:"2.3.1 中继服务器配置",slug:"_2-3-1-中继服务器配置",normalizedTitle:"2.3.1 中继服务器配置",charIndex:4151},{level:4,title:"2.3.2 其他peer",slug:"_2-3-2-其他peer",normalizedTitle:"2.3.2 其他peer",charIndex:6113},{level:4,title:"2.3.3 测试",slug:"_2-3-3-测试",normalizedTitle:"2.3.3 测试",charIndex:6588},{level:3,title:"2.4 WireGuard配置文件说明",slug:"_2-4-wireguard配置文件说明",normalizedTitle:"2.4 wireguard配置文件说明",charIndex:6627},{level:2,title:"3 WireGuard工具",slug:"_3-wireguard工具",normalizedTitle:"3 wireguard工具",charIndex:8033},{level:3,title:"3.1 wg-easy",slug:"_3-1-wg-easy",normalizedTitle:"3.1 wg-easy",charIndex:8051},{level:3,title:"3.2 wg-gen-web",slug:"_3-2-wg-gen-web",normalizedTitle:"3.2 wg-gen-web",charIndex:9077},{level:3,title:"3.3 dsnet",slug:"_3-3-dsnet",normalizedTitle:"3.3 dsnet",charIndex:9131}],headersStr:"1 引言 1.1 什么是WireGuard 1.2 WireGuard可以用来做什么 1.3 WireGuard原理 1.4 WireGuard安装 2 WireGuard组网实现内网穿透 2.1 前提条件 2.2 网络拓扑结构 2.3 具体步骤 2.3.1 中继服务器配置 2.3.2 其他peer 2.3.3 测试 2.4 WireGuard配置文件说明 3 WireGuard工具 3.1 wg-easy 3.2 wg-gen-web 3.3 dsnet",content:'# 1 引言\n\n\n# 1.1 什么是WireGuard\n\n\n\n官方介绍如下：\n\n> WireGuard ® 是一款极其简单但快速且现代的 VPN，采用最先进的加密技术。它的目标是比 IPsec 更快、更简单、更精简、更有用，同时避免令人头疼的问题。它的性能远高于 OpenVPN。\n> \n> WireGuard 被设计为通用 VPN，可在嵌入式接口和超级计算机上运行，适合许多不同的情况。它最初针对 Linux 内核发布，现在已跨平台（Windows、macOS、BSD、iOS、Android）且可广泛部署。它目前正在大力开发中，但它可能已被视为业内最安全、最易于使用且最简单的 VPN 解决方案。\n\n我们可以用一句话概括它：\n\nWGuard是一款可以组建虚拟私人局域网（VPN）的软件，允许用户通过公共网络（如互联网）安全地传输数据，同时保持数据的机密性和完整性。\n\nWireGuard有如下优势：\n\n * 更轻便：以Linux内核模块的形式运行，资源占用小。\n * 更高效：相比目前主流的IPSec、OpenVPN等协议，WireGuard的效率要更高。\n * 更快速：比目前主流的VPN协议，连接速度要更快。\n * 更安全：使用了更先进的加密技术。\n * 更易搭建：部署难度相对更低。\n * 更隐蔽：以UDP协议进行数据传输，比TCP协议更低调。\n * 不易被封锁：TCP阻断对WireGuard无效，IP被墙的情况下仍然可用。\n * 更省电：不使用时不进行数据传输，移动端更省电。\n\n\n# 1.2 WireGuard可以用来做什么\n\n 1. 建立VPN（不限设备类型）\n    \n    WireGuard支持多种平台，包括电脑、智能手机和路由器。这一特性使其成为构建虚拟私有网络（VPN）的理想选择，能在这些设备上实现安全连接。无论是用于远程工作、保护数据隐私，还是绕过地理限制，WireGuard都能提供稳定且安全的网络连接。\n\n 2. 实现内网穿透\n    \n    > 内网穿透，即NAT（Network Address Translator）穿透，是指计算机在内网（局域网）内使用私有IP地址，在连接外网（互联网）时使用全局IP地址的技术。该技术被普遍使用在有多台主机但只通过一个公有IP地址访问的私有网络中。\n    > \n    > 举个例子：比如我在实验室配置了一个服务器 Server A，当我在实验室的时候，就可以通过自己的笔记本使用SSH连接【因为我和服务器处于一个局域网】，当我回宿舍以后，就没有办法直接使用SSH连接了【因为我和服务器不在一个局域网】，这个时候就需要进行NAT穿透，让我在宿舍也可以使用SSH连接Server A。\n    \n    > 通过Wireguard可以将广域网上的主机连接起来，形成一个局域网。只需要有一台具有固定公网IP的服务器，就可以将其作为我们搭建的局域网的中心节点，让其他的主机（不论是否有公网IP，不论是否在NAT内），都通过这个中心节点和彼此相连。由此就构建了一个中心辐射型的局域网，实现了内网穿透等功能。\n\n 3. Docker容器通信\n    \n    WireGuard还可用于Docker容器之间的通信。在Docker环境中，容器之间的网络通信是一个重要的问题。WireGuard通过提供一种安全的通信方式，能够在不同容器之间建立一个加密的网络连接，从而保障数据的安全传输。这对于需要在不同容器间安全共享数据的应用尤为重要。\n\n\n# 1.3 WireGuard原理\n\nWireGuard源码地址\n\nWireGuard 是一种在第 3 层（网络层）运行的安全网络隧道，与传统的 VPN 解决方案（如 IPsec 和 OpenVPN）相比，它的设计更安全、性能更高且更易于使用。它是作为 Linux 内核虚拟网络接口实现的，基于安全隧道的基本原理：将peer的公钥与隧道源 IP 地址关联。\n\n相关术语：\n\n>  * Peer/Node/Device\n>    \n>    连接到VPN 并为自己注册一个VPN子网地址（如 192.0.2.3）的主机。还可以通过使用逗号分隔的 CIDR 指定子网范围，为其自身地址以外的 IP 地址选择路由。\n> \n>  * 中继服务器（Bounce Server）\n>    \n>    一个公网可达的peer，可以将流量中继到 NAT 后面的其他peer。Bounce Server 并不是特殊的节点，它和其他peer一样，唯一的区别是它有公网 IP，并且开启了内核级别的 IP 转发，可以将 威屁恩 的流量转发到其他客户端。\n> \n>  * 子网（Subnet）\n>    \n>    一组私有 IP，例如 192.0.2.1-255 或 192.168.1.1/24，一般在 NAT 后面，例如办公室局域网或家庭网络。\n> \n>  * CIDR 表示法\n>    \n>    CIDR，即无类域间路由（Classless Inter-Domain Routing），是一种用于对IP地址进行灵活表示和分配的标准。\n> \n>  * NAT\n>    \n>    子网的私有 IP 地址由路由器提供，通过公网无法直接访问私有子网设备，需要通过 NAT 做网络地址转换。路由器会跟踪发出的连接，并将响应转发到正确的内部 IP。\n> \n>  * 公开端点（Public Endpoint）\n>    \n>    节点的公网 IP 地址:端口，例如 123.124.125.126:1234，或者直接使用域名 some.domain.tld:1234。如果peer节点不在同一子网中，那么节点的公开端点必须使用公网 IP 地址。\n> \n>  * 私钥（Private key）\n>    \n>    单个节点的 WireGuard 私钥，生成方法是：wg genkey > example.key。\n> \n>  * 公钥（Public key）\n>    \n>    单个节点的 WireGuard 公钥，生成方式为：wg pubkey < example.key > example.key.pub。\n> \n>  * DNS\n>    \n>    域名服务器，用于将域名解析为 VPN 客户端的 IP，不让 DNS请求泄漏到 VPN 之外。\n\n主要功能和原理如下\n\n> WireGuard 通过添加一个（或多个）网络接口来工作，例如 eth0 或 wlan0 ，称为 wg0 （或 wg1 、 wg2 、 wg3 等）。然后可以使用 ifconfig(8) 或 ip-address(8) 正常配置该网络接口，并使用 route(8) 或 ip-route(8) 添加和删除其路由，以及所有普通网络实用程序都是如此。接口的特定 WireGuard 方面使用 wg(8) 工具进行配置。该接口充当隧道接口。\n> \n> WireGuard 将隧道 IP 地址与公钥和远程端点相关联。当接口向peer发送数据包时，它会执行以下操作：\n> \n>  1. 该数据包适用于 192.168.30.8。那是哪位peer啊？让我看看...好吧，这是给peer ABCDEFGH 的。 （或者，如果它不适合任何已配置的peer，则丢弃该数据包。）\n>  2. 使用peer ABCDEFGH 的公钥加密整个 IP 数据包。\n>  3. Peer ABCDEFGH 的远程端点是什么？让我看看...好的，端点是主机 216.58.211.110 上的 UDP 端口 53133。\n>  4. 使用 UDP 通过 Internet 将步骤 2 中的加密字节发送到 216.58.211.110:53133。\n> \n> 当接口收到数据包时，会发生以下情况：\n> \n>  1. 我刚刚从主机 98.139.183.24 上的 UDP 端口 7361 收到一个数据包。让我们来解密吧！\n>  2. 它为peer LMNOPQRS 正确解密和验证。好的，让我们记住，peer LMNOPQRS 的最新 Internet 端点是使用 UDP 的 98.139.183.24:7361。\n>  3. 解密后，明文数据包来自 192.168.43.89。是否允许peer LMNOPQRS 以 192.168.43.89 向我们发送数据包？\n>  4. 如果是，则在接口上接受数据包。如果没有，就放弃它。\n> \n> WireGuard 的核心是一个称为加密密钥路由的概念，它的工作原理是将公钥与隧道内允许的隧道 IP 地址列表相关联。每个网络接口都有一个私钥和一个peer点列表。每个peer都有一个公钥。公钥短小且简单，由peer用来相互验证。它们可以通过任何带外方法传递以在配置文件中使用，类似于将 SSH 公钥发送给朋友以访问 shell 服务器的方式。\n\n\n# 1.4 WireGuard安装\n\nwireGuard官方安装教程\n\n\n# 2 WireGuard组网实现内网穿透\n\n\n# 2.1 前提条件\n\n 1. 公网服务器： 必须拥有一台具有公网IP地址的服务器，这是内网穿透的关键。该服务器充当中转站，负责将外部请求传递到内部网络。\n 2. 网络设备配置权限： 需要对内部网络的路由器或防火墙有一定的配置权限，以便进行端口映射或其他必要的网络设置。这确保了从公网服务器到内网的连接是有效的。\n 3. 安装WireGuard： 在公网服务器和内网设备上都需要安装和配置WireGuard软件。确保两端的WireGuard配置一致，包括公私钥的生成和网络接口的配置。\n 4. 开启相应端口： 在公网服务器的防火墙配置中，需要打开WireGuard所使用的端口（默认是51820/UDP），以确保能够接收来自内网设备的连接请求。\n 5. 合适的网络拓扑： 确保了解内部网络的拓扑结构，以便正确设置WireGuard配置，包括允许流量通过的子网、路由等。\n\n\n# 2.2 网络拓扑结构\n\n\n\n\n# 2.3 具体步骤\n\n# 2.3.1 中继服务器配置\n\n 1. 创建密钥对\n    \n    > wg genkey | tee server_privatekey | wg pubkey > server_publickey\n    > \n    > 执行以上两条命令后，会在执行命令的当前文件夹自动生成2个文件：\n\n * 开启IP地址转发\n   \n   > sudo sysctl net.ipv4.ip_forward\n   > \n   > 如果显示1则说明已开启，否则则未开启。\n   > \n   > echo "net.ipv4.ip_forward = 1" >> /etc/sysctl.conf\n   > echo "net.ipv4.conf.all.proxy_arp = 1" >> /etc/sysctl.conf\n   > sysctl -p /etc/sysctl.conf\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > \n   > 1\n   > 2\n   > 3\n\n * 设置IP地址伪装\n   \n   # 允许防火墙伪装IP\n   firewall-cmd --add-masquerade\n   # 检查是否允许伪装IP\n   firewall-cmd --query-masquerade\n   # 禁止防火墙伪装IP\n   firewall-cmd --remove-masquerade\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * 配置wireguard虚拟网卡（不推荐，只是让读者直观了解过程）\n   \n   sudo ip link add wg0 type wireguard # 添加一块叫 wg0 的虚拟 wireguard 网卡\n   sudo ip addr add 192.168.71.1/24 dev wg0 # 给 wg0 网卡添加 ip 地址 192.168.71.1，子网掩码 255.255.255.0\n   sudo wg set wg0 private-key ./server-privatekey # wireguard 设置密钥\n   sudo ip link set wg0 up # 启用刚刚添加的网卡\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n   \n   > 我们可以通过ip addr命令查看到wg0网卡的状态\n   > \n   > \n   > \n   > 可以看到网卡wg0 接口是已启用的，具有 IPv4 地址 192.168.71.1\n   > \n   > 输入wg命令则可以看到配置信息，配置文件通常在\n   \n   有想继续尝试这种方式的可以看一下官方教程\n\n * 编写配置文件配置网卡（推荐，应该wg set命令需要提供很多参数，很容易出错）\n   \n   > 我们在/etc/wireguard目录中创建wg0.conf并编写配置，配置项请看2.4 配置项说明\n   > \n   > [Interface]\n   > # 本机密钥\n   > PrivateKey = KIDTljv66CgVYBNlrSD13Au6qfUdIcFJkTBkuErhTEk=\n   > # 本机地址\n   > Address = 192.168.71.1/24\n   > # 监听端口\n   > ListenPort = 51820\n   > \n   > [Peer]\n   > # 对端的publickey\n   > PublicKey = iWy57DmR6wVXcVzMDOa2WyywO0WT5JRAGYIlh0v/nW8=\n   > # 对端地址\n   > AllowedIPs = 192.168.71.2/24\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n\n * 重新启动网卡\n   \n   sudo wg-quick down wg0\n   sudo wg-quick up wg0\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n# 2.3.2 其他peer\n\n我这里只列举MacOS的操作方式（其他都同理，就是要配置私钥和公钥）\n\n\n\n操作完之后，它会给出密钥对，我们只需要添加好其他信息即可。\n\n\n\n配置文件如下：\n\n[Interface]\n# 本机密钥\nPrivateKey = kDUqWzkbaB1EU5C2ADoId1TXtZF89xxn0VV45EcjFHs=\n# 本机地址\nAddress = 192.168.71.2/24\n\n[Peer]\n# 对端公钥，即公网服务器公钥\nPublicKey = bEm1p736FQySfKlTTUCeHmiwTmna5umZWOWLGWqioSk=\n# 允许此对等方的传入流量并指定传出流量的目标。\nAllowedIPs = 192.168.71.0/24\n# 公网IP+监听端口号\nEndpoint = 1.1.1.1:51820\nPersistentKeepalive = 25\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 2.3.3 测试\n\nMacOS端：\n\n\n\n服务器Ping 主机：\n\n\n\n\n# 2.4 WireGuard配置文件说明\n\n * interface部分：\n   * PrivateKey: 由 wg genkey 生成的 Base64 编码的私钥。必须配置。\n   * ListenPort: 用于监听的 16 位端口。可选，如果未指定，则随机选择端口。\n   * DNS: 指定 DNS 服务器的 IP 地址。\n   * FwMark: 用于传出数据包的 32 位 fwmark。如果设置为 0 或 "off"，则禁用此选项。可选。可以以十六进制形式指定，例如，以 "0x" 开头。可选。\n * Peer 部分：\n   * PublicKey: 由 wg pubkey 根据私钥计算的 Base64 编码的公钥。必须配置。\n   * PresharedKey: 由 wg genpsk 生成的 Base64 编码的预共享密钥。可选，可以省略。此选项为现有的公钥加密提供了额外的对称密钥加密层，以增强对抗后量子计算的能力。\n   * AllowedIPs: 逗号分隔的 IP 地址（IPv4 或 IPv6）列表，带有 CIDR 掩码，用于允许此对等方的传入流量并指定传出流量的目标。可以多次指定。可用 0.0.0.0/0 匹配所有 IPv4 地址，使用 ::/0 匹配所有 IPv6 地址。\n   * Endpoint: 一个 IP 地址或主机名，后跟冒号，然后是一个端口号。此端点将自动更新为来自对等方的正确经过身份验证的数据包的最新源 IP 地址和端口。可选。\n   * PersistentKeepalive: 保持活跃的时间间隔，介于 1 和 65535 之间，表示多久发送一次对等方的身份验证空数据包，以保持有状态的防火墙或 NAT 映射的有效性。如果设置为 0 或 "off"，则禁用此选项。可选，默认情况下此选项被禁用。\n\n下面是一个简单的配置文件示例：\n\n[Interface]\nPrivateKey = yAnz5TF+lXXJte14tji3zlMNq+hd2rYUIgJBgB3fBmk=\nListenPort = 51820\n\n[Peer]\nPublicKey = xTIBA5rboUvnH4htodjb6e697QjLERt1NAB4mZqp8Dg=\nEndpoint = 192.95.5.67:1234\nAllowedIPs = 10.192.122.3/32, 10.192.124.1/24\n\n[Peer]\nPublicKey = TrMvSoP4jYQlY6RIzBgbssQqY3vxI2Pi+y71lOWWXX0=\nEndpoint = [2607:5300:60:6b0::c05f:543]:2468\nAllowedIPs = 10.192.122.4/32, 192.168.0.0/16\n\n[Peer]\nPublicKey = gN65BkIKy1eCE9pP1wdc8ROUtkHLF2PfAqYdyYBz6EA=\nEndpoint = test.wireguard.com:18981\nAllowedIPs = 10.10.10.230/32\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 3 WireGuard工具\n\n\n# 3.1 wg-easy\n\ngithub地址\n\n这是一个用于管理 WireGuard 设置的 Web 用户界面。使用它之前我们得先安装docker和docker-compose。这里我给出docker-compose.yml配置文件示例。还有很多配置项可在仓库中找到，灵活配置VPN\n\nversion: \'3\'\nservices:\n  wg-easy:\n    image: weejewel/wg-easy\n    container_name: wg-easy\n    environment:\n      - WG_HOST=YOUR_SERVER_IP # 公网IP\n      - PASSWORD=YOUR_ADMIN_PASSWORD # Web UI登录密码\n      - WG_PORT=51820 # 监听端口\n      - WG_PERSISTENT_KEEPALIVE=25 # 保持“连接”打开的值（以秒为单位）\n      - WG_DEFAULT_ADDRESS=192.168.71.0 # 客户端 IP 地址范围\n      - WG_ALLOWED_IPS=192.168.71.0/24 # 客户端将使用的允许 IP\n    volumes:\n      - ~/.wg-easy:/etc/wireguard\n    ports:\n      - 51820:51820/udp\n      - 51821:51821/tcp\n    cap_add:\n      - NET_ADMIN\n      - SYS_MODULE\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1\n      - net.ipv4.ip_forward=1\n    restart: unless-stopped\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n通过docker compose up -d部署好后，我们进入Web界面即可添加Client。\n\n这里，我们只需要将这三个配置文件分给对应的Client的即可完成网络搭建，特别方便！\n\n\n# 3.2 wg-gen-web\n\nwg-gen-web\n\n跟wg-easy类似，不过功能更强大。\n\n\n\n\n# 3.3 dsnet\n\ngithub地址\n\n一款用于管理集中式wireguard VPN 的FAST 命令。\n\n',normalizedContent:'# 1 引言\n\n\n# 1.1 什么是wireguard\n\n\n\n官方介绍如下：\n\n> wireguard ® 是一款极其简单但快速且现代的 vpn，采用最先进的加密技术。它的目标是比 ipsec 更快、更简单、更精简、更有用，同时避免令人头疼的问题。它的性能远高于 openvpn。\n> \n> wireguard 被设计为通用 vpn，可在嵌入式接口和超级计算机上运行，适合许多不同的情况。它最初针对 linux 内核发布，现在已跨平台（windows、macos、bsd、ios、android）且可广泛部署。它目前正在大力开发中，但它可能已被视为业内最安全、最易于使用且最简单的 vpn 解决方案。\n\n我们可以用一句话概括它：\n\nwguard是一款可以组建虚拟私人局域网（vpn）的软件，允许用户通过公共网络（如互联网）安全地传输数据，同时保持数据的机密性和完整性。\n\nwireguard有如下优势：\n\n * 更轻便：以linux内核模块的形式运行，资源占用小。\n * 更高效：相比目前主流的ipsec、openvpn等协议，wireguard的效率要更高。\n * 更快速：比目前主流的vpn协议，连接速度要更快。\n * 更安全：使用了更先进的加密技术。\n * 更易搭建：部署难度相对更低。\n * 更隐蔽：以udp协议进行数据传输，比tcp协议更低调。\n * 不易被封锁：tcp阻断对wireguard无效，ip被墙的情况下仍然可用。\n * 更省电：不使用时不进行数据传输，移动端更省电。\n\n\n# 1.2 wireguard可以用来做什么\n\n 1. 建立vpn（不限设备类型）\n    \n    wireguard支持多种平台，包括电脑、智能手机和路由器。这一特性使其成为构建虚拟私有网络（vpn）的理想选择，能在这些设备上实现安全连接。无论是用于远程工作、保护数据隐私，还是绕过地理限制，wireguard都能提供稳定且安全的网络连接。\n\n 2. 实现内网穿透\n    \n    > 内网穿透，即nat（network address translator）穿透，是指计算机在内网（局域网）内使用私有ip地址，在连接外网（互联网）时使用全局ip地址的技术。该技术被普遍使用在有多台主机但只通过一个公有ip地址访问的私有网络中。\n    > \n    > 举个例子：比如我在实验室配置了一个服务器 server a，当我在实验室的时候，就可以通过自己的笔记本使用ssh连接【因为我和服务器处于一个局域网】，当我回宿舍以后，就没有办法直接使用ssh连接了【因为我和服务器不在一个局域网】，这个时候就需要进行nat穿透，让我在宿舍也可以使用ssh连接server a。\n    \n    > 通过wireguard可以将广域网上的主机连接起来，形成一个局域网。只需要有一台具有固定公网ip的服务器，就可以将其作为我们搭建的局域网的中心节点，让其他的主机（不论是否有公网ip，不论是否在nat内），都通过这个中心节点和彼此相连。由此就构建了一个中心辐射型的局域网，实现了内网穿透等功能。\n\n 3. docker容器通信\n    \n    wireguard还可用于docker容器之间的通信。在docker环境中，容器之间的网络通信是一个重要的问题。wireguard通过提供一种安全的通信方式，能够在不同容器之间建立一个加密的网络连接，从而保障数据的安全传输。这对于需要在不同容器间安全共享数据的应用尤为重要。\n\n\n# 1.3 wireguard原理\n\nwireguard源码地址\n\nwireguard 是一种在第 3 层（网络层）运行的安全网络隧道，与传统的 vpn 解决方案（如 ipsec 和 openvpn）相比，它的设计更安全、性能更高且更易于使用。它是作为 linux 内核虚拟网络接口实现的，基于安全隧道的基本原理：将peer的公钥与隧道源 ip 地址关联。\n\n相关术语：\n\n>  * peer/node/device\n>    \n>    连接到vpn 并为自己注册一个vpn子网地址（如 192.0.2.3）的主机。还可以通过使用逗号分隔的 cidr 指定子网范围，为其自身地址以外的 ip 地址选择路由。\n> \n>  * 中继服务器（bounce server）\n>    \n>    一个公网可达的peer，可以将流量中继到 nat 后面的其他peer。bounce server 并不是特殊的节点，它和其他peer一样，唯一的区别是它有公网 ip，并且开启了内核级别的 ip 转发，可以将 威屁恩 的流量转发到其他客户端。\n> \n>  * 子网（subnet）\n>    \n>    一组私有 ip，例如 192.0.2.1-255 或 192.168.1.1/24，一般在 nat 后面，例如办公室局域网或家庭网络。\n> \n>  * cidr 表示法\n>    \n>    cidr，即无类域间路由（classless inter-domain routing），是一种用于对ip地址进行灵活表示和分配的标准。\n> \n>  * nat\n>    \n>    子网的私有 ip 地址由路由器提供，通过公网无法直接访问私有子网设备，需要通过 nat 做网络地址转换。路由器会跟踪发出的连接，并将响应转发到正确的内部 ip。\n> \n>  * 公开端点（public endpoint）\n>    \n>    节点的公网 ip 地址:端口，例如 123.124.125.126:1234，或者直接使用域名 some.domain.tld:1234。如果peer节点不在同一子网中，那么节点的公开端点必须使用公网 ip 地址。\n> \n>  * 私钥（private key）\n>    \n>    单个节点的 wireguard 私钥，生成方法是：wg genkey > example.key。\n> \n>  * 公钥（public key）\n>    \n>    单个节点的 wireguard 公钥，生成方式为：wg pubkey < example.key > example.key.pub。\n> \n>  * dns\n>    \n>    域名服务器，用于将域名解析为 vpn 客户端的 ip，不让 dns请求泄漏到 vpn 之外。\n\n主要功能和原理如下\n\n> wireguard 通过添加一个（或多个）网络接口来工作，例如 eth0 或 wlan0 ，称为 wg0 （或 wg1 、 wg2 、 wg3 等）。然后可以使用 ifconfig(8) 或 ip-address(8) 正常配置该网络接口，并使用 route(8) 或 ip-route(8) 添加和删除其路由，以及所有普通网络实用程序都是如此。接口的特定 wireguard 方面使用 wg(8) 工具进行配置。该接口充当隧道接口。\n> \n> wireguard 将隧道 ip 地址与公钥和远程端点相关联。当接口向peer发送数据包时，它会执行以下操作：\n> \n>  1. 该数据包适用于 192.168.30.8。那是哪位peer啊？让我看看...好吧，这是给peer abcdefgh 的。 （或者，如果它不适合任何已配置的peer，则丢弃该数据包。）\n>  2. 使用peer abcdefgh 的公钥加密整个 ip 数据包。\n>  3. peer abcdefgh 的远程端点是什么？让我看看...好的，端点是主机 216.58.211.110 上的 udp 端口 53133。\n>  4. 使用 udp 通过 internet 将步骤 2 中的加密字节发送到 216.58.211.110:53133。\n> \n> 当接口收到数据包时，会发生以下情况：\n> \n>  1. 我刚刚从主机 98.139.183.24 上的 udp 端口 7361 收到一个数据包。让我们来解密吧！\n>  2. 它为peer lmnopqrs 正确解密和验证。好的，让我们记住，peer lmnopqrs 的最新 internet 端点是使用 udp 的 98.139.183.24:7361。\n>  3. 解密后，明文数据包来自 192.168.43.89。是否允许peer lmnopqrs 以 192.168.43.89 向我们发送数据包？\n>  4. 如果是，则在接口上接受数据包。如果没有，就放弃它。\n> \n> wireguard 的核心是一个称为加密密钥路由的概念，它的工作原理是将公钥与隧道内允许的隧道 ip 地址列表相关联。每个网络接口都有一个私钥和一个peer点列表。每个peer都有一个公钥。公钥短小且简单，由peer用来相互验证。它们可以通过任何带外方法传递以在配置文件中使用，类似于将 ssh 公钥发送给朋友以访问 shell 服务器的方式。\n\n\n# 1.4 wireguard安装\n\nwireguard官方安装教程\n\n\n# 2 wireguard组网实现内网穿透\n\n\n# 2.1 前提条件\n\n 1. 公网服务器： 必须拥有一台具有公网ip地址的服务器，这是内网穿透的关键。该服务器充当中转站，负责将外部请求传递到内部网络。\n 2. 网络设备配置权限： 需要对内部网络的路由器或防火墙有一定的配置权限，以便进行端口映射或其他必要的网络设置。这确保了从公网服务器到内网的连接是有效的。\n 3. 安装wireguard： 在公网服务器和内网设备上都需要安装和配置wireguard软件。确保两端的wireguard配置一致，包括公私钥的生成和网络接口的配置。\n 4. 开启相应端口： 在公网服务器的防火墙配置中，需要打开wireguard所使用的端口（默认是51820/udp），以确保能够接收来自内网设备的连接请求。\n 5. 合适的网络拓扑： 确保了解内部网络的拓扑结构，以便正确设置wireguard配置，包括允许流量通过的子网、路由等。\n\n\n# 2.2 网络拓扑结构\n\n\n\n\n# 2.3 具体步骤\n\n# 2.3.1 中继服务器配置\n\n 1. 创建密钥对\n    \n    > wg genkey | tee server_privatekey | wg pubkey > server_publickey\n    > \n    > 执行以上两条命令后，会在执行命令的当前文件夹自动生成2个文件：\n\n * 开启ip地址转发\n   \n   > sudo sysctl net.ipv4.ip_forward\n   > \n   > 如果显示1则说明已开启，否则则未开启。\n   > \n   > echo "net.ipv4.ip_forward = 1" >> /etc/sysctl.conf\n   > echo "net.ipv4.conf.all.proxy_arp = 1" >> /etc/sysctl.conf\n   > sysctl -p /etc/sysctl.conf\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > \n   > 1\n   > 2\n   > 3\n\n * 设置ip地址伪装\n   \n   # 允许防火墙伪装ip\n   firewall-cmd --add-masquerade\n   # 检查是否允许伪装ip\n   firewall-cmd --query-masquerade\n   # 禁止防火墙伪装ip\n   firewall-cmd --remove-masquerade\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * 配置wireguard虚拟网卡（不推荐，只是让读者直观了解过程）\n   \n   sudo ip link add wg0 type wireguard # 添加一块叫 wg0 的虚拟 wireguard 网卡\n   sudo ip addr add 192.168.71.1/24 dev wg0 # 给 wg0 网卡添加 ip 地址 192.168.71.1，子网掩码 255.255.255.0\n   sudo wg set wg0 private-key ./server-privatekey # wireguard 设置密钥\n   sudo ip link set wg0 up # 启用刚刚添加的网卡\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n   \n   > 我们可以通过ip addr命令查看到wg0网卡的状态\n   > \n   > \n   > \n   > 可以看到网卡wg0 接口是已启用的，具有 ipv4 地址 192.168.71.1\n   > \n   > 输入wg命令则可以看到配置信息，配置文件通常在\n   \n   有想继续尝试这种方式的可以看一下官方教程\n\n * 编写配置文件配置网卡（推荐，应该wg set命令需要提供很多参数，很容易出错）\n   \n   > 我们在/etc/wireguard目录中创建wg0.conf并编写配置，配置项请看2.4 配置项说明\n   > \n   > [interface]\n   > # 本机密钥\n   > privatekey = kidtljv66cgvybnlrsd13au6qfudicfjktbkuerhtek=\n   > # 本机地址\n   > address = 192.168.71.1/24\n   > # 监听端口\n   > listenport = 51820\n   > \n   > [peer]\n   > # 对端的publickey\n   > publickey = iwy57dmr6wvxcvzmdoa2wyywo0wt5jragyilh0v/nw8=\n   > # 对端地址\n   > allowedips = 192.168.71.2/24\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n\n * 重新启动网卡\n   \n   sudo wg-quick down wg0\n   sudo wg-quick up wg0\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n# 2.3.2 其他peer\n\n我这里只列举macos的操作方式（其他都同理，就是要配置私钥和公钥）\n\n\n\n操作完之后，它会给出密钥对，我们只需要添加好其他信息即可。\n\n\n\n配置文件如下：\n\n[interface]\n# 本机密钥\nprivatekey = kduqwzkbab1eu5c2adoid1txtzf89xxn0vv45ecjfhs=\n# 本机地址\naddress = 192.168.71.2/24\n\n[peer]\n# 对端公钥，即公网服务器公钥\npublickey = bem1p736fqysfklttucehmiwtmna5umzwowlgwqiosk=\n# 允许此对等方的传入流量并指定传出流量的目标。\nallowedips = 192.168.71.0/24\n# 公网ip+监听端口号\nendpoint = 1.1.1.1:51820\npersistentkeepalive = 25\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 2.3.3 测试\n\nmacos端：\n\n\n\n服务器ping 主机：\n\n\n\n\n# 2.4 wireguard配置文件说明\n\n * interface部分：\n   * privatekey: 由 wg genkey 生成的 base64 编码的私钥。必须配置。\n   * listenport: 用于监听的 16 位端口。可选，如果未指定，则随机选择端口。\n   * dns: 指定 dns 服务器的 ip 地址。\n   * fwmark: 用于传出数据包的 32 位 fwmark。如果设置为 0 或 "off"，则禁用此选项。可选。可以以十六进制形式指定，例如，以 "0x" 开头。可选。\n * peer 部分：\n   * publickey: 由 wg pubkey 根据私钥计算的 base64 编码的公钥。必须配置。\n   * presharedkey: 由 wg genpsk 生成的 base64 编码的预共享密钥。可选，可以省略。此选项为现有的公钥加密提供了额外的对称密钥加密层，以增强对抗后量子计算的能力。\n   * allowedips: 逗号分隔的 ip 地址（ipv4 或 ipv6）列表，带有 cidr 掩码，用于允许此对等方的传入流量并指定传出流量的目标。可以多次指定。可用 0.0.0.0/0 匹配所有 ipv4 地址，使用 ::/0 匹配所有 ipv6 地址。\n   * endpoint: 一个 ip 地址或主机名，后跟冒号，然后是一个端口号。此端点将自动更新为来自对等方的正确经过身份验证的数据包的最新源 ip 地址和端口。可选。\n   * persistentkeepalive: 保持活跃的时间间隔，介于 1 和 65535 之间，表示多久发送一次对等方的身份验证空数据包，以保持有状态的防火墙或 nat 映射的有效性。如果设置为 0 或 "off"，则禁用此选项。可选，默认情况下此选项被禁用。\n\n下面是一个简单的配置文件示例：\n\n[interface]\nprivatekey = yanz5tf+lxxjte14tji3zlmnq+hd2ryuigjbgb3fbmk=\nlistenport = 51820\n\n[peer]\npublickey = xtiba5rbouvnh4htodjb6e697qjlert1nab4mzqp8dg=\nendpoint = 192.95.5.67:1234\nallowedips = 10.192.122.3/32, 10.192.124.1/24\n\n[peer]\npublickey = trmvsop4jyqly6rizbgbssqqy3vxi2pi+y71lowwxx0=\nendpoint = [2607:5300:60:6b0::c05f:543]:2468\nallowedips = 10.192.122.4/32, 192.168.0.0/16\n\n[peer]\npublickey = gn65bkiky1ece9pp1wdc8routkhlf2pfaqydyybz6ea=\nendpoint = test.wireguard.com:18981\nallowedips = 10.10.10.230/32\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 3 wireguard工具\n\n\n# 3.1 wg-easy\n\ngithub地址\n\n这是一个用于管理 wireguard 设置的 web 用户界面。使用它之前我们得先安装docker和docker-compose。这里我给出docker-compose.yml配置文件示例。还有很多配置项可在仓库中找到，灵活配置vpn\n\nversion: \'3\'\nservices:\n  wg-easy:\n    image: weejewel/wg-easy\n    container_name: wg-easy\n    environment:\n      - wg_host=your_server_ip # 公网ip\n      - password=your_admin_password # web ui登录密码\n      - wg_port=51820 # 监听端口\n      - wg_persistent_keepalive=25 # 保持“连接”打开的值（以秒为单位）\n      - wg_default_address=192.168.71.0 # 客户端 ip 地址范围\n      - wg_allowed_ips=192.168.71.0/24 # 客户端将使用的允许 ip\n    volumes:\n      - ~/.wg-easy:/etc/wireguard\n    ports:\n      - 51820:51820/udp\n      - 51821:51821/tcp\n    cap_add:\n      - net_admin\n      - sys_module\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1\n      - net.ipv4.ip_forward=1\n    restart: unless-stopped\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n通过docker compose up -d部署好后，我们进入web界面即可添加client。\n\n这里，我们只需要将这三个配置文件分给对应的client的即可完成网络搭建，特别方便！\n\n\n# 3.2 wg-gen-web\n\nwg-gen-web\n\n跟wg-easy类似，不过功能更强大。\n\n\n\n\n# 3.3 dsnet\n\ngithub地址\n\n一款用于管理集中式wireguard vpn 的fast 命令。\n\n',charsets:{cjk:!0},lastUpdated:"2023/11/25, 14:50:49",lastUpdatedTimestamp:1700895049e3},{title:"SSH教程",frontmatter:{title:"SSH教程",date:"2022-01-23T13:12:04.000Z",tags:["SSH"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/975871/",categories:["工具","网络工具"],readingShow:"top"},regularPath:"/02.%E5%B7%A5%E5%85%B7/02.%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/02.SSH%E6%95%99%E7%A8%8B.html",relativePath:"02.工具/02.网络工具/02.SSH教程.md",key:"v-2472c4c6",path:"/pages/975871/",headers:[{level:2,title:"1 SSH基本知识",slug:"_1-ssh基本知识",normalizedTitle:"1 ssh基本知识",charIndex:2},{level:3,title:"1.1 SSH是什么",slug:"_1-1-ssh是什么",normalizedTitle:"1.1 ssh是什么",charIndex:16},{level:3,title:"1.2 SSH架构",slug:"_1-2-ssh架构",normalizedTitle:"1.2 ssh架构",charIndex:142},{level:2,title:"2 ssh登录",slug:"_2-ssh登录",normalizedTitle:"2 ssh登录",charIndex:565},{level:3,title:"2.1 基本用法",slug:"_2-1-基本用法",normalizedTitle:"2.1 基本用法",charIndex:577},{level:3,title:"2.2 配置文件",slug:"_2-2-配置文件",normalizedTitle:"2.2 配置文件",charIndex:1482},{level:3,title:"2.3 密钥登录",slug:"_2-3-密钥登录",normalizedTitle:"2.3 密钥登录",charIndex:1801},{level:2,title:"3 scp传文件",slug:"_3-scp传文件",normalizedTitle:"3 scp传文件",charIndex:2774},{level:3,title:"3.1 scp命令简介",slug:"_3-1-scp命令简介",normalizedTitle:"3.1 scp命令简介",charIndex:2787},{level:3,title:"3.2 基本语法",slug:"_3-2-基本语法",normalizedTitle:"3.2 基本语法",charIndex:2974},{level:2,title:"4 参考文献",slug:"_4-参考文献",normalizedTitle:"4 参考文献",charIndex:3371}],headersStr:"1 SSH基本知识 1.1 SSH是什么 1.2 SSH架构 2 ssh登录 2.1 基本用法 2.2 配置文件 2.3 密钥登录 3 scp传文件 3.1 scp命令简介 3.2 基本语法 4 参考文献",content:"# 1 SSH基本知识\n\n\n# 1.1 SSH是什么\n\nSSH为Secure Shell的缩写，是一种网络协议，用于加密两台计算机之间的通信，保证不被窃听或篡改，并且支持各种身份验证机制。在事务中，它主要用户保证远程登录贺远程通信的安全，任何网络服务都可以用这个协议来加密。\n\n\n# 1.2 SSH架构\n\nSSH的软件架构是C/S模式，即客户端-服务器模式。在这个架构中，SSH软件分成了两个部分：向服务器发出请求的部分，称为客户端，OpenSSH的实现为ssh；接受客户端发出的请求的部分，称为服务器，OpenSSH的实现为sshd。 其中大写的SSH表示协议，小写的ssh表示客户端软件。 OpenSSH的客户端是二进制程序ssh。它在Linux/Unix系统的位置是/usr/local/bin/ssh，windows系统的位置是/Program Files/OpenSSH/bin/ssh.exe。Linux系统一般都自带ssh，如果没有则需要自己安装。安装命令如下：\n\n# Ubuntu 和 Debian\nsudo apt install openssh-client\n# CentOS 和 Fedora\nsudo dnf install openssh-clients\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n# 2 ssh登录\n\n\n# 2.1 基本用法\n\n远程登录服务器有以下几种方式：\n\nssh hostname # 没有指定用户名，将使用客户端的当前用户名\nssh user@hostname # 指定用户名\nssh user@hostname -p 22 # 登录端口为22，使用-p可以登录到某一特定的端口。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n其中user为用户名，hostname为IP地址或域名 第一次登录时会提示：\n\nThe authenticity of host '123.57.47.211 (123.57.47.211)' can't be established.\nECDSA key fingerprint is SHA256:iy237yysfCe013/l+kpDGfEG9xxHxm0dnxnAbJTPpG8.\nAre you sure you want to continue connecting (yes/no/[fingerprint])?\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n上述这段文字告诉用户，这台服务器的指纹是陌生的，让用户选择是否要继续连接（输入yes或no）。 所谓“服务器指纹”，指的是 SSH 服务器公钥的哈希值。每台 SSH 服务器都有唯一一对密钥，用于跟客户端通信，其中公钥的哈希值就可以用来识别服务器。\n\n输入yes，然后回车即可。这样会将服务器的信息记录在~/.ssh//known_hosts文件中，然后输入密码即可登录到远程服务器。 在~/.ssh/known_hosts文件中保存了本机连接过的所有服务器的公钥指纹信息，每次通过ssh连接一台服务器，系统会通过该文件判断当前需要连接的服务器是否为陌生主机。而如果之前ssh登陆过的服务器的密钥发生了更改，那么登录就会收到提示Host key verification failed，由于发生改变了，所以西我们需要删除之前的主机的指纹信息，添加新的。这个可以使用ssh-keygen -R <hostname>来进行删除。\n\n如果我们需要退出登录，输入logout或exit都可以实现，也可以使用快捷键Ctrl+d退出。\n\n\n# 2.2 配置文件\n\n创建文件~/.ssh/config，此为用户的个人配置文件，其保存相关配置信息。我们可以在文件中输入：\n\nHost myServer1\n    HostName IP地址或域名\n    User 用户名\nHost myServer2\n    HostName IP地址或域名\n    User 用户名\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n之后再使用服务器时，就可以直接使用别名myServer1、myServer2进行登录。 SSH客户端的全局配置文件为/etc/ssh/ssh_config，其优先级低于用户个人配置文件。除了配置文件，~/.ssh还有一些用户个人的密钥文件和其他文件\n\n\n# 2.3 密钥登录\n\n * 创建密钥 首先在本台主机上创建密钥，输入ssh-keygen指令，然后一直回车即可。该命令会为本机生成公私钥对，通过密钥来进行远程登录的验证机制使用了密码学中的非对称加密体系。执行命令后，会在~/.ssh/文件夹下生成两个新的文件：\n   \n     1. `id_rsa`：私钥\n     2. `id_rsa.pub`：公钥\n   \n   注意，一定要保护好生成的私钥`id_rsa`，一旦暴露，利用上述指令可以重新生成新的密钥。\n   \n   \n   \n\n * 免密登录 如果想要免密登录某个服务器，我们只需要将刚才生成的公钥保存在需要登录的远程服务器~/.ssh/authorized_keys文件中。例如我想免密登录到myServer1服务器，则将~/.ssh/id_rsa.pub公钥中的内容，复制到myServer1中的~/.ssh/authorized_keys文件中。也可以使用如下命令一键添加公钥： ssh-copy-id myServer1。 第一次应用ssh-copy-id系统会提示输入远程服务器的密码，之后登录时就可以免密登录了。\n\n一般来说，应用密钥登录比使用密码登录更加安全，所以启用密钥登录之后，最好关闭服务器的密码登录。如果需要在远程服务器上关闭密码登录。具体方法是先远程登录到服务器中，然后找到sshd的配置文件/etc/ssh/sshd_config，最后将PasswordAuthentication这一项设置为no。 PasswordAuthentication no sshd是服务器运行的后台进程，当我们修改配置文件以后，需要重新启动sshd，然后修改才能生效。可应用下面语句重启远程服务器上的ssh和sshd服务。\n\nsudo systemctl restart ssh.service\nsudo systemctl restart sshd.service\n\n\n1\n2\n\n1\n2\n\n * 执行远程命令 免密登录后，我们可以在命令行下直接执行远程命令：ssh user@hostname command。这样的命令会使SSH在登录成功后，立刻在远程主机上执行命令comand。但并不是真正的登录，执行完命令后还在原主机。 测试：ssh myServer1 ls\n\n\n# 3 scp传文件\n\n\n# 3.1 scp命令简介\n\nscp是secure copy的缩写，相当于cp命令+SSH。它的底层是SSH协议，默认端口是22，相当于先使用ssh命令登录远程主机，然后再进行拷贝操作。 scp主要用于以下三种复制操作：\n\n * 本地复制到远程。\n * 远程复制到本地。\n * 两个远程系统之间的复制。\n\n使用scp传输数据时，文件和密码都是加密的，不会泄露敏感信息。\n\n\n# 3.2 基本语法\n\nscp的语法类似cp的语法。\n\nscp source destination\n\n\n1\n\n1\n\n\n上面命令中，source是文件当前的位置，destination是文件所要复制到的位置。它们都可以包含用户名和主机名。例如：\n\nscp myServer1:main.cpp main.cpp\n\n\n1\n\n1\n\n\n上面命令即是将远程主机（myServer1）用户主目录下的main.cpp复制为本机当前目录下的main.cpp。注意主机与文件之间要使用:分隔。 scp会先用SSH登录到远程主机，然后在加密连接之中复制文件。客户端发起连接后，会提示用户输入密码。其中用户名和主机名若省略则是代表当前主机下的当前用户名。\n\nscp支持一次复制多个文件。scp source1 source2 destination。如果存在同名文件，scp会在没有警告的情况下覆盖同名文件。\n\n\n# 4 参考文献\n\nLinux基础课 菜鸟教程",normalizedContent:"# 1 ssh基本知识\n\n\n# 1.1 ssh是什么\n\nssh为secure shell的缩写，是一种网络协议，用于加密两台计算机之间的通信，保证不被窃听或篡改，并且支持各种身份验证机制。在事务中，它主要用户保证远程登录贺远程通信的安全，任何网络服务都可以用这个协议来加密。\n\n\n# 1.2 ssh架构\n\nssh的软件架构是c/s模式，即客户端-服务器模式。在这个架构中，ssh软件分成了两个部分：向服务器发出请求的部分，称为客户端，openssh的实现为ssh；接受客户端发出的请求的部分，称为服务器，openssh的实现为sshd。 其中大写的ssh表示协议，小写的ssh表示客户端软件。 openssh的客户端是二进制程序ssh。它在linux/unix系统的位置是/usr/local/bin/ssh，windows系统的位置是/program files/openssh/bin/ssh.exe。linux系统一般都自带ssh，如果没有则需要自己安装。安装命令如下：\n\n# ubuntu 和 debian\nsudo apt install openssh-client\n# centos 和 fedora\nsudo dnf install openssh-clients\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n# 2 ssh登录\n\n\n# 2.1 基本用法\n\n远程登录服务器有以下几种方式：\n\nssh hostname # 没有指定用户名，将使用客户端的当前用户名\nssh user@hostname # 指定用户名\nssh user@hostname -p 22 # 登录端口为22，使用-p可以登录到某一特定的端口。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n其中user为用户名，hostname为ip地址或域名 第一次登录时会提示：\n\nthe authenticity of host '123.57.47.211 (123.57.47.211)' can't be established.\necdsa key fingerprint is sha256:iy237yysfce013/l+kpdgfeg9xxhxm0dnxnabjtppg8.\nare you sure you want to continue connecting (yes/no/[fingerprint])?\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n上述这段文字告诉用户，这台服务器的指纹是陌生的，让用户选择是否要继续连接（输入yes或no）。 所谓“服务器指纹”，指的是 ssh 服务器公钥的哈希值。每台 ssh 服务器都有唯一一对密钥，用于跟客户端通信，其中公钥的哈希值就可以用来识别服务器。\n\n输入yes，然后回车即可。这样会将服务器的信息记录在~/.ssh//known_hosts文件中，然后输入密码即可登录到远程服务器。 在~/.ssh/known_hosts文件中保存了本机连接过的所有服务器的公钥指纹信息，每次通过ssh连接一台服务器，系统会通过该文件判断当前需要连接的服务器是否为陌生主机。而如果之前ssh登陆过的服务器的密钥发生了更改，那么登录就会收到提示host key verification failed，由于发生改变了，所以西我们需要删除之前的主机的指纹信息，添加新的。这个可以使用ssh-keygen -r <hostname>来进行删除。\n\n如果我们需要退出登录，输入logout或exit都可以实现，也可以使用快捷键ctrl+d退出。\n\n\n# 2.2 配置文件\n\n创建文件~/.ssh/config，此为用户的个人配置文件，其保存相关配置信息。我们可以在文件中输入：\n\nhost myserver1\n    hostname ip地址或域名\n    user 用户名\nhost myserver2\n    hostname ip地址或域名\n    user 用户名\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n之后再使用服务器时，就可以直接使用别名myserver1、myserver2进行登录。 ssh客户端的全局配置文件为/etc/ssh/ssh_config，其优先级低于用户个人配置文件。除了配置文件，~/.ssh还有一些用户个人的密钥文件和其他文件\n\n\n# 2.3 密钥登录\n\n * 创建密钥 首先在本台主机上创建密钥，输入ssh-keygen指令，然后一直回车即可。该命令会为本机生成公私钥对，通过密钥来进行远程登录的验证机制使用了密码学中的非对称加密体系。执行命令后，会在~/.ssh/文件夹下生成两个新的文件：\n   \n     1. `id_rsa`：私钥\n     2. `id_rsa.pub`：公钥\n   \n   注意，一定要保护好生成的私钥`id_rsa`，一旦暴露，利用上述指令可以重新生成新的密钥。\n   \n   \n   \n\n * 免密登录 如果想要免密登录某个服务器，我们只需要将刚才生成的公钥保存在需要登录的远程服务器~/.ssh/authorized_keys文件中。例如我想免密登录到myserver1服务器，则将~/.ssh/id_rsa.pub公钥中的内容，复制到myserver1中的~/.ssh/authorized_keys文件中。也可以使用如下命令一键添加公钥： ssh-copy-id myserver1。 第一次应用ssh-copy-id系统会提示输入远程服务器的密码，之后登录时就可以免密登录了。\n\n一般来说，应用密钥登录比使用密码登录更加安全，所以启用密钥登录之后，最好关闭服务器的密码登录。如果需要在远程服务器上关闭密码登录。具体方法是先远程登录到服务器中，然后找到sshd的配置文件/etc/ssh/sshd_config，最后将passwordauthentication这一项设置为no。 passwordauthentication no sshd是服务器运行的后台进程，当我们修改配置文件以后，需要重新启动sshd，然后修改才能生效。可应用下面语句重启远程服务器上的ssh和sshd服务。\n\nsudo systemctl restart ssh.service\nsudo systemctl restart sshd.service\n\n\n1\n2\n\n1\n2\n\n * 执行远程命令 免密登录后，我们可以在命令行下直接执行远程命令：ssh user@hostname command。这样的命令会使ssh在登录成功后，立刻在远程主机上执行命令comand。但并不是真正的登录，执行完命令后还在原主机。 测试：ssh myserver1 ls\n\n\n# 3 scp传文件\n\n\n# 3.1 scp命令简介\n\nscp是secure copy的缩写，相当于cp命令+ssh。它的底层是ssh协议，默认端口是22，相当于先使用ssh命令登录远程主机，然后再进行拷贝操作。 scp主要用于以下三种复制操作：\n\n * 本地复制到远程。\n * 远程复制到本地。\n * 两个远程系统之间的复制。\n\n使用scp传输数据时，文件和密码都是加密的，不会泄露敏感信息。\n\n\n# 3.2 基本语法\n\nscp的语法类似cp的语法。\n\nscp source destination\n\n\n1\n\n1\n\n\n上面命令中，source是文件当前的位置，destination是文件所要复制到的位置。它们都可以包含用户名和主机名。例如：\n\nscp myserver1:main.cpp main.cpp\n\n\n1\n\n1\n\n\n上面命令即是将远程主机（myserver1）用户主目录下的main.cpp复制为本机当前目录下的main.cpp。注意主机与文件之间要使用:分隔。 scp会先用ssh登录到远程主机，然后在加密连接之中复制文件。客户端发起连接后，会提示用户输入密码。其中用户名和主机名若省略则是代表当前主机下的当前用户名。\n\nscp支持一次复制多个文件。scp source1 source2 destination。如果存在同名文件，scp会在没有警告的情况下覆盖同名文件。\n\n\n# 4 参考文献\n\nlinux基础课 菜鸟教程",charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"Shell教程",frontmatter:{title:"Shell教程",date:"2022-01-22T09:23:42.000Z",tags:["Shell"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/0fc47a/",categories:["工具","开发工具"],readingShow:"top"},regularPath:"/02.%E5%B7%A5%E5%85%B7/03.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/01.Shell%E6%95%99%E7%A8%8B.html",relativePath:"02.工具/03.开发工具/01.Shell教程.md",key:"v-509f409b",path:"/pages/0fc47a/",headers:[{level:2,title:"1. Shell概论",slug:"_1-shell概论",normalizedTitle:"1. shell概论",charIndex:2},{level:2,title:"2 Shell语法",slug:"_2-shell语法",normalizedTitle:"2 shell语法",charIndex:1006},{level:3,title:"2.1 注释",slug:"_2-1-注释",normalizedTitle:"2.1 注释",charIndex:1020},{level:3,title:"2.2 变量",slug:"_2-2-变量",normalizedTitle:"2.2 变量",charIndex:1447},{level:3,title:"2.3 数组",slug:"_2-3-数组",normalizedTitle:"2.3 数组",charIndex:4945},{level:3,title:"2.4 expr命令与基本运算符",slug:"_2-4-expr命令与基本运算符",normalizedTitle:"2.4 expr命令与基本运算符",charIndex:6294},{level:3,title:"2.5 read命令",slug:"_2-5-read命令",normalizedTitle:"2.5 read命令",charIndex:11340},{level:3,title:"2.6 echo命令",slug:"_2-6-echo命令",normalizedTitle:"2.6 echo命令",charIndex:11593},{level:3,title:"2.7 printf命令",slug:"_2-7-printf命令",normalizedTitle:"2.7 printf命令",charIndex:12489},{level:3,title:"2.8 test命令与判断符号[]",slug:"_2-8-test命令与判断符号",normalizedTitle:"2.8 test命令与判断符号[]",charIndex:13291},{level:3,title:"2.9 判断语句",slug:"_2-9-判断语句",normalizedTitle:"2.9 判断语句",charIndex:14178},{level:3,title:"2.10 循环语句",slug:"_2-10-循环语句",normalizedTitle:"2.10 循环语句",charIndex:14555},{level:3,title:"2.11 函数",slug:"_2-11-函数",normalizedTitle:"2.11 函数",charIndex:15457},{level:3,title:"2.12 exit命令",slug:"_2-12-exit命令",normalizedTitle:"2.12 exit命令",charIndex:16008},{level:3,title:"2.13 文件重定向",slug:"_2-13-文件重定向",normalizedTitle:"2.13 文件重定向",charIndex:16135},{level:3,title:"2.14 引入外部脚本",slug:"_2-14-引入外部脚本",normalizedTitle:"2.14 引入外部脚本",charIndex:17010},{level:2,title:"3 参考文献",slug:"_3-参考文献",normalizedTitle:"3 参考文献",charIndex:17126}],headersStr:"1. Shell概论 2 Shell语法 2.1 注释 2.2 变量 2.3 数组 2.4 expr命令与基本运算符 2.5 read命令 2.6 echo命令 2.7 printf命令 2.8 test命令与判断符号[] 2.9 判断语句 2.10 循环语句 2.11 函数 2.12 exit命令 2.13 文件重定向 2.14 引入外部脚本 3 参考文献",content:'# 1. Shell概论\n\nShell是一个用C语言编写的程序，它诞生于Unix，是我们通过命令行与Unix/Linux交互的工具。笼统地说：Shell既是一种命令语言，又是一种程序设计语言。\n\n而Shell脚本是一种为Shell编写的脚本程序，有的时候也被称为Shell（但二者是两个完全不同的概念！），它可以直接在命令行中执行，也可以将一套逻辑组织成一个文件，方便复用。 Acwing网站提供给的AC Terminal中的命令行就可以看成是一个“Shell脚本在逐行执行”。\n\nUnix/Linux系统中常见的shell脚本有很多：\n\n * Bourne Shell（/usr/bin/sh或/bin/sh）\n * Bourne Again Shell（/bin/bash）\n * C Shell（/usr/bin/csh）\n * K Shell（/usr/bin/ksh）\n * Shell for Root（/sbin/sh）\n\n由于Linux系统中一般默认使用bash，而且其易用免费，所以我们接下来学习bash中的语法。\n\n脚本示例\n\n进入终端，新建一个hello.sh文件，内容如下：\n\n#! /bin/bash\necho "Hello, World!"\n\n\n1\n2\n\n1\n2\n\n\n说明：\n\n * sh后缀则表示该文件是Shell脚本文件。\n\n * #!告诉系统这个脚本用什么解释器来执行，后面所跟的就是你所需要用的解释器。这个一般都需要添加上，具体解释见运行。\n\n * echo指令用于字符串的输出，所以运行该文件会输出Hello,World。\n\n运行方式：\n\n * 作为可执行文件\n   \n   该方法将hello.sh作为可执行程序运行，由于未指定解释器，所以使用该方法第一行一定要指定解释器。\n\n#! /bin/bash\nchmod +x hello.sh #使脚本具有可执行权限；\n./hello.sh #当前路径下执行\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n * 用解释器执行\n   \n   该方法直接运行解释器，此时hello.sh作为Shell解释器的参数。此时Shell脚本就不需要指定解释器信息，则不需要第一行的注释了。\n   \n   bash hello.sh #当然也可以用缩写 sh hello.sh\n   \n   \n   1\n   \n   1\n   \n\n输出：\n\n\n\n\n# 2 Shell语法\n\n\n# 2.1 注释\n\n * 单行注释\n   \n   每一行中#之后的内容均是注释。\n   \n   # 这是一行注释\n   \n   echo "Hello, World" # 这也是一行注释\n   \n   \n   1\n   2\n   3\n   \n   1\n   2\n   3\n   \n\n * 多行注释\n   \n   Shell中的多行注释有点特别，格式为：\n   \n   :<<EOF\n   第一行注释\n   ...\n   第n行注释\n   EOF\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   其中EOF可以替换成其他任意字符串，如：\n   \n   :<<!\n   第一行注释\n   ...\n   第n行注释\n   !\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n# 2.2 变量\n\n * 定义变量\n   \n   定义变量时，变量名不加美元符号$，同时特别需要注意的一点就是变量名与等号之间不能有空格（如果有自动打空格的习惯在这里最好克制）。shell中的变量命名同样须遵循如下规则：\n   \n   * 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。\n   * 中间不能有空格，可以使用下划线 _。\n   * 不能使用标点符号。\n   * 不能使用bash里的关键字（可用help命令查看保留关键字）。\n   \n   如下：\n   \n   # 有效的Shell变量名称\n   _var\n   var123\n   LF_DDFHI_X\n   \n   # 无效的Shell变量名称\n   ?var\n   123abc\n   echo\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   和现在大多数的语言一样，Shell定义变量不需要指定变量类型，如下：\n   \n   name1="a" #单引号定义字符串\n   name2=\'a\' #双引号定义字符串\n   name3=a   #也可以不加引号，同样表示字符串\n   \n   \n   1\n   2\n   3\n   \n   1\n   2\n   3\n   \n   \n   在Bash shell中，每一个变量的值都是字符串，无论你给变量赋值用的时单引号双引号还是没有使用引号，都是使用字符串的i形式存储的，这很特殊。\n\n * 使用变量\n   \n   使用变量我们需要加上$符号或者${}符号。花括号时可选的，主要是为了帮助解释器识别变量边界。\n   \n   一定要注意：只有使用变量的时候才加美元符号$\n   \n   name=hzf\n   echo $name\n   echo ${name}\n   echo ${name}123\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n\n\n\n * 只读变量\n   \n   我们可以使用readOnly或者declare将变量设置为只读。\n   \n   name=hzf\n   readOnly name\n   #declare -r name #两种写法均可。\n   name=ylf #此时会报错，因为已经设置成了只读变量。\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n\n\n\n\n\n * 删除变量\n   \n   unset可以删除变量。\n   \n   name=hzf\n   unset name\n   echo $name\n   \n   \n   1\n   2\n   3\n   \n   1\n   2\n   3\n   \n   \n   此时没有输出hzf，代表已经删除了，这里没有报错是因为Shell将没有定义的变量设置为空字符串。\n\n * 变量类型\n   \n   根据访问权限划分可以分为：\n   \n   * 自定义变量（局部变量）\n     \n     在脚本或命令中定义，仅在当前Shell示例中有效，其他Shell启动的程序不能访问局部变量。即为子进程不能访问的变量。\n   \n   * 环境变量（全局变量）\n     \n     所有程序，包括shell启动程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。即为子进程可以访问的变量。\n   \n   自定义变量转换为环境变量：\n   \n   name=hzf#定义自定义变量\n   export name\n   delcare -x name#两种方法均可\n   \n   \n   1\n   2\n   3\n   \n   1\n   2\n   3\n   \n   \n   环境变量转化为自定义变量\n   \n   export name=hzf#定义环境变量。\n   delcare +x name#改为自定义变量。\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n * Shell字符串\n   \n   字符串可以用单引号，也可以用双引号，也可以不用引号。但其中是有区别的：\n   \n   * 使用单引号字符串，其中的变量名不会输出，但可以输出转义字符。单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。\n   \n   * 不用引号的字符串，其中变量可以输出，但是不能输出转移字符。\n   \n   * 使用双引号的字符串，既可以输出变量也可以输出转义字符。\n   \n   示例：\n   \n   name=hzf\n   echo 123$name\\n\n   echo "123$name\\n"\n   echo \'123$name\\n\'\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n   \n   输出：\n\n\n\n字符串操作\n\n * 拼接字符串\n   \n   name=xyz\n   #双引号字符串拼接\n   s1="Hello, $ {name} !”\n   s2="Hello, "$ {name}"!"\n   echo $s1 $s2\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n\n * 获取字符串长度\n   \n   name=hzf\n   echo ${#name}\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n\n\n * 提取字符串\n   \n   注意，第一个字符的索引为000，给出的两个参数第一个为起始位置，第二个为截取长度。\n   \n   name="Hello, World!"                                                                                                        \n   echo ${name}\n   echo ${name:0:4}\n   echo ${name:0}\n   echo ${name:1}\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n\n * 文件参数变量\n   \n   在执行Shell脚本时，可以向脚本传递参数。$1是第一个参数，$2是第二个参数，以此类推。特殊的，$0是文件名（包含路径）。例如：\n   \n   echo "文件名:$0"                                                                                                                                              \n   echo "第一个参数:$1"\n   echo "第二个参数:$2"\n   echo "$*"\n   echo "$@"\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   然后我们执行的时候在后面添加参数即可。如果没有给出，那么则为空字符。\n\n\n\n * 其他参数相关变量\n   \n   参数           说明\n   $#           代表文件传入的参数个数，如上例中值为2\n   $*           由所有参数构成的用空格隔开的字符串，如上例中值为"$1 $2"\n   $@           每个参数分别用双引号括起来的字符串，如上例中值为"$1" "$2"\n   $$           脚本当前运行的进程ID\n   $?           上一条命令的退出状态（注意不是stdout，而是exit code）。0表示正常退出，其他值表示错误\n   $(command)   返回command这条命令的stdout（可嵌套）\n   command      返回command这条命令的stdout（不可嵌套）\n\n\n# 2.3 数组\n\n数组中可以存放多个值。Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小（与 PHP 类似）。与大部分编程语言类似，数组元素的下标由 0 开始。\n\n * 定义\n   \n   Shell 数组用括号来表示，元素用"空格"符号分割开，语法格式如下：\n   \n   array_name=(value1 value2 ... valuen)\n   \n   \n   1\n   \n   1\n   \n   \n   如：\n   \n   name=(张三 "李四" \'王五\')\n   \n   \n   1\n   \n   1\n   \n   \n   也可以直接通过定义数组中元素的值来创建数组，如：\n   \n   name[0]="张三"\n   \n   \n   1\n   \n   1\n   \n   \n   这样就创建了name数组。\n\n * 访问数组元素\n   \n   * 访问单个元素\n     \n     语法格式为：${array_name[index]}\n     \n     如：\n     \n     name[0]="123"                                                                                                                                                 \n     name[3]="124"\n     echo "${name[0]}"\n     echo "${name[3]}"\n     \n     \n     1\n     2\n     3\n     4\n     \n     1\n     2\n     3\n     4\n     \n   \n   \n   \n   * 访问所有元素\n     \n     格式：\n     \n     ${array[@]}#第一种写法\n     ${array[*]}#第二种写法\n     \n     \n     1\n     2\n     \n     1\n     2\n     \n     \n     示例：\n     \n     array=(1 abc "def" yxc)\n     \n     echo ${array[@]}  # 第一种写法\n     echo ${array[*]}  # 第二种写法\n     \n     \n     1\n     2\n     3\n     4\n     \n     1\n     2\n     3\n     4\n     \n     \n     \n   \n   * 获取数组长度\n     \n     同字符串写法：\n     \n     array=(1 abc "def" yxc)\n     \n     echo ${#array[@]} #第一种写法\n     echo ${#array[*]} #第二种写法\n     \n     \n     1\n     2\n     3\n     4\n     \n     1\n     2\n     3\n     4\n     \n\n\n\n\n# 2.4 expr命令与基本运算符\n\nShell 和其他编程语言一样，支持多种运算符，包括：\n\n * 算数运算符\n * 关系运算符\n * 布尔运算符\n * 字符串运算符\n * 文件测试运算符\n\n但是原生Bash不支持简单的数学运算，我们需要通过其他命令来实现，如awk,expr，expr命令最常用，所以这里介绍expr。\n\nexpr是一款表达式计算工具，使用它能完成表达式的求值操作。格式为：\n\nexpr 表达式\n\n\n1\n\n1\n\n\n * 表达式说明\n   \n   * 用空格隔开每一项\n   * 用反斜杠放在shell特定的字符前面（发现表达式运行错误时，可以试试转义）\n   * 对包含空格和其他特殊字符的字符串要用引号括起来\n   * expr会在stdout中输出结果。如果为逻辑关系表达式，则结果为真，stdout为1，否则为0。\n   * expr的exit code：如果为逻辑关系表达式，则结果为真，exit code为0，否则为1。\n   * 完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号，而是反引号，代表执行该命令。通常在 Esc 键下边。\n\n * 算数表达式\n   \n   下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：\n   \n   运算符   说明                          举例\n   +     加法                          expr $a + $b 结果为 30。\n   -     减法                          expr $a - $b 结果为 -10。\n   *     乘法                          expr $a \\* $b 结果为 200。\n   /     除法                          expr $b / $a 结果为 2。\n   %     取余                          expr $b % $a 结果为 0。\n   =     赋值                          a=$b 将把变量 b 的值赋给 a。\n   ==    相等。用于比较两个数字，相同则返回 true。     [ $a == $b ] 返回 false。\n   !=    不相等。用于比较两个数字，不相同则返回 true。   [ $a != $b ] 返回 true。\n   \n   **注意：**条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。注意乘号等特殊符号需要转义。()可表优先级，但同样需要反斜杠转移。\n   \n   实例：\n   \n   a=10                                                                                                                                                                         \n   b=20\n   \n   echo "a + b = `expr $a + $b`"\n   echo "a - b = `expr $a - $b`"\n   echo "a * b = `expr $a \\* $b`"\n   echo "a / b = `expr $a / $b`"\n   echo "a % b = `expr $a % $b`"\n   echo "a == b = `expr [$a == $b]`"\n   echo "a != b = `expr [$a != $b]`"\n   a=$b\n   echo "$a"\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n\n\n * 关系运算符\n   \n   Shell支持正常的关系比较运算符，即<,<=,>,>=等。其会返回01代表结果。\n   \n   实例：\n   \n   a=10                                                                                                                                                                         \n   b=20\n   echo "a < b : `expr $a \\< $b`" #需要转义\n   echo "a > b : `expr $a \'>\' $b`" #也可以用引号括起来。\n   echo "a >= b : `expr $a \'>=\' $b`"\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   \n   \n   同时，Shell也给出了自己特定的比较命令，如下表：\n\n运算符   说明                              举例\n-eq   检测两个数是否相等，相等返回 true。            [ $a -eq $b ] 返回 false。\n-ne   检测两个数是否不相等，不相等返回 true。          [ $a -ne $b ]返回 true。\n-gt   检测左边的数是否大于右边的，如果是，则返回 true。     [ $a -gt $b ] 返回 false。\n-lt   检测左边的数是否小于右边的，如果是，则返回 true。     [ $a -lt $b ] 返回 true。\n-ge   检测左边的数是否大于等于右边的，如果是，则返回 true。   [ $a -ge $b ] 返回 false。\n-le   检测左边的数是否小于等于右边的，如果是，则返回 true。   [ $a -le $b ] 返回 true。\n\n实例（注：if...then是条件语句，之后会讲解）：\n\n#!/bin/bash\n\na=10\nb=20\n\nif [ $a -eq $b ]\nthen\n echo "$a -eq $b : a 等于 b"\nelse\n echo "$a -eq $b: a 不等于 b"\nfi\nif [ $a -ne $b ]\nthen\n echo "$a -ne $b: a 不等于 b"\nelse\n echo "$a -ne $b : a 等于 b"\nfi\nif [ $a -gt $b ]\nthen\n echo "$a -gt $b: a 大于 b"\nelse\n echo "$a -gt $b: a 不大于 b"\nfi\nif [ $a -lt $b ]\nthen\n echo "$a -lt $b: a 小于 b"\nelse\n echo "$a -lt $b: a 不小于 b"\nfi\nif [ $a -ge $b ]\nthen\n echo "$a -ge $b: a 大于或等于 b"\nelse\n echo "$a -ge $b: a 小于 b"\nfi\nif [ $a -le $b ]\nthen\n echo "$a -le $b: a 小于或等于 b"\nelse\n echo "$a -le $b: a 大于 b"\nfi\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n\n * 字符串表达式\n   \n   即结合expr命令实现对字符串的操作，常见有以下：\n   \n   * length str：返回str的长度。\n   * index str charSet:返回字符集charSet中任意一个字符在str中最前面字符的位置。下标从1开始，如果不存在，则返回0。\n   * substr str st len：截取字符串str，从st位置开始，长度最大为len的子串。如果截取不成功，则返回空字符串。\n   \n   实例：\n   \n   str="Hello,World!"\n   echo `expr length "$str"` #`不是单引号，而是反引号，代表执行该命令。\n   echo `expr index "$str" llo`\n   echo `expr substr "$str" 1 4`\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n   \n   \n\n * 文件测试运算符\n   \n   文件测试运算符用于检测 Unix 文件的各种属性。\n   \n   属性检测描述如下：\n   \n   操作符       说明                                         举例\n   -b file   检测文件是否是块设备文件，如果是，则返回 true。                 [ -b $file ] 返回 false。\n   -c file   检测文件是否是字符设备文件，如果是，则返回 true。                [ -c $file ] 返回 false。\n   -d file   检测文件是否是目录，如果是，则返回 true。                    [ -d $file ] 返回 false。\n   -f file   检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。   [ -f $file ] 返回 true。\n   -g file   检测文件是否设置了 SGID 位，如果是，则返回 true。             [ -g $file ] 返回 false。\n   -k file   检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。     [ -k $file ] 返回 false。\n   -p file   检测文件是否是有名管道，如果是，则返回 true。                  [ -p $file ] 返回 false。\n   -u file   检测文件是否设置了 SUID 位，如果是，则返回 true。             [ -u $file ] 返回 false。\n   -r file   检测文件是否可读，如果是，则返回 true。                     [ -r $file ] 返回 true。\n   -w file   检测文件是否可写，如果是，则返回 true。                     [ -w $file ] 返回 true。\n   -x file   检测文件是否可执行，如果是，则返回 true。                    [ -x $file ] 返回 true。\n   -s file   检测文件是否为空（文件大小是否大于0），不为空返回 true。            [ -s $file ] 返回 true。\n   -e file   检测文件（包括目录）是否存在，如果是，则返回 true。               [ -e $file ] 返回 true。\n\n\n# 2.5 read命令\n\nread命令可用于从标准输入中读取单行数据，当读到文件结束符时，exit code为1，否则为0。\n\n参数说明：\n\n * -p：后面可以接提示信息。\n * -t：后面跟秒数，定义输入字符的等待时间，超过等待时间后会自动忽略此命令\n\n实例：\n\nread name\necho $name\nread -p "please input your name:" -t 30 name #读入name的值，等待30s。\necho $name\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n\n\n# 2.6 echo命令\n\necho命令用于字符串的输出，在前面的过程中我们已经接触到了，其命令格式为：\n\necho string\n\n\n1\n\n1\n\n\n我们可以用echo实现更复杂的输出格式控制。\n\n * 显示普通字符串\n   \n   echo "Hello, World!"\n   \n   \n   1\n   \n   1\n   \n   \n   这种情况下，我们不加双引号也是可以的。\n\n * 显示转义字符\n   \n   echo "\\"Hello,World!\\""\n   \n   \n   1\n   \n   1\n   \n   \n   同样，这里的双引号也可以省略。\n\n * 显示变量\n   \n   name=hzf\n   echo "My name is $name"\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n * 显示换行等特殊字符\n   \n   注意，这些字符都需要通过-e命令开启转义才能起作用的，如：\\\\ \\a \\b \\c \\d \\e \\f \\n \\r \\t \\v 这些是要在有 -e 的时候才能起作用, 其他时候的转义是不用- e也能转义的。\n   \n   echo -e "Hello\\n" #-e开启转义。\n   echo "World!"\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n\n\n * 显示结果定向至文件\n   \n   echo "Hello, World!" > output.txt\n   \n   \n   1\n   \n   1\n   \n   \n   \n\n * 原样输出字符串\n   \n   前面有提及，如果想原样输出，不进行转义或者取变量，用单引号。\n   \n   name=hzf\n   echo \'$name\'\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n   \n   \n\n * 显示命令执行结果\n   \n   使用反引号。\n   \n   echo `date`\n   echo `ls`\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n\n\n\n# 2.7 printf命令\n\nShell的printf命令和C语言中的printf差不多，用于格式化输出。该命令不会像echo命令一样自动添加换行。其语法为：\n\nprintf format-string [args]\n\n\n1\n\n1\n\n\n其中format-string为格式控制字符串，[args]为参数列表。\n\n实例：\n\n#-表示左对齐，没有则表示右对齐，d为宽度。%s表示输出字符串，%d整型输出。\n#%-10s则表示输出宽度为10的左对齐字符串。而%-4.2f则表示输出4位整数，保留2位小数。\nprintf "%-10s %-8s %-4s\\n" 姓名 性别 体重kg  \nprintf "%-10s %-8s %-4.2f\\n" 郭靖 男 66.1234\nprintf "%-10s %-8s %-4.2f\\n" 杨过 男 48.6543\nprintf "%-10s %-8s %-4.2f\\n" 郭芙 女 47.9876\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n * 命令格式指示符\n   \n   符号      说明\n   %c      ASCII字符.显示相对应参数的第一个字符\n   %d,%i   十进制整数\n   %E      浮点格式([-d].precisionE [+-dd])\n   %e      浮点格式([-d].precisione [+-dd])\n   %g      %e或%f转换,看哪一个较短,则删除结尾的零\n   %G      %E或%f转换,看哪一个较短,则删除结尾的零\n   %s      字符串\n   %u      不带正负号的十进制值\n   %x      不带正负号的十六进制.使用a至f表示10至15\n   %%      字面意义的%\n   %X      不带正负号的十六进制.使用A至F表示10至15\n\n\n# 2.8 test命令与判断符号[]\n\n在命令行中输入man test，即可查看test命令的用法。 test命令可以用于判断文件类型，以及对变量做比较。test命令用exit code返回结果，而不是使用stdout。0表示真，非0表示假。这里可以通过echo $?来输出上一条命令的结果。\n\n * 文件判断 命令格式：test 测试参数 filename 其中常用测试参数如下表：\n\n测试参数   代表意义\n-e     文件是否存在\n-f     是否为文件\n-d     是否为目录\n-r     文件是否可读\n-w     文件是否可写\n-x     文件是否可执行\n-s     是否为非空文件\n测试     \n       \n\n * 整数之间的比较 命令格式：test $a 关系运算符 $b 其中关系运算符为上文所提及的，这里不作列举。\n * 字符串比较 相关操作如表所示：\n\n测试参数                代表意义\ntest -z str         判断str是否为空，如果为空，返回true，否则false\ntest -n str         判断str是否为非空，如果非空，返回true，否则false.其中-n可以省略\ntest str1 == str2   判断str1是否等于str2\ntest str1 != str2   判断str1是否不等于str2\n`                   \n\n * 多重条件判定 即判断多个条件是否符合要求，可以嵌套多层。具体操作图表所示：\n\n测试参数   代表意义\n-a     两条件是否同时成立\n-o     两条件是否至少一个成立\n!      取反。对返回结果取反\n       \n\n * 判断符号[] 和test命令用法几乎一模一样，只是将需要判断的内容放入括号中。 更常用于if语句中，且[[]]是[]的加强版，支持的特性也更多。 值得注意的是一些特性：[]内的每一项都必须用空格隔开；中括号内的变量，最好用双引号括起来；中括号内的常数，最好用单或双引号括起来。\n\n\n# 2.9 判断语句\n\n * if语句 和python的语法有点像，命令格式如下：\n\nif [ 条件 ]\nthen\n  内容\nelif [ 条件 ]\nthen \n  内容\nelse\n  内容\n fi\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n注意fi为结束标记，是一定需要加的，作为结尾闭合。 实例：\n\n * case...esac形式 命令格式如下：\n\ncase $变量名 in \n  value1)\n    内容\n    ;; # ;;，类似break\n  value2)\n    内容\n    ;;\n  *) #类似default\n    内容\n    ;;\nesac # 也是结尾闭合语句\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n测试\n\n\n# 2.10 循环语句\n\n * for...in...do...done语句 命令格式：\n\nfor var in val1 val2 val3 ... valN\ndo\n  内容\ndone # 结尾闭合\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n循环规则为：从左到右遍历，当变量值为列表时，则一次遍历完列表。 实例1：输出a 2 cc，每个元素一行：\n\nfor var in a 2 cc\ndo \n  echo $var\ndone            \n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n\n * for((...;...;...)) do...done语句 命令格式：\n\nfor ((expression; condition; expression))\ndo\n  内容\ndone\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n测试：输出1-10。\n\nfor ((i=0; i<=10; ++i))\ndo\n  echo $i\ndone \n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n * while...do...done语句 命令格式：\n\nwhile 条件\ndo \n  内容\ndone\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n实例：文件结束符为ctrl+d，输入文件结束符后read指令返回false。\n\nwhile reabashd name\ndo\n  echo $name\ndone\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n\n * unti...do..done语句 和while语句相同，while能实现的脚本until同样可以实现。但区别是until循环的退出状态为0，与while刚好相反，即while循环在条件为真时继续执行循环而until在条件为假时继续执行循环。\n * break语句\n * 跳出当前的一层循环，break不能跳出case语句。\n * continue语句 跳出当前循环。\n * 死循环的处理方式 如果Terminal可以打开该程序，则输入Ctrl+c即可。否则可以直接关闭进程：使用top命令找到该进程的PID；输入kill -9 PID即可关掉此进程。\n\n\n# 2.11 函数\n\n定义格式：\n\n[ function ] function_name [()]{\n  内容;\n  [return int;]\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n说明：\n\n 1. 可以带function func()定义，也可以直接fun()定义，不带任何参数。\n 2. 参数返回，可以显示加：return返回，如果不加，将以最后一条命令运行结果作为返回值。return后跟数值n(0-255，不能超过该范围)。 其中函数返回值通过$?获取。\n 3. 函数体声明局部变量可以用local关键字声明。\n\n实例：\n\nfunction add(){\n  echo "相加预算函数"\n  echo "请输入第一个数"\n  read a\n  echo "请输入第二个数"\n  read b\n  return $(($a + $b))\n}\nadd\necho "结果为$?"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n * 函数参数 在shell中，调用函数可以向其传递参数。在函数体内部，通过$n的形式来获取参数的值。例如，$1表示第一个参数，$2表示第二个参数。这个规则和上文说的文件参数相同。也是在执行的后面添加参数。\n\n\n# 2.12 exit命令\n\nexit命令用来退出当前的shell进程，并返回一个退出状态（0-255，只有0表示成功，其他都表示失败）；使用$?即可接收这个退出状态。 exit命令可以接收一个整数值作为参数，代表退出状态。如果不指定，默认值为0。\n\n\n# 2.13 文件重定向\n\n每个进程默认打开3个文件描述符：\n\n * stdin：标准输入，从命令行读取数据，文件描述符为0。\n * stdout：标准输出，向命令行输出数据，文件描述符为1。\n * stderr：标准错误输出，向命令行输出数据，文件描述符为2。 可以用文件重定向将这三个文件重定向到其他文件中去。重定向命令列表如下：\n\n命令                说明\ncommand > file    将输出重定向到 file。\ncommand < file    将输入重定向到 file。\ncommand >> file   将输出以追加的方式重定向到 file。\nn > file          将文件描述符为 n 的文件重定向到 file。\nn >> file         将文件描述符为 n 的文件以追加的方式重定向到 file。\nn >& m            将输出文件 m 和 n 合并。\nn <& m            将输入文件 m 和 n 合并。\n<< tag            将开始标记 tag 和结束标记 tag 之间的内容作为输入。\n\n * 输入输出重定向实例\n\necho -e "Hello \\c" > output.txt  # 将stdout重定向到output.txt中\necho "World" >> output.txt  # 将字符串追加到output.txt中\n\nread str < output.txt  # 从output.txt中读取字符串\n\necho $str  # 输出结果：Hello World\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n * 同时重定向stdin和stdout\n\n创建main.sh编写脚本：\n\nread a\nread b\n\necho $(expr "$a" + "$b")\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n创建input.txt，填写内容为：\n\n10\n20\n\n\n1\n2\n\n1\n2\n\n\n执行结果如下：\n\n\n# 2.14 引入外部脚本\n\n类似C/C++中的include操作，bash也可以引入其他文件中的代码。 语法格式为：\n\n. filename # 注意空格\n或者\nsource filename\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 3 参考文献\n\nLinux基础课 菜鸟教程',normalizedContent:'# 1. shell概论\n\nshell是一个用c语言编写的程序，它诞生于unix，是我们通过命令行与unix/linux交互的工具。笼统地说：shell既是一种命令语言，又是一种程序设计语言。\n\n而shell脚本是一种为shell编写的脚本程序，有的时候也被称为shell（但二者是两个完全不同的概念！），它可以直接在命令行中执行，也可以将一套逻辑组织成一个文件，方便复用。 acwing网站提供给的ac terminal中的命令行就可以看成是一个“shell脚本在逐行执行”。\n\nunix/linux系统中常见的shell脚本有很多：\n\n * bourne shell（/usr/bin/sh或/bin/sh）\n * bourne again shell（/bin/bash）\n * c shell（/usr/bin/csh）\n * k shell（/usr/bin/ksh）\n * shell for root（/sbin/sh）\n\n由于linux系统中一般默认使用bash，而且其易用免费，所以我们接下来学习bash中的语法。\n\n脚本示例\n\n进入终端，新建一个hello.sh文件，内容如下：\n\n#! /bin/bash\necho "hello, world!"\n\n\n1\n2\n\n1\n2\n\n\n说明：\n\n * sh后缀则表示该文件是shell脚本文件。\n\n * #!告诉系统这个脚本用什么解释器来执行，后面所跟的就是你所需要用的解释器。这个一般都需要添加上，具体解释见运行。\n\n * echo指令用于字符串的输出，所以运行该文件会输出hello,world。\n\n运行方式：\n\n * 作为可执行文件\n   \n   该方法将hello.sh作为可执行程序运行，由于未指定解释器，所以使用该方法第一行一定要指定解释器。\n\n#! /bin/bash\nchmod +x hello.sh #使脚本具有可执行权限；\n./hello.sh #当前路径下执行\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n * 用解释器执行\n   \n   该方法直接运行解释器，此时hello.sh作为shell解释器的参数。此时shell脚本就不需要指定解释器信息，则不需要第一行的注释了。\n   \n   bash hello.sh #当然也可以用缩写 sh hello.sh\n   \n   \n   1\n   \n   1\n   \n\n输出：\n\n\n\n\n# 2 shell语法\n\n\n# 2.1 注释\n\n * 单行注释\n   \n   每一行中#之后的内容均是注释。\n   \n   # 这是一行注释\n   \n   echo "hello, world" # 这也是一行注释\n   \n   \n   1\n   2\n   3\n   \n   1\n   2\n   3\n   \n\n * 多行注释\n   \n   shell中的多行注释有点特别，格式为：\n   \n   :<<eof\n   第一行注释\n   ...\n   第n行注释\n   eof\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   其中eof可以替换成其他任意字符串，如：\n   \n   :<<!\n   第一行注释\n   ...\n   第n行注释\n   !\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n# 2.2 变量\n\n * 定义变量\n   \n   定义变量时，变量名不加美元符号$，同时特别需要注意的一点就是变量名与等号之间不能有空格（如果有自动打空格的习惯在这里最好克制）。shell中的变量命名同样须遵循如下规则：\n   \n   * 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。\n   * 中间不能有空格，可以使用下划线 _。\n   * 不能使用标点符号。\n   * 不能使用bash里的关键字（可用help命令查看保留关键字）。\n   \n   如下：\n   \n   # 有效的shell变量名称\n   _var\n   var123\n   lf_ddfhi_x\n   \n   # 无效的shell变量名称\n   ?var\n   123abc\n   echo\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   和现在大多数的语言一样，shell定义变量不需要指定变量类型，如下：\n   \n   name1="a" #单引号定义字符串\n   name2=\'a\' #双引号定义字符串\n   name3=a   #也可以不加引号，同样表示字符串\n   \n   \n   1\n   2\n   3\n   \n   1\n   2\n   3\n   \n   \n   在bash shell中，每一个变量的值都是字符串，无论你给变量赋值用的时单引号双引号还是没有使用引号，都是使用字符串的i形式存储的，这很特殊。\n\n * 使用变量\n   \n   使用变量我们需要加上$符号或者${}符号。花括号时可选的，主要是为了帮助解释器识别变量边界。\n   \n   一定要注意：只有使用变量的时候才加美元符号$\n   \n   name=hzf\n   echo $name\n   echo ${name}\n   echo ${name}123\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n\n\n\n * 只读变量\n   \n   我们可以使用readonly或者declare将变量设置为只读。\n   \n   name=hzf\n   readonly name\n   #declare -r name #两种写法均可。\n   name=ylf #此时会报错，因为已经设置成了只读变量。\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n\n\n\n\n\n * 删除变量\n   \n   unset可以删除变量。\n   \n   name=hzf\n   unset name\n   echo $name\n   \n   \n   1\n   2\n   3\n   \n   1\n   2\n   3\n   \n   \n   此时没有输出hzf，代表已经删除了，这里没有报错是因为shell将没有定义的变量设置为空字符串。\n\n * 变量类型\n   \n   根据访问权限划分可以分为：\n   \n   * 自定义变量（局部变量）\n     \n     在脚本或命令中定义，仅在当前shell示例中有效，其他shell启动的程序不能访问局部变量。即为子进程不能访问的变量。\n   \n   * 环境变量（全局变量）\n     \n     所有程序，包括shell启动程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。即为子进程可以访问的变量。\n   \n   自定义变量转换为环境变量：\n   \n   name=hzf#定义自定义变量\n   export name\n   delcare -x name#两种方法均可\n   \n   \n   1\n   2\n   3\n   \n   1\n   2\n   3\n   \n   \n   环境变量转化为自定义变量\n   \n   export name=hzf#定义环境变量。\n   delcare +x name#改为自定义变量。\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n * shell字符串\n   \n   字符串可以用单引号，也可以用双引号，也可以不用引号。但其中是有区别的：\n   \n   * 使用单引号字符串，其中的变量名不会输出，但可以输出转义字符。单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。\n   \n   * 不用引号的字符串，其中变量可以输出，但是不能输出转移字符。\n   \n   * 使用双引号的字符串，既可以输出变量也可以输出转义字符。\n   \n   示例：\n   \n   name=hzf\n   echo 123$name\\n\n   echo "123$name\\n"\n   echo \'123$name\\n\'\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n   \n   输出：\n\n\n\n字符串操作\n\n * 拼接字符串\n   \n   name=xyz\n   #双引号字符串拼接\n   s1="hello, $ {name} !”\n   s2="hello, "$ {name}"!"\n   echo $s1 $s2\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n\n * 获取字符串长度\n   \n   name=hzf\n   echo ${#name}\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n\n\n * 提取字符串\n   \n   注意，第一个字符的索引为000，给出的两个参数第一个为起始位置，第二个为截取长度。\n   \n   name="hello, world!"                                                                                                        \n   echo ${name}\n   echo ${name:0:4}\n   echo ${name:0}\n   echo ${name:1}\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n\n * 文件参数变量\n   \n   在执行shell脚本时，可以向脚本传递参数。$1是第一个参数，$2是第二个参数，以此类推。特殊的，$0是文件名（包含路径）。例如：\n   \n   echo "文件名:$0"                                                                                                                                              \n   echo "第一个参数:$1"\n   echo "第二个参数:$2"\n   echo "$*"\n   echo "$@"\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   然后我们执行的时候在后面添加参数即可。如果没有给出，那么则为空字符。\n\n\n\n * 其他参数相关变量\n   \n   参数           说明\n   $#           代表文件传入的参数个数，如上例中值为2\n   $*           由所有参数构成的用空格隔开的字符串，如上例中值为"$1 $2"\n   $@           每个参数分别用双引号括起来的字符串，如上例中值为"$1" "$2"\n   $$           脚本当前运行的进程id\n   $?           上一条命令的退出状态（注意不是stdout，而是exit code）。0表示正常退出，其他值表示错误\n   $(command)   返回command这条命令的stdout（可嵌套）\n   command      返回command这条命令的stdout（不可嵌套）\n\n\n# 2.3 数组\n\n数组中可以存放多个值。bash shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小（与 php 类似）。与大部分编程语言类似，数组元素的下标由 0 开始。\n\n * 定义\n   \n   shell 数组用括号来表示，元素用"空格"符号分割开，语法格式如下：\n   \n   array_name=(value1 value2 ... valuen)\n   \n   \n   1\n   \n   1\n   \n   \n   如：\n   \n   name=(张三 "李四" \'王五\')\n   \n   \n   1\n   \n   1\n   \n   \n   也可以直接通过定义数组中元素的值来创建数组，如：\n   \n   name[0]="张三"\n   \n   \n   1\n   \n   1\n   \n   \n   这样就创建了name数组。\n\n * 访问数组元素\n   \n   * 访问单个元素\n     \n     语法格式为：${array_name[index]}\n     \n     如：\n     \n     name[0]="123"                                                                                                                                                 \n     name[3]="124"\n     echo "${name[0]}"\n     echo "${name[3]}"\n     \n     \n     1\n     2\n     3\n     4\n     \n     1\n     2\n     3\n     4\n     \n   \n   \n   \n   * 访问所有元素\n     \n     格式：\n     \n     ${array[@]}#第一种写法\n     ${array[*]}#第二种写法\n     \n     \n     1\n     2\n     \n     1\n     2\n     \n     \n     示例：\n     \n     array=(1 abc "def" yxc)\n     \n     echo ${array[@]}  # 第一种写法\n     echo ${array[*]}  # 第二种写法\n     \n     \n     1\n     2\n     3\n     4\n     \n     1\n     2\n     3\n     4\n     \n     \n     \n   \n   * 获取数组长度\n     \n     同字符串写法：\n     \n     array=(1 abc "def" yxc)\n     \n     echo ${#array[@]} #第一种写法\n     echo ${#array[*]} #第二种写法\n     \n     \n     1\n     2\n     3\n     4\n     \n     1\n     2\n     3\n     4\n     \n\n\n\n\n# 2.4 expr命令与基本运算符\n\nshell 和其他编程语言一样，支持多种运算符，包括：\n\n * 算数运算符\n * 关系运算符\n * 布尔运算符\n * 字符串运算符\n * 文件测试运算符\n\n但是原生bash不支持简单的数学运算，我们需要通过其他命令来实现，如awk,expr，expr命令最常用，所以这里介绍expr。\n\nexpr是一款表达式计算工具，使用它能完成表达式的求值操作。格式为：\n\nexpr 表达式\n\n\n1\n\n1\n\n\n * 表达式说明\n   \n   * 用空格隔开每一项\n   * 用反斜杠放在shell特定的字符前面（发现表达式运行错误时，可以试试转义）\n   * 对包含空格和其他特殊字符的字符串要用引号括起来\n   * expr会在stdout中输出结果。如果为逻辑关系表达式，则结果为真，stdout为1，否则为0。\n   * expr的exit code：如果为逻辑关系表达式，则结果为真，exit code为0，否则为1。\n   * 完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号，而是反引号，代表执行该命令。通常在 esc 键下边。\n\n * 算数表达式\n   \n   下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：\n   \n   运算符   说明                          举例\n   +     加法                          expr $a + $b 结果为 30。\n   -     减法                          expr $a - $b 结果为 -10。\n   *     乘法                          expr $a \\* $b 结果为 200。\n   /     除法                          expr $b / $a 结果为 2。\n   %     取余                          expr $b % $a 结果为 0。\n   =     赋值                          a=$b 将把变量 b 的值赋给 a。\n   ==    相等。用于比较两个数字，相同则返回 true。     [ $a == $b ] 返回 false。\n   !=    不相等。用于比较两个数字，不相同则返回 true。   [ $a != $b ] 返回 true。\n   \n   **注意：**条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。注意乘号等特殊符号需要转义。()可表优先级，但同样需要反斜杠转移。\n   \n   实例：\n   \n   a=10                                                                                                                                                                         \n   b=20\n   \n   echo "a + b = `expr $a + $b`"\n   echo "a - b = `expr $a - $b`"\n   echo "a * b = `expr $a \\* $b`"\n   echo "a / b = `expr $a / $b`"\n   echo "a % b = `expr $a % $b`"\n   echo "a == b = `expr [$a == $b]`"\n   echo "a != b = `expr [$a != $b]`"\n   a=$b\n   echo "$a"\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n\n\n * 关系运算符\n   \n   shell支持正常的关系比较运算符，即<,<=,>,>=等。其会返回01代表结果。\n   \n   实例：\n   \n   a=10                                                                                                                                                                         \n   b=20\n   echo "a < b : `expr $a \\< $b`" #需要转义\n   echo "a > b : `expr $a \'>\' $b`" #也可以用引号括起来。\n   echo "a >= b : `expr $a \'>=\' $b`"\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   \n   \n   同时，shell也给出了自己特定的比较命令，如下表：\n\n运算符   说明                              举例\n-eq   检测两个数是否相等，相等返回 true。            [ $a -eq $b ] 返回 false。\n-ne   检测两个数是否不相等，不相等返回 true。          [ $a -ne $b ]返回 true。\n-gt   检测左边的数是否大于右边的，如果是，则返回 true。     [ $a -gt $b ] 返回 false。\n-lt   检测左边的数是否小于右边的，如果是，则返回 true。     [ $a -lt $b ] 返回 true。\n-ge   检测左边的数是否大于等于右边的，如果是，则返回 true。   [ $a -ge $b ] 返回 false。\n-le   检测左边的数是否小于等于右边的，如果是，则返回 true。   [ $a -le $b ] 返回 true。\n\n实例（注：if...then是条件语句，之后会讲解）：\n\n#!/bin/bash\n\na=10\nb=20\n\nif [ $a -eq $b ]\nthen\n echo "$a -eq $b : a 等于 b"\nelse\n echo "$a -eq $b: a 不等于 b"\nfi\nif [ $a -ne $b ]\nthen\n echo "$a -ne $b: a 不等于 b"\nelse\n echo "$a -ne $b : a 等于 b"\nfi\nif [ $a -gt $b ]\nthen\n echo "$a -gt $b: a 大于 b"\nelse\n echo "$a -gt $b: a 不大于 b"\nfi\nif [ $a -lt $b ]\nthen\n echo "$a -lt $b: a 小于 b"\nelse\n echo "$a -lt $b: a 不小于 b"\nfi\nif [ $a -ge $b ]\nthen\n echo "$a -ge $b: a 大于或等于 b"\nelse\n echo "$a -ge $b: a 小于 b"\nfi\nif [ $a -le $b ]\nthen\n echo "$a -le $b: a 小于或等于 b"\nelse\n echo "$a -le $b: a 大于 b"\nfi\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n\n * 字符串表达式\n   \n   即结合expr命令实现对字符串的操作，常见有以下：\n   \n   * length str：返回str的长度。\n   * index str charset:返回字符集charset中任意一个字符在str中最前面字符的位置。下标从1开始，如果不存在，则返回0。\n   * substr str st len：截取字符串str，从st位置开始，长度最大为len的子串。如果截取不成功，则返回空字符串。\n   \n   实例：\n   \n   str="hello,world!"\n   echo `expr length "$str"` #`不是单引号，而是反引号，代表执行该命令。\n   echo `expr index "$str" llo`\n   echo `expr substr "$str" 1 4`\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n   \n   \n\n * 文件测试运算符\n   \n   文件测试运算符用于检测 unix 文件的各种属性。\n   \n   属性检测描述如下：\n   \n   操作符       说明                                         举例\n   -b file   检测文件是否是块设备文件，如果是，则返回 true。                 [ -b $file ] 返回 false。\n   -c file   检测文件是否是字符设备文件，如果是，则返回 true。                [ -c $file ] 返回 false。\n   -d file   检测文件是否是目录，如果是，则返回 true。                    [ -d $file ] 返回 false。\n   -f file   检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。   [ -f $file ] 返回 true。\n   -g file   检测文件是否设置了 sgid 位，如果是，则返回 true。             [ -g $file ] 返回 false。\n   -k file   检测文件是否设置了粘着位(sticky bit)，如果是，则返回 true。     [ -k $file ] 返回 false。\n   -p file   检测文件是否是有名管道，如果是，则返回 true。                  [ -p $file ] 返回 false。\n   -u file   检测文件是否设置了 suid 位，如果是，则返回 true。             [ -u $file ] 返回 false。\n   -r file   检测文件是否可读，如果是，则返回 true。                     [ -r $file ] 返回 true。\n   -w file   检测文件是否可写，如果是，则返回 true。                     [ -w $file ] 返回 true。\n   -x file   检测文件是否可执行，如果是，则返回 true。                    [ -x $file ] 返回 true。\n   -s file   检测文件是否为空（文件大小是否大于0），不为空返回 true。            [ -s $file ] 返回 true。\n   -e file   检测文件（包括目录）是否存在，如果是，则返回 true。               [ -e $file ] 返回 true。\n\n\n# 2.5 read命令\n\nread命令可用于从标准输入中读取单行数据，当读到文件结束符时，exit code为1，否则为0。\n\n参数说明：\n\n * -p：后面可以接提示信息。\n * -t：后面跟秒数，定义输入字符的等待时间，超过等待时间后会自动忽略此命令\n\n实例：\n\nread name\necho $name\nread -p "please input your name:" -t 30 name #读入name的值，等待30s。\necho $name\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n\n\n# 2.6 echo命令\n\necho命令用于字符串的输出，在前面的过程中我们已经接触到了，其命令格式为：\n\necho string\n\n\n1\n\n1\n\n\n我们可以用echo实现更复杂的输出格式控制。\n\n * 显示普通字符串\n   \n   echo "hello, world!"\n   \n   \n   1\n   \n   1\n   \n   \n   这种情况下，我们不加双引号也是可以的。\n\n * 显示转义字符\n   \n   echo "\\"hello,world!\\""\n   \n   \n   1\n   \n   1\n   \n   \n   同样，这里的双引号也可以省略。\n\n * 显示变量\n   \n   name=hzf\n   echo "my name is $name"\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n * 显示换行等特殊字符\n   \n   注意，这些字符都需要通过-e命令开启转义才能起作用的，如：\\\\ \\a \\b \\c \\d \\e \\f \\n \\r \\t \\v 这些是要在有 -e 的时候才能起作用, 其他时候的转义是不用- e也能转义的。\n   \n   echo -e "hello\\n" #-e开启转义。\n   echo "world!"\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n\n\n * 显示结果定向至文件\n   \n   echo "hello, world!" > output.txt\n   \n   \n   1\n   \n   1\n   \n   \n   \n\n * 原样输出字符串\n   \n   前面有提及，如果想原样输出，不进行转义或者取变量，用单引号。\n   \n   name=hzf\n   echo \'$name\'\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n   \n   \n\n * 显示命令执行结果\n   \n   使用反引号。\n   \n   echo `date`\n   echo `ls`\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n\n\n\n# 2.7 printf命令\n\nshell的printf命令和c语言中的printf差不多，用于格式化输出。该命令不会像echo命令一样自动添加换行。其语法为：\n\nprintf format-string [args]\n\n\n1\n\n1\n\n\n其中format-string为格式控制字符串，[args]为参数列表。\n\n实例：\n\n#-表示左对齐，没有则表示右对齐，d为宽度。%s表示输出字符串，%d整型输出。\n#%-10s则表示输出宽度为10的左对齐字符串。而%-4.2f则表示输出4位整数，保留2位小数。\nprintf "%-10s %-8s %-4s\\n" 姓名 性别 体重kg  \nprintf "%-10s %-8s %-4.2f\\n" 郭靖 男 66.1234\nprintf "%-10s %-8s %-4.2f\\n" 杨过 男 48.6543\nprintf "%-10s %-8s %-4.2f\\n" 郭芙 女 47.9876\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n * 命令格式指示符\n   \n   符号      说明\n   %c      ascii字符.显示相对应参数的第一个字符\n   %d,%i   十进制整数\n   %e      浮点格式([-d].precisione [+-dd])\n   %e      浮点格式([-d].precisione [+-dd])\n   %g      %e或%f转换,看哪一个较短,则删除结尾的零\n   %g      %e或%f转换,看哪一个较短,则删除结尾的零\n   %s      字符串\n   %u      不带正负号的十进制值\n   %x      不带正负号的十六进制.使用a至f表示10至15\n   %%      字面意义的%\n   %x      不带正负号的十六进制.使用a至f表示10至15\n\n\n# 2.8 test命令与判断符号[]\n\n在命令行中输入man test，即可查看test命令的用法。 test命令可以用于判断文件类型，以及对变量做比较。test命令用exit code返回结果，而不是使用stdout。0表示真，非0表示假。这里可以通过echo $?来输出上一条命令的结果。\n\n * 文件判断 命令格式：test 测试参数 filename 其中常用测试参数如下表：\n\n测试参数   代表意义\n-e     文件是否存在\n-f     是否为文件\n-d     是否为目录\n-r     文件是否可读\n-w     文件是否可写\n-x     文件是否可执行\n-s     是否为非空文件\n测试     \n       \n\n * 整数之间的比较 命令格式：test $a 关系运算符 $b 其中关系运算符为上文所提及的，这里不作列举。\n * 字符串比较 相关操作如表所示：\n\n测试参数                代表意义\ntest -z str         判断str是否为空，如果为空，返回true，否则false\ntest -n str         判断str是否为非空，如果非空，返回true，否则false.其中-n可以省略\ntest str1 == str2   判断str1是否等于str2\ntest str1 != str2   判断str1是否不等于str2\n`                   \n\n * 多重条件判定 即判断多个条件是否符合要求，可以嵌套多层。具体操作图表所示：\n\n测试参数   代表意义\n-a     两条件是否同时成立\n-o     两条件是否至少一个成立\n!      取反。对返回结果取反\n       \n\n * 判断符号[] 和test命令用法几乎一模一样，只是将需要判断的内容放入括号中。 更常用于if语句中，且[[]]是[]的加强版，支持的特性也更多。 值得注意的是一些特性：[]内的每一项都必须用空格隔开；中括号内的变量，最好用双引号括起来；中括号内的常数，最好用单或双引号括起来。\n\n\n# 2.9 判断语句\n\n * if语句 和python的语法有点像，命令格式如下：\n\nif [ 条件 ]\nthen\n  内容\nelif [ 条件 ]\nthen \n  内容\nelse\n  内容\n fi\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n注意fi为结束标记，是一定需要加的，作为结尾闭合。 实例：\n\n * case...esac形式 命令格式如下：\n\ncase $变量名 in \n  value1)\n    内容\n    ;; # ;;，类似break\n  value2)\n    内容\n    ;;\n  *) #类似default\n    内容\n    ;;\nesac # 也是结尾闭合语句\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n测试\n\n\n# 2.10 循环语句\n\n * for...in...do...done语句 命令格式：\n\nfor var in val1 val2 val3 ... valn\ndo\n  内容\ndone # 结尾闭合\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n循环规则为：从左到右遍历，当变量值为列表时，则一次遍历完列表。 实例1：输出a 2 cc，每个元素一行：\n\nfor var in a 2 cc\ndo \n  echo $var\ndone            \n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n\n * for((...;...;...)) do...done语句 命令格式：\n\nfor ((expression; condition; expression))\ndo\n  内容\ndone\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n测试：输出1-10。\n\nfor ((i=0; i<=10; ++i))\ndo\n  echo $i\ndone \n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n * while...do...done语句 命令格式：\n\nwhile 条件\ndo \n  内容\ndone\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n实例：文件结束符为ctrl+d，输入文件结束符后read指令返回false。\n\nwhile reabashd name\ndo\n  echo $name\ndone\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n\n * unti...do..done语句 和while语句相同，while能实现的脚本until同样可以实现。但区别是until循环的退出状态为0，与while刚好相反，即while循环在条件为真时继续执行循环而until在条件为假时继续执行循环。\n * break语句\n * 跳出当前的一层循环，break不能跳出case语句。\n * continue语句 跳出当前循环。\n * 死循环的处理方式 如果terminal可以打开该程序，则输入ctrl+c即可。否则可以直接关闭进程：使用top命令找到该进程的pid；输入kill -9 pid即可关掉此进程。\n\n\n# 2.11 函数\n\n定义格式：\n\n[ function ] function_name [()]{\n  内容;\n  [return int;]\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n说明：\n\n 1. 可以带function func()定义，也可以直接fun()定义，不带任何参数。\n 2. 参数返回，可以显示加：return返回，如果不加，将以最后一条命令运行结果作为返回值。return后跟数值n(0-255，不能超过该范围)。 其中函数返回值通过$?获取。\n 3. 函数体声明局部变量可以用local关键字声明。\n\n实例：\n\nfunction add(){\n  echo "相加预算函数"\n  echo "请输入第一个数"\n  read a\n  echo "请输入第二个数"\n  read b\n  return $(($a + $b))\n}\nadd\necho "结果为$?"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n * 函数参数 在shell中，调用函数可以向其传递参数。在函数体内部，通过$n的形式来获取参数的值。例如，$1表示第一个参数，$2表示第二个参数。这个规则和上文说的文件参数相同。也是在执行的后面添加参数。\n\n\n# 2.12 exit命令\n\nexit命令用来退出当前的shell进程，并返回一个退出状态（0-255，只有0表示成功，其他都表示失败）；使用$?即可接收这个退出状态。 exit命令可以接收一个整数值作为参数，代表退出状态。如果不指定，默认值为0。\n\n\n# 2.13 文件重定向\n\n每个进程默认打开3个文件描述符：\n\n * stdin：标准输入，从命令行读取数据，文件描述符为0。\n * stdout：标准输出，向命令行输出数据，文件描述符为1。\n * stderr：标准错误输出，向命令行输出数据，文件描述符为2。 可以用文件重定向将这三个文件重定向到其他文件中去。重定向命令列表如下：\n\n命令                说明\ncommand > file    将输出重定向到 file。\ncommand < file    将输入重定向到 file。\ncommand >> file   将输出以追加的方式重定向到 file。\nn > file          将文件描述符为 n 的文件重定向到 file。\nn >> file         将文件描述符为 n 的文件以追加的方式重定向到 file。\nn >& m            将输出文件 m 和 n 合并。\nn <& m            将输入文件 m 和 n 合并。\n<< tag            将开始标记 tag 和结束标记 tag 之间的内容作为输入。\n\n * 输入输出重定向实例\n\necho -e "hello \\c" > output.txt  # 将stdout重定向到output.txt中\necho "world" >> output.txt  # 将字符串追加到output.txt中\n\nread str < output.txt  # 从output.txt中读取字符串\n\necho $str  # 输出结果：hello world\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n * 同时重定向stdin和stdout\n\n创建main.sh编写脚本：\n\nread a\nread b\n\necho $(expr "$a" + "$b")\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n创建input.txt，填写内容为：\n\n10\n20\n\n\n1\n2\n\n1\n2\n\n\n执行结果如下：\n\n\n# 2.14 引入外部脚本\n\n类似c/c++中的include操作，bash也可以引入其他文件中的代码。 语法格式为：\n\n. filename # 注意空格\n或者\nsource filename\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 3 参考文献\n\nlinux基础课 菜鸟教程',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"Vim教程",frontmatter:{title:"Vim教程",date:"2022-01-21T10:00:00.000Z",tags:["Vim"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},categories:["工具","开发工具"],permalink:"/pages/e7b5a5/",readingShow:"top"},regularPath:"/02.%E5%B7%A5%E5%85%B7/03.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/03.Vim%E6%95%99%E7%A8%8B.html",relativePath:"02.工具/03.开发工具/03.Vim教程.md",key:"v-1a482803",path:"/pages/e7b5a5/",headers:[{level:2,title:"1. Vim",slug:"_1-vim",normalizedTitle:"1. vim",charIndex:2},{level:3,title:"1.1 Vim简介",slug:"_1-1-vim简介",normalizedTitle:"1.1 vim简介",charIndex:13},{level:3,title:"1.2 Vim模式",slug:"_1-2-vim模式",normalizedTitle:"1.2 vim模式",charIndex:342},{level:4,title:"1.2.1 正常模式(Normal-mode)",slug:"_1-2-1-正常模式-normal-mode",normalizedTitle:"1.2.1 正常模式(normal-mode)",charIndex:563},{level:4,title:"1.2.2 插入模式(Insert-mode)",slug:"_1-2-2-插入模式-insert-mode",normalizedTitle:"1.2.2 插入模式(insert-mode)",charIndex:5148},{level:4,title:"1.2.3 命令模式(Command -mode)",slug:"_1-2-3-命令模式-command-mode",normalizedTitle:"1.2.3 命令模式(command -mode)",charIndex:5585},{level:4,title:"1.2.4 可视模式(Visual-mode)",slug:"_1-2-4-可视模式-visual-mode",normalizedTitle:"1.2.4 可视模式(visual-mode)",charIndex:6297},{level:3,title:"1.3 快捷键速览图",slug:"_1-3-快捷键速览图",normalizedTitle:"1.3 快捷键速览图",charIndex:7386},{level:2,title:"2 参考文献",slug:"_2-参考文献",normalizedTitle:"2 参考文献",charIndex:7403}],headersStr:"1. Vim 1.1 Vim简介 1.2 Vim模式 1.2.1 正常模式(Normal-mode) 1.2.2 插入模式(Insert-mode) 1.2.3 命令模式(Command -mode) 1.2.4 可视模式(Visual-mode) 1.3 快捷键速览图 2 参考文献",content:'# 1. Vim\n\n\n# 1.1 Vim简介\n\nvim就是linux系统上的一款文本编辑器，具有语法高亮，代码补全，代码缩进，根据扩展名识别编程语言以及编译等方便编程的功能。是程序开发者一款非常好用的工具，这也是我们为什么要学习vim。\n\n需要注意的是，作为程序员一般认为vim是一个程序开发工具而不是文字处理软件。如果学会了vim，对编程效率有极大的提高。\n\n如果没有安装vim，可以通过:sudo apt-get install vim来安装。\n\n\n\n这个就是vim的界面，界面介绍在之后会介绍，同时vim对应的键盘功能图如下：\n\n\n\n图源：https://www.runoob.com/linux/linux-vim.html\n\n这个键盘图特别重要，也是vim的核心。\n\n\n# 1.2 Vim模式\n\n在使用vim之间，我们有必要了解它的模式，也可以认为是状态，一共有四种模式：\n\n * 正常模式(Normal-mode)；\n * 插入模式(Insert-mode)；\n * 命令模式(Command -mode)；\n * 可视模式(Visual-mode)。\n\n有的时候通常也认为是三个模式，即没有可视模式（可能是因为这个模式存在感低），我们可以参考下图理解模式之间的转换：\n\n\n\n接下来我们分别介绍这几个模式。\n\n# 1.2.1 正常模式(Normal-mode)\n\n此模式一般用于浏览文件，包括一些复制，粘贴，删除等操作。我们从任何模式返回到正常模式，只需要按下ESC键。\n\n当我们通过vim 文件名.后缀启动vim时，就进入到了正常模式，如果已有文件，则打开它，否则就打开一个新的文件，并命名为文件名。\n\n此时我们是无法向文件写内容的，此状态下敲击键盘会被vim识别为命令，而不是输入字符。\n\n当我们输入i，I, a,A 时会进入插入模式。\n\n当我们输入v时会进入可视模式。\n\n当我们输入:时会进入命令模式，即在最底下一行输入命令。所以也叫底线命令模式。\n\n要重点介绍的一个内容就是如何删除、复制，剪切以及粘贴了。vim对于复制，剪切，粘贴有它自己的一套术语。其中复制被叫做yank(y)， 剪切被叫做delete(d)，粘贴被叫做put(p)。\n\n * 删除\n   \n   * c -向下删除一行。如果要删除多行，则输入nc，即可向下删除nnn行。\n   * x - 向后删除一个字符，相当于del按键。如果要连续删除多个字符，则输入nx，即可删除nnn个。\n   * X -向前删除一个字符， 相当于Backspace按键。同理nX。\n\n * 复制(yank)\n   \n   我们如果需要复制文本，那么需要将光标放到你想要复制的地方，然后根据需求按下相应命令即可。\n   \n   * y -复制选中的文本（选中文本在视图模式中会讲到）。\n   \n   * yy -复制当前行，包括换行符。\n   \n   * <number>yy -复制从光标所在的当前行开始的number行文本。\n     \n     例如3yy即可复制从当前行开始的333行文本。\n   \n   * y$ -复制从光标位置到行尾的文本。\n   \n   * y^ -复制从光标位置到行首的文本。\n   \n   * yw -复制到下一个词的开头。\n   \n   * yiw - 复制当前词。\n   \n   * y% -复制匹配符号范围的内容。默认支持的符号对为(),{},[]。这个在复制括号内容时，非常有用。\n   \n   * yG -复制游标所在行到最后一行的行的所有数据。\n   \n   * ynG -n为数组，复制游标所在行到第nnn行的所有数据。\n\n * 剪切(delete)\n   \n   这个命令正常来说也可以作删除用。剪切文本时将光标移动到想要的位置，根据需求按下相应命令即可。\n   \n   * d -剪切选中的文本。\n   \n   * dd -剪切当前行，包括换行符等。\n   \n   * <number>dd -剪切从光标位置所在的行开始的number行文本。\n   \n   * d$ - 剪切从光标位置到行尾的内容。\n   \n   * ...不难发现，这些命令和复制差不多，就是将y换成d。这里就不再做阐述了。\n\n * 粘贴(put)\n   \n   先将光标移动到想要粘贴的位置，然后按p键即可将剪贴板的内容复制到当前光标后面。\n   \n   当然，大写的P则是复制到光标位置前面。\n\n * 其他常用操作\n   \n   快捷键                                     功能\n   J                                       将光标所在行与下一行的数据结合成同一行\n   gg=G                                    将全文代码格式化\n   u                                       撤销。(常用)\n   Ctrl+r                                  取消撤销。(常用)\n   这个 u与 Ctrl+r 是很常用的指令！一个是复原，另一个则是重做一次～   \n   利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！\n   .                                       不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！\n                                           (常用)\n   n                                       重复前一个查找操作（常用）\n   N                                       反向重复前一个查找操作（常用）\n\n其他的不常用操作这里不作列举。\n\n我们可以通过方向键操作光标位置，注意linux中的方向键可以通过hjkl分别代表左下上右。这里给出移动光标的方法表格：\n\n快捷键                                                  功能\nh 或 向左箭头键(←)                                         光标向左移动一个字符\nj 或 向下箭头键(↓)                                         光标向下移动一个字符\nk 或 向上箭头键(↑)                                         光标向上移动一个字符\nl 或 向右箭头键(→)                                         光标向右移动一个字符\n如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。    \n如果想要进行多次移动的话，例如向下移动 30 行，可以使用 "30j" 或 "30↓" 的组合按键，\n亦即加上想要进行的次数(数字)后，按下动作即可！\nCtrl] + f                                            屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)\nCtrl + b                                             屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)\nCtrl + d                                             屏幕『向下』移动半页\nCtrl] + u                                            屏幕『向上』移动半页\n+                                                    光标移动到非空格符的下一行行首\n-                                                    光标移动到非空格符的上一行行首\nn<space>                                             那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20\n                                                     则光标会向后面移动 20 个字符距离。\n0 或功能键``Home`                                        这是数字『 0 』：移动到这一行的最前面字符处 (常用)\n$ 或功能键``End`                                         移动到这一行的最后面字符处(常用)\nH                                                    光标移动到这个屏幕的最上方那一行的第一个字符\nM                                                    光标移动到这个屏幕的中央那一行的第一个字符\nL                                                    光标移动到这个屏幕的最下方那一行的第一个字符\nG                                                    移动到这个档案的最后一行(常用)\n:n或nG                                                n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)\ngg                                                   移动到这个档案的第一行，相当于 1G 啊！ (常用)\nn<Enter>                                             n 为数字。光标向下移动 n 行(常用)\nf{char}                                              光标跳转到光标所在行从光标开始之后的char字符处。即从光标位置到该行尾检索char字符，光标位置前的不处理\nF{char}                                              光标跳转到光标所在行从光标开始之前的char字符处。即从行开头到光标处检索char字符，光标位置前的不处理\nW或者w（大小写均可）                                          跳转到下一个单词的开头。支持数字前缀\nb或者B（大小写均可）                                          跳转到上一个单词的开头。支持数字前缀。\n{                                                    光标跳转到段首\n}                                                    光标跳转到段尾\n^                                                    光标跳转到软行首。即该行的最早非空格位置字符。\nE或e（大小写均可）                                           移动到词尾。\n(                                                    句首\n)                                                    下一句首\n%                                                    括号匹配。\n\n正常模式只有一些基本的命令，因此我们需要靠命令模式来输入更多的命令。\n\n# 1.2.2 插入模式(Insert-mode)\n\n由上相信大家应该知道怎么由正常模式进入输入模式，即按下i(insert)即可进入插入模式。\n\n在插入模式中，操作和正常的文本编辑器差不多，这里不作叙述。给出对应的快捷键操作表。\n\n快捷键                  功能\nCtrl + m或者Ctrl + j   开启新行\nCtrl + e             插入光标下的字符\nCtrl + y             插入光标上的字符\nCtrl + a             插入上次插入的文本\nCtrl + @             插入上次插入的文本并结束插入模式\nCtrl + w             删除光标前的一个单词\nCtrl + u             删除当前行的所有字符\nCtrl + T             在当前行首插入一个移位宽度的缩进\nCtrl + D             从当前行首删除一个位移宽度的缩进\n\n# 1.2.3 命令模式(Command -mode)\n\n我们在一般命令模式下按下:/?这三个字母中的任意一个就可以进入命令行模式了，命令行在最下面，可以进行查找、替换、保存、退出、配置编译器等操作。需要注意的就是我们每执行完一个命令之后就会回到正常模式，所以在需要操作的时候一定要输入:/?这三个字母中的其中一个。\n\n当然输入三个字母进入实现的命令是不一样的，这里给出具体操作。\n\n * /word -向光标之下（向后搜索）寻找第一个值为word的字符串。\n\n * ?word -向光标之上（向前搜索）寻找第一个值为word的字符串。\n\n * :n1,n2s/word1/word2/g -n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将字符串替换为word2。\n   \n   如果在g后面加上c命令，即:n1,n2s/word1/word2/gc那么会在替换前要求用户确认。\n\n * :1,$s/word1/word2/g -将全文的word1替换成word2。\n   \n   同理，如果在g后面加上c命令，也会要求确认。\n\n * :w -保存。\n\n * :w! -强制保存，当文件属性为只读时强制写入。不过这还是跟你对该文档的权限有关。\n\n * :q -退出vim。\n\n * :q! -强制退出vim。\n\n * :wq -保存并退出。\n\n * :set paste -设置成粘贴模式，取消代码自动缩进。\n\n * :set nopaste -取消粘贴模式，开启代码自动缩进。\n\n * :set nu -显示行号。\n\n * set nonu -隐藏行号。\n\n * :noh -关闭查找关键词高亮。\n\n# 1.2.4 可视模式(Visual-mode)\n\n这个模式存在感很低，有的甚至将它归结为正常模式。因为进入可视模式最直接的一个目的就是选中区域，然后再这个区域上进行操作，例如删除，替换等。不过，我认为这个模式异常重要，因为技巧性特别多。用好了这个模式，效率能大大的提高。\n\n * 如何选中一块区域？\n   \n   在vim中有三种激活可视模式并选择一块区域的方法：\n   \n   模式类型   激活方式       选择效果         左下角提示（即提示你当前处于何种模式）\n   字符文本   v(小写)      逐个字符选择文本     VISUAL\n   行文本    V(大写)      逐行选择文本       VISUAL LINE\n   块文本    Ctrl + v   按照块的方式选择文本   VISUAL BLOCK\n   \n   可能看着有点懵。我们来解释一下，\n   \n   * 对于字符文本选择，实际上就是从当前光标位置开始，通过方向键去逐个字符连续选取文本，和我们在平常的文本编辑器中按住shift键移动方向键选取功能相同；\n   * 对于行文本选择，那么也是从当前光标位置开始选择，通过方向键去逐行连续选取文本，和上一个区别在于粒度不一样，这个方式选择的最小单位是行；\n   * 而对于块文本选择为最强大的选择模式，因为前面两种选择具有局限性，这个模式它可以完全无视行的存在，可以在文本中按照需要的区域自由u许纳泽。\n   \n   我们来看一个例子：\n   \n   \n   \n   假设我们要选择Hello,Linux，那么使用字符文本选择我们只需要将光标移动到H处，然后进入字符文本选择模式，再通过方向键选中即可。块文本选择同理操作即可。\n\n * 如何快速选择目标区域？\n   \n   如果通过以上模式而不使用快捷键选取，那么效率很低。而在正常模式中，我们已经介绍了很多快速移动光标的命令，而在可视模式下，这些快速移动光标的命令也是可以使用的。\n\n * 如何重复选择目标区域?\n   \n   可以使用gv命令来重新选中之前选中的目标区域。\n\n * 对选中的区域进行操作\n   \n   命令   命令效果\n   d    删除选中文本\n   c    修改选中文本\n   r    替换选中文本\n   I    在选中文本前插入\n   A    在选中文本后插入\n   gu   选中区域转为小写\n   gU   选中区域转为大写\n   g~   大小写互调\n   >    向右缩进一个单位\n   <    向左缩进一个单位\n\n\n# 1.3 快捷键速览图\n\n\n\n\n# 2 参考文献\n\ny总Linux基础课\n\n精通 VIM ，此文就够了-zempty\n\nLinux vi/vim - runoob.com\n\nvim编辑器 莫迟',normalizedContent:'# 1. vim\n\n\n# 1.1 vim简介\n\nvim就是linux系统上的一款文本编辑器，具有语法高亮，代码补全，代码缩进，根据扩展名识别编程语言以及编译等方便编程的功能。是程序开发者一款非常好用的工具，这也是我们为什么要学习vim。\n\n需要注意的是，作为程序员一般认为vim是一个程序开发工具而不是文字处理软件。如果学会了vim，对编程效率有极大的提高。\n\n如果没有安装vim，可以通过:sudo apt-get install vim来安装。\n\n\n\n这个就是vim的界面，界面介绍在之后会介绍，同时vim对应的键盘功能图如下：\n\n\n\n图源：https://www.runoob.com/linux/linux-vim.html\n\n这个键盘图特别重要，也是vim的核心。\n\n\n# 1.2 vim模式\n\n在使用vim之间，我们有必要了解它的模式，也可以认为是状态，一共有四种模式：\n\n * 正常模式(normal-mode)；\n * 插入模式(insert-mode)；\n * 命令模式(command -mode)；\n * 可视模式(visual-mode)。\n\n有的时候通常也认为是三个模式，即没有可视模式（可能是因为这个模式存在感低），我们可以参考下图理解模式之间的转换：\n\n\n\n接下来我们分别介绍这几个模式。\n\n# 1.2.1 正常模式(normal-mode)\n\n此模式一般用于浏览文件，包括一些复制，粘贴，删除等操作。我们从任何模式返回到正常模式，只需要按下esc键。\n\n当我们通过vim 文件名.后缀启动vim时，就进入到了正常模式，如果已有文件，则打开它，否则就打开一个新的文件，并命名为文件名。\n\n此时我们是无法向文件写内容的，此状态下敲击键盘会被vim识别为命令，而不是输入字符。\n\n当我们输入i，i, a,a 时会进入插入模式。\n\n当我们输入v时会进入可视模式。\n\n当我们输入:时会进入命令模式，即在最底下一行输入命令。所以也叫底线命令模式。\n\n要重点介绍的一个内容就是如何删除、复制，剪切以及粘贴了。vim对于复制，剪切，粘贴有它自己的一套术语。其中复制被叫做yank(y)， 剪切被叫做delete(d)，粘贴被叫做put(p)。\n\n * 删除\n   \n   * c -向下删除一行。如果要删除多行，则输入nc，即可向下删除nnn行。\n   * x - 向后删除一个字符，相当于del按键。如果要连续删除多个字符，则输入nx，即可删除nnn个。\n   * x -向前删除一个字符， 相当于backspace按键。同理nx。\n\n * 复制(yank)\n   \n   我们如果需要复制文本，那么需要将光标放到你想要复制的地方，然后根据需求按下相应命令即可。\n   \n   * y -复制选中的文本（选中文本在视图模式中会讲到）。\n   \n   * yy -复制当前行，包括换行符。\n   \n   * <number>yy -复制从光标所在的当前行开始的number行文本。\n     \n     例如3yy即可复制从当前行开始的333行文本。\n   \n   * y$ -复制从光标位置到行尾的文本。\n   \n   * y^ -复制从光标位置到行首的文本。\n   \n   * yw -复制到下一个词的开头。\n   \n   * yiw - 复制当前词。\n   \n   * y% -复制匹配符号范围的内容。默认支持的符号对为(),{},[]。这个在复制括号内容时，非常有用。\n   \n   * yg -复制游标所在行到最后一行的行的所有数据。\n   \n   * yng -n为数组，复制游标所在行到第nnn行的所有数据。\n\n * 剪切(delete)\n   \n   这个命令正常来说也可以作删除用。剪切文本时将光标移动到想要的位置，根据需求按下相应命令即可。\n   \n   * d -剪切选中的文本。\n   \n   * dd -剪切当前行，包括换行符等。\n   \n   * <number>dd -剪切从光标位置所在的行开始的number行文本。\n   \n   * d$ - 剪切从光标位置到行尾的内容。\n   \n   * ...不难发现，这些命令和复制差不多，就是将y换成d。这里就不再做阐述了。\n\n * 粘贴(put)\n   \n   先将光标移动到想要粘贴的位置，然后按p键即可将剪贴板的内容复制到当前光标后面。\n   \n   当然，大写的p则是复制到光标位置前面。\n\n * 其他常用操作\n   \n   快捷键                                     功能\n   j                                       将光标所在行与下一行的数据结合成同一行\n   gg=g                                    将全文代码格式化\n   u                                       撤销。(常用)\n   ctrl+r                                  取消撤销。(常用)\n   这个 u与 ctrl+r 是很常用的指令！一个是复原，另一个则是重做一次～   \n   利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！\n   .                                       不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！\n                                           (常用)\n   n                                       重复前一个查找操作（常用）\n   n                                       反向重复前一个查找操作（常用）\n\n其他的不常用操作这里不作列举。\n\n我们可以通过方向键操作光标位置，注意linux中的方向键可以通过hjkl分别代表左下上右。这里给出移动光标的方法表格：\n\n快捷键                                                  功能\nh 或 向左箭头键(←)                                         光标向左移动一个字符\nj 或 向下箭头键(↓)                                         光标向下移动一个字符\nk 或 向上箭头键(↑)                                         光标向上移动一个字符\nl 或 向右箭头键(→)                                         光标向右移动一个字符\n如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。    \n如果想要进行多次移动的话，例如向下移动 30 行，可以使用 "30j" 或 "30↓" 的组合按键，\n亦即加上想要进行的次数(数字)后，按下动作即可！\nctrl] + f                                            屏幕『向下』移动一页，相当于 [page down]按键 (常用)\nctrl + b                                             屏幕『向上』移动一页，相当于 [page up] 按键 (常用)\nctrl + d                                             屏幕『向下』移动半页\nctrl] + u                                            屏幕『向上』移动半页\n+                                                    光标移动到非空格符的下一行行首\n-                                                    光标移动到非空格符的上一行行首\nn<space>                                             那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20\n                                                     则光标会向后面移动 20 个字符距离。\n0 或功能键``home`                                        这是数字『 0 』：移动到这一行的最前面字符处 (常用)\n$ 或功能键``end`                                         移动到这一行的最后面字符处(常用)\nh                                                    光标移动到这个屏幕的最上方那一行的第一个字符\nm                                                    光标移动到这个屏幕的中央那一行的第一个字符\nl                                                    光标移动到这个屏幕的最下方那一行的第一个字符\ng                                                    移动到这个档案的最后一行(常用)\n:n或ng                                                n 为数字。移动到这个档案的第 n 行。例如 20g 则会移动到这个档案的第 20 行(可配合 :set nu)\ngg                                                   移动到这个档案的第一行，相当于 1g 啊！ (常用)\nn<enter>                                             n 为数字。光标向下移动 n 行(常用)\nf{char}                                              光标跳转到光标所在行从光标开始之后的char字符处。即从光标位置到该行尾检索char字符，光标位置前的不处理\nf{char}                                              光标跳转到光标所在行从光标开始之前的char字符处。即从行开头到光标处检索char字符，光标位置前的不处理\nw或者w（大小写均可）                                          跳转到下一个单词的开头。支持数字前缀\nb或者b（大小写均可）                                          跳转到上一个单词的开头。支持数字前缀。\n{                                                    光标跳转到段首\n}                                                    光标跳转到段尾\n^                                                    光标跳转到软行首。即该行的最早非空格位置字符。\ne或e（大小写均可）                                           移动到词尾。\n(                                                    句首\n)                                                    下一句首\n%                                                    括号匹配。\n\n正常模式只有一些基本的命令，因此我们需要靠命令模式来输入更多的命令。\n\n# 1.2.2 插入模式(insert-mode)\n\n由上相信大家应该知道怎么由正常模式进入输入模式，即按下i(insert)即可进入插入模式。\n\n在插入模式中，操作和正常的文本编辑器差不多，这里不作叙述。给出对应的快捷键操作表。\n\n快捷键                  功能\nctrl + m或者ctrl + j   开启新行\nctrl + e             插入光标下的字符\nctrl + y             插入光标上的字符\nctrl + a             插入上次插入的文本\nctrl + @             插入上次插入的文本并结束插入模式\nctrl + w             删除光标前的一个单词\nctrl + u             删除当前行的所有字符\nctrl + t             在当前行首插入一个移位宽度的缩进\nctrl + d             从当前行首删除一个位移宽度的缩进\n\n# 1.2.3 命令模式(command -mode)\n\n我们在一般命令模式下按下:/?这三个字母中的任意一个就可以进入命令行模式了，命令行在最下面，可以进行查找、替换、保存、退出、配置编译器等操作。需要注意的就是我们每执行完一个命令之后就会回到正常模式，所以在需要操作的时候一定要输入:/?这三个字母中的其中一个。\n\n当然输入三个字母进入实现的命令是不一样的，这里给出具体操作。\n\n * /word -向光标之下（向后搜索）寻找第一个值为word的字符串。\n\n * ?word -向光标之上（向前搜索）寻找第一个值为word的字符串。\n\n * :n1,n2s/word1/word2/g -n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将字符串替换为word2。\n   \n   如果在g后面加上c命令，即:n1,n2s/word1/word2/gc那么会在替换前要求用户确认。\n\n * :1,$s/word1/word2/g -将全文的word1替换成word2。\n   \n   同理，如果在g后面加上c命令，也会要求确认。\n\n * :w -保存。\n\n * :w! -强制保存，当文件属性为只读时强制写入。不过这还是跟你对该文档的权限有关。\n\n * :q -退出vim。\n\n * :q! -强制退出vim。\n\n * :wq -保存并退出。\n\n * :set paste -设置成粘贴模式，取消代码自动缩进。\n\n * :set nopaste -取消粘贴模式，开启代码自动缩进。\n\n * :set nu -显示行号。\n\n * set nonu -隐藏行号。\n\n * :noh -关闭查找关键词高亮。\n\n# 1.2.4 可视模式(visual-mode)\n\n这个模式存在感很低，有的甚至将它归结为正常模式。因为进入可视模式最直接的一个目的就是选中区域，然后再这个区域上进行操作，例如删除，替换等。不过，我认为这个模式异常重要，因为技巧性特别多。用好了这个模式，效率能大大的提高。\n\n * 如何选中一块区域？\n   \n   在vim中有三种激活可视模式并选择一块区域的方法：\n   \n   模式类型   激活方式       选择效果         左下角提示（即提示你当前处于何种模式）\n   字符文本   v(小写)      逐个字符选择文本     visual\n   行文本    v(大写)      逐行选择文本       visual line\n   块文本    ctrl + v   按照块的方式选择文本   visual block\n   \n   可能看着有点懵。我们来解释一下，\n   \n   * 对于字符文本选择，实际上就是从当前光标位置开始，通过方向键去逐个字符连续选取文本，和我们在平常的文本编辑器中按住shift键移动方向键选取功能相同；\n   * 对于行文本选择，那么也是从当前光标位置开始选择，通过方向键去逐行连续选取文本，和上一个区别在于粒度不一样，这个方式选择的最小单位是行；\n   * 而对于块文本选择为最强大的选择模式，因为前面两种选择具有局限性，这个模式它可以完全无视行的存在，可以在文本中按照需要的区域自由u许纳泽。\n   \n   我们来看一个例子：\n   \n   \n   \n   假设我们要选择hello,linux，那么使用字符文本选择我们只需要将光标移动到h处，然后进入字符文本选择模式，再通过方向键选中即可。块文本选择同理操作即可。\n\n * 如何快速选择目标区域？\n   \n   如果通过以上模式而不使用快捷键选取，那么效率很低。而在正常模式中，我们已经介绍了很多快速移动光标的命令，而在可视模式下，这些快速移动光标的命令也是可以使用的。\n\n * 如何重复选择目标区域?\n   \n   可以使用gv命令来重新选中之前选中的目标区域。\n\n * 对选中的区域进行操作\n   \n   命令   命令效果\n   d    删除选中文本\n   c    修改选中文本\n   r    替换选中文本\n   i    在选中文本前插入\n   a    在选中文本后插入\n   gu   选中区域转为小写\n   gu   选中区域转为大写\n   g~   大小写互调\n   >    向右缩进一个单位\n   <    向左缩进一个单位\n\n\n# 1.3 快捷键速览图\n\n\n\n\n# 2 参考文献\n\ny总linux基础课\n\n精通 vim ，此文就够了-zempty\n\nlinux vi/vim - runoob.com\n\nvim编辑器 莫迟',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"AI时代下的GPU生存工具包：每个开发人员必须了解的最基本知识",frontmatter:{title:"AI时代下的GPU生存工具包：每个开发人员必须了解的最基本知识",author:{name:"Pursuit",link:"https://github.com/unique-pure"},date:"2024-03-19T20:20:55.000Z",permalink:"/pages/df386a/",categories:["学习笔记","闲杂文章"],tags:[null],readingShow:"top"},regularPath:"/03.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/04.%E9%97%B2%E6%9D%82%E6%96%87%E7%AB%A0/01.AI%E6%97%B6%E4%BB%A3%E4%B8%8B%E7%9A%84GPU%E7%94%9F%E5%AD%98%E5%B7%A5%E5%85%B7%E5%8C%85%EF%BC%9A%E6%AF%8F%E4%B8%AA%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86.html",relativePath:"03.学习笔记/04.闲杂文章/01.AI时代下的GPU生存工具包：每个开发人员必须了解的最基本知识.md",key:"v-4b74d0db",path:"/pages/df386a/",headers:[{level:2,title:"1 CPU知识为何不再足够",slug:"_1-cpu知识为何不再足够",normalizedTitle:"1 cpu知识为何不再足够",charIndex:11},{level:2,title:"2 GPU驱动开发如何解决这些问题",slug:"_2-gpu驱动开发如何解决这些问题",normalizedTitle:"2 gpu驱动开发如何解决这些问题",charIndex:715},{level:2,title:"3 GPU和CPU有什么区别",slug:"_3-gpu和cpu有什么区别",normalizedTitle:"3 gpu和cpu有什么区别",charIndex:1141},{level:2,title:"4 GPU类型",slug:"_4-gpu类型",normalizedTitle:"4 gpu类型",charIndex:1734},{level:2,title:"5 使用 Nvidia 的 CUDA 进行 GPU 驱动开发",slug:"_5-使用-nvidia-的-cuda-进行-gpu-驱动开发",normalizedTitle:"5 使用 nvidia 的 cuda 进行 gpu 驱动开发",charIndex:2198},{level:3,title:"5.1 Linux安装CUDA",slug:"_5-1-linux安装cuda",normalizedTitle:"5.1 linux安装cuda",charIndex:2295},{level:3,title:"5.2 基本命令",slug:"_5-2-基本命令",normalizedTitle:"5.2 基本命令",charIndex:2729},{level:3,title:"5.3 开始使用CUDA框架",slug:"_5-3-开始使用cuda框架",normalizedTitle:"5.3 开始使用cuda框架",charIndex:3020},{level:4,title:"5.3.1 数组加法问题",slug:"_5-3-1-数组加法问题",normalizedTitle:"5.3.1 数组加法问题",charIndex:3072},{level:4,title:"5.3.2 使用 GPU 在 Python 中优化图像生成",slug:"_5-3-2-使用-gpu-在-python-中优化图像生成",normalizedTitle:"5.3.2 使用 gpu 在 python 中优化图像生成",charIndex:5571},{level:4,title:"5.3.3 使用 GPU 训练猫狗神经网络",slug:"_5-3-3-使用-gpu-训练猫狗神经网络",normalizedTitle:"5.3.3 使用 gpu 训练猫狗神经网络",charIndex:10786},{level:2,title:"6 结论",slug:"_6-结论",normalizedTitle:"6 结论",charIndex:14582}],headersStr:"1 CPU知识为何不再足够 2 GPU驱动开发如何解决这些问题 3 GPU和CPU有什么区别 4 GPU类型 5 使用 Nvidia 的 CUDA 进行 GPU 驱动开发 5.1 Linux安装CUDA 5.2 基本命令 5.3 开始使用CUDA框架 5.3.1 数组加法问题 5.3.2 使用 GPU 在 Python 中优化图像生成 5.3.3 使用 GPU 训练猫狗神经网络 6 结论",content:"翻译原文地址\n\n\n# 1 CPU知识为何不再足够\n\n在当今的人工智能时代，大多数开发者都是按照CPU的方式进行训练。这种认知也已经成为我们学术中的一部分，因此很自然地会以CPU为导向来思考和解决问题。\n\n然而，CPU 的问题在于它们依赖于串行架构。在当今世界中，我们依赖大量并行任务的情况下，CPU 无法很好地处理这些场景。\n\n因此，开发者面临着如下问题。\n\n * 执行并行任务\n   \n   > CPU 传统上是线性运行的，一次执行一条指令。这种限制源于这样一个事实：CPU 通常具有一些针对单线程性能进行优化的强大内核。当面临多个任务时，CPU会分配其资源来逐个处理每个任务，从而导致指令的顺序执行。在需要同时关注众多任务的情况下，这种方法变得低效。\n   > \n   > 尽管我们通过诸如多线程等技术来提高CPU性能，但CPU的基本设计理念是优先考虑顺序执行。\n\n * 高效运行AI模型\n   \n   > AI 模型采用 Transformer 等先进架构，利用并行处理来增强性能。与顺序运行的旧递归神经网络 (RNN) 不同，GPT 等现代 Transformer 可以同时处理多个单词，从而提高训练效率和能力。因为当我们并行训练时，会产生更大的模型，而更大的模型会产生更好的输出。\n   > \n   > 并行的概念已从自然语言处理扩展到图像识别等其他领域。例如，图像识别架构 AlexNet 通过同时处理图像的不同部分，展示了并行处理的威力，从而实现准确的模式识别。\n   > \n   > 然而，CPU 的设计侧重于单线程性能，很难充分挖掘并行处理的潜力。它们难以有效分配和执行复杂AI模型所需的大量并行计算。\n\n\n# 2 GPU驱动开发如何解决这些问题\n\n * GPU 核心的大规模并行性\n   \n   > 与 CPU 中更大、更强大的内核相比，工程师设计的 GPU 具有更小、高度专业化的内核。该架构允许 GPU 同时执行多个并行任务。\n   > \n   > GPU 中的大量核心非常适合依赖于并行性的工作负载，例如图形渲染和复杂的数学计算。\n   > \n   > 如下图所示，5.3.2使用 GPU 并行性来减少复杂任务所需的时间。\n\n * AI 模型中使用的并行性\n   \n   > 人工智能模型，特别是基于 TensorFlow 等深度学习框架构建的模型，表现出高度的并行性。神经网络训练涉及大量矩阵运算，而 GPU 凭借其庞大的核心数量，擅长并行化这些运算。 TensorFlow 与其他流行的深度学习框架一起进行优化，以利用 GPU 的能力来加速模型训练和推理。\n   > \n   > 如下图所示，5.3.3使用 GPU 的强大功能来训练神经网络。\n\n\n# 3 GPU和CPU有什么区别\n\n * CPU\n   \n   * 串行架构\n     \n     > 中央处理单元 (CPU) 的设计重点是顺序处理。它们擅长线性执行一组指令。CPU 针对需要高单线程性能的任务进行了优化，例如：\n     > \n     >  * 通用计算\n     >  * 系统操作\n     >  * 处理涉及条件分支的复杂算法\n   \n   * 并行任务的核心数量有限\n     \n     > CPU 的核心数量较少，在消费级处理器中通常为 2-16 个核心。每个内核都能够独立处理自己的指令集。\n\n * GPU\n   \n   * 并行架构\n     \n     > 图形处理单元（GPU）采用并行架构设计，使其能够高效地执行并行处理任务。这有利于：\n     > \n     >  * 渲染图形\n     >  * 执行复杂的数学计算\n     >  * 运行可并行算法\n     > \n     > GPU 通过将多个任务分解为更小的并行子任务来同时处理多个任务。\n   \n   * 数千个内核用于并行任务\n     \n     > 与 CPU 不同，GPU 拥有更多的核心，通常有数千个。这些内核被组织成流式多处理器 (SM) 或类似的结构。丰富的内核使 GPU 能够同时处理大量数据，非常适合并行任务，例如图像和视频处理、深度学习和科学模拟。\n\n\n# 4 GPU类型\n\n * 通用 Gpu\n   \n   > 通用 GPU 实例（P3 和 P4 实例）适用于广泛的工作负载，包括机器学习训练和推理、图像处理和视频编码。它们的平衡性能使它们成为各种计算任务的理想选择。\n\n * 推理优化的 GPU\n   \n   > 推理是运行已经训练好的 AI 模型并对实时数据进行预测或任务求解的过程。推理优化的 GPU 实例（P5 和 Inf1 实例）在低延迟和成本效率至关重要的情况下表现出色，特别适用于机器学习推理任务。\n\n * 图形优化的 GPU\n   \n   > 图形优化的 GPU 实例（G4 实例）专门设计用于处理图形密集型任务，如视频游戏开发中的 3D 图形渲染。这些实例非常适合需要处理大量图形数据的应用程序。\n\n * 托管 GPU\n   \n   > Amazon SageMaker 是一种托管服务，为机器学习提供了易于使用的 GPU 实例。它提供对多种 GPU 实例（包括 P3、P4 和 P5 实例）的访问，适用于想要轻松开始机器学习而无需管理底层基础设施的组织。\n\n\n# 5 使用 Nvidia 的 CUDA 进行 GPU 驱动开发\n\nCUDA 是 NVIDIA 开发的并行计算平台和编程模型，使开发人员能够利用 GPU 加速器的强大功能来加速其应用程序。\n\n\n# 5.1 Linux安装CUDA\n\n 1. 下载CUDA\n\n 2. 从上面的链接下载基本安装程序以及驱动程序安装程序\n\n 3. 转到主文件夹中的 .bashrc（如果使用其他shell则使用对应的配置文件）\n\n 4. 在配置文件中添加以下行：\n    \n    export PATH=\"/usr/local/cuda-12.3/bin:$PATH\"\n    export LD_LIBRARY_PATH=\"/usr/local/cuda-12.3/lib64:$LD_LIBRARY_PATH\"\n    \n    \n    1\n    2\n    \n    1\n    2\n    \n\n 5. 然后执行以下命令：\n    \n    sudo apt-get install cuda-toolkit\n    sudo apt-get install nvidia-gds\n    \n    \n    1\n    2\n    \n    1\n    2\n    \n\n\n# 5.2 基本命令\n\n * lspci | grep VGA\n   \n   > 识别并列出系统中的 GPU。\n\n * nvidia-smi\n   \n   > “NVIDIA 系统管理界面”，它提供有关系统中 NVIDIA GPU 的详细信息，包括利用率、温度、内存使用情况等。\n\n * sudo lshw -C display\n   \n   > 提供有关系统中显示控制器（包括显卡）的详细信息。\n\n * inxi -G\n   \n   > 提供有关图形子系统的信息，包括有关 GPU 和显示器的详细信息。\n\n * sudo hwinfo --gfxcard\n   \n   > \n\n\n# 5.3 开始使用CUDA框架\n\n当我们安装了 CUDA 框架后，让我们开始执行展示其功能的操作。\n\n# 5.3.1 数组加法问题\n\n数组加法问题是演示 GPU 并行化的一个合适问题。考虑以下数组：\n\n * 数组 A=[1,2,3,4,5,6]A = [1,2,3,4,5,6]A=[1,2,3,4,5,6]\n\n * 数组 B=[7,8,9,10,11,12]B = [7,8,9,10,11,12]B=[7,8,9,10,11,12]\n\n * 我们需要存储每个元素的和并将其存储在数组CCC中。我们需要存储每个元素的和并将其存储在数组CCC中。\n\n * 就像 C=[1+7,2+8,3+9,4+10,5+11,6+12]=[8,10,12,14,16,18]C = [1+7,2+8,3+9,4+10,5+11,6+12] = [8,10,12,14,16,18]C=[1+7,2+8,3+9,4+10,5+11,6+12]=[8,10,12,14,16,18]\n\n * 如果CPU要执行这样的操作，它将执行如下代码所示的操作。\n   \n   #include <stdio.h>\n   int a[] = {1,2,3,4,5,6};\n   int b[] = {7,8,9,10,11,12};\n   int c[6];\n   \n   int main() {\n       int N = 6;  // Number of elements\n   \n       for (int i = 0; i < N; i++) {\n           c[i] = a[i] + b[i];\n       }\n   \n       for (int i = 0; i < N; i++) {\n           printf(\"c[%d] = %d\", i, c[i]);\n       }\n   \n       return 0;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   \n\n这种方法是逐个遍历数组元素并依次执行加法。然而，当处理大量数字时，这种方法由于其顺序性质而变得缓慢。\n\n为了解决这个限制，GPU 通过并行化加法过程提供了一种解决方案。与依次执行运算的 CPU 不同，GPU 可以同时执行多项加法。例如，运算1+7、2+8、3+9、4+10、5+111+7、2+8、3+9、4+10、5+111+7、2+8、3+9、4+10、5+11和6+126+126+12可以借助GPU并行化同时执行。\n\n利用CUDA，我们将使用内核文件 (.cu) 进行展示。实现并行加法的代码如下：\n\n__global__ void vectorAdd(int* a, int* b, int* c) {\n    int i = threadIdx.x;\n    c[i] = a[i] + b[i];\n    return;\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n * __global__ 说明符表明该函数是一个内核函数，将在 GPU 上调用。\n * vectorAdd 采用三个整数指针（aaa、bbb 和 ccc）作为参数，表示要相加的向量。\n * threadIdx.x 检索当前线程的索引（在一维网格中）。\n * 向量 aaa 和 bbb 的相应元素之和存储在向量 ccc 中。\n\n现在我们来看看主要功能。创建指针 cudaA 、 cudaB 和 cudaC 来指向 GPU 上的内存。\n\n// 利用 CUDA 使用并行计算加法的函数\nint main() {\n    int a[] = {1,2,3};\n    int b[] = {4,5,6};\n    int c[sizeof(a) / sizeof(int)] = {0};\n    // 创建指向 GPU 的指针\n    int* cudaA = 0;\n    int* cudaB = 0;\n    int* cudaC = 0;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n使用 cudaMalloc ，在 GPU 上为向量 cudaA、cudaB 和 cudaC 分配内存。\n\n// 在GPU中分配内存\ncudaMalloc(&cudaA,sizeof(a));\ncudaMalloc(&cudaB,sizeof(b));\ncudaMalloc(&cudaC,sizeof(c));\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n内核函数 vectorAdd 使用一个块和等于向量大小的多个线程启动。\n\n// 用一个程序块和与向量大小相等的线程数启动内核\nvectorAdd <<<1, sizeof(a) / sizeof(a[0])>>> (cudaA, cudaB, cudaC);\n\n\n1\n2\n\n1\n2\n\n\n结果向量 cudaC 从GPU复制回主机。\n\n// 将结果向量复制回主机\ncudaMemcpy(c, cudaC, sizeof(c), cudaMemcpyDeviceToHost);\n\n\n1\n2\n\n1\n2\n\n\n然后我们可以照常打印结果\n\n    // 打印结果\n    for (int i = 0; i < sizeof(c) / sizeof(int); i++) {\n        printf(\"c[%d] = %d\", i, c[i]);\n    }\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n为了执行此代码，我们将使用 nvcc 命令。我们将得到输出为：\n\n\n\n这是完整的代码供读者参考。\n\n# 5.3.2 使用 GPU 在 Python 中优化图像生成\n\n本节探讨使用 GPU 处理来优化性能密集型任务，例如图像生成。\n\nMandelbrot 集是一种数学构造，它根据规定方程中特定数字的行为形成复杂的视觉模式。生成一个这样的图案需要耗费大量资源。在下面的代码片段中，您可以观察到使用 CPU 处理生成 Mandelbrot 集的传统方法，该方法速度很慢。\n\n# 导入必要的库\nfrom matplotlib import pyplot as plt\nimport numpy as np\nfrom pylab import imshow, show\nfrom timeit import default_timer as timer\n\n# 计算给定点 (x, y) 的 Mandelbrot 集的函数\ndef mandel(x, y, max_iters):\n    c = complex(x, y)\n    z = 0.0j\n    # 迭代检查该点是否在 Mandelbrot 集中\n    for i in range(max_iters):\n        z = z*z + c\n        if (z.real*z.real + z.imag*z.imag) >= 4:\n            return i\n    # 如果在最大迭代次数内，则将其视为集合的一部分\n    return max_iters\n\n# 在指定区域内创建 Mandelbrot 分形的函数\ndef create_fractal(min_x, max_x, min_y, max_y, image, iters):\n    height = image.shape[0]\n    width = image.shape[1]\n\n    # 根据指定区域计算像素大小\n    pixel_size_x = (max_x - min_x) / width\n    pixel_size_y = (max_y - min_y) / height\n\n    # 在图像中迭代每个像素并计算Mandelbrot值\n    for x in range(width):\n        real = min_x + x * pixel_size_x\n        for y in range(height):\n            imag = min_y + y * pixel_size_y\n            color = mandel(real, imag, iters)\n            image[y, x] = color\n\n# 为 Mandelbrot 集创建一个空白图像数组\nimage = np.zeros((1024, 1536), dtype=np.uint8)\n\n# 记录性能测量的开始时间\nstart = timer()\n\n# 在指定的区域和迭代次数内生成Mandelbrot集合\ncreate_fractal(-2.0, 1.0, -1.0, 1.0, image, 20)\n\n# 计算创建 Mandelbrot 集所需的时间\ndt = timer() - start\n\n# 打印生成 Mandelbrot 集所需的时间\nprint(\"Mandelbrot created in %f s\" % dt)\n\n# 使用 matplotlib 显示 Mandelbrot 集\nimshow(image)\nshow()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n上面的代码在 4.07 秒内生成输出。\n\n为了加快速度，我们可以使用 Numba 库将代码与 GPU 并行化，具体操作如下：\n\n * 我们将从 numba 导入即时编译、用于 GPU 加速的 CUDA 以及其他工具库\n   \n   import numpy as np\n   from numba import jit, cuda, uint32, f8, uint8\n   from pylab import imshow, show\n   from timeit import default_timer as timer\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n\n * @jit 装饰器指示 Numba 执行即时编译，将 Python 代码转换为机器代码以提高执行速度。\n   \n   @jit\n   def mandel(x, y, max_iters):\n       c = complex(x, y)\n       z = 0.0j\n       for i in range(max_iters):\n           z = z*z + c\n           if (z.real*z.real + z.imag*z.imag) >= 4:\n               return i\n   \n       return max_iters\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n\n * mandel_gpu 是使用 cuda.jit 创建的 mandel 函数的 GPU 兼容版本。这允许将 mandel 逻辑卸载到 GPU。这是通过使用 @cuda.jit 装饰器并指定函数参数的数据类型（f8 表示浮点数，``uint32表示无符号32位整数）来完成的。device=True` 参数指示该函数将在 GPU 上运行。\n   \n   mandel_gpu = cuda.jit((f8, f8, uint32), device=True)(mandel)\n   \n   \n   1\n   \n   1\n   \n\n * mandel_kernel 函数被定义为在 CUDA GPU 上执行。它负责跨 GPU 线程并行生成 Mandelbrot 集。\n   \n   @cuda.jit((f8, f8, f8, f8, uint8[:,:], uint32))\n   def mandel_kernel(min_x, max_x, min_y, max_y, image, iters):\n       height = image.shape[0]\n       width = image.shape[1]\n   \n       pixel_size_x = (max_x - min_x) / width\n       pixel_size_y = (max_y - min_y) / height\n   \n       startX, startY = cuda.grid(2)\n       gridX = cuda.gridDim.x * cuda.blockDim.x\n       gridY = cuda.gridDim.y * cuda.blockDim.y\n   \n       for x in range(startX, width, gridX):\n           real = min_x + x * pixel_size_x\n           for y in range(startY, height, gridY):\n               imag = min_y + y * pixel_size_y\n               image[y, x] = mandel_gpu(real, imag, iters)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   \n\n * 现在，我们可以在 create_fractal_gpu 函数中使用 GPU 加速的 Mandelbrot 集生成。该函数分配 GPU 内存，启动 GPU 内核 (mandel_kernel)，并将结果复制回 CPU。\n   \n   def create_fractal_gpu(min_x, max_x, min_y, max_y, image, iters):\n       # Step 1: 为图像分配GPU内存\n       d_image = cuda.to_device(image)\n   \n       # Step 2: 定义GPU并行化的线程和块数\n       threadsperblock = (16, 16)\n       blockspergrid_x = int(np.ceil(image.shape[1] / threadsperblock[0]))\n       blockspergrid_y = int(np.ceil(image.shape[0] / threadsperblock[1]))\n       blockspergrid = (blockspergrid_x, blockspergrid_y)\n   \n       # Step 3: 测量开始时间\n       start = timer()\n   \n       # Step 4: 启动 GPU 内核（mandel_kernel）在 GPU 上计算 Mandelbrot 集。\n       mandel_kernel[blockspergrid, threadsperblock](min_x, max_x, min_y, max_y, d_image, iters)\n   \n       # Step 5: 等待 GPU 完成其工作（同步）\n       cuda.synchronize()\n   \n       # Step 6: 测量GPU处理所需的时间\n       dt = timer() - start\n   \n       # Step 7: 将结果从 GPU 内存复制回 CPU\n       d_image.copy_to_host(image)\n   \n       # Step 8: 显示 Mandelbrot 集图像\n       print(\"Mandelbrot created on GPU in %f s\" % dt)\n       imshow(image)\n       show()\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   \n\n上面的代码在 0.0046 seconds 中执行。这比我们之前的基于 CPU 的代码要快得多。\n\n\n\n这是完整的代码供读者参考。\n\n# 5.3.3 使用 GPU 训练猫狗神经网络\n\n我们现在看到的热门话题之一是 GPU 如何在人工智能中使用，因此为了证明我们将创建一个神经网络来区分猫和狗。我们将使用以下代码训练和使用猫与狗模型，其中使用了卷积神经网络（CNN），您可以阅读有关它的更多详细信息。\n\n * 先决条件\n   \n   1. CUDA\n   \n   2. Tensorflow -> 可以通过 pip install tensorflow[and-cuda] 安装\n   \n   3. 我们将使用来自kaggle的猫和狗的数据集\n   \n   4. 下载完成后，解压，将训练文件夹中的猫和狗的图片整理到不同的子文件夹中，如下图所示。\n      \n      \n\n * 导入库\n   \n   >  * pandas 和 numpy 用于数据操作。\n   > \n   >  * Sequential用于在神经网络中创建线性层堆栈。\n   > \n   >  * Convolution2D、``MaxPooling2D、Dense和Flatten` 是用于构建卷积神经网络 (CNN) 的层。\n   > \n   >  * ImageDataGenerator用于在训练期间进行实时数据增强。\n   > \n   > import pandas as pd\n   > import numpy as np\n   > from keras.models import Sequential\n   > from keras.layers import Convolution2D, MaxPooling2D, Dense, Flatten\n   > from keras.preprocessing.image import ImageDataGenerator\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n\n * 初始化卷积神经网络\n   \n   > classifier = Sequential()\n   > \n   > \n   > 1\n   > \n   > 1\n\n * 加载训练数据\n   \n   > train_datagen = ImageDataGenerator(\n   >     rescale=1./255,\n   >     shear_range=0.2,\n   >     zoom_range=0.2,\n   >     horizontal_flip=True\n   > )\n   > test_datagen = ImageDataGenerator(rescale=1./255)\n   > \n   > training_set = train_datagen.flow_from_directory(\n   >     './training_set',\n   >     target_size=(64, 64),\n   >     batch_size=32,\n   >     class_mode='binary'\n   > )\n   > \n   > test_set = test_datagen.flow_from_directory(\n   >     './test_set',\n   >     target_size=(64, 64),\n   >     batch_size=32,\n   >     class_mode='binary'\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n   > 16\n   > 17\n   > 18\n   > 19\n   > 20\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n   > 16\n   > 17\n   > 18\n   > 19\n   > 20\n\n * 构建 CNN 架构\n   \n   > classifier.add(Convolution2D(32, 3, 3, input_shape=(64, 64, 3), activation='relu'))\n   > classifier.add(MaxPooling2D(pool_size=(2, 2)))\n   > classifier.add(Flatten())\n   > classifier.add(Dense(units=128, activation='relu'))\n   > classifier.add(Dense(units=1, activation='sigmoid'))\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n\n * 编译模型\n   \n   > classifier.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])\n   > \n   > \n   > 1\n   > \n   > 1\n\n * 训练模型\n   \n   > classifier.fit(training_set, epochs=25, validation_data=test_set, validation_steps=2000)\n   > classifier.save('trained_model.h5')\n   > \n   > \n   > 1\n   > 2\n   > \n   > 1\n   > 2\n\n一旦我们训练完模型，模型就会使用 classifier.save 存储在 .h5 文件中。在下面的代码中，我们将使用这个 trained_model.h5 文件来识别猫和狗。\n\nimport numpy as np\nfrom keras.models import load_model\nimport keras.utils as image\n\ndef predict_image(imagepath, classifier):\n    predict = image.load_img(imagepath, target_size=(64, 64))\n    predict_modified = image.img_to_array(predict)\n    predict_modified = predict_modified / 255\n    predict_modified = np.expand_dims(predict_modified, axis=0)\n    result = classifier.predict(predict_modified)\n\n    if result[0][0] >= 0.5:\n        prediction = 'dog'\n        probability = result[0][0]\n        print(\"Probability = \" + str(probability))\n        print(\"Prediction = \" + prediction)\n    else:\n        prediction = 'cat'\n        probability = 1 - result[0][0]\n        print(\"Probability = \" + str(probability))\n        print(\"Prediction = \" + prediction)\n\n# 加载训练好的模型\nloaded_classifier = load_model('trained_model.h5')\n\n# 示例用法\ndog_image = \"dog.jpg\"\npredict_image(dog_image, loaded_classifier)\n\ncat_image = \"cat.jpg\"\npredict_image(cat_image, loaded_classifier)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n输出结果如下：\n\n\n\n这是完整的代码供读者学习参考。\n\n\n# 6 结论\n\n在即将到来的AI时代，GPU是一个不容忽视的东西，我们应该更加了解它的能力。随着我们从传统的串行算法过渡到日益流行的并行算法，GPU 成为加速复杂计算不可或缺的工具。 GPU 的并行处理能力在处理人工智能和机器学习任务固有的海量数据集和复杂的神经网络架构方面特别有优势。此外，GPU 的作用超出了传统的机器学习领域，在科学研究、模拟和数据密集型任务中找到了应用。事实证明，GPU 的并行处理能力有助于解决从药物发现、气候建模到金融模拟等各个领域的挑战。",normalizedContent:"翻译原文地址\n\n\n# 1 cpu知识为何不再足够\n\n在当今的人工智能时代，大多数开发者都是按照cpu的方式进行训练。这种认知也已经成为我们学术中的一部分，因此很自然地会以cpu为导向来思考和解决问题。\n\n然而，cpu 的问题在于它们依赖于串行架构。在当今世界中，我们依赖大量并行任务的情况下，cpu 无法很好地处理这些场景。\n\n因此，开发者面临着如下问题。\n\n * 执行并行任务\n   \n   > cpu 传统上是线性运行的，一次执行一条指令。这种限制源于这样一个事实：cpu 通常具有一些针对单线程性能进行优化的强大内核。当面临多个任务时，cpu会分配其资源来逐个处理每个任务，从而导致指令的顺序执行。在需要同时关注众多任务的情况下，这种方法变得低效。\n   > \n   > 尽管我们通过诸如多线程等技术来提高cpu性能，但cpu的基本设计理念是优先考虑顺序执行。\n\n * 高效运行ai模型\n   \n   > ai 模型采用 transformer 等先进架构，利用并行处理来增强性能。与顺序运行的旧递归神经网络 (rnn) 不同，gpt 等现代 transformer 可以同时处理多个单词，从而提高训练效率和能力。因为当我们并行训练时，会产生更大的模型，而更大的模型会产生更好的输出。\n   > \n   > 并行的概念已从自然语言处理扩展到图像识别等其他领域。例如，图像识别架构 alexnet 通过同时处理图像的不同部分，展示了并行处理的威力，从而实现准确的模式识别。\n   > \n   > 然而，cpu 的设计侧重于单线程性能，很难充分挖掘并行处理的潜力。它们难以有效分配和执行复杂ai模型所需的大量并行计算。\n\n\n# 2 gpu驱动开发如何解决这些问题\n\n * gpu 核心的大规模并行性\n   \n   > 与 cpu 中更大、更强大的内核相比，工程师设计的 gpu 具有更小、高度专业化的内核。该架构允许 gpu 同时执行多个并行任务。\n   > \n   > gpu 中的大量核心非常适合依赖于并行性的工作负载，例如图形渲染和复杂的数学计算。\n   > \n   > 如下图所示，5.3.2使用 gpu 并行性来减少复杂任务所需的时间。\n\n * ai 模型中使用的并行性\n   \n   > 人工智能模型，特别是基于 tensorflow 等深度学习框架构建的模型，表现出高度的并行性。神经网络训练涉及大量矩阵运算，而 gpu 凭借其庞大的核心数量，擅长并行化这些运算。 tensorflow 与其他流行的深度学习框架一起进行优化，以利用 gpu 的能力来加速模型训练和推理。\n   > \n   > 如下图所示，5.3.3使用 gpu 的强大功能来训练神经网络。\n\n\n# 3 gpu和cpu有什么区别\n\n * cpu\n   \n   * 串行架构\n     \n     > 中央处理单元 (cpu) 的设计重点是顺序处理。它们擅长线性执行一组指令。cpu 针对需要高单线程性能的任务进行了优化，例如：\n     > \n     >  * 通用计算\n     >  * 系统操作\n     >  * 处理涉及条件分支的复杂算法\n   \n   * 并行任务的核心数量有限\n     \n     > cpu 的核心数量较少，在消费级处理器中通常为 2-16 个核心。每个内核都能够独立处理自己的指令集。\n\n * gpu\n   \n   * 并行架构\n     \n     > 图形处理单元（gpu）采用并行架构设计，使其能够高效地执行并行处理任务。这有利于：\n     > \n     >  * 渲染图形\n     >  * 执行复杂的数学计算\n     >  * 运行可并行算法\n     > \n     > gpu 通过将多个任务分解为更小的并行子任务来同时处理多个任务。\n   \n   * 数千个内核用于并行任务\n     \n     > 与 cpu 不同，gpu 拥有更多的核心，通常有数千个。这些内核被组织成流式多处理器 (sm) 或类似的结构。丰富的内核使 gpu 能够同时处理大量数据，非常适合并行任务，例如图像和视频处理、深度学习和科学模拟。\n\n\n# 4 gpu类型\n\n * 通用 gpu\n   \n   > 通用 gpu 实例（p3 和 p4 实例）适用于广泛的工作负载，包括机器学习训练和推理、图像处理和视频编码。它们的平衡性能使它们成为各种计算任务的理想选择。\n\n * 推理优化的 gpu\n   \n   > 推理是运行已经训练好的 ai 模型并对实时数据进行预测或任务求解的过程。推理优化的 gpu 实例（p5 和 inf1 实例）在低延迟和成本效率至关重要的情况下表现出色，特别适用于机器学习推理任务。\n\n * 图形优化的 gpu\n   \n   > 图形优化的 gpu 实例（g4 实例）专门设计用于处理图形密集型任务，如视频游戏开发中的 3d 图形渲染。这些实例非常适合需要处理大量图形数据的应用程序。\n\n * 托管 gpu\n   \n   > amazon sagemaker 是一种托管服务，为机器学习提供了易于使用的 gpu 实例。它提供对多种 gpu 实例（包括 p3、p4 和 p5 实例）的访问，适用于想要轻松开始机器学习而无需管理底层基础设施的组织。\n\n\n# 5 使用 nvidia 的 cuda 进行 gpu 驱动开发\n\ncuda 是 nvidia 开发的并行计算平台和编程模型，使开发人员能够利用 gpu 加速器的强大功能来加速其应用程序。\n\n\n# 5.1 linux安装cuda\n\n 1. 下载cuda\n\n 2. 从上面的链接下载基本安装程序以及驱动程序安装程序\n\n 3. 转到主文件夹中的 .bashrc（如果使用其他shell则使用对应的配置文件）\n\n 4. 在配置文件中添加以下行：\n    \n    export path=\"/usr/local/cuda-12.3/bin:$path\"\n    export ld_library_path=\"/usr/local/cuda-12.3/lib64:$ld_library_path\"\n    \n    \n    1\n    2\n    \n    1\n    2\n    \n\n 5. 然后执行以下命令：\n    \n    sudo apt-get install cuda-toolkit\n    sudo apt-get install nvidia-gds\n    \n    \n    1\n    2\n    \n    1\n    2\n    \n\n\n# 5.2 基本命令\n\n * lspci | grep vga\n   \n   > 识别并列出系统中的 gpu。\n\n * nvidia-smi\n   \n   > “nvidia 系统管理界面”，它提供有关系统中 nvidia gpu 的详细信息，包括利用率、温度、内存使用情况等。\n\n * sudo lshw -c display\n   \n   > 提供有关系统中显示控制器（包括显卡）的详细信息。\n\n * inxi -g\n   \n   > 提供有关图形子系统的信息，包括有关 gpu 和显示器的详细信息。\n\n * sudo hwinfo --gfxcard\n   \n   > \n\n\n# 5.3 开始使用cuda框架\n\n当我们安装了 cuda 框架后，让我们开始执行展示其功能的操作。\n\n# 5.3.1 数组加法问题\n\n数组加法问题是演示 gpu 并行化的一个合适问题。考虑以下数组：\n\n * 数组 a=[1,2,3,4,5,6]a = [1,2,3,4,5,6]a=[1,2,3,4,5,6]\n\n * 数组 b=[7,8,9,10,11,12]b = [7,8,9,10,11,12]b=[7,8,9,10,11,12]\n\n * 我们需要存储每个元素的和并将其存储在数组ccc中。我们需要存储每个元素的和并将其存储在数组ccc中。\n\n * 就像 c=[1+7,2+8,3+9,4+10,5+11,6+12]=[8,10,12,14,16,18]c = [1+7,2+8,3+9,4+10,5+11,6+12] = [8,10,12,14,16,18]c=[1+7,2+8,3+9,4+10,5+11,6+12]=[8,10,12,14,16,18]\n\n * 如果cpu要执行这样的操作，它将执行如下代码所示的操作。\n   \n   #include <stdio.h>\n   int a[] = {1,2,3,4,5,6};\n   int b[] = {7,8,9,10,11,12};\n   int c[6];\n   \n   int main() {\n       int n = 6;  // number of elements\n   \n       for (int i = 0; i < n; i++) {\n           c[i] = a[i] + b[i];\n       }\n   \n       for (int i = 0; i < n; i++) {\n           printf(\"c[%d] = %d\", i, c[i]);\n       }\n   \n       return 0;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   \n\n这种方法是逐个遍历数组元素并依次执行加法。然而，当处理大量数字时，这种方法由于其顺序性质而变得缓慢。\n\n为了解决这个限制，gpu 通过并行化加法过程提供了一种解决方案。与依次执行运算的 cpu 不同，gpu 可以同时执行多项加法。例如，运算1+7、2+8、3+9、4+10、5+111+7、2+8、3+9、4+10、5+111+7、2+8、3+9、4+10、5+11和6+126+126+12可以借助gpu并行化同时执行。\n\n利用cuda，我们将使用内核文件 (.cu) 进行展示。实现并行加法的代码如下：\n\n__global__ void vectoradd(int* a, int* b, int* c) {\n    int i = threadidx.x;\n    c[i] = a[i] + b[i];\n    return;\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n * __global__ 说明符表明该函数是一个内核函数，将在 gpu 上调用。\n * vectoradd 采用三个整数指针（aaa、bbb 和 ccc）作为参数，表示要相加的向量。\n * threadidx.x 检索当前线程的索引（在一维网格中）。\n * 向量 aaa 和 bbb 的相应元素之和存储在向量 ccc 中。\n\n现在我们来看看主要功能。创建指针 cudaa 、 cudab 和 cudac 来指向 gpu 上的内存。\n\n// 利用 cuda 使用并行计算加法的函数\nint main() {\n    int a[] = {1,2,3};\n    int b[] = {4,5,6};\n    int c[sizeof(a) / sizeof(int)] = {0};\n    // 创建指向 gpu 的指针\n    int* cudaa = 0;\n    int* cudab = 0;\n    int* cudac = 0;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n使用 cudamalloc ，在 gpu 上为向量 cudaa、cudab 和 cudac 分配内存。\n\n// 在gpu中分配内存\ncudamalloc(&cudaa,sizeof(a));\ncudamalloc(&cudab,sizeof(b));\ncudamalloc(&cudac,sizeof(c));\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n内核函数 vectoradd 使用一个块和等于向量大小的多个线程启动。\n\n// 用一个程序块和与向量大小相等的线程数启动内核\nvectoradd <<<1, sizeof(a) / sizeof(a[0])>>> (cudaa, cudab, cudac);\n\n\n1\n2\n\n1\n2\n\n\n结果向量 cudac 从gpu复制回主机。\n\n// 将结果向量复制回主机\ncudamemcpy(c, cudac, sizeof(c), cudamemcpydevicetohost);\n\n\n1\n2\n\n1\n2\n\n\n然后我们可以照常打印结果\n\n    // 打印结果\n    for (int i = 0; i < sizeof(c) / sizeof(int); i++) {\n        printf(\"c[%d] = %d\", i, c[i]);\n    }\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n为了执行此代码，我们将使用 nvcc 命令。我们将得到输出为：\n\n\n\n这是完整的代码供读者参考。\n\n# 5.3.2 使用 gpu 在 python 中优化图像生成\n\n本节探讨使用 gpu 处理来优化性能密集型任务，例如图像生成。\n\nmandelbrot 集是一种数学构造，它根据规定方程中特定数字的行为形成复杂的视觉模式。生成一个这样的图案需要耗费大量资源。在下面的代码片段中，您可以观察到使用 cpu 处理生成 mandelbrot 集的传统方法，该方法速度很慢。\n\n# 导入必要的库\nfrom matplotlib import pyplot as plt\nimport numpy as np\nfrom pylab import imshow, show\nfrom timeit import default_timer as timer\n\n# 计算给定点 (x, y) 的 mandelbrot 集的函数\ndef mandel(x, y, max_iters):\n    c = complex(x, y)\n    z = 0.0j\n    # 迭代检查该点是否在 mandelbrot 集中\n    for i in range(max_iters):\n        z = z*z + c\n        if (z.real*z.real + z.imag*z.imag) >= 4:\n            return i\n    # 如果在最大迭代次数内，则将其视为集合的一部分\n    return max_iters\n\n# 在指定区域内创建 mandelbrot 分形的函数\ndef create_fractal(min_x, max_x, min_y, max_y, image, iters):\n    height = image.shape[0]\n    width = image.shape[1]\n\n    # 根据指定区域计算像素大小\n    pixel_size_x = (max_x - min_x) / width\n    pixel_size_y = (max_y - min_y) / height\n\n    # 在图像中迭代每个像素并计算mandelbrot值\n    for x in range(width):\n        real = min_x + x * pixel_size_x\n        for y in range(height):\n            imag = min_y + y * pixel_size_y\n            color = mandel(real, imag, iters)\n            image[y, x] = color\n\n# 为 mandelbrot 集创建一个空白图像数组\nimage = np.zeros((1024, 1536), dtype=np.uint8)\n\n# 记录性能测量的开始时间\nstart = timer()\n\n# 在指定的区域和迭代次数内生成mandelbrot集合\ncreate_fractal(-2.0, 1.0, -1.0, 1.0, image, 20)\n\n# 计算创建 mandelbrot 集所需的时间\ndt = timer() - start\n\n# 打印生成 mandelbrot 集所需的时间\nprint(\"mandelbrot created in %f s\" % dt)\n\n# 使用 matplotlib 显示 mandelbrot 集\nimshow(image)\nshow()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n上面的代码在 4.07 秒内生成输出。\n\n为了加快速度，我们可以使用 numba 库将代码与 gpu 并行化，具体操作如下：\n\n * 我们将从 numba 导入即时编译、用于 gpu 加速的 cuda 以及其他工具库\n   \n   import numpy as np\n   from numba import jit, cuda, uint32, f8, uint8\n   from pylab import imshow, show\n   from timeit import default_timer as timer\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n\n * @jit 装饰器指示 numba 执行即时编译，将 python 代码转换为机器代码以提高执行速度。\n   \n   @jit\n   def mandel(x, y, max_iters):\n       c = complex(x, y)\n       z = 0.0j\n       for i in range(max_iters):\n           z = z*z + c\n           if (z.real*z.real + z.imag*z.imag) >= 4:\n               return i\n   \n       return max_iters\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n\n * mandel_gpu 是使用 cuda.jit 创建的 mandel 函数的 gpu 兼容版本。这允许将 mandel 逻辑卸载到 gpu。这是通过使用 @cuda.jit 装饰器并指定函数参数的数据类型（f8 表示浮点数，``uint32表示无符号32位整数）来完成的。device=true` 参数指示该函数将在 gpu 上运行。\n   \n   mandel_gpu = cuda.jit((f8, f8, uint32), device=true)(mandel)\n   \n   \n   1\n   \n   1\n   \n\n * mandel_kernel 函数被定义为在 cuda gpu 上执行。它负责跨 gpu 线程并行生成 mandelbrot 集。\n   \n   @cuda.jit((f8, f8, f8, f8, uint8[:,:], uint32))\n   def mandel_kernel(min_x, max_x, min_y, max_y, image, iters):\n       height = image.shape[0]\n       width = image.shape[1]\n   \n       pixel_size_x = (max_x - min_x) / width\n       pixel_size_y = (max_y - min_y) / height\n   \n       startx, starty = cuda.grid(2)\n       gridx = cuda.griddim.x * cuda.blockdim.x\n       gridy = cuda.griddim.y * cuda.blockdim.y\n   \n       for x in range(startx, width, gridx):\n           real = min_x + x * pixel_size_x\n           for y in range(starty, height, gridy):\n               imag = min_y + y * pixel_size_y\n               image[y, x] = mandel_gpu(real, imag, iters)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   \n\n * 现在，我们可以在 create_fractal_gpu 函数中使用 gpu 加速的 mandelbrot 集生成。该函数分配 gpu 内存，启动 gpu 内核 (mandel_kernel)，并将结果复制回 cpu。\n   \n   def create_fractal_gpu(min_x, max_x, min_y, max_y, image, iters):\n       # step 1: 为图像分配gpu内存\n       d_image = cuda.to_device(image)\n   \n       # step 2: 定义gpu并行化的线程和块数\n       threadsperblock = (16, 16)\n       blockspergrid_x = int(np.ceil(image.shape[1] / threadsperblock[0]))\n       blockspergrid_y = int(np.ceil(image.shape[0] / threadsperblock[1]))\n       blockspergrid = (blockspergrid_x, blockspergrid_y)\n   \n       # step 3: 测量开始时间\n       start = timer()\n   \n       # step 4: 启动 gpu 内核（mandel_kernel）在 gpu 上计算 mandelbrot 集。\n       mandel_kernel[blockspergrid, threadsperblock](min_x, max_x, min_y, max_y, d_image, iters)\n   \n       # step 5: 等待 gpu 完成其工作（同步）\n       cuda.synchronize()\n   \n       # step 6: 测量gpu处理所需的时间\n       dt = timer() - start\n   \n       # step 7: 将结果从 gpu 内存复制回 cpu\n       d_image.copy_to_host(image)\n   \n       # step 8: 显示 mandelbrot 集图像\n       print(\"mandelbrot created on gpu in %f s\" % dt)\n       imshow(image)\n       show()\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   \n\n上面的代码在 0.0046 seconds 中执行。这比我们之前的基于 cpu 的代码要快得多。\n\n\n\n这是完整的代码供读者参考。\n\n# 5.3.3 使用 gpu 训练猫狗神经网络\n\n我们现在看到的热门话题之一是 gpu 如何在人工智能中使用，因此为了证明我们将创建一个神经网络来区分猫和狗。我们将使用以下代码训练和使用猫与狗模型，其中使用了卷积神经网络（cnn），您可以阅读有关它的更多详细信息。\n\n * 先决条件\n   \n   1. cuda\n   \n   2. tensorflow -> 可以通过 pip install tensorflow[and-cuda] 安装\n   \n   3. 我们将使用来自kaggle的猫和狗的数据集\n   \n   4. 下载完成后，解压，将训练文件夹中的猫和狗的图片整理到不同的子文件夹中，如下图所示。\n      \n      \n\n * 导入库\n   \n   >  * pandas 和 numpy 用于数据操作。\n   > \n   >  * sequential用于在神经网络中创建线性层堆栈。\n   > \n   >  * convolution2d、``maxpooling2d、dense和flatten` 是用于构建卷积神经网络 (cnn) 的层。\n   > \n   >  * imagedatagenerator用于在训练期间进行实时数据增强。\n   > \n   > import pandas as pd\n   > import numpy as np\n   > from keras.models import sequential\n   > from keras.layers import convolution2d, maxpooling2d, dense, flatten\n   > from keras.preprocessing.image import imagedatagenerator\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n\n * 初始化卷积神经网络\n   \n   > classifier = sequential()\n   > \n   > \n   > 1\n   > \n   > 1\n\n * 加载训练数据\n   \n   > train_datagen = imagedatagenerator(\n   >     rescale=1./255,\n   >     shear_range=0.2,\n   >     zoom_range=0.2,\n   >     horizontal_flip=true\n   > )\n   > test_datagen = imagedatagenerator(rescale=1./255)\n   > \n   > training_set = train_datagen.flow_from_directory(\n   >     './training_set',\n   >     target_size=(64, 64),\n   >     batch_size=32,\n   >     class_mode='binary'\n   > )\n   > \n   > test_set = test_datagen.flow_from_directory(\n   >     './test_set',\n   >     target_size=(64, 64),\n   >     batch_size=32,\n   >     class_mode='binary'\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n   > 16\n   > 17\n   > 18\n   > 19\n   > 20\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n   > 16\n   > 17\n   > 18\n   > 19\n   > 20\n\n * 构建 cnn 架构\n   \n   > classifier.add(convolution2d(32, 3, 3, input_shape=(64, 64, 3), activation='relu'))\n   > classifier.add(maxpooling2d(pool_size=(2, 2)))\n   > classifier.add(flatten())\n   > classifier.add(dense(units=128, activation='relu'))\n   > classifier.add(dense(units=1, activation='sigmoid'))\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n\n * 编译模型\n   \n   > classifier.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])\n   > \n   > \n   > 1\n   > \n   > 1\n\n * 训练模型\n   \n   > classifier.fit(training_set, epochs=25, validation_data=test_set, validation_steps=2000)\n   > classifier.save('trained_model.h5')\n   > \n   > \n   > 1\n   > 2\n   > \n   > 1\n   > 2\n\n一旦我们训练完模型，模型就会使用 classifier.save 存储在 .h5 文件中。在下面的代码中，我们将使用这个 trained_model.h5 文件来识别猫和狗。\n\nimport numpy as np\nfrom keras.models import load_model\nimport keras.utils as image\n\ndef predict_image(imagepath, classifier):\n    predict = image.load_img(imagepath, target_size=(64, 64))\n    predict_modified = image.img_to_array(predict)\n    predict_modified = predict_modified / 255\n    predict_modified = np.expand_dims(predict_modified, axis=0)\n    result = classifier.predict(predict_modified)\n\n    if result[0][0] >= 0.5:\n        prediction = 'dog'\n        probability = result[0][0]\n        print(\"probability = \" + str(probability))\n        print(\"prediction = \" + prediction)\n    else:\n        prediction = 'cat'\n        probability = 1 - result[0][0]\n        print(\"probability = \" + str(probability))\n        print(\"prediction = \" + prediction)\n\n# 加载训练好的模型\nloaded_classifier = load_model('trained_model.h5')\n\n# 示例用法\ndog_image = \"dog.jpg\"\npredict_image(dog_image, loaded_classifier)\n\ncat_image = \"cat.jpg\"\npredict_image(cat_image, loaded_classifier)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n输出结果如下：\n\n\n\n这是完整的代码供读者学习参考。\n\n\n# 6 结论\n\n在即将到来的ai时代，gpu是一个不容忽视的东西，我们应该更加了解它的能力。随着我们从传统的串行算法过渡到日益流行的并行算法，gpu 成为加速复杂计算不可或缺的工具。 gpu 的并行处理能力在处理人工智能和机器学习任务固有的海量数据集和复杂的神经网络架构方面特别有优势。此外，gpu 的作用超出了传统的机器学习领域，在科学研究、模拟和数据密集型任务中找到了应用。事实证明，gpu 的并行处理能力有助于解决从药物发现、气候建模到金融模拟等各个领域的挑战。",charsets:{cjk:!0},lastUpdated:"2024/03/20, 13:15:30",lastUpdatedTimestamp:171091173e4},{title:"雪韵初见·南京初雪",frontmatter:{title:"雪韵初见·南京初雪",author:{name:"Pursuit",link:"https://github.com/unique-pure"},date:"2023-12-19T09:28:46.000Z",permalink:"/pages/608406/",categories:["生活杂谈","随写编年","2023年"],tags:[null],readingShow:"top"},regularPath:"/04.%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/01.%E9%9A%8F%E5%86%99%E7%BC%96%E5%B9%B4/02.2023%E5%B9%B4/01.%E9%9B%AA%E9%9F%B5%E5%88%9D%E8%A7%81%C2%B7%E5%8D%97%E4%BA%AC%E5%88%9D%E9%9B%AA.html",relativePath:"04.生活杂谈/01.随写编年/02.2023年/01.雪韵初见·南京初雪.md",key:"v-59070e48",path:"/pages/608406/",headersStr:null,content:"2023年12月18日，南京下了一整天的雪，雪花纷纷，如诗如画。白茫茫的世界，仿佛是一片纯净的画布，被雪的柔美覆盖。而在南航校园里，这场雪更添了一份独特的美丽。南航的雪景如同童话般迷人，树木被白雪裹挟着，建筑物顶部披上了银装，仿佛置身于梦幻世界。学生们穿梭在雪花飞舞的空间，踏出一串串有趣的足迹，留下了一段段温暖的回忆。\n\n\n\n\n\n\n\n\n\n\n\n\n雪积的很厚，虽然相比北方可能还算是微薄的，但对于南京来说，已经是难得的雪景。\n我印象中江西是只下过一场大雪的，那时的记忆如同冰雪一样清晰。那场雪是我小学时的冬天，当时还是童真稚嫩的模样。和同学们一起在学校的草坪上嬉戏，打着雪仗，欢笑声在雪的映衬下更显灿烂。虽然我们玩得不亦乐乎，但那时候的我还没有尝试过堆雪人，有些许遗憾。 而今天，机会来了，和实验室的小伙伴们欢聚一堂，一同投身到雪雕的世界中，我们聚精会神地堆起雪人，大宝（左）和小雪（右）矗立在雪地中，虽然抽象却充满了趣味。\n\n雪人巍然而立，也成为了这场雪夜的参与者。堆完雪人后，我们迫不及待地展开了雪仗大战，雪花在夜空中飞舞，欢笑声在寒冷的空气中回荡。在这激烈而欢快的雪仗中，我们体验到了友情的温暖，仿佛回到了童年时光，充满着无尽的欢笑和快乐。\n\n有机会一定要去北方玩，尤其是在冬季，感受那儿更为宏伟壮丽的雪景，或许可以尝试一下滑雪\n\n南航其他艺术家雪人图片大赏：\n\n\n\n\n\n\n\n",normalizedContent:"2023年12月18日，南京下了一整天的雪，雪花纷纷，如诗如画。白茫茫的世界，仿佛是一片纯净的画布，被雪的柔美覆盖。而在南航校园里，这场雪更添了一份独特的美丽。南航的雪景如同童话般迷人，树木被白雪裹挟着，建筑物顶部披上了银装，仿佛置身于梦幻世界。学生们穿梭在雪花飞舞的空间，踏出一串串有趣的足迹，留下了一段段温暖的回忆。\n\n\n\n\n\n\n\n\n\n\n\n\n雪积的很厚，虽然相比北方可能还算是微薄的，但对于南京来说，已经是难得的雪景。\n我印象中江西是只下过一场大雪的，那时的记忆如同冰雪一样清晰。那场雪是我小学时的冬天，当时还是童真稚嫩的模样。和同学们一起在学校的草坪上嬉戏，打着雪仗，欢笑声在雪的映衬下更显灿烂。虽然我们玩得不亦乐乎，但那时候的我还没有尝试过堆雪人，有些许遗憾。 而今天，机会来了，和实验室的小伙伴们欢聚一堂，一同投身到雪雕的世界中，我们聚精会神地堆起雪人，大宝（左）和小雪（右）矗立在雪地中，虽然抽象却充满了趣味。\n\n雪人巍然而立，也成为了这场雪夜的参与者。堆完雪人后，我们迫不及待地展开了雪仗大战，雪花在夜空中飞舞，欢笑声在寒冷的空气中回荡。在这激烈而欢快的雪仗中，我们体验到了友情的温暖，仿佛回到了童年时光，充满着无尽的欢笑和快乐。\n\n有机会一定要去北方玩，尤其是在冬季，感受那儿更为宏伟壮丽的雪景，或许可以尝试一下滑雪\n\n南航其他艺术家雪人图片大赏：\n\n\n\n\n\n\n\n",charsets:{cjk:!0},lastUpdated:"2023/12/19, 10:23:42",lastUpdatedTimestamp:1702952622e3},{title:"镜像网站",frontmatter:{title:"镜像网站",author:{name:"Pursuit"},link:"https://github.com/unique-pure",date:"2024-03-20T13:12:27.000Z",permalink:"/pages/04404f/",categories:["资源收藏","实用网站"],tags:[null],readingShow:"top"},regularPath:"/05.%E8%B5%84%E6%BA%90%E6%94%B6%E8%97%8F/01.%E5%AE%9E%E7%94%A8%E7%BD%91%E7%AB%99/02.%E9%95%9C%E5%83%8F.html",relativePath:"05.资源收藏/01.实用网站/02.镜像.md",key:"v-72ab0e2f",path:"/pages/04404f/",headersStr:null,content:"清华大学Pypi镜像站 Docker镜像代理 Github镜像代理",normalizedContent:"清华大学pypi镜像站 docker镜像代理 github镜像代理",charsets:{cjk:!0},lastUpdated:"2024/03/27, 22:22:21",lastUpdatedTimestamp:1711549341e3},{title:"2023年年终总结",frontmatter:{title:"2023年年终总结",description:null,author:{name:"Pursuit",link:"https://github.com/unique-pure"},date:"2024-01-04T13:30:41.000Z",permalink:"/pages/a0354f/",categories:["生活杂谈","随写编年","年终总结"],tags:[null],readingShow:"top"},regularPath:"/04.%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/01.%E9%9A%8F%E5%86%99%E7%BC%96%E5%B9%B4/01.%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/01.%E6%88%91%E7%9A%842023.html",relativePath:"04.生活杂谈/01.随写编年/01.年终总结/01.我的2023.md",key:"v-3bd47188",path:"/pages/a0354f/",headersStr:null,content:"在2023年，我感觉自己好像没做太多有意义的事，一直处于一种无法进入状态的状态，留下了不少遗憾。例如上半年，我原本计划去实习，但总是担心学校这边有事情需要处理。另外，由于没有早早确定自己的职业方向，我对科研抱有一些幻想，曾经认为未来可能会从事学术工作，就想着不参加实习了。然而，实际上，我发现我的情况并不适合攻读博士学位。清楚了自己的定位，现在的目标就是好好学技术，顺利毕业，能够进入大厂就好。\n\n2023年，我旅游的次数也比较少，只去了两座城市。在我生日时，我和女朋友一同踏上了厦门的海滨之旅，海边的宁静治愈了我内心的疲惫，沿海城市的浪漫氛围让我陶醉其中。尤其是鼓浪屿，那里的清风让整个旅程充满了凉爽与宁静。12月份，我去杭州找了好兄弟ygm，西湖很美，正如苏轼笔下的“水光潋滟晴方好，山色空蒙雨亦奇。欲把西湖比西子，淡妆浓抹总相宜”。期待在2024年，能够继续走出去，领略更多大好河山。\n\n自入学以来，一直感觉自己并未真正领悟到太多新知识，2020年的那份热情也似乎渐行渐远。然而，唯一令我开心的事情是，我从九月份开始坚持健身，一直持续到现在，取得了很大的进步，身体强度大幅提升。目前，我在卧推上的表现也有了显著提升，已经能够推动60kg，期望在2024年，能够保持这份坚持，早日实现推动80kg的目标。\n\n这大致是我的2023年总结，希望在2024，能够进入状态，多出去走走，多锻炼身体，多看点电影，多学点东西。",normalizedContent:"在2023年，我感觉自己好像没做太多有意义的事，一直处于一种无法进入状态的状态，留下了不少遗憾。例如上半年，我原本计划去实习，但总是担心学校这边有事情需要处理。另外，由于没有早早确定自己的职业方向，我对科研抱有一些幻想，曾经认为未来可能会从事学术工作，就想着不参加实习了。然而，实际上，我发现我的情况并不适合攻读博士学位。清楚了自己的定位，现在的目标就是好好学技术，顺利毕业，能够进入大厂就好。\n\n2023年，我旅游的次数也比较少，只去了两座城市。在我生日时，我和女朋友一同踏上了厦门的海滨之旅，海边的宁静治愈了我内心的疲惫，沿海城市的浪漫氛围让我陶醉其中。尤其是鼓浪屿，那里的清风让整个旅程充满了凉爽与宁静。12月份，我去杭州找了好兄弟ygm，西湖很美，正如苏轼笔下的“水光潋滟晴方好，山色空蒙雨亦奇。欲把西湖比西子，淡妆浓抹总相宜”。期待在2024年，能够继续走出去，领略更多大好河山。\n\n自入学以来，一直感觉自己并未真正领悟到太多新知识，2020年的那份热情也似乎渐行渐远。然而，唯一令我开心的事情是，我从九月份开始坚持健身，一直持续到现在，取得了很大的进步，身体强度大幅提升。目前，我在卧推上的表现也有了显著提升，已经能够推动60kg，期望在2024年，能够保持这份坚持，早日实现推动80kg的目标。\n\n这大致是我的2023年总结，希望在2024，能够进入状态，多出去走走，多锻炼身体，多看点电影，多学点东西。",charsets:{cjk:!0},lastUpdated:"2024/03/12, 20:31:36",lastUpdatedTimestamp:1710246696e3},{title:"Mac工具",frontmatter:{title:"Mac工具",author:{name:"Pursuit"},link:"https://github.com/unique-pure",date:"2024-03-19T22:24:42.000Z",permalink:"/pages/e6b9d0/",categories:["资源收藏","实用网站"],tags:[null],readingShow:"top"},regularPath:"/05.%E8%B5%84%E6%BA%90%E6%94%B6%E8%97%8F/01.%E5%AE%9E%E7%94%A8%E7%BD%91%E7%AB%99/01.%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3.html",relativePath:"05.资源收藏/01.实用网站/01.系统相关.md",key:"v-08ac2779",path:"/pages/e6b9d0/",headers:[{level:2,title:"1 MacOS",slug:"_1-macos",normalizedTitle:"1 macos",charIndex:2},{level:2,title:"2 Linux",slug:"_2-linux",normalizedTitle:"2 linux",charIndex:60}],headersStr:"1 MacOS 2 Linux",content:"# 1 MacOS\n\n * Mac命令行命令\n   \n   > 这个网站收集各种有用的 Mac 命令行的命令。\n\n\n# 2 Linux",normalizedContent:"# 1 macos\n\n * mac命令行命令\n   \n   > 这个网站收集各种有用的 mac 命令行的命令。\n\n\n# 2 linux",charsets:{cjk:!0},lastUpdated:"2024/03/27, 22:22:21",lastUpdatedTimestamp:1711549341e3},{title:"遵循最佳实践，各种语言实现数据结构和算法的模版",frontmatter:{title:"遵循最佳实践，各种语言实现数据结构和算法的模版",tags:["算法"],author:{name:"Pursuit"},link:"https://github.com/unique-pure",date:"2023-12-14T16:52:26.000Z",categories:["资源收藏","优秀项目"],permalink:"/pages/0070df/",readingShow:"top"},regularPath:"/05.%E8%B5%84%E6%BA%90%E6%94%B6%E8%97%8F/02.%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE/01.%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%A8%A1%E7%89%88.html",relativePath:"05.资源收藏/02.优秀项目/01.算法实现模版.md",key:"v-6cf98a73",path:"/pages/0070df/",headersStr:null,content:"The Algorithms提供 GitHub 最大的开源算法库。 The Algorithms 官方网站 The Algorithms Github仓库\n\n以下是部分语言实现数据和算法的仓库，以供学习。\n\n 1. Go\n 2. Java\n 3. C++\n 4. C\n 5. Python\n 6. JavaScript",normalizedContent:"the algorithms提供 github 最大的开源算法库。 the algorithms 官方网站 the algorithms github仓库\n\n以下是部分语言实现数据和算法的仓库，以供学习。\n\n 1. go\n 2. java\n 3. c++\n 4. c\n 5. python\n 6. javascript",charsets:{cjk:!0},lastUpdated:"2023/12/15, 11:35:04",lastUpdatedTimestamp:1702611304e3},{title:"遵循最佳实践，各种语言实现设计模式的模版",frontmatter:{title:"遵循最佳实践，各种语言实现设计模式的模版",tags:["设计模式"],author:{name:"Pursuit"},link:"https://github.com/unique-pure",date:"2023-12-14T17:21:13.000Z",permalink:"/pages/7634df/",categories:["资源收藏","优秀项目"],readingShow:"top"},regularPath:"/05.%E8%B5%84%E6%BA%90%E6%94%B6%E8%97%8F/02.%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%A8%A1%E7%89%88.html",relativePath:"05.资源收藏/02.优秀项目/02.设计模式实现模版.md",key:"v-47fabeb6",path:"/pages/7634df/",headersStr:null,content:"23种设计模式分类如下：\n\n模式类型    描述                                             包括的模式\n创建型模式   这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new         工厂模式（Factory Pattern）\n        运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。      抽象工厂模式（Abstract Factory Pattern）\n                                                       单例模式（Singleton Pattern）\n                                                       建造者模式（Builder Pattern）\n                                                       原型模式（Prototype Pattern）\n结构型模式   这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。   适配器模式（Adapter Pattern）\n                                                       桥接模式（Bridge Pattern）\n                                                       过滤器模式（Filter、Criteria Pattern）\n                                                       组合模式（Composite Pattern）\n                                                       装饰器模式（Decorator Pattern）\n                                                       外观模式（Facade Pattern）\n                                                       享元模式（Flyweight Pattern）\n                                                       代理模式（Proxy Pattern）\n行为型模式   这些设计模式特别关注对象之间的通信，即对象之间的行为。                    责任链模式（Chain of Responsibility Pattern）\n                                                       命令模式（Command Pattern）\n                                                       解释器模式（Interpreter Pattern）\n                                                       迭代器模式（Iterator Pattern）\n                                                       中介者模式（Mediator Pattern）\n                                                       备忘录模式（Memento Pattern）\n                                                       观察者模式（Observer Pattern）\n                                                       状态模式（State Pattern）\n                                                       空对象模式（Null Object Pattern）\n                                                       策略模式（Strategy Pattern）\n                                                       模板模式（Template Pattern）\n                                                       访问者模式（Visitor Pattern）\n\n设计模式的六大原则是软件设计中的基石，它们为构建灵活、易于维护和升级的软件系统提供了指导。以下是对这六大原则的简要说明：\n\n 1. 开闭原则（Open Close Principle）：\n    \n    * 意义：对扩展开放，对修改关闭。即在需要进行拓展时，不修改原有代码，实现热插拔的效果。\n    * 实现方式：使用接口和抽象类，通过抽象化来保持程序的扩展性，易于维护和升级。\n\n 2. 里氏代换原则（Liskov Substitution Principle）：\n    \n    * 意义：任何基类可以出现的地方，子类一定可以出现。基类能够被派生类替换，且不影响软件单位的功能，实现真正的复用。\n    * 补充关系：是对开闭原则的补充，通过继承关系实现对抽象化的具体步骤规范。\n\n 3. 依赖倒转原则（Dependence Inversion Principle）：\n    \n    * 基础：是开闭原则的基础。具体内容为针对接口编程，依赖于抽象而不依赖于具体。\n\n 4. 接口隔离原则（Interface Segregation Principle）：\n    \n    * 意义：使用多个隔离的接口比使用单个接口更好，降低类之间的耦合度。\n    * 设计思想：从大型软件架构出发，强调降低依赖，降低耦合。\n\n 5. 迪米特法则，又称最少知道原则（Demeter Principle）：\n    \n    * 定义：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。\n\n 6. 合成复用原则（Composite Reuse Principle）：\n    \n    * 意义：尽量使用合成/聚合的方式，而不是使用继承。通过组合而非继承实现代码复用，增强系统的灵活性。\n\n这些原则提供了一种指导思想，帮助开发人员设计出具有弹性、可维护性和可扩展性的软件系统。通过遵循这些原则，可以有效应对软件变化，提高代码质量和可维护性。\n\n以下是部分语言实现设计模式的仓库，以供学习。\n\n 1. Go\n 2. Java\n 3. C++\n 4. Python\n 5. JavaScript",normalizedContent:"23种设计模式分类如下：\n\n模式类型    描述                                             包括的模式\n创建型模式   这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new         工厂模式（factory pattern）\n        运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。      抽象工厂模式（abstract factory pattern）\n                                                       单例模式（singleton pattern）\n                                                       建造者模式（builder pattern）\n                                                       原型模式（prototype pattern）\n结构型模式   这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。   适配器模式（adapter pattern）\n                                                       桥接模式（bridge pattern）\n                                                       过滤器模式（filter、criteria pattern）\n                                                       组合模式（composite pattern）\n                                                       装饰器模式（decorator pattern）\n                                                       外观模式（facade pattern）\n                                                       享元模式（flyweight pattern）\n                                                       代理模式（proxy pattern）\n行为型模式   这些设计模式特别关注对象之间的通信，即对象之间的行为。                    责任链模式（chain of responsibility pattern）\n                                                       命令模式（command pattern）\n                                                       解释器模式（interpreter pattern）\n                                                       迭代器模式（iterator pattern）\n                                                       中介者模式（mediator pattern）\n                                                       备忘录模式（memento pattern）\n                                                       观察者模式（observer pattern）\n                                                       状态模式（state pattern）\n                                                       空对象模式（null object pattern）\n                                                       策略模式（strategy pattern）\n                                                       模板模式（template pattern）\n                                                       访问者模式（visitor pattern）\n\n设计模式的六大原则是软件设计中的基石，它们为构建灵活、易于维护和升级的软件系统提供了指导。以下是对这六大原则的简要说明：\n\n 1. 开闭原则（open close principle）：\n    \n    * 意义：对扩展开放，对修改关闭。即在需要进行拓展时，不修改原有代码，实现热插拔的效果。\n    * 实现方式：使用接口和抽象类，通过抽象化来保持程序的扩展性，易于维护和升级。\n\n 2. 里氏代换原则（liskov substitution principle）：\n    \n    * 意义：任何基类可以出现的地方，子类一定可以出现。基类能够被派生类替换，且不影响软件单位的功能，实现真正的复用。\n    * 补充关系：是对开闭原则的补充，通过继承关系实现对抽象化的具体步骤规范。\n\n 3. 依赖倒转原则（dependence inversion principle）：\n    \n    * 基础：是开闭原则的基础。具体内容为针对接口编程，依赖于抽象而不依赖于具体。\n\n 4. 接口隔离原则（interface segregation principle）：\n    \n    * 意义：使用多个隔离的接口比使用单个接口更好，降低类之间的耦合度。\n    * 设计思想：从大型软件架构出发，强调降低依赖，降低耦合。\n\n 5. 迪米特法则，又称最少知道原则（demeter principle）：\n    \n    * 定义：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。\n\n 6. 合成复用原则（composite reuse principle）：\n    \n    * 意义：尽量使用合成/聚合的方式，而不是使用继承。通过组合而非继承实现代码复用，增强系统的灵活性。\n\n这些原则提供了一种指导思想，帮助开发人员设计出具有弹性、可维护性和可扩展性的软件系统。通过遵循这些原则，可以有效应对软件变化，提高代码质量和可维护性。\n\n以下是部分语言实现设计模式的仓库，以供学习。\n\n 1. go\n 2. java\n 3. c++\n 4. python\n 5. javascript",charsets:{cjk:!0},lastUpdated:"2023/12/14, 19:43:19",lastUpdatedTimestamp:1702554199e3},{title:"Go 语言优秀资源整理，为项目落地加速🏃",frontmatter:{title:"Go 语言优秀资源整理，为项目落地加速🏃",author:{name:"Pursuit"},link:"https://github.com/unique-pure",date:"2023-12-15T11:26:53.000Z",permalink:"/pages/9fd05a/",categories:["资源收藏","优秀项目"],tags:[null],readingShow:"top"},regularPath:"/05.%E8%B5%84%E6%BA%90%E6%94%B6%E8%97%8F/02.%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE/03.Go%E4%BC%98%E7%A7%80%E8%B5%84%E6%BA%90.html",relativePath:"05.资源收藏/02.优秀项目/03.Go优秀资源.md",key:"v-3a888ae4",path:"/pages/9fd05a/",headers:[{level:2,title:"指导原则",slug:"指导原则",normalizedTitle:"指导原则",charIndex:411},{level:2,title:"Awesome",slug:"awesome",normalizedTitle:"awesome",charIndex:637},{level:2,title:"大牛/组织",slug:"大牛-组织",normalizedTitle:"大牛/组织",charIndex:1038},{level:3,title:"大牛",slug:"大牛",normalizedTitle:"大牛",charIndex:1038},{level:3,title:"组织",slug:"组织",normalizedTitle:"组织",charIndex:1041},{level:2,title:"文档",slug:"文档",normalizedTitle:"文档",charIndex:1497},{level:2,title:"指南",slug:"指南",normalizedTitle:"指南",charIndex:1591},{level:2,title:"文章",slug:"文章",normalizedTitle:"文章",charIndex:3115},{level:2,title:"付费教程",slug:"付费教程",normalizedTitle:"付费教程",charIndex:3476},{level:2,title:"成品项目",slug:"成品项目",normalizedTitle:"成品项目",charIndex:3546},{level:3,title:"静态网站生成器",slug:"静态网站生成器",normalizedTitle:"静态网站生成器",charIndex:4184},{level:2,title:"学习项目",slug:"学习项目",normalizedTitle:"学习项目",charIndex:4265},{level:2,title:"开源类库",slug:"开源类库",normalizedTitle:"开源类库",charIndex:4446},{level:3,title:"Web 框架",slug:"web-框架",normalizedTitle:"web 框架",charIndex:4455},{level:3,title:"业务框架",slug:"业务框架",normalizedTitle:"业务框架",charIndex:5037},{level:3,title:"项目骨架",slug:"项目骨架",normalizedTitle:"项目骨架",charIndex:5438},{level:3,title:"DDD 框架",slug:"ddd-框架",normalizedTitle:"ddd 框架",charIndex:5701},{level:3,title:"TCP 框架",slug:"tcp-框架",normalizedTitle:"tcp 框架",charIndex:5868},{level:3,title:"中间件",slug:"中间件",normalizedTitle:"中间件",charIndex:5901},{level:3,title:"并发",slug:"并发",normalizedTitle:"并发",charIndex:2597},{level:3,title:"命令行",slug:"命令行",normalizedTitle:"命令行",charIndex:1485},{level:4,title:"参数解析",slug:"参数解析",normalizedTitle:"参数解析",charIndex:6100},{level:4,title:"输出展示",slug:"输出展示",normalizedTitle:"输出展示",charIndex:6285},{level:4,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:6943},{level:3,title:"终端工具",slug:"终端工具",normalizedTitle:"终端工具",charIndex:7229},{level:3,title:"路由",slug:"路由",normalizedTitle:"路由",charIndex:7637},{level:3,title:"网络",slug:"网络",normalizedTitle:"网络",charIndex:7880},{level:4,title:"LDAP",slug:"ldap",normalizedTitle:"ldap",charIndex:9469},{level:4,title:"网络代理",slug:"网络代理",normalizedTitle:"网络代理",charIndex:9537},{level:3,title:"HTTP压测",slug:"http压测",normalizedTitle:"http压测",charIndex:10006},{level:3,title:"HTTP",slug:"http",normalizedTitle:"http",charIndex:3612},{level:3,title:"WebSocket",slug:"websocket",normalizedTitle:"websocket",charIndex:10424},{level:3,title:"即时通信",slug:"即时通信",normalizedTitle:"即时通信",charIndex:10629},{level:3,title:"网关",slug:"网关",normalizedTitle:"网关",charIndex:10948},{level:3,title:"序列化",slug:"序列化",normalizedTitle:"序列化",charIndex:11061},{level:3,title:"解压缩",slug:"解压缩",normalizedTitle:"解压缩",charIndex:11405},{level:3,title:"RPC",slug:"rpc",normalizedTitle:"rpc",charIndex:8417},{level:3,title:"邮件",slug:"邮件",normalizedTitle:"邮件",charIndex:3854},{level:3,title:"消息队列",slug:"消息队列",normalizedTitle:"消息队列",charIndex:12202},{level:3,title:"文件/存储",slug:"文件-存储",normalizedTitle:"文件/存储",charIndex:12297},{level:3,title:"模板引擎",slug:"模板引擎",normalizedTitle:"模板引擎",charIndex:13030},{level:3,title:"代码生成",slug:"代码生成",normalizedTitle:"代码生成",charIndex:11287},{level:3,title:"文本处理",slug:"文本处理",normalizedTitle:"文本处理",charIndex:13298},{level:4,title:"Markdown",slug:"markdown",normalizedTitle:"markdown",charIndex:3893},{level:4,title:"HTML/CSS",slug:"html-css",normalizedTitle:"html/css",charIndex:13566},{level:4,title:"其他",slug:"其他-2",normalizedTitle:"其他",charIndex:6943},{level:3,title:"文档",slug:"文档-2",normalizedTitle:"文档",charIndex:1497},{level:3,title:"数学计算",slug:"数学计算",normalizedTitle:"数学计算",charIndex:15251},{level:3,title:"日期时间",slug:"日期时间",normalizedTitle:"日期时间",charIndex:15387},{level:3,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:8601},{level:3,title:"爬虫",slug:"爬虫",normalizedTitle:"爬虫",charIndex:9662},{level:3,title:"数据库",slug:"数据库",normalizedTitle:"数据库",charIndex:1921},{level:4,title:"SQL解析",slug:"sql解析",normalizedTitle:"sql解析",charIndex:16169},{level:4,title:"分布式事务",slug:"分布式事务",normalizedTitle:"分布式事务",charIndex:16312},{level:4,title:"数据库相关",slug:"数据库相关",normalizedTitle:"数据库相关",charIndex:16386},{level:4,title:"数据库客户端",slug:"数据库客户端",normalizedTitle:"数据库客户端",charIndex:17733},{level:4,title:"数据库引擎",slug:"数据库引擎",normalizedTitle:"数据库引擎",charIndex:18165},{level:3,title:"缓存",slug:"缓存",normalizedTitle:"缓存",charIndex:19169},{level:3,title:"搜索推荐",slug:"搜索推荐",normalizedTitle:"搜索推荐",charIndex:19478},{level:3,title:"表单",slug:"表单",normalizedTitle:"表单",charIndex:19883},{level:3,title:"Auth",slug:"auth",normalizedTitle:"auth",charIndex:9491},{level:3,title:"加密/解密",slug:"加密-解密",normalizedTitle:"加密/解密",charIndex:20183},{level:3,title:"视频",slug:"视频",normalizedTitle:"视频",charIndex:3149},{level:3,title:"图形处理",slug:"图形处理",normalizedTitle:"图形处理",charIndex:20705},{level:4,title:"图片识别",slug:"图片识别",normalizedTitle:"图片识别",charIndex:21400},{level:3,title:"图表",slug:"图表",normalizedTitle:"图表",charIndex:6505},{level:3,title:"构建编译",slug:"构建编译",normalizedTitle:"构建编译",charIndex:21634},{level:4,title:"静态资源内嵌",slug:"静态资源内嵌",normalizedTitle:"静态资源内嵌",charIndex:22078},{level:3,title:"优雅升级",slug:"优雅升级",normalizedTitle:"优雅升级",charIndex:22260},{level:3,title:"代码分析",slug:"代码分析",normalizedTitle:"代码分析",charIndex:22373},{level:3,title:"调试",slug:"调试",normalizedTitle:"调试",charIndex:23187},{level:3,title:"测试",slug:"测试",normalizedTitle:"测试",charIndex:2349},{level:3,title:"错误处理",slug:"错误处理",normalizedTitle:"错误处理",charIndex:7850},{level:3,title:"安全",slug:"安全",normalizedTitle:"安全",charIndex:3039},{level:3,title:"系统信息",slug:"系统信息",normalizedTitle:"系统信息",charIndex:25630},{level:3,title:"UUID",slug:"uuid",normalizedTitle:"uuid",charIndex:25827},{level:3,title:"日志",slug:"日志",normalizedTitle:"日志",charIndex:25477},{level:3,title:"监控告警",slug:"监控告警",normalizedTitle:"监控告警",charIndex:26370},{level:3,title:"统计分析",slug:"统计分析",normalizedTitle:"统计分析",charIndex:22618},{level:3,title:"容器技术",slug:"容器技术",normalizedTitle:"容器技术",charIndex:3700},{level:3,title:"集群管理",slug:"集群管理",normalizedTitle:"集群管理",charIndex:27259},{level:4,title:"Kubernetes",slug:"kubernetes",normalizedTitle:"kubernetes",charIndex:3689},{level:3,title:"机器学习",slug:"机器学习",normalizedTitle:"机器学习",charIndex:27522},{level:3,title:"人工智能",slug:"人工智能",normalizedTitle:"人工智能",charIndex:27790},{level:3,title:"算法",slug:"算法",normalizedTitle:"算法",charIndex:918},{level:3,title:"数据结构",slug:"数据结构",normalizedTitle:"数据结构",charIndex:948},{level:3,title:"依赖注入",slug:"依赖注入",normalizedTitle:"依赖注入",charIndex:28944},{level:3,title:"JSON",slug:"json",normalizedTitle:"json",charIndex:4951},{level:3,title:"依赖管理",slug:"依赖管理",normalizedTitle:"依赖管理",charIndex:29529},{level:3,title:"微服务",slug:"微服务",normalizedTitle:"微服务",charIndex:5826},{level:3,title:"Serverless",slug:"serverless",normalizedTitle:"serverless",charIndex:30168},{level:3,title:"devops",slug:"devops",normalizedTitle:"devops",charIndex:30570},{level:3,title:"持续集成/部署",slug:"持续集成-部署",normalizedTitle:"持续集成/部署",charIndex:30611},{level:3,title:"Git",slug:"git",normalizedTitle:"git",charIndex:99},{level:3,title:"限流器",slug:"限流器",normalizedTitle:"限流器",charIndex:31439},{level:3,title:"编译器",slug:"编译器",normalizedTitle:"编译器",charIndex:31681},{level:3,title:"解释器",slug:"解释器",normalizedTitle:"解释器",charIndex:19967},{level:4,title:"语言解释器",slug:"语言解释器",normalizedTitle:"语言解释器",charIndex:31868},{level:4,title:"PHP",slug:"php",normalizedTitle:"php",charIndex:7936},{level:4,title:"自定义解释器",slug:"自定义解释器",normalizedTitle:"自定义解释器",charIndex:32822},{level:3,title:"代码生成",slug:"代码生成-2",normalizedTitle:"代码生成",charIndex:11287},{level:3,title:"编辑器",slug:"编辑器",normalizedTitle:"编辑器",charIndex:33622},{level:3,title:"运行器",slug:"运行器",normalizedTitle:"运行器",charIndex:33676},{level:3,title:"查询语言",slug:"查询语言",normalizedTitle:"查询语言",charIndex:33775},{level:3,title:"游戏相关",slug:"游戏相关",normalizedTitle:"游戏相关",charIndex:33988},{level:3,title:"桌面开发",slug:"桌面开发",normalizedTitle:"桌面开发",charIndex:34101},{level:4,title:"GUI",slug:"gui",normalizedTitle:"gui",charIndex:34109},{level:4,title:"桌面辅助包",slug:"桌面辅助包",normalizedTitle:"桌面辅助包",charIndex:34953},{level:4,title:"桌面应用",slug:"桌面应用",normalizedTitle:"桌面应用",charIndex:34575},{level:3,title:"移动端",slug:"移动端",normalizedTitle:"移动端",charIndex:35121},{level:3,title:"协程/线程",slug:"协程-线程",normalizedTitle:"协程/线程",charIndex:35179},{level:3,title:"任务/定时器",slug:"任务-定时器",normalizedTitle:"任务/定时器",charIndex:35400},{level:3,title:"流处理",slug:"流处理",normalizedTitle:"流处理",charIndex:30560},{level:3,title:"微信",slug:"微信",normalizedTitle:"微信",charIndex:4040},{level:3,title:"SDK",slug:"sdk",normalizedTitle:"sdk",charIndex:5403},{level:3,title:"区块链",slug:"区块链",normalizedTitle:"区块链",charIndex:36087},{level:3,title:"开发辅助包",slug:"开发辅助包",normalizedTitle:"开发辅助包",charIndex:36208},{level:3,title:"代码生成",slug:"代码生成-3",normalizedTitle:"代码生成",charIndex:11287},{level:3,title:"系统开发",slug:"系统开发",normalizedTitle:"系统开发",charIndex:37306},{level:3,title:"未归类",slug:"未归类",normalizedTitle:"未归类",charIndex:37527},{level:2,title:"logo",slug:"logo",normalizedTitle:"logo",charIndex:30355},{level:2,title:"工具",slug:"工具",normalizedTitle:"工具",charIndex:537},{level:2,title:"资源站点",slug:"资源站点",normalizedTitle:"资源站点",charIndex:38787}],headersStr:"指导原则 Awesome 大牛/组织 大牛 组织 文档 指南 文章 付费教程 成品项目 静态网站生成器 学习项目 开源类库 Web 框架 业务框架 项目骨架 DDD 框架 TCP 框架 中间件 并发 命令行 参数解析 输出展示 其他 终端工具 路由 网络 LDAP 网络代理 HTTP压测 HTTP WebSocket 即时通信 网关 序列化 解压缩 RPC 邮件 消息队列 文件/存储 模板引擎 代码生成 文本处理 Markdown HTML/CSS 其他 文档 数学计算 日期时间 配置 爬虫 数据库 SQL解析 分布式事务 数据库相关 数据库客户端 数据库引擎 缓存 搜索推荐 表单 Auth 加密/解密 视频 图形处理 图片识别 图表 构建编译 静态资源内嵌 优雅升级 代码分析 调试 测试 错误处理 安全 系统信息 UUID 日志 监控告警 统计分析 容器技术 集群管理 Kubernetes 机器学习 人工智能 算法 数据结构 依赖注入 JSON 依赖管理 微服务 Serverless devops 持续集成/部署 Git 限流器 编译器 解释器 语言解释器 PHP 自定义解释器 代码生成 编辑器 运行器 查询语言 游戏相关 桌面开发 GUI 桌面辅助包 桌面应用 移动端 协程/线程 任务/定时器 流处理 微信 SDK 区块链 开发辅助包 代码生成 系统开发 未归类 logo 工具 资源站点",content:'> Go 语言优秀资源整理，为项目落地加速🏃\n> \n> 转载分享，出处如下，谢谢 😆\n> \n> 原文地址: https://shockerli.net/post/go-awesome\n> \n> GitHub: https://github.com/shockerli/go-awesome\n\n----------------------------------------\n\n> 官网: https://golang.org\n> \n> 国内官网镜像(访问快): https://golang.google.cn\n> \n> GitHub: https://github.com/golang/go\n> \n> 开发者平台: https://go.dev\n> \n> Wiki: https://github.com/golang/go/wiki\n> \n> 官方博客: https://blog.golang.org\n\n\n# 指导原则\n\n * 简单性\n   \n   > 复杂性把可读的程序变得不可读，复杂性终结了很多软件项目。\n\n * 可读性\n   \n   > 代码是给人看的，代码阅读时长远超编写。程序必须可维护，那可读是第一步。\n\n * 生产率\n   \n   > 拥有众多的工具集和基础库，可以很简单方便的完成绝大多数工作。 编译速度足够快，拥有动态语言的高效，但却不会面临动态语言不可靠的问题。 自带编程规范，使得团队代码一致，也帮助开发者发现和避免潜在的错误。\n\n\n# Awesome\n\n * GitHub Topic for Go\n * Awesome Go\n * golang-open-source-projects - 含描述的中文版 Awesome Go\n * Awesome Go Storage - Go 存储相关开源项目\n * awesome-go-China - 专门收集华人写的开源项目\n * Go Patterns - Go 版本的设计模式\n * sevenelevenlee/go-patterns - 设计模式\n * GoF 设计模式\n * greyireland/algorithm-pattern - 算法模板\n * go-algorithms - Go 版本的数据结构和算法\n * Go 学习之路 - Go 学习资料汇集\n * Go 开发者路线图\n * ReposHub-Go\n * VisuAlgo - 数据结构和算法动态可视化\n\n\n# 大牛/组织\n\n> Go 语言方面的大牛，或者优秀 Go 项目的组织\n\n\n# 大牛\n\n * mattn - 写了数百个 Go 项目，盛产优质项目\n * Unknwon - gogs/macaron 等项目作者，《The Way to Go》译者\n * Jinzhu - gorm/QOR 等作者\n * valyala - fasthttp/fastjson 等作者\n * vmihailenco - go-redis/go-pg 等作者\n * kataras - iris 作者\n * bep\n * spf13\n * tidwall\n\n\n# 组织\n\n * Gorilla web toolkit\n * loov\n * HashiCorp\n * lestrrat-go\n * Uber - Open Source Software at Uber\n * Stretchr - Tame your unstructured data\n * Containous\n * Charm - 提供一系列优秀的命令行工具和库\n\n\n# 文档\n\n * Proposing Changes to Go - Go 语言设计文档\n * Go 语言设计与实现\n * Go 语言原本\n * Go 101 （中文版）\n * Go 官方入门指南\n * Go 语言高级编程\n * Go 专家编程\n * Go 编程语言\n * Golang 标准库文档(官方/中文)\n * Go 语言标准库 在线阅读\n * 《The Way to Go》中文版\n * Go 语言圣经（中文版）\n * Go语言入门教程\n * Go 实战开发\n * Go Web 应用开发\n * Go 学习技能树\n * 实效 Go 编程\n * Go 语言语法详解笔记\n * Go 语言学习资料与社区索引\n * Go database/sql tutorial\n * GO 命令教程\n * 深入解析 Go\n * Go 语言博客实践\n * 学习 Go 语言\n * Go2编程指南\n * Go database/sql tutorial - Go 数据库(database/sql)开发使用教程\n * Go Web Examples - Go Web 开发示例\n * Go Assembly - 通过示例介绍 Go 汇编功能\n * Ultimate Go - 终极 Go 学习指南，包含大量文档化的代码和程序分析\n * Go 教程 - 腾讯云开发者手册\n * Golang 开发笔记\n * golang-notes - Go 源码阅读笔记\n * The Little Go Book （中文版）\n * Learning Go — from zero to hero\n * go-internals - 深入理解 Go\n * Learn Go with Tests\n * Go基础教程\n * 7天用Go从零实现系列\n * Go 语言高性能编程\n * Golang - 100天从新手到大师 - 某培训机构的部分教程内容\n * hoanhan101/algo - 107+ 编码面试问题，包括详细的解决方案，测试用例和程序分析\n * over-golang - Go 学习笔记\n * over-algorithm - Go 算法笔记\n * learngo - 1000+ Go 示例、练习和测试\n * go-leetcode - LeetCode 实现\n * 玩转 GO - 《Mastering GO》中文译本\n * leetcode-cookbook - LeetCode in Go\n * Golang修养之路\n * Go语法树入门\n * Go Concurrency Patterns - Go 并发模式场景集合\n * yezihack/algo - 数据结构与算法\n * golang-cheat-sheet-cn - GitHub上最流行的Golang代码速查表中文翻译版本\n\n\n# 指南\n\n * Uber Go Style Guide\n * The Go Programming Language Specification （中文老版）\n * 实效 Go 编程\n * Go Code Review Comments\n * Go Code Convention\n * Go FAQ 101\n * Go Details 101\n * Go Tips 101\n * Go Quizzes 101\n * go-advices\n * go-perfbook - 编写和优化Go代码\n * Practical Go: Real world advice for writing maintainable Go programs （Go 语言实践：编写可维护的程序的建议）\n * Go 安全指南 - 腾讯发布的《代码安全指南》Go 语言篇\n * Go Concurrency Guide\n * Go Recipes - 一些技巧\n\n\n# 文章\n\n * Go Training - 大量优质 Go 相关文章、视频等资料\n * Go语言爱好者周刊\n * Go 夜读 - Go 标准包、开源项目源代码阅读讲解\n * Go-Questions - Go 语言学习入门和进阶知识\n * Go的50度灰：Golang新开发者要注意的陷阱和常见错误\n * Go 程序的性能优化及 pprof 的使用\n * gops - Go语言程序查看和诊断工具\n * Go源码分析——http.ListenAndServe()是如何工作的\n * GoConvey 框架使用指南\n * GoStub 框架使用指南\n * GoMock 框架使用指南\n * Monkey 框架使用指南\n * The Evolution of a Go Programmer - Go 程序员的进化之路\n\n\n# 付费教程\n\n * 基于 Go 语言构建企业级的 RESTful API 服务 - 掘金小册\n * Go语言核心36讲 - 极客时间\n\n\n# 成品项目\n\n * Shiori - 书签管理\n * studygolang - Go 语言中文网\n * mkcert - 生成本地 HTTPS 加密证书的工具\n * cfssl - Cloudflare 开源的 PKI 和 TLS 工具集\n * Rainbond - 基于Docker、Kubernetes等容器技术的开源PaaS\n * NYADB2 - Go 实现的关系型数据库, 值得用于学习\n * EiBlog - 博客\n * pan-light - 不限速的百度网盘客户端, 基于 Go + Qt5 开发\n * BaiduPCS-Go - 百度网盘客户端（命令行）\n * daily-warm - 每天定时发邮件给你关心的人\n * pipe - 博客平台\n * mdr - 命令行下的 Markdown 阅读工具\n * miniflux - Feed 阅读器\n * golinks - 创建自定义书签、命令、搜索等\n * 链滴笔记 - 桌面端笔记应用\n * wayback - 网页快照备份\n * bbs-go - 开源社区\n * OpenSCRM - 基于Go和React的企业微信私域流量管理系统\n * Answer - 问答社区\n * listmonk - 资讯、邮件列表管理工具（Web）\n * 1Panel - Linux 服务器运维管理面板\n * Artalk - 自托管评论系统\n * memos - 笔记服务，具有移动客户端、浏览器扩展等生态\n\n\n# 静态网站生成器\n\n * Hugo\n * jrnl\n * plenti\n * verless\n * ink\n * moul - 生成照片站点\n * zas\n\n\n# 学习项目\n\n * 1m-go-websockets - 该项目演示了如何用 Go 编写一个可以提供超过一百万个 websockets 连接、运行内存小于 1GB 的服务器\n * Go by Example - 通过实例学习 Go\n * IAM - 身份识别与访问管理系统（教学项目）\n * 100-go-mistakes - 100 个 Go 常见错误\n\n\n# 开源类库\n\n\n# Web 框架\n\n * Macaron - 一款具有高生产力和模块化设计的 Go Web 框架 国产\n * Beego - 一个使用 Go 的思维来帮助您构建并开发 Go 应用程序的开源框架 国产\n * Gin - 轻量 Web 框架\n * Iris - Web 开发框架\n * Revel\n * echo\n * Faygo - 国产\n * Teleport - Socket 框架\n * GoFrame - 国产\n * QOR - 系列应用开发组件包\n * DotWeb - 国产\n * REST Layer - REST API framework\n * Honeytrap\n * Ponzu\n * utron\n * muxie\n * Buffalo - 快速生成 Web 项目的开发工具\n * go-web-framework-benchmark\n * fiber - 一种 Express 风格的、基于 fasthttp 的 HTTP Web 框架\n * aah\n * go-zero - 好未来开源的 Web 框架\n * pingcap/fn - 支持绑定任何方法，构建成 POST+JSON 接口\n * flamego - unknwon 开发的又一款 Web 框架\n * REST Layer - REST API 框架\n * rk-boot\n\n\n# 业务框架\n\n * YAO - 使用 JSON 即可创建数据库模型、编写 API 接口、描述管理后台界面的应用引擎\n * GoAdminGroup/go-admin - 后台管理快速开发框架，与 laravel-admin 类似\n * wenjianzhang/go-admin - 基于 Gin + Vue 实现的后台框架\n * gin-vue-admin - 基于 Gin + Vue 实现的后台框架\n * goxygen - 基于 Go, React, MongoDB 技术实现的全栈应用生成器\n * nging - Go语言通用后台管理框架\n * snake - 业务API框架\n * PocketBase - 带有后台管理面板、文件和权限管理、集成 SQLite 数据库的单一文件后端服务开发框架，支持 Dart 和 JS SDK 快速开发 APP\n * DoTenX - 低代码框架\n\n\n# 项目骨架\n\n * Standard Go Project Layout - Go 项目目录结构示例\n * go-starter - Adobe 的 Go 工程模板\n * go-clean-arch\n * go-rest-api - Go RESTful API Starter Kit\n * Create Go App CLI - 通过命令行创建前后端项目的开发骨架\n * clean-gin - 基于 Gin 构建的整洁架构项目骨架\n * golang-repo-template - 一个包含了很多实践的项目模板\n\n\n# DDD 框架\n\n * Wild Workouts - DDD、整洁架构、CQRS的示例项目\n * Clean Architecture in Go - 整洁架构示例\n * freedom - 基于六边形架构的框架\n * esim - 基于六边形架构的微服务框架\n * go-cleanarch - Go 整洁架构规则校验工具\n\n\n# TCP 框架\n\n * zinx - TCP并发服务器框架\n\n\n# 中间件\n\n * Negroni - Web 中间件\n * csrf - CSRF 中间件\n * handlers - A collection of useful handlers for Go\'s net/http package\n\n\n# 并发\n\n * SizedWaitGroup - 并发控制\n * concurrent - concurrency utilities\n\n\n# 命令行\n\n# 参数解析\n\n * urfave/cli - 命令行程序构建工具\n * Cobra - 命令行构建包\n * flaggy - 命令参数解析\n * pflag - 命令行参数处理\n * kong - 命令行解析\n * clop - 命令行解析包\n * go-flags - 命令行参数解析\n * mow.cli\n * go-arg - 基于结构体Tag解析命令行参数\n\n# 输出展示\n\n * progressbar - 在终端上输出进度条\n * cheggaaa/pb - 终端进度条\n * mpb - 支持多个进度条\n * Color - 命令行文字颜色\n * gookit/color - 命令行色彩使用库\n * termui - 终端仪表盘\n * tui - 终端 UI\n * termenv - 终端应用程序的高级 ANSI 样式和颜色支持\n * asciigraph - 在终端中绘制 ASCII 字符的图表\n * spinner - 涵盖70多种符号或进度条的控制器\n * tablewriter - 终端中输出表格内容\n * PIXterm - 在命令行终端中绘图\n * WTF - 一个命令行的信息仪表盘，可以定制显示内容\n * termdash - 基于 Go Terminal 的仪表板系统\n * bubbles - TUI 组件\n * bubbletea - TUI 框架\n * PTerm - 支持图表、表格、进度条、树等终端输出展示\n * Lip Gloss - 终端布局、样式\n * gum\n * glow - 终端渲染展示 Markdown\n * Slides - 终端渲染展示 Markdown\n * tview - Terminal UI\n * ASCIIPlayer - 在终端中通过 ASCII 输出图片或视频，支持 png、jpeg、gif、mp4、avi 等格式\n * go-pretty - 终端渲染表格、列表、进度条等\n * tcell\n\n# 其他\n\n * gosu - 以指定的用户权限来运行脚本\n * gotop - 类 top 系统监控显示\n * go-colorable - Colorable writer for Windows\n * go-isatty - TTY 环境判断\n * fzf - 终端模糊查询神器，支持多平台\n * go-daemon - daemon 进程包\n * go-prompt - 命令行交互式输入\n * peco - 交互式过滤工具\n * pty - PTY for Go\n * vtclean - 从终端输出字符串中解析出纯文本\n * Survey - 交互式输入\n\n\n# 终端工具\n\n * vgrep - 支持滚动分页的 grep\n * GoTTY - 基于Web的命令行实时共享\n * Jump - 根据习惯快速跳转目录\n * GoFish - 一个受 Homebrew 启发的跨平台软件管理工具，支持 Linux 和 Windows\n * viddy - 增强版 watch 命令\n * miller - 一个类似 sed、awk、cut、join 和 sort 的工具，用来处理基于命名索引的数据\n * assh - SSH 增强工具\n * duf - 比 df 更好用的磁盘使用率工具\n * ov - 终端文本阅读器，可替代 less、more、tail -f 等\n * trdsql - 可对 CSV/LTSV/JSON/TBLN 等文件执行 SQL 查询和导出\n * vhs - 终端录像工具，提供了在终端中录制和回放终端会话的功能，类似于将终端会话记录为视频的方式\n\n\n# 路由\n\n * HttpRouter\n * mux - URL 路由和调度器\n * chi\n * gocraft/web\n * go-querystring - 转换结构体为URL请求参数\n * gorilla/schema - converts structs to and from form values\n * CleverGo\n * rewrite - rewrite 中间件\n * BunRouter - 支持中间件、错误处理、路由优先级、兼容 net/http 接口\n\n\n# 网络\n\n * DNS - DNS 库\n * CoreDNS - DNS 服务器\n * RoadRunner - PHP 应用服务器、进程管理器、负载均衡，用于替代 Nginx + FPM\n * FrankenPHP - PHP 应用服务器\n * GoReplay - 流量收集&回放\n * Sharingan - 滴滴开源的流量录制回放工具\n * Glorp - HTTP 拦截&重放的 CLI 工具\n * p2pspider - 种子嗅探器\n * torrent - BitTorrent 相关工具库\n * rain - BitTorrent 客户端和库\n * httpteleport - Teleports 10Gbps http traffic over 1Gbps networks\n * FIND3 - WiFi 设备发现\n * SubFinder - 子域名发现工具\n * ggz - 短网址服务\n * httpstat\n * grab - 文件下载\n * go-getter - 可使用 URL 作为输入的主要形式从各种来源下载文件或目录\n * go-netty - 网络框架\n * gnet - 事件驱动 Go 网络框架\n * netpoll - 专注于 RPC 场景的 Non-blocking I/O 网络库\n * httplab - The interactive web server\n * yamux - Multiplexer\n * sftp - SFTP support for the go.crypto/ssh package\n * goftp - FTP 客户端\n * SFTPGo - 功能齐全且可高度配置的SFTP服务器，可选择支持HTTP/S、FTP/S和WebDAV。支持的存储后端包括：本地文件系统、加密的本地文件系统、S3（兼容）对象存储、Google Cloud Storage、Azure Blob Storage以及其他SFTP服务器。\n * evio - 事件驱动网络框架（reactor 模式）\n * gaio - 事件驱动网络框架（proactor 模式）\n * httpretty - 在终端上漂亮地打印出 HTTP 请求\n * blocky - 作为局域网 DNS 代理拦截广告\n * lossy - 模拟 net.PacketConn 和 net.Conn 接口的带宽，延迟和数据包丢失\n * go-libp2p - P2P\n * go-ipfs-api - IPFS\n * gomobile-ipfs - 为移动终端提供IPFS网络访问支持\n * go-multiaddr - multiaddr\n * kcp-go - 可靠的 UDP 通讯包\n * gliderlabs/ssh - 像 net/http 一样轻松搭建 SSH 服务器\n * netaddr - 网络地址处理\n * sx - 网络扫描命令工具\n * echoip - IP 地址查找服务\n * EasyTCP - TCP Server 框架\n * GoPacket - 网络捕获抓包\n * croc - 两台电脑之间传输文件\n * cmux - 监听同一个端口，启动多种协议服务\n * GeoIP2 Reader for Go - 解析&读取 MaxMind GeoLite2 和 GeoIP2 数据库\n * dns.toys - DNS 服务器\n * Apache Traffic Control - CDN 流量控制\n * NextTrace - 可视化路由追踪工具\n * pget - 文件下载工具，可多连接下载\n * CloudflareSpeedTest - 测试 Cloudflare CDN 延迟和速度，获取最快 IP\n\n# LDAP\n\n * go-ldap\n * GLAuth - LDAP Server\n * gldap - LDAP Service\n\n# 网络代理\n\n * Caddy - 类似 Nginx 的 Web 服务器\n * Traefik - 反向代理&负载均衡\n * snail007/goproxy - golang 实现的高性能代理服务器\n * ProxyPool - 采集免费的代理资源为爬虫提供有效的IP代理\n * frp - 可用于内网穿透的高性能的反向代理应用\n * nps - 一款轻量级、高性能、功能强大的内网穿透代理服务器\n * Pomerium - 基于身份的反向代理\n * V2Ray\n * V2Fly - V2Ray 的社区版本\n * Tailscale - WireGuard 解决方案\n * Clash - 支持多种协议的多平台代理客户端\n * elazarl/goproxy - HTTP 代理\n * oxy - Go middlewares for HTTP servers & proxies\n * ouqiang/goproxy - Go HTTP(S)代理库, 支持中间人代理解密HTTPS\n * pgrok - 提供给穷人的内网穿透\n\n\n# HTTP压测\n\n * Vegeta - HTTP 负载压测工具\n * hey - Web 压测工具\n * bombardier - Web 压测工具\n * go-wrk\n * plow\n * Ddosify\n\n\n# HTTP\n\n * fasthttp - 比 net/http 快 10 倍的 HTTP 工具包\n * Resty - HTTP & REST 客户端包\n * gout - HTTP 客户端\n * gentleman - HTTP 客户端\n * goz\n * UserAgent - 解析 HTTP User Agent\n * purell - URL 规范工具包\n * go-autorest - HTTP 管道请求方式的客户端\n * Req - HTTP 客户端\n * cors - CORS Handler\n * CertMagic - 为任意 Go 程序自动加上 HTTPS，TLS 证书签发、更新全自动\n\n\n# WebSocket\n\n * gorilla/websocket\n * nhooyr/websocket - 官方推荐的包\n * websocketd - Go 开发的一键搭建 WebSocket 服务器命令行工具\n * ws - WebSocket 开发包\n * melody - WebSocket 服务框架\n * neffos - 一个快速且可扩展的 WebSocket 框架\n * fastws\n\n\n# 即时通信\n\n * Centrifugo - 实时消息服务器，可以与任何语言编写的应用程序后端结合使用\n * goim - 支持集群的 im 及实时推送服务\n * Tinode - 即时消息服务器，通过 websocket/JSON 或 gRPC/TCP 等协议传输\n * WebRTC - WebRTC 实现\n * Berty - 安全的点对点通讯软件\n * Keybase - 即时通讯工具 Keybase 全平台客户端\n * gotify - 基于 WebSocket 的 PUSH 通知服务\n * nakama - 用于社交/实时游戏/实时应用的分布式服务端程序，自带面板、用户、聊天、存储、社交等功能\n * OpenIM\n\n\n# 网关\n\n * GoKu API Gateway CE - eoLinker 开源的 API 网关\n * Easegress\n * Manba\n * Tpk\n * BFE - 基于百度统一接入前端开源的七层流量接入系统\n\n\n# 序列化\n\n * vmihailenco/msgpack - 支持 msgpack\n * go/codec - 支持 msgpack/binc/cbor/json\n * golang/protobuf - Go 版本的 Protocol Buffers\n * gogo/protobuf - golang/protobuf 的扩展替代品\n * Objx - 操作 map, slice, JSON 等数据的包\n * msgp - MessagePack 代码生成器\n * Buf - protoc 替代品\n * protoc-gen-doc - Google Protocol Buffers 文档生成插件，支持 HTML、JSON、DocBook、Markdown 和自定义模板\n\n\n# 解压缩\n\n * snappy - Go 语言版本的 Snappy\n * cae - 实现 ZIP/TAR.GZ 解压缩\n * archiver - 多格式支持的解压缩包\n * compress - Optimized compression packages\n * Brotli\n * xz - xz 压缩格式读写包\n\n\n# RPC\n\n * gRPC-Go - gRPC 官方包\n * Go gRPC Middleware - gRPC 常用中间件\n * gorpc\n * gorilla/rpc - 构建基于 HTTP 的 RPC 服务，比如 JSON-RPC\n * Lile - gRPC 服务构建包\n * rpcx\n * Twirp - 基于 Protobuf 的 RPC 框架，与 gRPC 类似\n * dubbo-go - Dubbo Go 版本\n * Kitex\n * gRPCurl - 像 cURL 一样通过命令行访问 gRPC 服务\n * protoc-gen-doc - 文档生成插件\n * gRPC-Gateway - 读取 gRPC 服务定义并生成一个反向代理服务器，同时提供 gRPC 和 RESTful 风格的 API\n\n\n# 邮件\n\n * gomail - 邮件发送包\n * scorredoira/email\n * Hermes - Go 版本的 mailgen 引擎，根据配置生成 HTML 格式的邮件\n * Go-Guerrilla - SMTP 邮件服务器\n * MailHog - 基于Web和API的SMTP测试工具\n * Maddy - 邮件服务器\n * jordan-wright/email\n * Mox - 邮件服务器\n * Pop - 邮件发送工具，支持交互式和参数式\n * email-verifier - 邮箱校验，无需发送邮件\n\n\n# 消息队列\n\n * NSQ - 实时分布式消息平台\n * NATS - 云原生消息中间件\n * amqp - AMQP 0.9.1 客户端\n * sarama - Kafka 客户端\n\n\n# 文件/存储\n\n * MinIO - 对象存储服务器\n * rclone - 不同云存储之间同步文件\n * Syncthing - 文件同步\n * fsnotify - 文件系统监控工具\n * reflex - 监听文件变更并执行命令\n * gohttpserver - HTTP 静态文件服务器\n * XLSX - Excel 读写包\n * Excelize - 360 开源的 Excel 工具包\n * gopdf - PDF 生成\n * rsc/pdf - PDF reader\n * SeaweedFS - 分布式文件系统\n * go-fastdfs - 分布式文件存储服务\n * Dragonfly - 基于 P2P 的分布式文件系统\n * filetype - 检测文件类型\n * Afero - 文件操作包\n * fsync - 文件/目录同步\n * filebrowser - Web File Browser\n * Bigfile - 文件传输管理系统\n * filetype - 文件类型与 MIME 检测\n * go-app-paths - 跨平台检索目录文件\n * copy - 拷贝文件夹\n * lakeFS - 类 Git 文件对象存储\n * Duplicacy - 无锁云备份工具，支持几乎所有存储方式\n * CasaOS - 家庭云系统\n * AList - 支持多存储的文件列表程序\n * UniPDF - PDF 读写处理\n * mimetype - MIME 类型与文件扩展检测\n * gocryptfs - 加密 overlay 文件系统\n * restic - 备份工具，使用现代的加密方法对数据进行安全的备份，支持\n\n\n# 模板引擎\n\n * goTemplateBenchmark - 给各 Go 模板引擎做性能测试，当然也就包含了最全的模板引擎包\n * Jet - 速度很快\n * amber - HTML 模板引擎\n * fasttemplate - Simple and fast template engine for Go\n * quicktemplate\n * mustache\n * Ace\n * Sprig - 常用模板方法\n * pongo2 - Django 语法风格的模板引擎\n * plush\n\n\n# 代码生成\n\n * esc\n\n\n# 文本处理\n\n# Markdown\n\n * Blackfriday - Markdown 解析器\n * Lute - 结构化的 Markdown 引擎\n * goldmark - Markdown 解析器\n * docx2md - 转换 Word 为 Markdown\n * glamour - 命令行下渲染 Markdown\n * go-md2man - 转换 Markdown 为 man 手册内容\n * gomarkdown/markdown\n * html-to-markdown - 转换 HTML 为 Markdown\n\n# HTML/CSS\n\n * DOM - HTML DOM 节点操作\n * obelisk - 保存 Web 网页为 HTML 单页面\n * html2text - HTML 转 text\n * go-readability - 让 HTML 可读性更高\n * gomponents - 声明式视图组件，可以渲染成 HTML5\n * daz - HTML 组件组合，渲染 HTML\n * html-strip-tags-go - 去除 HTML 标签\n * bluemonday - XSS 探测\n * cascadia - CSS 选择器\n * htmlquery - XPath 语法查询 HTML\n * xmlquery - XPath 语法查询 XML\n * xpath - XPath 语法\n * goquery - jQuery 语法查询 HTML\n * css - CSS 选择器\n\n# 其他\n\n * go-runewidth - 字符长度计算\n * gpy - Go 语言汉字转拼音工具\n * go-hashids - hashids 的 Go 版本\n * go-pinyin - 汉语拼音转换工具 Go 版\n * mahonia - 字符集编码转换\n * pangu.go - Go 版本的 pangu，给中英文之间加空格\n * goorgeous - A Go ORG syntax parser to HTML\n * sergi/go-diff - Go 版本的 diff 工具包\n * sourcegraph/go-diff - Go 版本的 diff 工具包\n * Chroma - 代码语法高亮\n * syntaxhighlight - 代码高亮\n * kyokomi/emoji\n * enescakir/emoji\n * golang/freetype - Freetype font rasterizer\n * prose - natural language processing library\n * minify - Web 静态资源压缩(HTML/JS/CSS/JSON/XML/SVG)\n * Inflection - Pluralizes and singularizes English nouns\n * autocorrect - 自动给中英文之间加入合理的空格并纠正专用名词大小写\n * bleve - modern text indexing\n * etree - XML 解析&生成\n * go-xml\n * feeds - RSS 内容生成\n * gofeed - RSS & Atom feeds 内容解析\n * sitemap - sitemap.xml 生成\n * yarr - RSS 阅读软件\n * gogrep - 通过语法树搜索 Go 源码\n * PipeIt - 文本转换，清理和提取工具\n * regexp2 - 全功能正则表达式引擎。如果标准库的 regexp 满足不了你，可以尝试使用 regexp2\n * html2article - 基于文本密度的 html2article 实现\n * hostctl - hosts 命令行管理工具\n * go-shellwords - 解析命令行中字段\n * woke - 检查文本文件中是否存在歧视词汇\n * go-password-validator - 密码强度校验器\n * xurls - 从文本中提取 URL\n * whatlanggo - 自然语言探测\n * go-enry - 检测编程语言\n * fuzzy - 字符串模糊匹配\n * godlp - 数据脱敏\n * Zoekt - 文本搜索引擎\n\n\n# 文档\n\n * swag - Swagger for Go\n * gin-swagger - Swagger for Gin\n * go-swagger - Swagger 2.0 implementation for go\n\n\n# 数学计算\n\n * decimal - 解决浮点数计算精度问题\n * fixed\n * apd - decimal 包\n * mathfmt - 将 LaTeX 语法的注释转换为数学公式格式\n * q - 量子计算模拟器\n * accounting - 货币格式化\n\n\n# 日期时间\n\n * now\n * when - 自然日期时间解析\n * Carbon - Carbon 时间处理库的 Go 语言实现\n * strftime - 时间格式化\n * dateparse - 解析任意未知格式的时间字符串\n\n\n# 配置\n\n * GoDotEnv - .env 配置文件解析\n * go-yaml/yaml\n * ghodss/yaml\n * toml - TOML 解析&编码包\n * INI - INI 配置文件解析\n * Viper - 支持 JSON, TOML, YAML, HCL, Java 等配置文件\n * fig\n * Multiconfig\n * configor\n * envconfig\n * confd - 配置管理工具\n * HCL - configuration language\n * env - 解析 ENV 环境变量到结构体中\n * configor\n * koanf\n * go-toml - TOML\n * butler - Adobe 开源的配置管理系统\n * envsubst - 环境变量替换\n\n\n# 爬虫\n\n * Crawlab - 基于Golang的分布式爬虫管理平台，支持Python、NodeJS、Go、Java、PHP等多种编程语言以及多种爬虫框架\n * Colly - 网络爬虫框架\n * Pholcus - 支持分布式的高并发、重量级爬虫软件\n * go_spider\n * Muffet - 网站链接检查器\n * Creeper\n * Geziyor - 支持 JS 渲染的快速爬虫框架\n * Apollo - 一个爬虫工具\n * ferret - 声明式 Web 数据抓取\n * gocrawl\n * Antch\n * katana - 爬虫&蜘蛛框架\n\n\n# 数据库\n\n# SQL解析\n\n * pingcap/parser - 兼容 MySQL 的 SQL 解析\n * xsqlparser - SQL 解析\n * sqlparser - SQL 解析\n * vitess-sqlparser - SQL 解析\n * dbml-go - DBML 解析\n\n# 分布式事务\n\n * go-saga - Saga 分布式事务实现\n * DTM - 跨语言的分布式事务管理服务，支持TCC、Saga、XA等\n\n# 数据库相关\n\n * usql - 几乎支持全部 SQL 与 NoSQL 数据库的命令行工具\n * GORM - GORM V2\n   * GORM V1\n   * gorm2sql - 根据 Model Struct 生成建表语句\n   * gorm-sharding - 基于 Conn 层做 SQL 拦截、AST 解析、分表路由、自增主键填充，对使用者透明\n * Xorm\n * XormPlus - Xorm 的定制增强版本\n * GoRose\n * sqlx - database/sql 扩展包\n * dbq - 数据库操作\n * gendry - 滴滴开源的SQL Builder\n * ozzo-dbx\n * Squirrel - Fluent SQL Builder\n * qb - the database toolkit for go\n * mgo\n   * globalsign/mgo - The MongoDB driver for Go\n   * mgo使用指南\n * kingshard - MySQL Proxy\n * SOAR - 对SQL进行优化和改写的自动化工具\n * SQLE - SQL 审核工具\n * Vitess - 用于部署、扩展和管理大型MySQL实例集群的数据库解决方案\n * gh-ost - GitHub 开源的在线更改 MySQL 表结构的工具\n * SQLer - write APIs using direct SQL queries with no hassle, let\'s rethink about SQL\n * gocraft/dbr\n * Gaea - 小米开源的基于 MySQL 协议的数据库中间件\n * OctoSQL - 支持多数据库的 SQL 查询工具\n * goose - 数据库迁移工具\n * migrate - 数据库迁移工具\n * dbmate - 数据库迁移工具\n * ent - An Entity Framework For Go\n * godb - a Go query builder and struct mapper\n * go-nulltype\n * go-mysql - MySQL 工具集\n * SQLittle - 纯读取 SQLite 文件\n * Bifrost - MySQL 同步到 Redis、ClickHouse 等服务的异构中间件\n * elasticsql - 转换 SQL 成 Elasticsearch DSL\n * POP - 基于 sqlx 封装的数据库 ORM 工具\n * REL - Modern Database Access Layer for Go\n * RDB - Redis RDB 文件解析和生成工具，支持转 JSON、转 AOF、寻找 Big Key、生成 RDB 文件及绘制内存火焰图等功能\n * Bytebase - 基于网络、零配置、无依赖的数据库 Schema 变更和版本控制管理工具\n * Bun - SQL 优先的 ORM，写 SQL 的方式写 Go 代码，支持 PostgreSQL、MySQL、MSSQL、SQLite\n\n# 数据库客户端\n\n * Go-MySQL-Driver - MySQL 驱动\n * go-mssqldb - MSSQL 驱动\n * pq - PostgreSQL 驱动\n * mongo-go-driver - MongoDB 官方出品的 Go 语言驱动\n * qmgo - MongoDB 客户端\n * clickhouse-go - ClickHouse 官方 Go 语言客户端\n * go-clickhouse - ClickHouse 客户端\n * go-sqlite3 - SQLite3 驱动\n * gohbase - HBase 客户端\n * redigo - Redis 客户端\n * go-redis - Redis 客户端\n * rueidis - Redis 客户端\n * redsync - 基于 Redis 的分布式锁\n * redislock - 基于 Redis 的分布式锁\n * Tiny RDM - Redis 桌面客户端\n\n# 数据库引擎\n\n * etcd - KV 分布式存储\n * InfluxDB - 时间序列数据库\n * Prometheus - 服务监控系统 & 时间序列数据库\n * tstorage - 时间序列数据库\n * Thanos - 支持 Prometheus 简化部署、高可用、分布式存储\n * CockroachDB - 分布式 SQL 数据库\n * Cayley - 图数据库\n * RadonDB - 基于 MySQL 研发的新一代分布式关系型数据库\n * TiDB - 分布式关系型数据库，兼容 MySQL 协议\n * AresDB - Uber 开源的 GPU 驱动的实时分析存储&查询引擎\n * leveldb - LevelDB 的 Go 实现\n * Dgraph - 分布式图数据库\n * rqlite - 基于 SQLite 的轻量级分布式关系数据库\n * gaeadb\n * BadgerDB - KV 数据库，支持 ACID 事务\n * LBADD - 用 Go 实现的分布式 SQL 数据库\n * go-memdb - 建立在不可变 Radix 树上的内存数据库\n * VectorSQL - 应用于 IoT 和大数据的 DBMS 数据库，类似于 ClickHouse\n * BuntDB - 基于内存的KV数据库，支持磁盘持久化、ACID事务\n * TinySQL - 迷你分布式关系型数据库\n * Tile38 - GEO 数据库\n * Redcon - 兼容 Redis 协议的自定义 Redis 服务，采用 BuntDB 和 Tile38 实现存储\n * genji - 文档内嵌型数据库\n * Dolt - 像 Git 一样操作数据库\n * rosedb - 简洁、高效的 KV 数据库，支持多种数据结构\n * LinDB - 分布式时序数据库\n * mandodb - 一个示例项目，作者介绍如何从零开始实现一个小型的时序数据库\n * go-mysql-server - 解析 MySQL 协议并优化 SQL 的数据库引擎\n * Milvus - 向量数据库\n * FerretDB - MangoDB 替代品\n * LotusDB - 快速 KV 存储引擎，兼容 LSM 和 B+ 树\n * NutsDB - 可持久化、事务的内嵌 KV 数据库\n * Olric\n\n\n# 缓存\n\n * GCache\n * bbolt - key/value store\n * BigCache\n * go-cache - KV 内存缓存\n * gomemcache - Memcache 客户端\n * cache2go\n * ristretto\n * fastcache\n * FreeCache\n * godis - Go 语言实现的 Redis 服务器和分布式集群\n * groupcache - 分布式缓存\n * cachego - 支持 Redis、Bolt 等缓存接口\n * diskv - 基于硬盘的 KV 存储\n * Pebble - 被 CockroachDB 使用的 KV 存储\n\n\n# 搜索推荐\n\n * wukong - 全文搜索引擎\n * go-elasticsearch - 官方 ES 客户端\n * elastic - Elasticsearch 客户端\n * go-mysql-elasticsearch - Sync MySQL data into elasticsearch\n * gse - Go 语言分词\n * sego - Go 中文分词\n * gojieba - "结巴"中文分词的 Go 语言版本\n * Riot - 全文搜索引擎\n * simplefts - 超简单的全文搜索引擎实现\n * Blast - 全文搜索(Archived)\n * Fuzzy Search - 文本模糊搜索\n * gorse - 单节点训练和分布式预测推荐系统引擎\n * gofound - 全文搜索引擎\n * ZincSearch - 全文搜索引擎\n * Bluge - 文本分词\n\n\n# 表单\n\n * validator\n * ozzo-validation - 使用代码指定规则，而非Tag\n * go-tagexpr - 字节跳动开源的结构体标签表达式解释器\n * govalidator\n\n\n# Auth\n\n * Casbin - 权限控制管理\n * pam-ussh - Uber\'s SSH certificate pam module\n * jwt-go - JWT for Go\n * kataras/jwt - JWT 轻量级实现\n * cristalhq/jwt\n * sessions - 后端 SESSION 服务\n * securecookie - cookie 加密/解密\n * Goth - Multi-Provider Authentication for Go\n * branca - 号称比 JWT 更安全的 token 解决方案\n * gin-jwt - Gin 框架的 JWT 中间件\n * Authboss - Web Auth 系统\n * ZITADEL - 身份认证系统，支持各种认证模式\n\n\n# 加密/解密\n\n * 2fa - Two-factor authentication on the command line\n * age - 文件加密工具（库）\n * CIRCL - Cloudflare Interoperable, Reusable Cryptographic Library\n\n\n# 视频\n\n * goav - FFmpeg 视频处理\n * lal - 直播流媒体网络传输服务器\n * bililive-go - 直播录制工具\n * screego - 通过浏览器共享开发者屏幕\n * livego - 直播服务器\n * Monibuca - 流媒体服务器开发框架\n * olive - 支持虎牙等平台的直播录制\n * lux - 各大视频网站的视频下载工具\n\n\n# 图形处理\n\n * barcode - 条形码/二维码生成器\n * picfit - 图片操作、裁剪、管理服务器\n * gmfs - 图片操作、裁剪、管理服务器\n * besticon - favicon 服务\n * Caire - 图片操作库\n * Imaging - 图片操作库\n * gocaptcha - 验证码生成\n * base64Captcha - 验证码\n * go-is-svg - 校验是否为 SVG 图片\n * identicon - 根据用户的 IP 、邮箱名等任意数据为用户产生漂亮的随机头像\n * prominentcolor - 识别图片的主要颜色\n * dchest/captcha - 生成和验证图片或音频验证码\n * bimg - 图片处理\n * imaginary - 图片处理服务\n * primitive - 用原始几何图形绘制图形\n * orly - 生成你自己的O\'RLY动物书封面\n * smartcrop - 智能裁剪图片\n * gift - 图片滤镜\n * Germanium - 给代码生成图片\n * Go Graphics - 2D 图片渲染\n * canvas - 矢量图绘制\n * formulae - 数学公式解析、计算、图表绘制\n * imagor - 图像处理服务器\n * Triangula - 给图片增加三角形纹样风格的滤镜\n * D2 - 一种将文本转换成图形的图表脚本语言\n * ImGo - 简洁、链式调用的图像处理库\n * Invoice - 发票生成工具，可通过参数和配置文件进行创建和管理各种类型的发票\n\n# 图片识别\n\n * go-face - 面部识别\n\n\n# 图表\n\n * go-echarts - Echarts 图表库\n * gonum/plot - 图形绘制\n * pinhole - 3D 线框图绘制\n * globe - 地球线框图绘制\n * ink - Go 中的 2D 图形框架\n * go-plantuml - 基于 Go 源码生成 plantuml 图\n * go-diagrams - 通过代码生成图表\n * GoCity - 3D 展示城市\n\n\n# 构建编译\n\n * Mage - 类似于 Makefile 的命令行工具，用于构建和运行 Go 项目\n * GoReleaser - Go 多平台二进制文件打包、并支持发布到 Homebrew 的工具\n * goxc - 跨平台编译工具（因 1.5 版本开始已自带交叉编译，故已不再维护）\n * Task - 类似于 Make 的构建工具\n * codegangsta/gin - 热编译工具\n * Air - 热编译工具\n * gowatch - 热编译工具\n * Fresh - 热编译工具\n * dh-make-golang - 自动构建 Debian 包\n * gobinaries - 不用安装Go就能编译安装Go编写的程序\n * nFPM - deb、rpm、apk 等打包工具\n * Gox - Go 跨端编译工具\n * garble - 混淆代码\n * gobfuscate - 混淆代码\n * go-appimage - Go 语言实现 AppImage 打包工具\n\n# 静态资源内嵌\n\n * pkger - 将静态文件打包成 Go 二进制文件\n * mewn - 静态文件嵌入打包到二进制文件\n * statik - 静态文件嵌入\n * go.rice\n * go-bindata - 将静态文件转换成 Go 代码文件\n * vfsgen - 将静态文件打包成 http.FileSystem 类型进行访问\n * packr\n\n\n# 优雅升级\n\n * tableflip - Web 服务升级\n * selfupdate - 二进制文件自动升级\n * overseer\n * go-github-selfupdate - 依托 GitHub 自动升级\n\n\n# 代码分析\n\n * reviewdog - Code Review 机器人\n * revive - 代码检查分析\n * GolangCI-Lint - 代码质量检查分析工具\n * errcheck - 检测未处理的错误(errors)\n * Staticcheck - 一系列的 Go 代码静态分析工具\n * Golint - Google 官方出品的代码质量检测工具\n * GoReporter\n * go-critic\n * gocloc - 分语言代码行数统计\n * coca - 代码统计分析\n * Go Report Card - Go 项目质量分析报告工具\n * ddsv-go - 死锁检测工具\n * golang/perf - 官方性能量化分析工具\n * GoPlantUML - 为 Go 项目生成 PlantUML 类图\n * gosize - 分析Go二进制文件大小\n * shotizam - 分析 Go 二进制文件的大小并输出到 SQLite3\n * goconst - 查找可以被常量替换的重复字符串\n * sploit - 帮助二进制分析和开发的库\n * perf - Perf Utilities for Go\n * fgprof - Go 性能分析工具\n * conprof - 协程分析\n * statsview - 实时 Go 运行时统计数据可视化分析器\n * codesearch - 代码搜索工具\n * Pyroscope - 可视化程序性能监控工具，支持多种语言\n * gosec - 代码安全性检查工具\n * gokart - 代码静态分析工具\n * gofumpt - gofmt 增强版代码格式化工具\n * NoVerify - PHP 代码分析工具\n * fieldalignment - 结构体字段内存对齐分析和自动修复工具\n * Bearer - 代码安全扫描工具\n\n\n# 调试\n\n * go-spew - 变量打印工具\n * Delve - Debug 工具\n * gdlv - Delve 界面版本\n * Weaver - 跟踪 Go 程序执行链路\n * repr - 变量打印工具\n * pp - 彩色变量打印工具\n * ffmt - 变量打印工具\n * gops - 谷歌官方出品的 Go 程序监控调试工具\n * pprof\n * go-callvis - 可视化Go程序的调用图\n * q - 自动打印变量类型并且格式化输出\n * Litter\n * RDebug - 滴滴开源的一款用于 RD 研发、自测、调试的实用工具\n * debugcharts - Go 内存占用可视化调试工具\n * gcvis - 实时可视化 gctrace\n * pkg/profile\n * statsviz - 在浏览器中实时查看 Go 应用程序运行时统计信息（GC，MemStats 等）\n * autopprof - 自动分析 pprof\n * stack - 捕获、操作、格式化调用栈信息\n * pretty - 打印变量\n * go-deadlock - 对 (RW)Mutex 进行注入，并提供死锁检测\n * mmcloughlin/profile\n * gcnotifier - 当发生 GC 时通知\n * grmon - 命令行监控显示 goroutines\n * valast - 打印输出变量的 go/ast 结构，类似于 PHP 的 var_export 函数\n * lensm - Go 汇编与源码对照查看工具\n * holmes - 基于规则的自动 Go Profile Dumper\n\n\n# 测试\n\n * GoConvey - 含Web界面的单元测试框架\n * GoMock - 谷歌出品的Mock测试框架\n * GoStub\n * Monkey - (Archived) Monkey patching in Go\n * gomonkey - 猴子补丁，对函数、变量等进行打桩，方便单元测试，Fork 自 Monkey\n * SuperMonkey - 让私有方法可测\n * mockery - 自动为接口生成 mock 代码\n * Ginkgo - BBD 测试框架\n * fperf - 压测工具\n * gocheck\n * Testify\n * gotests - 根据源码自动生成测试文件\n * TestSQL - 根据 SQL 创建语句生成测试数据\n * httpmock - HTTP Mock\n * Goblin - BDD 测试框架\n * go-faker/faker - Struct Data Fake Generator\n * gofakeit - 随机数据生成器\n * dmgk/faker\n * go-tprof - 包测试报告生成工具\n * go-fuzz - randomized testing for Go\n * gofight - Testing API Handler\n * sqlmock - SQL 测试\n * sqlbench - SQL\n * silk - 基于 Markdown 的接口测试\n * gock - HTTP mock 测试\n * godog - BDD 测试框架 Cucumber 的 Go 版本\n * endly - E2E（端到端）测试\n * is - 迷你测试框架\n * Terratest - 基础设施测试，比如 Docker\n * agouti - Web 驱动的验收测试框架\n * httpexpect - 端到端 HTTP & REST 测试框架\n * gocov - 测试覆盖率\n * miniredis - Redis 数据测试\n * htmltest - HTML 测试\n * gnomock - 无需 mock 的 Go 代码测试框架\n * gunit - xUnit 风格测试框架\n * quicktest\n * k6 - 负载测试工具\n * go-cover-treemap - 将覆盖率测试结果转换成 TreeMap 图\n * ZTF - 禅道开源的自动化测试框架\n * Moq - 为接口生成 Mock 代码\n\n\n# 错误处理\n\n * errors\n * errorx\n * errwrap - Go tool to wrap and fix errors with the new %w verb directive\n * erris - Linter for errors.Is and errors.As\n * eris - 旨在通过错误包装，堆栈跟踪和输出格式为你提供对错误处理的更多控制\n * errlog - 使用静态和堆栈跟踪分析来快速确定哪个函数调用导致的错误\n * juju/errors\n * go-fault - GitHub 官方出品，基于标准库 http 中间件的故障注入库\n * merry - 支持堆栈、状态码的错误处理\n * cockroachdb/errors - 功能强大、可替代 errors 和 github.com/pkg/errors 的错误处理包\n * go-multierror - 支持错误列表\n\n\n# 安全\n\n * Kunpeng - 开源POC检测框架\n * nmap - 安全审计工具 nmap 开发包\n * Hetty - 用于安全研究的 HTTP 工具包，具有 Web 接口和代理日志查看器的拦截 HTTP 代理\n * Fibratus - Windows 内核漏洞利用和跟踪工具\n * Secure - HTTP 安全中间件\n * nuclei - 基于YAML语法模板的定制化快速漏洞扫描器\n * Gitleaks - 用于在 Git 存储库中查找敏感信息和密钥的开源工具\n\n\n# 系统信息\n\n * go-hardware - 收集了一堆关于硬件信息的包\n * cpuid - CPU 信息\n * gopsutil - ps 功能包\n * go-sysinfo - 系统信息\n * go-locale - 跨平台语言检测库\n * go-ps - 系统进程信息\n * psgo - ps 命令实现\n * ghw - 硬件信息\n * machineid - 获取机器ID\n\n\n# UUID\n\n * go.uuid - UUID 库\n * SEQSVR - Go + MySQL 实现的分布式 ID 生成服务\n * google/uuid - Google 开源的 uuid 包\n * gofrs/uuid\n * snowflake - Twitter snowflake IDs\n * sonyflake - Sony 版本的 Twitter\'s Snowflake\n * ulid - ULID Go 语言实现\n * ksuid - K-Sortable Globally Unique IDs\n * go-nanoid - NanoID 实现\n * xid - 全局唯一 ID 生成器\n\n\n# 日志\n\n * logr - 日志包标准接口\n * Logrus - 日志记录包\n * zerolog\n * zap - Uber 开发的日志记录包\n * Seelog\n * logkit - 七牛开源的日志收集工具\n * gogstash - 类似于 Logstash 的日志收集器\n * lumberjack - 日志文件切割\n * file-rotatelogs - 日志文件切割\n * go-syslog - 极速 Syslog 解析器\n * glog\n\n\n# 监控告警\n\n * OpenFalcon - 小米开源的监控系统\n * Prometheus - 服务监控系统 & 时间序列数据库\n * Grafana - 分析监视平台, 支持 Graphite, Elasticsearch, OpenTSDB, Prometheus, InfluxDB 等数据源\n   * grabana - 用 Go 代码快速创建 grafana dashboards\n * Jaeger - 分布式追踪系统\n * go-osstat - 系统指标统计\n * grafterm - Metrics dashboards on terminal\n * mymon - MySQL 运行监控\n * PingMe - 支持多消息平台的服务可用性报警命令工具\n * supervisord - Go 语言实现 Supervisor\n * Grafana Tempo - 分布式追踪系统\n * EaseProbe - 服务探活工具并通知\n * Uptrace - APM 工具，支持 OpenTelemetry 追踪、指标和日志\n * Nightingale - 滴滴基于 OpenFalcon 开源的监控系统\n\n\n# 统计分析\n\n * Fathom - Web 站点统计\n * Veneur - 分布式实时数据处理管道\n * gonum - 科学计算相关\n\n\n# 容器技术\n\n * moby - Docker\n * docker-ce\n * Rancher - 全栈化企业级容器管理平台\n * Gorsair\n * docui - TUI Client for Docker\n * Podman - 管理和运行任何符合 OCI 规范的容器和容器镜像\n * Skopeo - 镜像管理工具\n * Buildah - 构建 OCI 容器镜像的工具\n * go-docker - 用 Go 实现 Docker 核心功能\n * Packer - 轻量级的镜像定义工具\n * cosign - 容器签名和验证\n * SlimToolkit - 检查、缩小和调试容器\n\n\n# 集群管理\n\n * Nomad - 集群管理器和调度器\n * OpenShift Origin - Red Hat 开发的容器化软件解决方案\n\n# Kubernetes\n\n * kubernetes - 容器调度管理平台\n * k0s - 最小体积的 k8s 发行版\n * sealos - 一条命令部署 Kubernetes 高可用集群\n * KubeEye - 通过配置规则发现 Kubernetes 上的各种问题\n * endpoints-operator - K8S内部服务访问外部服务的具备探活功能的4层LB\n\n\n# 机器学习\n\n * goml - 机器学习库\n * GoLearn - 一个 "开箱即用" 的机器学习库\n * glow - 易用的分布式计算系统\n * Gobot - 机器人和物理计算语言库\n * Olivia - 神经网络\n * Pico - 基于像素强度比较的物体检测纸张的纯 Go 脸部检测库\n * tfgo - Tensorflow in Go\n * Prophecis - 微众银行自研的一站式云原生机器学习平台\n * AID - 机器学习ops平台，发现、部署、优化\n * SQLFlow - SQL引擎+AI引擎\n\n\n# 人工智能\n\n * go-openai - OpenAI API Go 客户端 SDK\n * LocalAI - 低成本的硬件上运行模型计算的本地计算框架，支持多种模型，提供兼容 OpenAI 接口协议的 REST API\n\n\n# 算法\n\n * GoDS - Go 实现了多种数据结构\n * Dragonboat - 多组 Raft 共识算法库\n * eliben/raft - Raft 算法\n * hashicorp/raft - Raft 算法\n * Graft - Raft 算法\n * golang-lru - LRU 算法实现\n * tinylru\n * finn - Fast Raft framework using the Redis protocol for Go\n * xorfilter\n * priyankchheda/algorithms - 各种算法的 Go 语言实现\n * meow - Meow hash\n * basalt - 高性能的分布式的专门空间优化的 Bitmap 服务, 杜绝 Bloomfilter 和 CuckooFilter 的误判\n * go-blurhash - BlurHash，是模糊图片的一种哈希算法\n * xxhash - xxHash 哈希算法实现\n * go-multihash - 各种 Hash 算法实现\n * memberlist - 基于 gossip 协议实现的管理集群成员和成员失败检测的开发包\n * backoff - 指数退避算法(Exponential Backoff)\n * FSM - 有限状态机\n\n\n# 数据结构\n\n * go-datastructures\n * Play-with-Data-Structures - 「玩转数据结构」课程的 Go 语言实现版本\n * HashMap\n * SipHash - SipHash-2-4\n * Bigslice\n * golang-set - The missing set collection\n * rbang - R!tree 实现\n * rtreego - R-tree\n * google/btree - B-Tree\n * tinybtree - B-tree\n * dataframe-go - 用于数据统计和操作的包\n * go-set - 集合工具包\n * orderedmap - 有序字典\n * trie\n * Slim - 空间高利用率的数据结构\n * bitset - 位集合及其操作\n * bloom - Bloom filters\n * roaring - 压缩位图\n * go-immutable-radix - Radix 树\n\n\n# 依赖注入\n\n * go-autowire - 使用注解自动生成 wire - 依赖注入\n * dig\n * Fx\n\n\n# JSON\n\n * GJSON - JSON 解释器\n * SJSON - JSON 修改工具\n * fastjson - fast JSON parser and validator for Go\n * jsonparser\n * ffjson\n * json-iterator - 滴滴开源的 JSON 解析器\n * gojsonq - JSON/YAML/XML/CSV 等数据查询\n * easyjson\n * go-jsonc - 将带注释的 JSON 转为无注释的\n * jin - JSON 操作工具包，同时具有标准库和类似 tidwall/gjson 和 tidwall/sjson 的功能\n * hujson - 支持注释的 JSON 解码\n * pkg/json - JSON Decoder\n * ColorJSON - 终端中打印彩色 JSON\n * jid - JSON 数据解析读取工具\n * jsonc - 支持注释与逗号\n * sonic - 字节跳动开源的 JSON 解析器&修改器\n * go-json\n * jsonquery - XPath 语法查询 JSON\n * fx - 命令行 JSON 显示\n\n\n# 依赖管理\n\n * goproxy.io - GOPROXY 代理服务\n * goproxy.cn - 更适合国内用户的代理服务\n * Gopm - Go 包管理工具\n * govendor - Vendor 包管理工具\n * gom - 包版本管理工具\n * rvflash/goup - 检查包版本是否有更新\n * owenthereal/goup - Go 多版本管理\n * Athens - GOPROXY 代理服务\n\n\n# 微服务\n\n * Istio [中文文档] - 大型微服务系统管理工具\n * goa\n * Micro - 微服务工具\n * Go Micro - 微服务框架\n * Go kit - Go 微服务工具集\n * GoKit CLI - Go kit 脚手架\n * gogo\n * go-chassis\n * Kite\n * Kratos - B站开源的微服务框架\n * Temporal - 微服务编排平台\n * Serf - 服务编排管理平台\n * Open Policy Agent - 通用策略引擎，CNCF 孵化项目\n * gizmo - 微服务工具集\n * MOSN - 用于边缘和服务网格的云原生网络数据平面\n * Erda - 为企业提供 DevOps、微服务治理、多云管理的 PaaS\n * Service Weaver\n * Consul - 服务发现、配置管理中心服务\n * Traefik Mesh - 简单的服务网格\n\n\n# Serverless\n\n * OpenFaaS - Serverless Functions Made Simple(功能服务化的 FaaS 框架)\n * faasd - 轻量级 FaaS 引擎\n * fn - 事件驱动的 FaaS\n * riff - 基于 Kubernetes 的 FaaS\n * Nuclio - 实时事件与数据的 Serverless 框架\n * Flogo - 事件驱动的 Serverless 框架\n * Dapr - 微软开源的云和边缘计算的微服务构件\n * kubeless\n * Fission - 基于 Kubernetes 的 Serverless\n * pulumi\n * Knative\n * fx\n * IronFunctions\n * schollz/faas - 让任何包的函数变成一个 HTTP 接口\n * Vanus - 无服务事件流处理系统\n\n\n# devops\n\n * act - 本地运行 GitHub Actions\n\n\n# 持续集成/部署\n\n * CDS - 持续集成服务\n * gopub\n * CodePub\n * syncd - 代码部署工具\n * Drone - 基于 Docker 的持续发布平台\n * Cyclone - 持续集成&发布平台\n * tbls - 用于记录数据库文档的 CI 友好工具\n * Woodpecker - Fork 自 Drone\n * Dagger - 基于容器的 CI/CD 工具\n\n\n# Git\n\n * gogs - 类似于 GitLab 的 Git 服务器\n * Gitea - 由 gogs 分叉出的 Git 服务器\n * go-git - Go 实现的 Git 操作\n * gitin - commit/branch/status explorer for git\n * hub - GitHub 命令行工具\n * git-o-matic - 一个监控 Git 仓库变化和自动 pull/push 的工具\n * gitbase - SQL 的方式查询 Git 日志\n * git-chglog - CHANGELOG 管理工具\n * chglog - CHANGELOG 管理工具\n * lazyhub - GitHub 的终端 UI 客户端\n * goaction - 在 Go 中编写 GitHub Action\n * bit - Git 命令增强版，支持文件和分支名称自动完成、命令和标志建议\n * go-github - GitHub API 操作库\n * askgit - 通过 SQL 访问 Git 仓库信息\n * git2graph - 根据 Git 仓库提交记录生成结构图\n * lazygit - Git 终端 UI\n * gh-dash - GitHub CLI（gh）漂亮终端面板\n * Soft Serve - 命令行式自托管 Git 服务器\n * Git LFS - 处理大文件的 Git 扩展\n\n\n# 限流器\n\n * Tollbooth - Simple middleware to rate-limit HTTP requests\n * ratelimit\n * RateLimit\n * go-rate\n * Circuit - 熔断器\n * uber-go/ratelimit\n * Sentinel - 阿里巴巴开源的面向分布式服务架构的流量控制组件 Go 语言版本\n * gohalt - 限流\n * gobreaker - 熔断器\n * ulule/limiter\n\n\n# 编译器\n\n * TinyGo - 一个适用于微控制器、WebAssembly 和命令行工具的 Go 编译器\n * minigo - A Go compiler from scratch\n * llir/llvm - LLVM 编译器\n * jit-compiler - JIT 编译器\n * Go+ - 七牛云开源面向数据科学的语言，完全兼容Go语言\n\n\n# 解释器\n\n# 语言解释器\n\n * participle - 通用的自定义语法解析包\n * GopherLua - VM and compiler for Lua in Go\n * go-lua - A Lua VM in pure Go\n * DCLua - Go Lua Compiler and VM\n * otto - JavaScript 解释器\n * goja - ECMAScript 5.1(+) 实现\n * v8go - Execute JavaScript from Go\n * gpython - Python Interpreter on Go\n * Grumpy - 转换 Python 为 Go 代码，谷歌开源\n * starlark-go - Starlark in Go\n * avo - x86 汇编程序构建器\n * wagon - WebAssembly 解释器\n * GopherJS - 把 Go 代码编译成 JavaScript 代码\n * Yaegi - Go 语言解释器\n * properties - Java properties scanner for Go\n * jvm.go - JVM\n * gobasic - A BASIC interpreter written in golang\n * golisp - Lisp 解释器\n * dst - Go Decorated Syntax Tree\n * mvdan/sh - Shell 解析、格式化、接口\n * tdewolff/parse - 通用词法分析器 Lexer，并内置支持解析 HTML/CSS/JSON/XML/JS/SVG 语法\n * Joker - Clojure\n\n# PHP\n\n * z7zmey/php-parser - PHP AST 语法解析\n * deuill/go-php - PHP bindings for Go\n * goridge - High-performance PHP-to-Golang IPC bridge\n * RoadRunner - 高性能PHP应用服务器，支持负载均衡及进程管理\n * VKCOM/php-parse - PHP AST 语法解析\n\n# 自定义解释器\n\n * CUE - Configure Unify Execute(Validate and define text-based and dynamic configuration)\n * cel-go - Common Expression Language(CEL 的 Go 实现)\n * Math-Engine - 使用 Go 实现的数学表达式解析计算引擎库，学习语法解析很适用\n * Gval - 表达式计算\n * expression-parsing\n * goexp - Recursive descent expression parser in Go\n * goastch - Go AST 语法解析\n * tdop\n * swallow\n * Anko\n * Expr - 编译&执行字符串中的表达式\n * Tengo - 用 Go 编写的脚本语言\n * V - Go 编写的语言\n * kumarUjjawal/bison\n * Monkey\n * govaluate\n * Compiler - 将自定义语法代码编译成 X86-64 Assembly\n * elvish - 交互式 Shell 语言\n * QLBridge - Go SQL Runtime Engine\n * YQL - SQL WHERE 风格的规则引擎\n * Flux - InfluxDB 数据语言\n * Spiker - Go 编写的简单规则表达式执行器，支持自定义函数和流程控制，适用于业务规则复杂的场景\n * gocc - 解析器生成器，可以将指定的文法转换为 Go 语言的解析器程序代码，用于编译和解析特定类型的源代码\n\n\n# 代码生成\n\n * jennifer - Go 代码生成\n * ifacemaker - 根据结构体方法生成接口\n * gg - Go 代码生成\n\n\n# 编辑器\n\n * micro - 基于终端的编辑器\n * sourcegraph - 代码搜索&导航\n\n\n# 运行器\n\n * gore - 在线运行 Go 代码\n * nodebook - 在线运行多种语言\n * go-pry - 像 Python、R、PHP 等在终端交互式输入与运行 Go 代码\n\n\n# 查询语言\n\n * graphql - Go 实现的 GraphQL\n * graphql-go\n * GQLEngine - 基于 graphql-go 实现\n * RQL - REST 资源查询语言\n * Thunder - GraphQL 服务构建框架\n * gqlgen - 构建 GraphQL 服务器的包\n * super-graph - 无需编写代码即可在 Go 项目中构建复杂的 GraphQL API\n\n\n# 游戏相关\n\n * Nano - 游戏开发框架\n * Leaf\n * einx\n * CloudRetro - 游戏云服务框架\n * G3N - Go 3D Game Engine\n * Ebiten - 2D 游戏库\n\n\n# 桌面开发\n\n# GUI\n\n * Lorca - 用 Go 编写 HTML5 桌面程序，依赖 Chrome 进行 UI 渲染，但却不把 Chrome 打包到应用中\n * webview - 用 Go/C/C++ 构建跨平台的桌面软件\n * walk - Windows GUI toolkit\n * go-gtk - Go bindings for GTK\n * andlabs/ui - Platform-native GUI library for Go\n * fyne - Material Design 风格的 GUI\n * go-gl - Go bindings for OpenGL (generated via glow)\n * therecipe/qt - 基于 Qt 的跨全平台 UI 包\n * giu - 基于 Dear ImGui 的跨平台 GUI 框架\n * go-app - 一个 WebAssembly 框架，用于使用 Go，HTML 和 CSS 构建 GUI 应用\n * wails - 使用 Go 和 Web 技术创建桌面应用程序\n * chromedp - 纯 Go 语言实现的驱动浏览器的 Chrome DevTools Protocol，可用于爬虫、反爬虫、测试等场景\n * Rod - 一个为简化自动化和爬虫设计的 devtools driver，利用浏览器的 devtools 可编程接口来操控浏览器\n * go-astilectron - 基于 Electron 的跨平台开发\n * Gio - 跨平台 UI 框架，支持移动应用\n * nucular - 基于 Gio 的实现\n * GoVCL - 跨平台的 GUI 包\n * vugu - WebAssembly UI 框架\n * GoGi - 2D/3D GUI 框架\n * systray - 跨平台支持菜单栏管理\n * go-flutter - 绑定 Flutter 到桌面应用\n * NuxUI\n\n# 桌面辅助包\n\n * pkg/browser - 在浏览器中打开文件、URL\n * MacDriver - macOS 原生 API\n * gon - 为 macOS 签名和公证\n\n# 桌面应用\n\n * xbar - 基于 Wails.app 开发的 macOS 菜单栏管理\n * 阿里云盘小白羊版 - UI由Flutter构建\n\n\n# 移动端\n\n * golang/mobile - Go support for Mobile devices\n\n\n# 协程/线程\n\n * ants - 协程池\n * tunny\n * go-workers - 安全地并发运行一组 worker，通过 channel 进行输入输出\n * Machine - 受 errgroup.Group 启发的协程管理\n * thread\n * conc - 更好用的结构化并发控制\n * zeropool - 零回收、类型安全的协程池\n * workerpool - 无阻塞队列任务池\n * pond - 协程池\n\n\n# 任务/定时器\n\n * RxGo - Go 版 ReactiveX，简单方便的处理异步数据流\n * Grift - Go based task runner\n * cron - a cron library for go\n * gocron - 任务定时调度器\n * jobrunner\n * CurlyQ - 后台任务处理库\n * overtalk/task - 任务的管理&执行，支持自定义次数的重发\n * PPGo_Job - 定时任务管理系统\n * gocelery - Celery 的 Go 语言实现\n * Machinery - 通过分布式消息实现异步任务调度\n * dkron - 分布式任务调度系统\n * Grit - 基于 MultiTree 实现的任务管理\n * Asynq - 异步分布式任务队列\n * cronsun - 分布式任务系统\n\n\n# 流处理\n\n * benthos\n * gostream\n * watermill\n * go-streams\n * goflow\n * Cadence (Cadence Web UI) - Uber开源的分布式工作流引擎，主要用于微服务编排和分布式事务等场景\n\n\n# 微信\n\n * weapp - 微信小程序 SDK\n * wechat - WeChat SDK for Go\n * wechat-go - 微信 Web 版 API 的 Go 实现\n\n\n# SDK\n\n * gopay - QQ、微信（WeChat）、支付宝（AliPay）的Go版本SDK\n * alipay - 支付宝SDK\n\n\n# 区块链\n\n * Hyperledger Fabric - 基于区块链的超级账本\n * go-ethereum - 以太坊协议的官方 Go 语言实现\n * bbgo - 用 Go 编写的加密货币交易框架\n * btcd - 比特币实现\n\n\n# 开发辅助包\n\n * cvt - 任意数据类型转换，支持自定义类型、提取结构体字段和值\n * copier - struct 之间拷贝值\n * cast - 数据类型转换\n * diff - 结构体&值比较\n * go-extend\n * com - 工具包\n * php2go - Go 实现的 140+ 个 PHP 函数功能包\n * gommon - Common packages for Go\n * reflect2 - reflect api without runtime reflect.Value cost\n * mapstructure - 将 map 值转换到结构体中\n * naza - Go语言基础库\n * automaxprocs - 自动设置 GOMAXPROCS\n * c2go - 将 C 代码转换为 Go 代码的工具\n * rnm - 代码重构辅助工具\n * memviz - 图形化数据结构\n * underscore.go\n * go-testdeep - 非常灵活的深度比较包，扩展了 Go 测试包\n * go-model - struct 操作包\n * concurrent-map - 并发安全 map\n * goleak - 检测 goroutine 泄漏\n * guregu/null - SQL/JSON的null处理包，提供替代类型\n * stats - 标准数字统计\n * Chronos - 静态竞争检测器\n * collection - 替代原生的 Slice\n * rf - 代码重构工具\n * bytebufferpool - byte buffers pool\n * bpool - byte buffers pool，支持 bytes.Buffers\n * mergo - 合并结构体和字典数据\n * go-funk - 基于反射实现的常用函数\n * lo - 基于 1.18+ 泛型的常用函数\n * juniper - 基于泛型实现常用的容器、迭代器、数据流等功能\n * mergo - 合并结构体和字典\n * xstrings - 字符串相关函数\n * pie - slice/map 链式处理\n\n\n# 代码生成\n\n * ChimeraCoder/gojson - 根据 JSON 生成结构体\n * db2struct - 根据表结构生成结构体\n * smallnest/gen - 根据表结构生成结构体\n * sqlc - 根据 SQL 语句生成 Go 代码\n * xo - 根据表结构或查询语句自动生成 Go 代码\n\n\n# 系统开发\n\n * LinuxKit - 为容器构建安全、便携、可移植操作系统的工具包\n * go-systemd - 绑定 systemd\n * Lima - Linux-on-Mac ("macOS subsystem for Linux", "containerd for Mac")\n * gopher-os - 一个兼容 Linux 的 64 位 POSIX 风格系统\n * gouring - 不依赖 CGO 实现系统调用\n\n\n# 未归类\n\n * go-playground - 比官方更好用的 Go Playground\n * Robotgo - Golang 跨平台自动化系统，控制键盘鼠标位图和读取屏幕，窗口句柄以及全局事件监听\n * go-homedir\n * i18n - i18n 多语言工具包\n * go-i18n - 多语言工具包\n * Paginater - 分页工具\n * gls - Goroutine local storage\n * mcuadros/go-version - 版本号比较\n * go-semver - 语义版本\n * semver - 另一个语义版本\n * hashicorp/go-version\n * Metabolize - Decodes HTML meta tags into a Golang struct\n * otp - 一次性密码工具包(One Time Password utilities)\n * misspell - 常拼写错误的英语单词\n * CRDT - CRDT(Convergent and Commutative Replicated Data Types)最终一致性算法的实现\n * script - Making it easy to write shell-like scripts in Go\n * sysadmin-utils\n * licenseclassifier - 识别文件中的 LICENSE 类型\n * go-license-detector\n * rose - 在 HTML 中嵌入和运行 Go 代码\n * esbuild - JavaScript 构建打包工具\n * clipboard - 剪切板\n * clipboard - 剪切板\n * clipboard - 剪切板\n * Timeliner - 搜集整理个人在社交网站上的数据并索引成时间线\n * hc - HomeKit 平台开发框架\n * address - 地址处理库，支持多国语言\n * webhook - 可执行 Shell 命令的 Web Hook 服务\n * webhookd - 为 Shell 脚本提供 Web Hook 服务\n * go-cid - CID spec Go 语言实现\n * gorush - APP 消息通知服务\n * EventBus - 事件总线\n * go-winio - 为 Win32 IO 操作提供接口支持\n * fq - 以 jq 语法读取二进制数据/文件\n * lego - Let\'s Encrypt client and ACME library\n\n\n# logo\n\n * Gophers\n\n\n# 工具\n\n * syndbg/goenv - Go 版本管理\n * wfarr/goenv - Go 版本管理\n * gvm - Go 版本管理\n * GoLand - IDE 软件\n * Visual Studio Code\n\n\n# 资源站点\n\n * Go 101\n * Go 语言中文网\n * Golang 中国\n * go-zh\n * Golang sizeof tips - 输入结构体定义，会显示内存布局\n * Golang Programs\n * Golang bot',normalizedContent:'> go 语言优秀资源整理，为项目落地加速🏃\n> \n> 转载分享，出处如下，谢谢 😆\n> \n> 原文地址: https://shockerli.net/post/go-awesome\n> \n> github: https://github.com/shockerli/go-awesome\n\n----------------------------------------\n\n> 官网: https://golang.org\n> \n> 国内官网镜像(访问快): https://golang.google.cn\n> \n> github: https://github.com/golang/go\n> \n> 开发者平台: https://go.dev\n> \n> wiki: https://github.com/golang/go/wiki\n> \n> 官方博客: https://blog.golang.org\n\n\n# 指导原则\n\n * 简单性\n   \n   > 复杂性把可读的程序变得不可读，复杂性终结了很多软件项目。\n\n * 可读性\n   \n   > 代码是给人看的，代码阅读时长远超编写。程序必须可维护，那可读是第一步。\n\n * 生产率\n   \n   > 拥有众多的工具集和基础库，可以很简单方便的完成绝大多数工作。 编译速度足够快，拥有动态语言的高效，但却不会面临动态语言不可靠的问题。 自带编程规范，使得团队代码一致，也帮助开发者发现和避免潜在的错误。\n\n\n# awesome\n\n * github topic for go\n * awesome go\n * golang-open-source-projects - 含描述的中文版 awesome go\n * awesome go storage - go 存储相关开源项目\n * awesome-go-china - 专门收集华人写的开源项目\n * go patterns - go 版本的设计模式\n * sevenelevenlee/go-patterns - 设计模式\n * gof 设计模式\n * greyireland/algorithm-pattern - 算法模板\n * go-algorithms - go 版本的数据结构和算法\n * go 学习之路 - go 学习资料汇集\n * go 开发者路线图\n * reposhub-go\n * visualgo - 数据结构和算法动态可视化\n\n\n# 大牛/组织\n\n> go 语言方面的大牛，或者优秀 go 项目的组织\n\n\n# 大牛\n\n * mattn - 写了数百个 go 项目，盛产优质项目\n * unknwon - gogs/macaron 等项目作者，《the way to go》译者\n * jinzhu - gorm/qor 等作者\n * valyala - fasthttp/fastjson 等作者\n * vmihailenco - go-redis/go-pg 等作者\n * kataras - iris 作者\n * bep\n * spf13\n * tidwall\n\n\n# 组织\n\n * gorilla web toolkit\n * loov\n * hashicorp\n * lestrrat-go\n * uber - open source software at uber\n * stretchr - tame your unstructured data\n * containous\n * charm - 提供一系列优秀的命令行工具和库\n\n\n# 文档\n\n * proposing changes to go - go 语言设计文档\n * go 语言设计与实现\n * go 语言原本\n * go 101 （中文版）\n * go 官方入门指南\n * go 语言高级编程\n * go 专家编程\n * go 编程语言\n * golang 标准库文档(官方/中文)\n * go 语言标准库 在线阅读\n * 《the way to go》中文版\n * go 语言圣经（中文版）\n * go语言入门教程\n * go 实战开发\n * go web 应用开发\n * go 学习技能树\n * 实效 go 编程\n * go 语言语法详解笔记\n * go 语言学习资料与社区索引\n * go database/sql tutorial\n * go 命令教程\n * 深入解析 go\n * go 语言博客实践\n * 学习 go 语言\n * go2编程指南\n * go database/sql tutorial - go 数据库(database/sql)开发使用教程\n * go web examples - go web 开发示例\n * go assembly - 通过示例介绍 go 汇编功能\n * ultimate go - 终极 go 学习指南，包含大量文档化的代码和程序分析\n * go 教程 - 腾讯云开发者手册\n * golang 开发笔记\n * golang-notes - go 源码阅读笔记\n * the little go book （中文版）\n * learning go — from zero to hero\n * go-internals - 深入理解 go\n * learn go with tests\n * go基础教程\n * 7天用go从零实现系列\n * go 语言高性能编程\n * golang - 100天从新手到大师 - 某培训机构的部分教程内容\n * hoanhan101/algo - 107+ 编码面试问题，包括详细的解决方案，测试用例和程序分析\n * over-golang - go 学习笔记\n * over-algorithm - go 算法笔记\n * learngo - 1000+ go 示例、练习和测试\n * go-leetcode - leetcode 实现\n * 玩转 go - 《mastering go》中文译本\n * leetcode-cookbook - leetcode in go\n * golang修养之路\n * go语法树入门\n * go concurrency patterns - go 并发模式场景集合\n * yezihack/algo - 数据结构与算法\n * golang-cheat-sheet-cn - github上最流行的golang代码速查表中文翻译版本\n\n\n# 指南\n\n * uber go style guide\n * the go programming language specification （中文老版）\n * 实效 go 编程\n * go code review comments\n * go code convention\n * go faq 101\n * go details 101\n * go tips 101\n * go quizzes 101\n * go-advices\n * go-perfbook - 编写和优化go代码\n * practical go: real world advice for writing maintainable go programs （go 语言实践：编写可维护的程序的建议）\n * go 安全指南 - 腾讯发布的《代码安全指南》go 语言篇\n * go concurrency guide\n * go recipes - 一些技巧\n\n\n# 文章\n\n * go training - 大量优质 go 相关文章、视频等资料\n * go语言爱好者周刊\n * go 夜读 - go 标准包、开源项目源代码阅读讲解\n * go-questions - go 语言学习入门和进阶知识\n * go的50度灰：golang新开发者要注意的陷阱和常见错误\n * go 程序的性能优化及 pprof 的使用\n * gops - go语言程序查看和诊断工具\n * go源码分析——http.listenandserve()是如何工作的\n * goconvey 框架使用指南\n * gostub 框架使用指南\n * gomock 框架使用指南\n * monkey 框架使用指南\n * the evolution of a go programmer - go 程序员的进化之路\n\n\n# 付费教程\n\n * 基于 go 语言构建企业级的 restful api 服务 - 掘金小册\n * go语言核心36讲 - 极客时间\n\n\n# 成品项目\n\n * shiori - 书签管理\n * studygolang - go 语言中文网\n * mkcert - 生成本地 https 加密证书的工具\n * cfssl - cloudflare 开源的 pki 和 tls 工具集\n * rainbond - 基于docker、kubernetes等容器技术的开源paas\n * nyadb2 - go 实现的关系型数据库, 值得用于学习\n * eiblog - 博客\n * pan-light - 不限速的百度网盘客户端, 基于 go + qt5 开发\n * baidupcs-go - 百度网盘客户端（命令行）\n * daily-warm - 每天定时发邮件给你关心的人\n * pipe - 博客平台\n * mdr - 命令行下的 markdown 阅读工具\n * miniflux - feed 阅读器\n * golinks - 创建自定义书签、命令、搜索等\n * 链滴笔记 - 桌面端笔记应用\n * wayback - 网页快照备份\n * bbs-go - 开源社区\n * openscrm - 基于go和react的企业微信私域流量管理系统\n * answer - 问答社区\n * listmonk - 资讯、邮件列表管理工具（web）\n * 1panel - linux 服务器运维管理面板\n * artalk - 自托管评论系统\n * memos - 笔记服务，具有移动客户端、浏览器扩展等生态\n\n\n# 静态网站生成器\n\n * hugo\n * jrnl\n * plenti\n * verless\n * ink\n * moul - 生成照片站点\n * zas\n\n\n# 学习项目\n\n * 1m-go-websockets - 该项目演示了如何用 go 编写一个可以提供超过一百万个 websockets 连接、运行内存小于 1gb 的服务器\n * go by example - 通过实例学习 go\n * iam - 身份识别与访问管理系统（教学项目）\n * 100-go-mistakes - 100 个 go 常见错误\n\n\n# 开源类库\n\n\n# web 框架\n\n * macaron - 一款具有高生产力和模块化设计的 go web 框架 国产\n * beego - 一个使用 go 的思维来帮助您构建并开发 go 应用程序的开源框架 国产\n * gin - 轻量 web 框架\n * iris - web 开发框架\n * revel\n * echo\n * faygo - 国产\n * teleport - socket 框架\n * goframe - 国产\n * qor - 系列应用开发组件包\n * dotweb - 国产\n * rest layer - rest api framework\n * honeytrap\n * ponzu\n * utron\n * muxie\n * buffalo - 快速生成 web 项目的开发工具\n * go-web-framework-benchmark\n * fiber - 一种 express 风格的、基于 fasthttp 的 http web 框架\n * aah\n * go-zero - 好未来开源的 web 框架\n * pingcap/fn - 支持绑定任何方法，构建成 post+json 接口\n * flamego - unknwon 开发的又一款 web 框架\n * rest layer - rest api 框架\n * rk-boot\n\n\n# 业务框架\n\n * yao - 使用 json 即可创建数据库模型、编写 api 接口、描述管理后台界面的应用引擎\n * goadmingroup/go-admin - 后台管理快速开发框架，与 laravel-admin 类似\n * wenjianzhang/go-admin - 基于 gin + vue 实现的后台框架\n * gin-vue-admin - 基于 gin + vue 实现的后台框架\n * goxygen - 基于 go, react, mongodb 技术实现的全栈应用生成器\n * nging - go语言通用后台管理框架\n * snake - 业务api框架\n * pocketbase - 带有后台管理面板、文件和权限管理、集成 sqlite 数据库的单一文件后端服务开发框架，支持 dart 和 js sdk 快速开发 app\n * dotenx - 低代码框架\n\n\n# 项目骨架\n\n * standard go project layout - go 项目目录结构示例\n * go-starter - adobe 的 go 工程模板\n * go-clean-arch\n * go-rest-api - go restful api starter kit\n * create go app cli - 通过命令行创建前后端项目的开发骨架\n * clean-gin - 基于 gin 构建的整洁架构项目骨架\n * golang-repo-template - 一个包含了很多实践的项目模板\n\n\n# ddd 框架\n\n * wild workouts - ddd、整洁架构、cqrs的示例项目\n * clean architecture in go - 整洁架构示例\n * freedom - 基于六边形架构的框架\n * esim - 基于六边形架构的微服务框架\n * go-cleanarch - go 整洁架构规则校验工具\n\n\n# tcp 框架\n\n * zinx - tcp并发服务器框架\n\n\n# 中间件\n\n * negroni - web 中间件\n * csrf - csrf 中间件\n * handlers - a collection of useful handlers for go\'s net/http package\n\n\n# 并发\n\n * sizedwaitgroup - 并发控制\n * concurrent - concurrency utilities\n\n\n# 命令行\n\n# 参数解析\n\n * urfave/cli - 命令行程序构建工具\n * cobra - 命令行构建包\n * flaggy - 命令参数解析\n * pflag - 命令行参数处理\n * kong - 命令行解析\n * clop - 命令行解析包\n * go-flags - 命令行参数解析\n * mow.cli\n * go-arg - 基于结构体tag解析命令行参数\n\n# 输出展示\n\n * progressbar - 在终端上输出进度条\n * cheggaaa/pb - 终端进度条\n * mpb - 支持多个进度条\n * color - 命令行文字颜色\n * gookit/color - 命令行色彩使用库\n * termui - 终端仪表盘\n * tui - 终端 ui\n * termenv - 终端应用程序的高级 ansi 样式和颜色支持\n * asciigraph - 在终端中绘制 ascii 字符的图表\n * spinner - 涵盖70多种符号或进度条的控制器\n * tablewriter - 终端中输出表格内容\n * pixterm - 在命令行终端中绘图\n * wtf - 一个命令行的信息仪表盘，可以定制显示内容\n * termdash - 基于 go terminal 的仪表板系统\n * bubbles - tui 组件\n * bubbletea - tui 框架\n * pterm - 支持图表、表格、进度条、树等终端输出展示\n * lip gloss - 终端布局、样式\n * gum\n * glow - 终端渲染展示 markdown\n * slides - 终端渲染展示 markdown\n * tview - terminal ui\n * asciiplayer - 在终端中通过 ascii 输出图片或视频，支持 png、jpeg、gif、mp4、avi 等格式\n * go-pretty - 终端渲染表格、列表、进度条等\n * tcell\n\n# 其他\n\n * gosu - 以指定的用户权限来运行脚本\n * gotop - 类 top 系统监控显示\n * go-colorable - colorable writer for windows\n * go-isatty - tty 环境判断\n * fzf - 终端模糊查询神器，支持多平台\n * go-daemon - daemon 进程包\n * go-prompt - 命令行交互式输入\n * peco - 交互式过滤工具\n * pty - pty for go\n * vtclean - 从终端输出字符串中解析出纯文本\n * survey - 交互式输入\n\n\n# 终端工具\n\n * vgrep - 支持滚动分页的 grep\n * gotty - 基于web的命令行实时共享\n * jump - 根据习惯快速跳转目录\n * gofish - 一个受 homebrew 启发的跨平台软件管理工具，支持 linux 和 windows\n * viddy - 增强版 watch 命令\n * miller - 一个类似 sed、awk、cut、join 和 sort 的工具，用来处理基于命名索引的数据\n * assh - ssh 增强工具\n * duf - 比 df 更好用的磁盘使用率工具\n * ov - 终端文本阅读器，可替代 less、more、tail -f 等\n * trdsql - 可对 csv/ltsv/json/tbln 等文件执行 sql 查询和导出\n * vhs - 终端录像工具，提供了在终端中录制和回放终端会话的功能，类似于将终端会话记录为视频的方式\n\n\n# 路由\n\n * httprouter\n * mux - url 路由和调度器\n * chi\n * gocraft/web\n * go-querystring - 转换结构体为url请求参数\n * gorilla/schema - converts structs to and from form values\n * clevergo\n * rewrite - rewrite 中间件\n * bunrouter - 支持中间件、错误处理、路由优先级、兼容 net/http 接口\n\n\n# 网络\n\n * dns - dns 库\n * coredns - dns 服务器\n * roadrunner - php 应用服务器、进程管理器、负载均衡，用于替代 nginx + fpm\n * frankenphp - php 应用服务器\n * goreplay - 流量收集&回放\n * sharingan - 滴滴开源的流量录制回放工具\n * glorp - http 拦截&重放的 cli 工具\n * p2pspider - 种子嗅探器\n * torrent - bittorrent 相关工具库\n * rain - bittorrent 客户端和库\n * httpteleport - teleports 10gbps http traffic over 1gbps networks\n * find3 - wifi 设备发现\n * subfinder - 子域名发现工具\n * ggz - 短网址服务\n * httpstat\n * grab - 文件下载\n * go-getter - 可使用 url 作为输入的主要形式从各种来源下载文件或目录\n * go-netty - 网络框架\n * gnet - 事件驱动 go 网络框架\n * netpoll - 专注于 rpc 场景的 non-blocking i/o 网络库\n * httplab - the interactive web server\n * yamux - multiplexer\n * sftp - sftp support for the go.crypto/ssh package\n * goftp - ftp 客户端\n * sftpgo - 功能齐全且可高度配置的sftp服务器，可选择支持http/s、ftp/s和webdav。支持的存储后端包括：本地文件系统、加密的本地文件系统、s3（兼容）对象存储、google cloud storage、azure blob storage以及其他sftp服务器。\n * evio - 事件驱动网络框架（reactor 模式）\n * gaio - 事件驱动网络框架（proactor 模式）\n * httpretty - 在终端上漂亮地打印出 http 请求\n * blocky - 作为局域网 dns 代理拦截广告\n * lossy - 模拟 net.packetconn 和 net.conn 接口的带宽，延迟和数据包丢失\n * go-libp2p - p2p\n * go-ipfs-api - ipfs\n * gomobile-ipfs - 为移动终端提供ipfs网络访问支持\n * go-multiaddr - multiaddr\n * kcp-go - 可靠的 udp 通讯包\n * gliderlabs/ssh - 像 net/http 一样轻松搭建 ssh 服务器\n * netaddr - 网络地址处理\n * sx - 网络扫描命令工具\n * echoip - ip 地址查找服务\n * easytcp - tcp server 框架\n * gopacket - 网络捕获抓包\n * croc - 两台电脑之间传输文件\n * cmux - 监听同一个端口，启动多种协议服务\n * geoip2 reader for go - 解析&读取 maxmind geolite2 和 geoip2 数据库\n * dns.toys - dns 服务器\n * apache traffic control - cdn 流量控制\n * nexttrace - 可视化路由追踪工具\n * pget - 文件下载工具，可多连接下载\n * cloudflarespeedtest - 测试 cloudflare cdn 延迟和速度，获取最快 ip\n\n# ldap\n\n * go-ldap\n * glauth - ldap server\n * gldap - ldap service\n\n# 网络代理\n\n * caddy - 类似 nginx 的 web 服务器\n * traefik - 反向代理&负载均衡\n * snail007/goproxy - golang 实现的高性能代理服务器\n * proxypool - 采集免费的代理资源为爬虫提供有效的ip代理\n * frp - 可用于内网穿透的高性能的反向代理应用\n * nps - 一款轻量级、高性能、功能强大的内网穿透代理服务器\n * pomerium - 基于身份的反向代理\n * v2ray\n * v2fly - v2ray 的社区版本\n * tailscale - wireguard 解决方案\n * clash - 支持多种协议的多平台代理客户端\n * elazarl/goproxy - http 代理\n * oxy - go middlewares for http servers & proxies\n * ouqiang/goproxy - go http(s)代理库, 支持中间人代理解密https\n * pgrok - 提供给穷人的内网穿透\n\n\n# http压测\n\n * vegeta - http 负载压测工具\n * hey - web 压测工具\n * bombardier - web 压测工具\n * go-wrk\n * plow\n * ddosify\n\n\n# http\n\n * fasthttp - 比 net/http 快 10 倍的 http 工具包\n * resty - http & rest 客户端包\n * gout - http 客户端\n * gentleman - http 客户端\n * goz\n * useragent - 解析 http user agent\n * purell - url 规范工具包\n * go-autorest - http 管道请求方式的客户端\n * req - http 客户端\n * cors - cors handler\n * certmagic - 为任意 go 程序自动加上 https，tls 证书签发、更新全自动\n\n\n# websocket\n\n * gorilla/websocket\n * nhooyr/websocket - 官方推荐的包\n * websocketd - go 开发的一键搭建 websocket 服务器命令行工具\n * ws - websocket 开发包\n * melody - websocket 服务框架\n * neffos - 一个快速且可扩展的 websocket 框架\n * fastws\n\n\n# 即时通信\n\n * centrifugo - 实时消息服务器，可以与任何语言编写的应用程序后端结合使用\n * goim - 支持集群的 im 及实时推送服务\n * tinode - 即时消息服务器，通过 websocket/json 或 grpc/tcp 等协议传输\n * webrtc - webrtc 实现\n * berty - 安全的点对点通讯软件\n * keybase - 即时通讯工具 keybase 全平台客户端\n * gotify - 基于 websocket 的 push 通知服务\n * nakama - 用于社交/实时游戏/实时应用的分布式服务端程序，自带面板、用户、聊天、存储、社交等功能\n * openim\n\n\n# 网关\n\n * goku api gateway ce - eolinker 开源的 api 网关\n * easegress\n * manba\n * tpk\n * bfe - 基于百度统一接入前端开源的七层流量接入系统\n\n\n# 序列化\n\n * vmihailenco/msgpack - 支持 msgpack\n * go/codec - 支持 msgpack/binc/cbor/json\n * golang/protobuf - go 版本的 protocol buffers\n * gogo/protobuf - golang/protobuf 的扩展替代品\n * objx - 操作 map, slice, json 等数据的包\n * msgp - messagepack 代码生成器\n * buf - protoc 替代品\n * protoc-gen-doc - google protocol buffers 文档生成插件，支持 html、json、docbook、markdown 和自定义模板\n\n\n# 解压缩\n\n * snappy - go 语言版本的 snappy\n * cae - 实现 zip/tar.gz 解压缩\n * archiver - 多格式支持的解压缩包\n * compress - optimized compression packages\n * brotli\n * xz - xz 压缩格式读写包\n\n\n# rpc\n\n * grpc-go - grpc 官方包\n * go grpc middleware - grpc 常用中间件\n * gorpc\n * gorilla/rpc - 构建基于 http 的 rpc 服务，比如 json-rpc\n * lile - grpc 服务构建包\n * rpcx\n * twirp - 基于 protobuf 的 rpc 框架，与 grpc 类似\n * dubbo-go - dubbo go 版本\n * kitex\n * grpcurl - 像 curl 一样通过命令行访问 grpc 服务\n * protoc-gen-doc - 文档生成插件\n * grpc-gateway - 读取 grpc 服务定义并生成一个反向代理服务器，同时提供 grpc 和 restful 风格的 api\n\n\n# 邮件\n\n * gomail - 邮件发送包\n * scorredoira/email\n * hermes - go 版本的 mailgen 引擎，根据配置生成 html 格式的邮件\n * go-guerrilla - smtp 邮件服务器\n * mailhog - 基于web和api的smtp测试工具\n * maddy - 邮件服务器\n * jordan-wright/email\n * mox - 邮件服务器\n * pop - 邮件发送工具，支持交互式和参数式\n * email-verifier - 邮箱校验，无需发送邮件\n\n\n# 消息队列\n\n * nsq - 实时分布式消息平台\n * nats - 云原生消息中间件\n * amqp - amqp 0.9.1 客户端\n * sarama - kafka 客户端\n\n\n# 文件/存储\n\n * minio - 对象存储服务器\n * rclone - 不同云存储之间同步文件\n * syncthing - 文件同步\n * fsnotify - 文件系统监控工具\n * reflex - 监听文件变更并执行命令\n * gohttpserver - http 静态文件服务器\n * xlsx - excel 读写包\n * excelize - 360 开源的 excel 工具包\n * gopdf - pdf 生成\n * rsc/pdf - pdf reader\n * seaweedfs - 分布式文件系统\n * go-fastdfs - 分布式文件存储服务\n * dragonfly - 基于 p2p 的分布式文件系统\n * filetype - 检测文件类型\n * afero - 文件操作包\n * fsync - 文件/目录同步\n * filebrowser - web file browser\n * bigfile - 文件传输管理系统\n * filetype - 文件类型与 mime 检测\n * go-app-paths - 跨平台检索目录文件\n * copy - 拷贝文件夹\n * lakefs - 类 git 文件对象存储\n * duplicacy - 无锁云备份工具，支持几乎所有存储方式\n * casaos - 家庭云系统\n * alist - 支持多存储的文件列表程序\n * unipdf - pdf 读写处理\n * mimetype - mime 类型与文件扩展检测\n * gocryptfs - 加密 overlay 文件系统\n * restic - 备份工具，使用现代的加密方法对数据进行安全的备份，支持\n\n\n# 模板引擎\n\n * gotemplatebenchmark - 给各 go 模板引擎做性能测试，当然也就包含了最全的模板引擎包\n * jet - 速度很快\n * amber - html 模板引擎\n * fasttemplate - simple and fast template engine for go\n * quicktemplate\n * mustache\n * ace\n * sprig - 常用模板方法\n * pongo2 - django 语法风格的模板引擎\n * plush\n\n\n# 代码生成\n\n * esc\n\n\n# 文本处理\n\n# markdown\n\n * blackfriday - markdown 解析器\n * lute - 结构化的 markdown 引擎\n * goldmark - markdown 解析器\n * docx2md - 转换 word 为 markdown\n * glamour - 命令行下渲染 markdown\n * go-md2man - 转换 markdown 为 man 手册内容\n * gomarkdown/markdown\n * html-to-markdown - 转换 html 为 markdown\n\n# html/css\n\n * dom - html dom 节点操作\n * obelisk - 保存 web 网页为 html 单页面\n * html2text - html 转 text\n * go-readability - 让 html 可读性更高\n * gomponents - 声明式视图组件，可以渲染成 html5\n * daz - html 组件组合，渲染 html\n * html-strip-tags-go - 去除 html 标签\n * bluemonday - xss 探测\n * cascadia - css 选择器\n * htmlquery - xpath 语法查询 html\n * xmlquery - xpath 语法查询 xml\n * xpath - xpath 语法\n * goquery - jquery 语法查询 html\n * css - css 选择器\n\n# 其他\n\n * go-runewidth - 字符长度计算\n * gpy - go 语言汉字转拼音工具\n * go-hashids - hashids 的 go 版本\n * go-pinyin - 汉语拼音转换工具 go 版\n * mahonia - 字符集编码转换\n * pangu.go - go 版本的 pangu，给中英文之间加空格\n * goorgeous - a go org syntax parser to html\n * sergi/go-diff - go 版本的 diff 工具包\n * sourcegraph/go-diff - go 版本的 diff 工具包\n * chroma - 代码语法高亮\n * syntaxhighlight - 代码高亮\n * kyokomi/emoji\n * enescakir/emoji\n * golang/freetype - freetype font rasterizer\n * prose - natural language processing library\n * minify - web 静态资源压缩(html/js/css/json/xml/svg)\n * inflection - pluralizes and singularizes english nouns\n * autocorrect - 自动给中英文之间加入合理的空格并纠正专用名词大小写\n * bleve - modern text indexing\n * etree - xml 解析&生成\n * go-xml\n * feeds - rss 内容生成\n * gofeed - rss & atom feeds 内容解析\n * sitemap - sitemap.xml 生成\n * yarr - rss 阅读软件\n * gogrep - 通过语法树搜索 go 源码\n * pipeit - 文本转换，清理和提取工具\n * regexp2 - 全功能正则表达式引擎。如果标准库的 regexp 满足不了你，可以尝试使用 regexp2\n * html2article - 基于文本密度的 html2article 实现\n * hostctl - hosts 命令行管理工具\n * go-shellwords - 解析命令行中字段\n * woke - 检查文本文件中是否存在歧视词汇\n * go-password-validator - 密码强度校验器\n * xurls - 从文本中提取 url\n * whatlanggo - 自然语言探测\n * go-enry - 检测编程语言\n * fuzzy - 字符串模糊匹配\n * godlp - 数据脱敏\n * zoekt - 文本搜索引擎\n\n\n# 文档\n\n * swag - swagger for go\n * gin-swagger - swagger for gin\n * go-swagger - swagger 2.0 implementation for go\n\n\n# 数学计算\n\n * decimal - 解决浮点数计算精度问题\n * fixed\n * apd - decimal 包\n * mathfmt - 将 latex 语法的注释转换为数学公式格式\n * q - 量子计算模拟器\n * accounting - 货币格式化\n\n\n# 日期时间\n\n * now\n * when - 自然日期时间解析\n * carbon - carbon 时间处理库的 go 语言实现\n * strftime - 时间格式化\n * dateparse - 解析任意未知格式的时间字符串\n\n\n# 配置\n\n * godotenv - .env 配置文件解析\n * go-yaml/yaml\n * ghodss/yaml\n * toml - toml 解析&编码包\n * ini - ini 配置文件解析\n * viper - 支持 json, toml, yaml, hcl, java 等配置文件\n * fig\n * multiconfig\n * configor\n * envconfig\n * confd - 配置管理工具\n * hcl - configuration language\n * env - 解析 env 环境变量到结构体中\n * configor\n * koanf\n * go-toml - toml\n * butler - adobe 开源的配置管理系统\n * envsubst - 环境变量替换\n\n\n# 爬虫\n\n * crawlab - 基于golang的分布式爬虫管理平台，支持python、nodejs、go、java、php等多种编程语言以及多种爬虫框架\n * colly - 网络爬虫框架\n * pholcus - 支持分布式的高并发、重量级爬虫软件\n * go_spider\n * muffet - 网站链接检查器\n * creeper\n * geziyor - 支持 js 渲染的快速爬虫框架\n * apollo - 一个爬虫工具\n * ferret - 声明式 web 数据抓取\n * gocrawl\n * antch\n * katana - 爬虫&蜘蛛框架\n\n\n# 数据库\n\n# sql解析\n\n * pingcap/parser - 兼容 mysql 的 sql 解析\n * xsqlparser - sql 解析\n * sqlparser - sql 解析\n * vitess-sqlparser - sql 解析\n * dbml-go - dbml 解析\n\n# 分布式事务\n\n * go-saga - saga 分布式事务实现\n * dtm - 跨语言的分布式事务管理服务，支持tcc、saga、xa等\n\n# 数据库相关\n\n * usql - 几乎支持全部 sql 与 nosql 数据库的命令行工具\n * gorm - gorm v2\n   * gorm v1\n   * gorm2sql - 根据 model struct 生成建表语句\n   * gorm-sharding - 基于 conn 层做 sql 拦截、ast 解析、分表路由、自增主键填充，对使用者透明\n * xorm\n * xormplus - xorm 的定制增强版本\n * gorose\n * sqlx - database/sql 扩展包\n * dbq - 数据库操作\n * gendry - 滴滴开源的sql builder\n * ozzo-dbx\n * squirrel - fluent sql builder\n * qb - the database toolkit for go\n * mgo\n   * globalsign/mgo - the mongodb driver for go\n   * mgo使用指南\n * kingshard - mysql proxy\n * soar - 对sql进行优化和改写的自动化工具\n * sqle - sql 审核工具\n * vitess - 用于部署、扩展和管理大型mysql实例集群的数据库解决方案\n * gh-ost - github 开源的在线更改 mysql 表结构的工具\n * sqler - write apis using direct sql queries with no hassle, let\'s rethink about sql\n * gocraft/dbr\n * gaea - 小米开源的基于 mysql 协议的数据库中间件\n * octosql - 支持多数据库的 sql 查询工具\n * goose - 数据库迁移工具\n * migrate - 数据库迁移工具\n * dbmate - 数据库迁移工具\n * ent - an entity framework for go\n * godb - a go query builder and struct mapper\n * go-nulltype\n * go-mysql - mysql 工具集\n * sqlittle - 纯读取 sqlite 文件\n * bifrost - mysql 同步到 redis、clickhouse 等服务的异构中间件\n * elasticsql - 转换 sql 成 elasticsearch dsl\n * pop - 基于 sqlx 封装的数据库 orm 工具\n * rel - modern database access layer for go\n * rdb - redis rdb 文件解析和生成工具，支持转 json、转 aof、寻找 big key、生成 rdb 文件及绘制内存火焰图等功能\n * bytebase - 基于网络、零配置、无依赖的数据库 schema 变更和版本控制管理工具\n * bun - sql 优先的 orm，写 sql 的方式写 go 代码，支持 postgresql、mysql、mssql、sqlite\n\n# 数据库客户端\n\n * go-mysql-driver - mysql 驱动\n * go-mssqldb - mssql 驱动\n * pq - postgresql 驱动\n * mongo-go-driver - mongodb 官方出品的 go 语言驱动\n * qmgo - mongodb 客户端\n * clickhouse-go - clickhouse 官方 go 语言客户端\n * go-clickhouse - clickhouse 客户端\n * go-sqlite3 - sqlite3 驱动\n * gohbase - hbase 客户端\n * redigo - redis 客户端\n * go-redis - redis 客户端\n * rueidis - redis 客户端\n * redsync - 基于 redis 的分布式锁\n * redislock - 基于 redis 的分布式锁\n * tiny rdm - redis 桌面客户端\n\n# 数据库引擎\n\n * etcd - kv 分布式存储\n * influxdb - 时间序列数据库\n * prometheus - 服务监控系统 & 时间序列数据库\n * tstorage - 时间序列数据库\n * thanos - 支持 prometheus 简化部署、高可用、分布式存储\n * cockroachdb - 分布式 sql 数据库\n * cayley - 图数据库\n * radondb - 基于 mysql 研发的新一代分布式关系型数据库\n * tidb - 分布式关系型数据库，兼容 mysql 协议\n * aresdb - uber 开源的 gpu 驱动的实时分析存储&查询引擎\n * leveldb - leveldb 的 go 实现\n * dgraph - 分布式图数据库\n * rqlite - 基于 sqlite 的轻量级分布式关系数据库\n * gaeadb\n * badgerdb - kv 数据库，支持 acid 事务\n * lbadd - 用 go 实现的分布式 sql 数据库\n * go-memdb - 建立在不可变 radix 树上的内存数据库\n * vectorsql - 应用于 iot 和大数据的 dbms 数据库，类似于 clickhouse\n * buntdb - 基于内存的kv数据库，支持磁盘持久化、acid事务\n * tinysql - 迷你分布式关系型数据库\n * tile38 - geo 数据库\n * redcon - 兼容 redis 协议的自定义 redis 服务，采用 buntdb 和 tile38 实现存储\n * genji - 文档内嵌型数据库\n * dolt - 像 git 一样操作数据库\n * rosedb - 简洁、高效的 kv 数据库，支持多种数据结构\n * lindb - 分布式时序数据库\n * mandodb - 一个示例项目，作者介绍如何从零开始实现一个小型的时序数据库\n * go-mysql-server - 解析 mysql 协议并优化 sql 的数据库引擎\n * milvus - 向量数据库\n * ferretdb - mangodb 替代品\n * lotusdb - 快速 kv 存储引擎，兼容 lsm 和 b+ 树\n * nutsdb - 可持久化、事务的内嵌 kv 数据库\n * olric\n\n\n# 缓存\n\n * gcache\n * bbolt - key/value store\n * bigcache\n * go-cache - kv 内存缓存\n * gomemcache - memcache 客户端\n * cache2go\n * ristretto\n * fastcache\n * freecache\n * godis - go 语言实现的 redis 服务器和分布式集群\n * groupcache - 分布式缓存\n * cachego - 支持 redis、bolt 等缓存接口\n * diskv - 基于硬盘的 kv 存储\n * pebble - 被 cockroachdb 使用的 kv 存储\n\n\n# 搜索推荐\n\n * wukong - 全文搜索引擎\n * go-elasticsearch - 官方 es 客户端\n * elastic - elasticsearch 客户端\n * go-mysql-elasticsearch - sync mysql data into elasticsearch\n * gse - go 语言分词\n * sego - go 中文分词\n * gojieba - "结巴"中文分词的 go 语言版本\n * riot - 全文搜索引擎\n * simplefts - 超简单的全文搜索引擎实现\n * blast - 全文搜索(archived)\n * fuzzy search - 文本模糊搜索\n * gorse - 单节点训练和分布式预测推荐系统引擎\n * gofound - 全文搜索引擎\n * zincsearch - 全文搜索引擎\n * bluge - 文本分词\n\n\n# 表单\n\n * validator\n * ozzo-validation - 使用代码指定规则，而非tag\n * go-tagexpr - 字节跳动开源的结构体标签表达式解释器\n * govalidator\n\n\n# auth\n\n * casbin - 权限控制管理\n * pam-ussh - uber\'s ssh certificate pam module\n * jwt-go - jwt for go\n * kataras/jwt - jwt 轻量级实现\n * cristalhq/jwt\n * sessions - 后端 session 服务\n * securecookie - cookie 加密/解密\n * goth - multi-provider authentication for go\n * branca - 号称比 jwt 更安全的 token 解决方案\n * gin-jwt - gin 框架的 jwt 中间件\n * authboss - web auth 系统\n * zitadel - 身份认证系统，支持各种认证模式\n\n\n# 加密/解密\n\n * 2fa - two-factor authentication on the command line\n * age - 文件加密工具（库）\n * circl - cloudflare interoperable, reusable cryptographic library\n\n\n# 视频\n\n * goav - ffmpeg 视频处理\n * lal - 直播流媒体网络传输服务器\n * bililive-go - 直播录制工具\n * screego - 通过浏览器共享开发者屏幕\n * livego - 直播服务器\n * monibuca - 流媒体服务器开发框架\n * olive - 支持虎牙等平台的直播录制\n * lux - 各大视频网站的视频下载工具\n\n\n# 图形处理\n\n * barcode - 条形码/二维码生成器\n * picfit - 图片操作、裁剪、管理服务器\n * gmfs - 图片操作、裁剪、管理服务器\n * besticon - favicon 服务\n * caire - 图片操作库\n * imaging - 图片操作库\n * gocaptcha - 验证码生成\n * base64captcha - 验证码\n * go-is-svg - 校验是否为 svg 图片\n * identicon - 根据用户的 ip 、邮箱名等任意数据为用户产生漂亮的随机头像\n * prominentcolor - 识别图片的主要颜色\n * dchest/captcha - 生成和验证图片或音频验证码\n * bimg - 图片处理\n * imaginary - 图片处理服务\n * primitive - 用原始几何图形绘制图形\n * orly - 生成你自己的o\'rly动物书封面\n * smartcrop - 智能裁剪图片\n * gift - 图片滤镜\n * germanium - 给代码生成图片\n * go graphics - 2d 图片渲染\n * canvas - 矢量图绘制\n * formulae - 数学公式解析、计算、图表绘制\n * imagor - 图像处理服务器\n * triangula - 给图片增加三角形纹样风格的滤镜\n * d2 - 一种将文本转换成图形的图表脚本语言\n * imgo - 简洁、链式调用的图像处理库\n * invoice - 发票生成工具，可通过参数和配置文件进行创建和管理各种类型的发票\n\n# 图片识别\n\n * go-face - 面部识别\n\n\n# 图表\n\n * go-echarts - echarts 图表库\n * gonum/plot - 图形绘制\n * pinhole - 3d 线框图绘制\n * globe - 地球线框图绘制\n * ink - go 中的 2d 图形框架\n * go-plantuml - 基于 go 源码生成 plantuml 图\n * go-diagrams - 通过代码生成图表\n * gocity - 3d 展示城市\n\n\n# 构建编译\n\n * mage - 类似于 makefile 的命令行工具，用于构建和运行 go 项目\n * goreleaser - go 多平台二进制文件打包、并支持发布到 homebrew 的工具\n * goxc - 跨平台编译工具（因 1.5 版本开始已自带交叉编译，故已不再维护）\n * task - 类似于 make 的构建工具\n * codegangsta/gin - 热编译工具\n * air - 热编译工具\n * gowatch - 热编译工具\n * fresh - 热编译工具\n * dh-make-golang - 自动构建 debian 包\n * gobinaries - 不用安装go就能编译安装go编写的程序\n * nfpm - deb、rpm、apk 等打包工具\n * gox - go 跨端编译工具\n * garble - 混淆代码\n * gobfuscate - 混淆代码\n * go-appimage - go 语言实现 appimage 打包工具\n\n# 静态资源内嵌\n\n * pkger - 将静态文件打包成 go 二进制文件\n * mewn - 静态文件嵌入打包到二进制文件\n * statik - 静态文件嵌入\n * go.rice\n * go-bindata - 将静态文件转换成 go 代码文件\n * vfsgen - 将静态文件打包成 http.filesystem 类型进行访问\n * packr\n\n\n# 优雅升级\n\n * tableflip - web 服务升级\n * selfupdate - 二进制文件自动升级\n * overseer\n * go-github-selfupdate - 依托 github 自动升级\n\n\n# 代码分析\n\n * reviewdog - code review 机器人\n * revive - 代码检查分析\n * golangci-lint - 代码质量检查分析工具\n * errcheck - 检测未处理的错误(errors)\n * staticcheck - 一系列的 go 代码静态分析工具\n * golint - google 官方出品的代码质量检测工具\n * goreporter\n * go-critic\n * gocloc - 分语言代码行数统计\n * coca - 代码统计分析\n * go report card - go 项目质量分析报告工具\n * ddsv-go - 死锁检测工具\n * golang/perf - 官方性能量化分析工具\n * goplantuml - 为 go 项目生成 plantuml 类图\n * gosize - 分析go二进制文件大小\n * shotizam - 分析 go 二进制文件的大小并输出到 sqlite3\n * goconst - 查找可以被常量替换的重复字符串\n * sploit - 帮助二进制分析和开发的库\n * perf - perf utilities for go\n * fgprof - go 性能分析工具\n * conprof - 协程分析\n * statsview - 实时 go 运行时统计数据可视化分析器\n * codesearch - 代码搜索工具\n * pyroscope - 可视化程序性能监控工具，支持多种语言\n * gosec - 代码安全性检查工具\n * gokart - 代码静态分析工具\n * gofumpt - gofmt 增强版代码格式化工具\n * noverify - php 代码分析工具\n * fieldalignment - 结构体字段内存对齐分析和自动修复工具\n * bearer - 代码安全扫描工具\n\n\n# 调试\n\n * go-spew - 变量打印工具\n * delve - debug 工具\n * gdlv - delve 界面版本\n * weaver - 跟踪 go 程序执行链路\n * repr - 变量打印工具\n * pp - 彩色变量打印工具\n * ffmt - 变量打印工具\n * gops - 谷歌官方出品的 go 程序监控调试工具\n * pprof\n * go-callvis - 可视化go程序的调用图\n * q - 自动打印变量类型并且格式化输出\n * litter\n * rdebug - 滴滴开源的一款用于 rd 研发、自测、调试的实用工具\n * debugcharts - go 内存占用可视化调试工具\n * gcvis - 实时可视化 gctrace\n * pkg/profile\n * statsviz - 在浏览器中实时查看 go 应用程序运行时统计信息（gc，memstats 等）\n * autopprof - 自动分析 pprof\n * stack - 捕获、操作、格式化调用栈信息\n * pretty - 打印变量\n * go-deadlock - 对 (rw)mutex 进行注入，并提供死锁检测\n * mmcloughlin/profile\n * gcnotifier - 当发生 gc 时通知\n * grmon - 命令行监控显示 goroutines\n * valast - 打印输出变量的 go/ast 结构，类似于 php 的 var_export 函数\n * lensm - go 汇编与源码对照查看工具\n * holmes - 基于规则的自动 go profile dumper\n\n\n# 测试\n\n * goconvey - 含web界面的单元测试框架\n * gomock - 谷歌出品的mock测试框架\n * gostub\n * monkey - (archived) monkey patching in go\n * gomonkey - 猴子补丁，对函数、变量等进行打桩，方便单元测试，fork 自 monkey\n * supermonkey - 让私有方法可测\n * mockery - 自动为接口生成 mock 代码\n * ginkgo - bbd 测试框架\n * fperf - 压测工具\n * gocheck\n * testify\n * gotests - 根据源码自动生成测试文件\n * testsql - 根据 sql 创建语句生成测试数据\n * httpmock - http mock\n * goblin - bdd 测试框架\n * go-faker/faker - struct data fake generator\n * gofakeit - 随机数据生成器\n * dmgk/faker\n * go-tprof - 包测试报告生成工具\n * go-fuzz - randomized testing for go\n * gofight - testing api handler\n * sqlmock - sql 测试\n * sqlbench - sql\n * silk - 基于 markdown 的接口测试\n * gock - http mock 测试\n * godog - bdd 测试框架 cucumber 的 go 版本\n * endly - e2e（端到端）测试\n * is - 迷你测试框架\n * terratest - 基础设施测试，比如 docker\n * agouti - web 驱动的验收测试框架\n * httpexpect - 端到端 http & rest 测试框架\n * gocov - 测试覆盖率\n * miniredis - redis 数据测试\n * htmltest - html 测试\n * gnomock - 无需 mock 的 go 代码测试框架\n * gunit - xunit 风格测试框架\n * quicktest\n * k6 - 负载测试工具\n * go-cover-treemap - 将覆盖率测试结果转换成 treemap 图\n * ztf - 禅道开源的自动化测试框架\n * moq - 为接口生成 mock 代码\n\n\n# 错误处理\n\n * errors\n * errorx\n * errwrap - go tool to wrap and fix errors with the new %w verb directive\n * erris - linter for errors.is and errors.as\n * eris - 旨在通过错误包装，堆栈跟踪和输出格式为你提供对错误处理的更多控制\n * errlog - 使用静态和堆栈跟踪分析来快速确定哪个函数调用导致的错误\n * juju/errors\n * go-fault - github 官方出品，基于标准库 http 中间件的故障注入库\n * merry - 支持堆栈、状态码的错误处理\n * cockroachdb/errors - 功能强大、可替代 errors 和 github.com/pkg/errors 的错误处理包\n * go-multierror - 支持错误列表\n\n\n# 安全\n\n * kunpeng - 开源poc检测框架\n * nmap - 安全审计工具 nmap 开发包\n * hetty - 用于安全研究的 http 工具包，具有 web 接口和代理日志查看器的拦截 http 代理\n * fibratus - windows 内核漏洞利用和跟踪工具\n * secure - http 安全中间件\n * nuclei - 基于yaml语法模板的定制化快速漏洞扫描器\n * gitleaks - 用于在 git 存储库中查找敏感信息和密钥的开源工具\n\n\n# 系统信息\n\n * go-hardware - 收集了一堆关于硬件信息的包\n * cpuid - cpu 信息\n * gopsutil - ps 功能包\n * go-sysinfo - 系统信息\n * go-locale - 跨平台语言检测库\n * go-ps - 系统进程信息\n * psgo - ps 命令实现\n * ghw - 硬件信息\n * machineid - 获取机器id\n\n\n# uuid\n\n * go.uuid - uuid 库\n * seqsvr - go + mysql 实现的分布式 id 生成服务\n * google/uuid - google 开源的 uuid 包\n * gofrs/uuid\n * snowflake - twitter snowflake ids\n * sonyflake - sony 版本的 twitter\'s snowflake\n * ulid - ulid go 语言实现\n * ksuid - k-sortable globally unique ids\n * go-nanoid - nanoid 实现\n * xid - 全局唯一 id 生成器\n\n\n# 日志\n\n * logr - 日志包标准接口\n * logrus - 日志记录包\n * zerolog\n * zap - uber 开发的日志记录包\n * seelog\n * logkit - 七牛开源的日志收集工具\n * gogstash - 类似于 logstash 的日志收集器\n * lumberjack - 日志文件切割\n * file-rotatelogs - 日志文件切割\n * go-syslog - 极速 syslog 解析器\n * glog\n\n\n# 监控告警\n\n * openfalcon - 小米开源的监控系统\n * prometheus - 服务监控系统 & 时间序列数据库\n * grafana - 分析监视平台, 支持 graphite, elasticsearch, opentsdb, prometheus, influxdb 等数据源\n   * grabana - 用 go 代码快速创建 grafana dashboards\n * jaeger - 分布式追踪系统\n * go-osstat - 系统指标统计\n * grafterm - metrics dashboards on terminal\n * mymon - mysql 运行监控\n * pingme - 支持多消息平台的服务可用性报警命令工具\n * supervisord - go 语言实现 supervisor\n * grafana tempo - 分布式追踪系统\n * easeprobe - 服务探活工具并通知\n * uptrace - apm 工具，支持 opentelemetry 追踪、指标和日志\n * nightingale - 滴滴基于 openfalcon 开源的监控系统\n\n\n# 统计分析\n\n * fathom - web 站点统计\n * veneur - 分布式实时数据处理管道\n * gonum - 科学计算相关\n\n\n# 容器技术\n\n * moby - docker\n * docker-ce\n * rancher - 全栈化企业级容器管理平台\n * gorsair\n * docui - tui client for docker\n * podman - 管理和运行任何符合 oci 规范的容器和容器镜像\n * skopeo - 镜像管理工具\n * buildah - 构建 oci 容器镜像的工具\n * go-docker - 用 go 实现 docker 核心功能\n * packer - 轻量级的镜像定义工具\n * cosign - 容器签名和验证\n * slimtoolkit - 检查、缩小和调试容器\n\n\n# 集群管理\n\n * nomad - 集群管理器和调度器\n * openshift origin - red hat 开发的容器化软件解决方案\n\n# kubernetes\n\n * kubernetes - 容器调度管理平台\n * k0s - 最小体积的 k8s 发行版\n * sealos - 一条命令部署 kubernetes 高可用集群\n * kubeeye - 通过配置规则发现 kubernetes 上的各种问题\n * endpoints-operator - k8s内部服务访问外部服务的具备探活功能的4层lb\n\n\n# 机器学习\n\n * goml - 机器学习库\n * golearn - 一个 "开箱即用" 的机器学习库\n * glow - 易用的分布式计算系统\n * gobot - 机器人和物理计算语言库\n * olivia - 神经网络\n * pico - 基于像素强度比较的物体检测纸张的纯 go 脸部检测库\n * tfgo - tensorflow in go\n * prophecis - 微众银行自研的一站式云原生机器学习平台\n * aid - 机器学习ops平台，发现、部署、优化\n * sqlflow - sql引擎+ai引擎\n\n\n# 人工智能\n\n * go-openai - openai api go 客户端 sdk\n * localai - 低成本的硬件上运行模型计算的本地计算框架，支持多种模型，提供兼容 openai 接口协议的 rest api\n\n\n# 算法\n\n * gods - go 实现了多种数据结构\n * dragonboat - 多组 raft 共识算法库\n * eliben/raft - raft 算法\n * hashicorp/raft - raft 算法\n * graft - raft 算法\n * golang-lru - lru 算法实现\n * tinylru\n * finn - fast raft framework using the redis protocol for go\n * xorfilter\n * priyankchheda/algorithms - 各种算法的 go 语言实现\n * meow - meow hash\n * basalt - 高性能的分布式的专门空间优化的 bitmap 服务, 杜绝 bloomfilter 和 cuckoofilter 的误判\n * go-blurhash - blurhash，是模糊图片的一种哈希算法\n * xxhash - xxhash 哈希算法实现\n * go-multihash - 各种 hash 算法实现\n * memberlist - 基于 gossip 协议实现的管理集群成员和成员失败检测的开发包\n * backoff - 指数退避算法(exponential backoff)\n * fsm - 有限状态机\n\n\n# 数据结构\n\n * go-datastructures\n * play-with-data-structures - 「玩转数据结构」课程的 go 语言实现版本\n * hashmap\n * siphash - siphash-2-4\n * bigslice\n * golang-set - the missing set collection\n * rbang - r!tree 实现\n * rtreego - r-tree\n * google/btree - b-tree\n * tinybtree - b-tree\n * dataframe-go - 用于数据统计和操作的包\n * go-set - 集合工具包\n * orderedmap - 有序字典\n * trie\n * slim - 空间高利用率的数据结构\n * bitset - 位集合及其操作\n * bloom - bloom filters\n * roaring - 压缩位图\n * go-immutable-radix - radix 树\n\n\n# 依赖注入\n\n * go-autowire - 使用注解自动生成 wire - 依赖注入\n * dig\n * fx\n\n\n# json\n\n * gjson - json 解释器\n * sjson - json 修改工具\n * fastjson - fast json parser and validator for go\n * jsonparser\n * ffjson\n * json-iterator - 滴滴开源的 json 解析器\n * gojsonq - json/yaml/xml/csv 等数据查询\n * easyjson\n * go-jsonc - 将带注释的 json 转为无注释的\n * jin - json 操作工具包，同时具有标准库和类似 tidwall/gjson 和 tidwall/sjson 的功能\n * hujson - 支持注释的 json 解码\n * pkg/json - json decoder\n * colorjson - 终端中打印彩色 json\n * jid - json 数据解析读取工具\n * jsonc - 支持注释与逗号\n * sonic - 字节跳动开源的 json 解析器&修改器\n * go-json\n * jsonquery - xpath 语法查询 json\n * fx - 命令行 json 显示\n\n\n# 依赖管理\n\n * goproxy.io - goproxy 代理服务\n * goproxy.cn - 更适合国内用户的代理服务\n * gopm - go 包管理工具\n * govendor - vendor 包管理工具\n * gom - 包版本管理工具\n * rvflash/goup - 检查包版本是否有更新\n * owenthereal/goup - go 多版本管理\n * athens - goproxy 代理服务\n\n\n# 微服务\n\n * istio [中文文档] - 大型微服务系统管理工具\n * goa\n * micro - 微服务工具\n * go micro - 微服务框架\n * go kit - go 微服务工具集\n * gokit cli - go kit 脚手架\n * gogo\n * go-chassis\n * kite\n * kratos - b站开源的微服务框架\n * temporal - 微服务编排平台\n * serf - 服务编排管理平台\n * open policy agent - 通用策略引擎，cncf 孵化项目\n * gizmo - 微服务工具集\n * mosn - 用于边缘和服务网格的云原生网络数据平面\n * erda - 为企业提供 devops、微服务治理、多云管理的 paas\n * service weaver\n * consul - 服务发现、配置管理中心服务\n * traefik mesh - 简单的服务网格\n\n\n# serverless\n\n * openfaas - serverless functions made simple(功能服务化的 faas 框架)\n * faasd - 轻量级 faas 引擎\n * fn - 事件驱动的 faas\n * riff - 基于 kubernetes 的 faas\n * nuclio - 实时事件与数据的 serverless 框架\n * flogo - 事件驱动的 serverless 框架\n * dapr - 微软开源的云和边缘计算的微服务构件\n * kubeless\n * fission - 基于 kubernetes 的 serverless\n * pulumi\n * knative\n * fx\n * ironfunctions\n * schollz/faas - 让任何包的函数变成一个 http 接口\n * vanus - 无服务事件流处理系统\n\n\n# devops\n\n * act - 本地运行 github actions\n\n\n# 持续集成/部署\n\n * cds - 持续集成服务\n * gopub\n * codepub\n * syncd - 代码部署工具\n * drone - 基于 docker 的持续发布平台\n * cyclone - 持续集成&发布平台\n * tbls - 用于记录数据库文档的 ci 友好工具\n * woodpecker - fork 自 drone\n * dagger - 基于容器的 ci/cd 工具\n\n\n# git\n\n * gogs - 类似于 gitlab 的 git 服务器\n * gitea - 由 gogs 分叉出的 git 服务器\n * go-git - go 实现的 git 操作\n * gitin - commit/branch/status explorer for git\n * hub - github 命令行工具\n * git-o-matic - 一个监控 git 仓库变化和自动 pull/push 的工具\n * gitbase - sql 的方式查询 git 日志\n * git-chglog - changelog 管理工具\n * chglog - changelog 管理工具\n * lazyhub - github 的终端 ui 客户端\n * goaction - 在 go 中编写 github action\n * bit - git 命令增强版，支持文件和分支名称自动完成、命令和标志建议\n * go-github - github api 操作库\n * askgit - 通过 sql 访问 git 仓库信息\n * git2graph - 根据 git 仓库提交记录生成结构图\n * lazygit - git 终端 ui\n * gh-dash - github cli（gh）漂亮终端面板\n * soft serve - 命令行式自托管 git 服务器\n * git lfs - 处理大文件的 git 扩展\n\n\n# 限流器\n\n * tollbooth - simple middleware to rate-limit http requests\n * ratelimit\n * ratelimit\n * go-rate\n * circuit - 熔断器\n * uber-go/ratelimit\n * sentinel - 阿里巴巴开源的面向分布式服务架构的流量控制组件 go 语言版本\n * gohalt - 限流\n * gobreaker - 熔断器\n * ulule/limiter\n\n\n# 编译器\n\n * tinygo - 一个适用于微控制器、webassembly 和命令行工具的 go 编译器\n * minigo - a go compiler from scratch\n * llir/llvm - llvm 编译器\n * jit-compiler - jit 编译器\n * go+ - 七牛云开源面向数据科学的语言，完全兼容go语言\n\n\n# 解释器\n\n# 语言解释器\n\n * participle - 通用的自定义语法解析包\n * gopherlua - vm and compiler for lua in go\n * go-lua - a lua vm in pure go\n * dclua - go lua compiler and vm\n * otto - javascript 解释器\n * goja - ecmascript 5.1(+) 实现\n * v8go - execute javascript from go\n * gpython - python interpreter on go\n * grumpy - 转换 python 为 go 代码，谷歌开源\n * starlark-go - starlark in go\n * avo - x86 汇编程序构建器\n * wagon - webassembly 解释器\n * gopherjs - 把 go 代码编译成 javascript 代码\n * yaegi - go 语言解释器\n * properties - java properties scanner for go\n * jvm.go - jvm\n * gobasic - a basic interpreter written in golang\n * golisp - lisp 解释器\n * dst - go decorated syntax tree\n * mvdan/sh - shell 解析、格式化、接口\n * tdewolff/parse - 通用词法分析器 lexer，并内置支持解析 html/css/json/xml/js/svg 语法\n * joker - clojure\n\n# php\n\n * z7zmey/php-parser - php ast 语法解析\n * deuill/go-php - php bindings for go\n * goridge - high-performance php-to-golang ipc bridge\n * roadrunner - 高性能php应用服务器，支持负载均衡及进程管理\n * vkcom/php-parse - php ast 语法解析\n\n# 自定义解释器\n\n * cue - configure unify execute(validate and define text-based and dynamic configuration)\n * cel-go - common expression language(cel 的 go 实现)\n * math-engine - 使用 go 实现的数学表达式解析计算引擎库，学习语法解析很适用\n * gval - 表达式计算\n * expression-parsing\n * goexp - recursive descent expression parser in go\n * goastch - go ast 语法解析\n * tdop\n * swallow\n * anko\n * expr - 编译&执行字符串中的表达式\n * tengo - 用 go 编写的脚本语言\n * v - go 编写的语言\n * kumarujjawal/bison\n * monkey\n * govaluate\n * compiler - 将自定义语法代码编译成 x86-64 assembly\n * elvish - 交互式 shell 语言\n * qlbridge - go sql runtime engine\n * yql - sql where 风格的规则引擎\n * flux - influxdb 数据语言\n * spiker - go 编写的简单规则表达式执行器，支持自定义函数和流程控制，适用于业务规则复杂的场景\n * gocc - 解析器生成器，可以将指定的文法转换为 go 语言的解析器程序代码，用于编译和解析特定类型的源代码\n\n\n# 代码生成\n\n * jennifer - go 代码生成\n * ifacemaker - 根据结构体方法生成接口\n * gg - go 代码生成\n\n\n# 编辑器\n\n * micro - 基于终端的编辑器\n * sourcegraph - 代码搜索&导航\n\n\n# 运行器\n\n * gore - 在线运行 go 代码\n * nodebook - 在线运行多种语言\n * go-pry - 像 python、r、php 等在终端交互式输入与运行 go 代码\n\n\n# 查询语言\n\n * graphql - go 实现的 graphql\n * graphql-go\n * gqlengine - 基于 graphql-go 实现\n * rql - rest 资源查询语言\n * thunder - graphql 服务构建框架\n * gqlgen - 构建 graphql 服务器的包\n * super-graph - 无需编写代码即可在 go 项目中构建复杂的 graphql api\n\n\n# 游戏相关\n\n * nano - 游戏开发框架\n * leaf\n * einx\n * cloudretro - 游戏云服务框架\n * g3n - go 3d game engine\n * ebiten - 2d 游戏库\n\n\n# 桌面开发\n\n# gui\n\n * lorca - 用 go 编写 html5 桌面程序，依赖 chrome 进行 ui 渲染，但却不把 chrome 打包到应用中\n * webview - 用 go/c/c++ 构建跨平台的桌面软件\n * walk - windows gui toolkit\n * go-gtk - go bindings for gtk\n * andlabs/ui - platform-native gui library for go\n * fyne - material design 风格的 gui\n * go-gl - go bindings for opengl (generated via glow)\n * therecipe/qt - 基于 qt 的跨全平台 ui 包\n * giu - 基于 dear imgui 的跨平台 gui 框架\n * go-app - 一个 webassembly 框架，用于使用 go，html 和 css 构建 gui 应用\n * wails - 使用 go 和 web 技术创建桌面应用程序\n * chromedp - 纯 go 语言实现的驱动浏览器的 chrome devtools protocol，可用于爬虫、反爬虫、测试等场景\n * rod - 一个为简化自动化和爬虫设计的 devtools driver，利用浏览器的 devtools 可编程接口来操控浏览器\n * go-astilectron - 基于 electron 的跨平台开发\n * gio - 跨平台 ui 框架，支持移动应用\n * nucular - 基于 gio 的实现\n * govcl - 跨平台的 gui 包\n * vugu - webassembly ui 框架\n * gogi - 2d/3d gui 框架\n * systray - 跨平台支持菜单栏管理\n * go-flutter - 绑定 flutter 到桌面应用\n * nuxui\n\n# 桌面辅助包\n\n * pkg/browser - 在浏览器中打开文件、url\n * macdriver - macos 原生 api\n * gon - 为 macos 签名和公证\n\n# 桌面应用\n\n * xbar - 基于 wails.app 开发的 macos 菜单栏管理\n * 阿里云盘小白羊版 - ui由flutter构建\n\n\n# 移动端\n\n * golang/mobile - go support for mobile devices\n\n\n# 协程/线程\n\n * ants - 协程池\n * tunny\n * go-workers - 安全地并发运行一组 worker，通过 channel 进行输入输出\n * machine - 受 errgroup.group 启发的协程管理\n * thread\n * conc - 更好用的结构化并发控制\n * zeropool - 零回收、类型安全的协程池\n * workerpool - 无阻塞队列任务池\n * pond - 协程池\n\n\n# 任务/定时器\n\n * rxgo - go 版 reactivex，简单方便的处理异步数据流\n * grift - go based task runner\n * cron - a cron library for go\n * gocron - 任务定时调度器\n * jobrunner\n * curlyq - 后台任务处理库\n * overtalk/task - 任务的管理&执行，支持自定义次数的重发\n * ppgo_job - 定时任务管理系统\n * gocelery - celery 的 go 语言实现\n * machinery - 通过分布式消息实现异步任务调度\n * dkron - 分布式任务调度系统\n * grit - 基于 multitree 实现的任务管理\n * asynq - 异步分布式任务队列\n * cronsun - 分布式任务系统\n\n\n# 流处理\n\n * benthos\n * gostream\n * watermill\n * go-streams\n * goflow\n * cadence (cadence web ui) - uber开源的分布式工作流引擎，主要用于微服务编排和分布式事务等场景\n\n\n# 微信\n\n * weapp - 微信小程序 sdk\n * wechat - wechat sdk for go\n * wechat-go - 微信 web 版 api 的 go 实现\n\n\n# sdk\n\n * gopay - qq、微信（wechat）、支付宝（alipay）的go版本sdk\n * alipay - 支付宝sdk\n\n\n# 区块链\n\n * hyperledger fabric - 基于区块链的超级账本\n * go-ethereum - 以太坊协议的官方 go 语言实现\n * bbgo - 用 go 编写的加密货币交易框架\n * btcd - 比特币实现\n\n\n# 开发辅助包\n\n * cvt - 任意数据类型转换，支持自定义类型、提取结构体字段和值\n * copier - struct 之间拷贝值\n * cast - 数据类型转换\n * diff - 结构体&值比较\n * go-extend\n * com - 工具包\n * php2go - go 实现的 140+ 个 php 函数功能包\n * gommon - common packages for go\n * reflect2 - reflect api without runtime reflect.value cost\n * mapstructure - 将 map 值转换到结构体中\n * naza - go语言基础库\n * automaxprocs - 自动设置 gomaxprocs\n * c2go - 将 c 代码转换为 go 代码的工具\n * rnm - 代码重构辅助工具\n * memviz - 图形化数据结构\n * underscore.go\n * go-testdeep - 非常灵活的深度比较包，扩展了 go 测试包\n * go-model - struct 操作包\n * concurrent-map - 并发安全 map\n * goleak - 检测 goroutine 泄漏\n * guregu/null - sql/json的null处理包，提供替代类型\n * stats - 标准数字统计\n * chronos - 静态竞争检测器\n * collection - 替代原生的 slice\n * rf - 代码重构工具\n * bytebufferpool - byte buffers pool\n * bpool - byte buffers pool，支持 bytes.buffers\n * mergo - 合并结构体和字典数据\n * go-funk - 基于反射实现的常用函数\n * lo - 基于 1.18+ 泛型的常用函数\n * juniper - 基于泛型实现常用的容器、迭代器、数据流等功能\n * mergo - 合并结构体和字典\n * xstrings - 字符串相关函数\n * pie - slice/map 链式处理\n\n\n# 代码生成\n\n * chimeracoder/gojson - 根据 json 生成结构体\n * db2struct - 根据表结构生成结构体\n * smallnest/gen - 根据表结构生成结构体\n * sqlc - 根据 sql 语句生成 go 代码\n * xo - 根据表结构或查询语句自动生成 go 代码\n\n\n# 系统开发\n\n * linuxkit - 为容器构建安全、便携、可移植操作系统的工具包\n * go-systemd - 绑定 systemd\n * lima - linux-on-mac ("macos subsystem for linux", "containerd for mac")\n * gopher-os - 一个兼容 linux 的 64 位 posix 风格系统\n * gouring - 不依赖 cgo 实现系统调用\n\n\n# 未归类\n\n * go-playground - 比官方更好用的 go playground\n * robotgo - golang 跨平台自动化系统，控制键盘鼠标位图和读取屏幕，窗口句柄以及全局事件监听\n * go-homedir\n * i18n - i18n 多语言工具包\n * go-i18n - 多语言工具包\n * paginater - 分页工具\n * gls - goroutine local storage\n * mcuadros/go-version - 版本号比较\n * go-semver - 语义版本\n * semver - 另一个语义版本\n * hashicorp/go-version\n * metabolize - decodes html meta tags into a golang struct\n * otp - 一次性密码工具包(one time password utilities)\n * misspell - 常拼写错误的英语单词\n * crdt - crdt(convergent and commutative replicated data types)最终一致性算法的实现\n * script - making it easy to write shell-like scripts in go\n * sysadmin-utils\n * licenseclassifier - 识别文件中的 license 类型\n * go-license-detector\n * rose - 在 html 中嵌入和运行 go 代码\n * esbuild - javascript 构建打包工具\n * clipboard - 剪切板\n * clipboard - 剪切板\n * clipboard - 剪切板\n * timeliner - 搜集整理个人在社交网站上的数据并索引成时间线\n * hc - homekit 平台开发框架\n * address - 地址处理库，支持多国语言\n * webhook - 可执行 shell 命令的 web hook 服务\n * webhookd - 为 shell 脚本提供 web hook 服务\n * go-cid - cid spec go 语言实现\n * gorush - app 消息通知服务\n * eventbus - 事件总线\n * go-winio - 为 win32 io 操作提供接口支持\n * fq - 以 jq 语法读取二进制数据/文件\n * lego - let\'s encrypt client and acme library\n\n\n# logo\n\n * gophers\n\n\n# 工具\n\n * syndbg/goenv - go 版本管理\n * wfarr/goenv - go 版本管理\n * gvm - go 版本管理\n * goland - ide 软件\n * visual studio code\n\n\n# 资源站点\n\n * go 101\n * go 语言中文网\n * golang 中国\n * go-zh\n * golang sizeof tips - 输入结构体定义，会显示内存布局\n * golang programs\n * golang bot',charsets:{cjk:!0},lastUpdated:"2023/12/19, 10:12:18",lastUpdatedTimestamp:1702951938e3},{title:"个人简介",frontmatter:{title:"个人简介",permalink:"/about/",categories:["关于"],description:null,date:"2023-11-24T16:30:27.000Z",tags:[null],author:{name:"Pursuit",link:"https://github.com/unique-pure"},readingShow:"top"},regularPath:"/07.%E5%85%B3%E4%BA%8E/01.about.html",relativePath:"07.关于/01.about.md",key:"v-4a02579b",path:"/about/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:45:17",lastUpdatedTimestamp:1700822717e3},{title:"友链",frontmatter:{title:"友链",permalink:"/friend/",categories:["友链"],description:null,date:"2023-11-24T16:30:27.000Z",tags:[null],author:{name:"Pursuit",link:"https://github.com/unique-pure"},readingShow:"top"},regularPath:"/08.%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5/01.%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5.html",relativePath:"08.友情链接/01.友情链接.md",key:"v-30e085c9",path:"/friend/",headers:[{level:2,title:"我的友链",slug:"我的友链",normalizedTitle:"我的友链",charIndex:2},{level:2,title:"友链申请",slug:"友链申请",normalizedTitle:"友链申请",charIndex:195}],headersStr:"我的友链 友链申请",content:'# 我的友链\n\npursuit\n\n💻学习📝记录🔗分享\n\n- name: pursuit\n  desc: "💻学习📝记录🔗分享"\n  avatar: /img/avatar.jpeg # 头像\n  link: https://unique-pure.github.io/ # 链接\n  bgColor: "#f8f9fa"\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 友链申请\n\n * 申请要求：\n   * ✅ 网站能够正常访问\n   * ✅ 网站类型为个人博客\n   * ✅ 网站需要包含本站友链\n   * ✅ 网站需要开通一年以上，且原创文章不少于 50 篇\n   * ❌ 不接受商业性或包含侵入性广告的站点\n   * ❌ 不接受违反中华人民共和国法律法规的站点\n\n如果符合如上条件，可在本页面评论区留言您的友链信息，格式：(点击代码块右上角一键复制)\n\n- name: pursuit # 昵称\n  desc: 💻学习📝记录🔗分享 # 介绍\n  avatar: https://github.com/unique-pure/NewPicGoLibrary/blob/main/img/67893254.jpeg # 头像\n  link: https://unique-pure.github.io/ # 链接\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n申请前记得先添加本站哦~',normalizedContent:'# 我的友链\n\npursuit\n\n💻学习📝记录🔗分享\n\n- name: pursuit\n  desc: "💻学习📝记录🔗分享"\n  avatar: /img/avatar.jpeg # 头像\n  link: https://unique-pure.github.io/ # 链接\n  bgcolor: "#f8f9fa"\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 友链申请\n\n * 申请要求：\n   * ✅ 网站能够正常访问\n   * ✅ 网站类型为个人博客\n   * ✅ 网站需要包含本站友链\n   * ✅ 网站需要开通一年以上，且原创文章不少于 50 篇\n   * ❌ 不接受商业性或包含侵入性广告的站点\n   * ❌ 不接受违反中华人民共和国法律法规的站点\n\n如果符合如上条件，可在本页面评论区留言您的友链信息，格式：(点击代码块右上角一键复制)\n\n- name: pursuit # 昵称\n  desc: 💻学习📝记录🔗分享 # 介绍\n  avatar: https://github.com/unique-pure/newpicgolibrary/blob/main/img/67893254.jpeg # 头像\n  link: https://unique-pure.github.io/ # 链接\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n申请前记得先添加本站哦~',charsets:{cjk:!0},lastUpdated:"2023/11/24, 18:39:24",lastUpdatedTimestamp:1700822364e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1,readingShow:"top"},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-0e8002ab",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/21, 20:55:58",lastUpdatedTimestamp:1700571358e3},{title:"Tmux教程",frontmatter:{title:"Tmux教程",date:"2022-01-21T00:00:00.000Z",tags:["Tmux"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},categories:["工具","开发工具"],permalink:"/pages/c81c74/",readingShow:"top"},regularPath:"/02.%E5%B7%A5%E5%85%B7/03.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/02.Tmux%E6%95%99%E7%A8%8B.html",relativePath:"02.工具/03.开发工具/02.Tmux教程.md",key:"v-1e268ac6",path:"/pages/c81c74/",headers:[{level:2,title:"1 tmux使用教程",slug:"_1-tmux使用教程",normalizedTitle:"1 tmux使用教程",charIndex:2},{level:3,title:"1.1 tmux安装",slug:"_1-1-tmux安装",normalizedTitle:"1.1 tmux安装",charIndex:17},{level:3,title:"1.2 tmux简介",slug:"_1-2-tmux简介",normalizedTitle:"1.2 tmux简介",charIndex:185},{level:3,title:"1.3 tmux结构",slug:"_1-3-tmux结构",normalizedTitle:"1.3 tmux结构",charIndex:714},{level:3,title:"1.4 tmux操作",slug:"_1-4-tmux操作",normalizedTitle:"1.4 tmux操作",charIndex:998},{level:4,title:"1.4.1 前缀键",slug:"_1-4-1-前缀键",normalizedTitle:"1.4.1 前缀键",charIndex:1074},{level:4,title:"1.4.2 会话(session)操作",slug:"_1-4-2-会话-session-操作",normalizedTitle:"1.4.2 会话(session)操作",charIndex:1456},{level:4,title:"1.4.3 窗口(window)操作",slug:"_1-4-3-窗口-window-操作",normalizedTitle:"1.4.3 窗口(window)操作",charIndex:2801},{level:4,title:"1.4.4 面板(pane)操作",slug:"_1-4-4-面板-pane-操作",normalizedTitle:"1.4.4 面板(pane)操作",charIndex:3384},{level:2,title:"2 参考文献",slug:"_2-参考文献",normalizedTitle:"2 参考文献",charIndex:5072}],headersStr:"1 tmux使用教程 1.1 tmux安装 1.2 tmux简介 1.3 tmux结构 1.4 tmux操作 1.4.1 前缀键 1.4.2 会话(session)操作 1.4.3 窗口(window)操作 1.4.4 面板(pane)操作 2 参考文献",content:'# 1 tmux使用教程\n\n\n# 1.1 tmux安装\n\n# Ubuntu 或 Debian\n$ sudo apt-get install tmux\n\n# CentOS 或 Fedora\n$ sudo yum install tmux\n\n# Mac\n$ brew install tmux\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 1.2 tmux简介\n\ntmux是一个非常优秀的终端复用器（terminal multiplexer），其可以使用一系列的终端session，它使您可以在一个终端中的多个程序之间轻松切换、分离它们（它们继续在后台运行）并将它们重新附加到不同的终端。\n\nsession：我们知道，在windows命令行中我们打开一个终端窗口，然后输入命令实现与计算机的交流。而这种用户与计算机的这种临时的交互就叫做session。\n\ntmux的主要功能有：\n\n * 分屏，即允许在单个窗口中访问多个会话。这对我们同时运行多个命令行程序非常有用。\n * 允许断开Terminal连接后，继续运行进程。这样，我们可以随时随地放心的进行操作，即使工作进行到一半突然断开，我们打开tmux仍可以重新进入到操作现场。\n * 会话共享（适用于结对编程或者远程教学）。我们可以将tmux的会话地址分享给其他人，这样他们就可以通过SSH接入该会话。更骚的是，如果你要给其他人演示远程服务器的操作，不必一直盯着屏幕，我们可以借助tmux，他就可以完全进入你的会话。\n\n当然，tmux的功能还有很多，相比于其他的终端复用器，tmux更易用也更强大，这也是我们为什么要学习tmux的原因。\n\n\n# 1.3 tmux结构\n\ntmux是采用C/S模型构建的，我们输入tmux即相当于开启了一个服务器，此时默认将新建一个session，然后再session中新建一个window，window中新建一个pane。其联系为：一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。\n\n以下即是实例： tmux: session 0: window 0: pane 0 pane 1 pane 2 ... window 1 window 2 ... session 1 session 2 ...\n\n\n\n\n# 1.4 tmux操作\n\n注：以下操作大多数都会给出命令和对应的快捷键，如果用于学习，建议两种操作都要学会，但在平常操作中，使用快捷键是更方便的。\n\n# 1.4.1 前缀键\n\ntmux提供了很多的快捷键。特别的是所有的快捷键都需要通过前缀键唤起，默认的快捷键为ctrl + b。我们可以通过tmux list-keys命令来查看所有快捷键指令。\n\n当然如果觉得ctrl + b不好用，习惯用其他的键，这里提供修改前缀键的方法如下：\n\n# 首先打开文件~/.tmux.conf\nvim ~/.tmux.conf\n# 设置前缀为Ctrl + a。\nset -g prefix C-a\n# 解除Ctrl + b与前缀的对应关系。\nunbind C-b\n# 绑定ctrl + a 成为新的指令前缀。\nbind C-a send-prefix\n#然后让它生效。我们也可以直接重启让它生效。\nsource ~/.tmux.conf\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 1.4.2 会话(session)操作\n\n * 新建会话：tmux new -s sessionName。\n   \n   这样，我们就可以创建一个名为sessionName的会话了。当然我们也可以直接简写为tmux，这样会新建一个无名称的会话。但为了我们方便管理，所以建议还是指定会话名称。\n\n * 断开当前会话：tmux detach。\n   \n   这样，我们就可以断开当前会话，但是会话 还是会在后台运行。当然，我们还可以使用快捷键：先按ctrl + b，再按 ctrl + d即可退出。\n   \n   注意：这个并没有真正的关闭会话。\n\n * 进入已存在的会话：tmux a -t sessionName或者直接输入tmux a。\n   \n   前者可以指定进入的sessionName会话，而后者是默认进入第一个会话。其中的a命令实际上就是attach，我们可以简写为a。\n\n * 关闭会话：tmux kill -session -t sessionName或者tmux kill -server。\n   \n   我们可以使用tmux的kill命令，其中kill命令有四种：kill -pane, kill -server, kill -session, kill window。根据需求我们使用自己需要的命令，需要注意的是，根据前面的联系，我们关闭了session，那么其中的所有pane和window也都不存在了，同理关闭server,那么所有session也都不存在了。所以这里即是使用kill -session和kill -server，前者关闭sessionName这个会话，后者关闭所有的会话。\n\n * 查看所有的会话：tmux ls。\n   \n   \n\n * 切换会话：switch命令用于切换会话。\n   \n   # 使用会话编号来切换\n   tmux switch -t 0\n   # 使用会话名称来切换\n   tmux switch -t sessionName\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n\n * 重命名会话：tmux rename-session -t sessionName new Name。\n\n * 常用会话操作快捷键。\n   \n   前缀       指令         功能\n   Ctrl+b   d          断开当前会话\n   Ctrl+b   D          选择要断开的会话\n   Ctrl+b   $          重命名当前会话\n   Ctrl+b   s          列出当前会话用于选择并切换\n   Ctrl+b   r          强制重载当前会话\n   Ctrl+b   ctrl + z   挂起当前会话\n\n * tmux中复制/粘贴文本的通用方法。\n   \n   (1).按下Ctrl + b前缀键，然后按[；\n   \n   (2).用鼠标选中文本，然后被选中的文本会被自动复制到tmux的剪贴板；\n   \n   (3).按下Ctrl + b后前缀键，然后按]，会自动将剪贴板的内容粘贴到光标处。\n\n# 1.4.3 窗口(window)操作\n\n * 新建窗口：tmux new-window -n windowName。\n   \n   如此我们可创建一个新的名为windowName的窗口。当然我们也可以直接输入tmux new-window来创建一个没有指定名称的窗口。 创建一个新窗口后，原窗口我们是看不到了的，但依然存在。\n\n * 切换窗口：tmux select-window -t windowName。\n\n * 重命名窗口：tmux rename-window windowName。\n\n * 常用窗口操作快捷键。\n   \n   前缀       指令      功能\n   Ctrl+b   c       新建窗口\n   Ctrl+b   &       关闭当前窗口，需要输入y or n确认\n   Ctrl+b   编号      切换到指定编号的窗口\n   Ctrl+b   p       切换到上一个窗口\n   Ctrl+b   n       切换到下一个窗口\n   Ctrl+b   w       显示窗口列表用于切换。\n   Ctrl+b   ,（逗号）   重命名当前窗口\n   Ctrl+b   .       修改当前窗口编号（适用于窗口排序）\n   Ctrl+b   f       快速定位到窗口（输入关键字匹配窗口）\n\n# 1.4.4 面板(pane)操作\n\n * 划分面板。\n   \n   注意，此划分是针对当前选中的面板，面板可以无限划分。\n   \n   # 划分成上下两个面板\n   tmux split-window\n   #划分成左右两个面板\n   tmux split-window -h\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n   \n   \n\n * 切换面板。\n   \n   tmux select-pane命令用来移动光标位置，这个更严谨的说应该是切换光标，因为我们的光标正好可以选中面板，即可以通过鼠标点击选中。当然，前者过于简单且没有逼格，我们可以通过快捷键或者命令来实现。\n   \n   # 光标切换到上方面板\n   tmux select-pane -U\n   # 光标切换到下方面板\n   tmux select-pane -D\n   # 光标切换到左方面板\n   tmux select-pane -L\n   # 光标切换到右方面板\n   tmux select-pane -R\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * 交换面板位置。\n   \n   tmux swap-pane可用于交换面板位置。同切换面板差不多的形式。\n   \n   # 上移\n   tmux swap-pane -U\n   # 下移\n   tmux swap-pane -D\n   # 左移\n   tmux swap-pane -L\n   # 右移\n   tmux swap-pane -R\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * 常用面板操作快捷键。\n   \n   前缀       指令               描述\n   Ctrl+b   "                当前面板上下一分为二，下侧新建面板\n   Ctrl+b   %                当前面板左右一分为二，右侧新建面板\n   Ctrl+b   x                关闭当前面板（关闭前需输入y or n确认）\n   Ctrl+b   z                最大化当前面板，再重复一次按键后恢复正常（v1.8版本新增）\n   Ctrl+b   !                将当前面板移动到新的窗口打开（原窗口中存在两个及以上面板有效）\n   Ctrl+b   ;                切换到最后一次使用的面板\n   Ctrl+b   q                显示面板编号，在编号消失前输入对应的数字可切换到相应的面板\n   Ctrl+b   方向键              移动光标切换面板\n   Ctrl+b   hjkl(分别代表左下上右)   移动光标切换面板\n   Ctrl+b   {                向前置换当前面板\n   Ctrl+b   }                向后置换当前面板\n   Ctrl+b   Ctrl+o           顺时针旋转当前窗口中的所有面板\n   Ctrl+b   o                选择下一面板\n   Ctrl+b   空格键              在自带的面板布局中循环切换\n   Ctrl+b   Alt+方向键          以5个单元格为单位调整当前面板边缘\n   Ctrl+b   Ctrl+方向键         以1个单元格为单位调整当前面板边缘（Mac下被系统快捷键覆盖）\n   Ctrl+b   t                显示时钟\n\n\n# 2 参考文献\n\nTmux 使用教程-阮一峰\n\nTmux使用手册-路易斯\n\ntmux使用教程-小可七',normalizedContent:'# 1 tmux使用教程\n\n\n# 1.1 tmux安装\n\n# ubuntu 或 debian\n$ sudo apt-get install tmux\n\n# centos 或 fedora\n$ sudo yum install tmux\n\n# mac\n$ brew install tmux\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 1.2 tmux简介\n\ntmux是一个非常优秀的终端复用器（terminal multiplexer），其可以使用一系列的终端session，它使您可以在一个终端中的多个程序之间轻松切换、分离它们（它们继续在后台运行）并将它们重新附加到不同的终端。\n\nsession：我们知道，在windows命令行中我们打开一个终端窗口，然后输入命令实现与计算机的交流。而这种用户与计算机的这种临时的交互就叫做session。\n\ntmux的主要功能有：\n\n * 分屏，即允许在单个窗口中访问多个会话。这对我们同时运行多个命令行程序非常有用。\n * 允许断开terminal连接后，继续运行进程。这样，我们可以随时随地放心的进行操作，即使工作进行到一半突然断开，我们打开tmux仍可以重新进入到操作现场。\n * 会话共享（适用于结对编程或者远程教学）。我们可以将tmux的会话地址分享给其他人，这样他们就可以通过ssh接入该会话。更骚的是，如果你要给其他人演示远程服务器的操作，不必一直盯着屏幕，我们可以借助tmux，他就可以完全进入你的会话。\n\n当然，tmux的功能还有很多，相比于其他的终端复用器，tmux更易用也更强大，这也是我们为什么要学习tmux的原因。\n\n\n# 1.3 tmux结构\n\ntmux是采用c/s模型构建的，我们输入tmux即相当于开启了一个服务器，此时默认将新建一个session，然后再session中新建一个window，window中新建一个pane。其联系为：一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。\n\n以下即是实例： tmux: session 0: window 0: pane 0 pane 1 pane 2 ... window 1 window 2 ... session 1 session 2 ...\n\n\n\n\n# 1.4 tmux操作\n\n注：以下操作大多数都会给出命令和对应的快捷键，如果用于学习，建议两种操作都要学会，但在平常操作中，使用快捷键是更方便的。\n\n# 1.4.1 前缀键\n\ntmux提供了很多的快捷键。特别的是所有的快捷键都需要通过前缀键唤起，默认的快捷键为ctrl + b。我们可以通过tmux list-keys命令来查看所有快捷键指令。\n\n当然如果觉得ctrl + b不好用，习惯用其他的键，这里提供修改前缀键的方法如下：\n\n# 首先打开文件~/.tmux.conf\nvim ~/.tmux.conf\n# 设置前缀为ctrl + a。\nset -g prefix c-a\n# 解除ctrl + b与前缀的对应关系。\nunbind c-b\n# 绑定ctrl + a 成为新的指令前缀。\nbind c-a send-prefix\n#然后让它生效。我们也可以直接重启让它生效。\nsource ~/.tmux.conf\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 1.4.2 会话(session)操作\n\n * 新建会话：tmux new -s sessionname。\n   \n   这样，我们就可以创建一个名为sessionname的会话了。当然我们也可以直接简写为tmux，这样会新建一个无名称的会话。但为了我们方便管理，所以建议还是指定会话名称。\n\n * 断开当前会话：tmux detach。\n   \n   这样，我们就可以断开当前会话，但是会话 还是会在后台运行。当然，我们还可以使用快捷键：先按ctrl + b，再按 ctrl + d即可退出。\n   \n   注意：这个并没有真正的关闭会话。\n\n * 进入已存在的会话：tmux a -t sessionname或者直接输入tmux a。\n   \n   前者可以指定进入的sessionname会话，而后者是默认进入第一个会话。其中的a命令实际上就是attach，我们可以简写为a。\n\n * 关闭会话：tmux kill -session -t sessionname或者tmux kill -server。\n   \n   我们可以使用tmux的kill命令，其中kill命令有四种：kill -pane, kill -server, kill -session, kill window。根据需求我们使用自己需要的命令，需要注意的是，根据前面的联系，我们关闭了session，那么其中的所有pane和window也都不存在了，同理关闭server,那么所有session也都不存在了。所以这里即是使用kill -session和kill -server，前者关闭sessionname这个会话，后者关闭所有的会话。\n\n * 查看所有的会话：tmux ls。\n   \n   \n\n * 切换会话：switch命令用于切换会话。\n   \n   # 使用会话编号来切换\n   tmux switch -t 0\n   # 使用会话名称来切换\n   tmux switch -t sessionname\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n\n * 重命名会话：tmux rename-session -t sessionname new name。\n\n * 常用会话操作快捷键。\n   \n   前缀       指令         功能\n   ctrl+b   d          断开当前会话\n   ctrl+b   d          选择要断开的会话\n   ctrl+b   $          重命名当前会话\n   ctrl+b   s          列出当前会话用于选择并切换\n   ctrl+b   r          强制重载当前会话\n   ctrl+b   ctrl + z   挂起当前会话\n\n * tmux中复制/粘贴文本的通用方法。\n   \n   (1).按下ctrl + b前缀键，然后按[；\n   \n   (2).用鼠标选中文本，然后被选中的文本会被自动复制到tmux的剪贴板；\n   \n   (3).按下ctrl + b后前缀键，然后按]，会自动将剪贴板的内容粘贴到光标处。\n\n# 1.4.3 窗口(window)操作\n\n * 新建窗口：tmux new-window -n windowname。\n   \n   如此我们可创建一个新的名为windowname的窗口。当然我们也可以直接输入tmux new-window来创建一个没有指定名称的窗口。 创建一个新窗口后，原窗口我们是看不到了的，但依然存在。\n\n * 切换窗口：tmux select-window -t windowname。\n\n * 重命名窗口：tmux rename-window windowname。\n\n * 常用窗口操作快捷键。\n   \n   前缀       指令      功能\n   ctrl+b   c       新建窗口\n   ctrl+b   &       关闭当前窗口，需要输入y or n确认\n   ctrl+b   编号      切换到指定编号的窗口\n   ctrl+b   p       切换到上一个窗口\n   ctrl+b   n       切换到下一个窗口\n   ctrl+b   w       显示窗口列表用于切换。\n   ctrl+b   ,（逗号）   重命名当前窗口\n   ctrl+b   .       修改当前窗口编号（适用于窗口排序）\n   ctrl+b   f       快速定位到窗口（输入关键字匹配窗口）\n\n# 1.4.4 面板(pane)操作\n\n * 划分面板。\n   \n   注意，此划分是针对当前选中的面板，面板可以无限划分。\n   \n   # 划分成上下两个面板\n   tmux split-window\n   #划分成左右两个面板\n   tmux split-window -h\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n   \n   \n\n * 切换面板。\n   \n   tmux select-pane命令用来移动光标位置，这个更严谨的说应该是切换光标，因为我们的光标正好可以选中面板，即可以通过鼠标点击选中。当然，前者过于简单且没有逼格，我们可以通过快捷键或者命令来实现。\n   \n   # 光标切换到上方面板\n   tmux select-pane -u\n   # 光标切换到下方面板\n   tmux select-pane -d\n   # 光标切换到左方面板\n   tmux select-pane -l\n   # 光标切换到右方面板\n   tmux select-pane -r\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * 交换面板位置。\n   \n   tmux swap-pane可用于交换面板位置。同切换面板差不多的形式。\n   \n   # 上移\n   tmux swap-pane -u\n   # 下移\n   tmux swap-pane -d\n   # 左移\n   tmux swap-pane -l\n   # 右移\n   tmux swap-pane -r\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * 常用面板操作快捷键。\n   \n   前缀       指令               描述\n   ctrl+b   "                当前面板上下一分为二，下侧新建面板\n   ctrl+b   %                当前面板左右一分为二，右侧新建面板\n   ctrl+b   x                关闭当前面板（关闭前需输入y or n确认）\n   ctrl+b   z                最大化当前面板，再重复一次按键后恢复正常（v1.8版本新增）\n   ctrl+b   !                将当前面板移动到新的窗口打开（原窗口中存在两个及以上面板有效）\n   ctrl+b   ;                切换到最后一次使用的面板\n   ctrl+b   q                显示面板编号，在编号消失前输入对应的数字可切换到相应的面板\n   ctrl+b   方向键              移动光标切换面板\n   ctrl+b   hjkl(分别代表左下上右)   移动光标切换面板\n   ctrl+b   {                向前置换当前面板\n   ctrl+b   }                向后置换当前面板\n   ctrl+b   ctrl+o           顺时针旋转当前窗口中的所有面板\n   ctrl+b   o                选择下一面板\n   ctrl+b   空格键              在自带的面板布局中循环切换\n   ctrl+b   alt+方向键          以5个单元格为单位调整当前面板边缘\n   ctrl+b   ctrl+方向键         以1个单元格为单位调整当前面板边缘（mac下被系统快捷键覆盖）\n   ctrl+b   t                显示时钟\n\n\n# 2 参考文献\n\ntmux 使用教程-阮一峰\n\ntmux使用手册-路易斯\n\ntmux使用教程-小可七',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"Home",frontmatter:{home:!0,heroText:"Pursuit's blog",tagline:"日拱一卒无有尽，功不唐捐终入海",features:[{title:"开发",details:"C++、Go、Python、Linux、数据结构与算法等相关技术",link:"/develop/",imgUrl:"/img/web.png"},{title:"工具",details:"Git、Github等工具使用",link:"/tool/",imgUrl:"/img/ui.png"},{title:"学习笔记",details:"记录自己的学习笔记，包括但不限于讲座笔记、论文笔记等",link:"/note/",imgUrl:"/img/other.png"}],readingShow:"top"},regularPath:"/",relativePath:"index.md",key:"v-3fce6544",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 22:16:11",lastUpdatedTimestamp:1700835371e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1,readingShow:"top"},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-1e09ee2b",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/21, 20:55:58",lastUpdatedTimestamp:1700571358e3},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1,readingShow:"top"},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-6097fb0b",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/21, 20:55:58",lastUpdatedTimestamp:1700571358e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"开发",link:"/develop/",items:[{text:"编程语言",link:"/develop/language/"},{text:"开发框架",link:"/develop/framework/"},{text:"数据结构与算法",link:"/develop/algorithm/"},{text:"数据存储",link:"/develop/storage/"},{text:"系统架构",link:"/develop/system/"},{text:"计算机网络",link:"/develop/network/"},{text:"云原生",link:"/develop/cloud/"}]},{text:"工具",link:"/tool/",items:[{text:"版本控制",link:"/tool/vcs/"},{text:"网络工具",link:"/tool/network/"},{text:"开发工具",link:"/tool/develop/"}]},{text:"学习笔记",link:"/note/",items:[{text:"学术搬砖",link:"/note/paper/"},{text:"实践项目",link:"/note/project/"},{text:"讲座研讨",link:"/note/lecture/"}]},{text:"生活杂谈",link:"/life/",items:[{text:"随写编年",link:"/life/year/"},{text:"追忆青春",link:"/life/youth/"},{text:"旅行日记",link:"/life/travel/"},{text:"文艺时光",link:"/life/art/"},{text:"烹调分享",link:"/life/cook/"}]},{text:"资源收藏",link:"/resource/",items:[{text:"实用网站",link:"/resource/website/"},{text:"优秀项目",link:"/resource/project/"}]},{text:"更多",link:"/more/",items:[{text:"面试",link:"/more/interview/"},{text:"实用技巧",link:"/more/tip/"},{text:"博客相关",link:"/more/blog/"}]},{text:"关于",link:"/about/"},{text:"友链",link:"/friend/"},{text:"索引",link:"/archives/",items:[{text:"分类",link:"/categories/"},{text:"标签",link:"/tags/"},{text:"归档",link:"/archives/"}]}],sidebarDepth:2,logo:"/img/logo.jpeg",repo:"unique-pure/my-vdoing-blog-template",searchMaxSuggestions:10,searchPlaceholder:"按下 𝑺 搜索",lastUpdated:"上次更新",editLinks:!1,sidebar:{"/00.目录页/":[["01.开发.md","开发","/develop/"],["02.工具.md","工具","/tool/"],["03.学习笔记.md","学习笔记","/note/"],["04.生活杂谈.md","生活杂谈","/life/"],["05.资源收藏.md","资源收藏","/resource/"],["06.更多.md","更多","/more/"]],catalogue:{"sub01.编程语言":"/develop/language/","sub02.开发框架":"/develop/framework/","sub03.数据结构与算法":"/develop/algorithm/","sub04.数据存储":"/develop/storage/","sub05.系统架构":"/develop/system/","sub06.计算机网络":"/develop/network/","sub07.云原生":"/develop/cloud/","开发":"/develop/","sub01版本控制":"/tool/vcs/","sub02网络工具":"/tool/network/","sub03.开发工具":"/tool/develop/","工具":"/tool/","sub01.学术搬砖":"/note/paper/","sub02.实践项目":"/note/project/","sub03.讲座研讨":"/note/lecture/","学习笔记":"/note/","sub01.随写编年":"/life/year/","sub02.追忆青春":"/life/youth/","sub03.旅行日记":"/life/travel/","sub04.文艺时光":"/life/art/","sub05.烹调分享":"/life/cook/","生活杂谈":"/life/","sub01实用网站":"/resource/website/","sub02优秀项目":"/resource/project/","资源收藏":"/resource/","sub01.面试":"/more/interview/","sub02.实用技巧":"/more/tip/","sub03.博客相关":"/more/blog/","更多":"/more/"},"/01.开发/":[{title:"编程语言",collapsable:!0,children:[{title:"Go",collapsable:!0,children:[]},{title:"C++",collapsable:!0,children:[["01.编程语言/02.C++/01.C++11多线程 std::thread详解.md","C++11多线程 std::thread详解","/pages/9c1ae3/"],["01.编程语言/02.C++/02.C语言如何从一定范围内生成随机整数.md","如何使用C语言从一定范围内生成随机整数？","/pages/f16b08/"]]},{title:"Python",collapsable:!0,children:[]}]},{title:"开发框架",collapsable:!0,children:[{title:"前端",collapsable:!0,children:[["02.开发框架/01.前端/01.Vite构建工具介绍.md","vite构建工具介绍","/pages/03e0a8/"]]},{title:"后端",collapsable:!0,children:[]},{title:"设计模式",collapsable:!0,children:[["02.开发框架/03.设计模式/01.设计模式之工厂模式详解（Java实现）.md","设计模式之工厂模式详解（Java实现）","/pages/f4cb7a/"],["02.开发框架/03.设计模式/02.设计模式之建造者模式详解（Java实现）.md","设计模式之建造者模式详解（Java实现）","/pages/04c857/"],["02.开发框架/03.设计模式/03.设计模式之原型模式详解（Java实现）.md","设计模式之原型模式详解（Java实现）","/pages/2d97a5/"],["02.开发框架/03.设计模式/04.设计模式之单例模式详解（Java实现）.md","设计模式之单例模式详解（Java实现）","/pages/a1ff4f/"],["02.开发框架/03.设计模式/05.设计模式之适配器模式详解（Java实现）.md","设计模式之适配器模式详解（Java实现）","/pages/2bc5dd/"],["02.开发框架/03.设计模式/06.设计模式之桥接模式详解（Java实现）.md","设计模式之桥接模式详解（Java实现）","/pages/aab372/"],["02.开发框架/03.设计模式/07.设计模式之组合模式详解（Java实现）.md","设计模式之组合模式详解（Java实现）","/pages/eac75e/"],["02.开发框架/03.设计模式/08.设计模式之装饰模式详解（Java实现）.md","设计模式之装饰模式详解（Java实现）","/pages/c49acf/"],["02.开发框架/03.设计模式/09.设计模式之外观模式详解（Java实现）.md","设计模式之外观模式详解（Java实现）","/pages/e40609/"],["02.开发框架/03.设计模式/10.设计模式之代理模式详解（Java实现）.md","设计模式之代理模式详解（Java实现）","/pages/933a7d/"],["02.开发框架/03.设计模式/11.设计模式之命令模式详解（Java实现）.md","设计模式之命令模式详解（Java实现）","/pages/31f81b/"],["02.开发框架/03.设计模式/12.设计模式之观察者模式详解（Java实现）.md","设计模式之观察者模式详解（Java实现）","/pages/e1f6d9/"],["02.开发框架/03.设计模式/13.设计模式之策略模式详解（Java）实现.md","设计模式之策略模式详解（Java实现）","/pages/b22ffc/"],["02.开发框架/03.设计模式/14.设计模式之模板方法模式详解（Java实现）.md","设计模式之模板方法模式详解（Java实现）","/pages/2aa461/"]]}]},{title:"数据结构与算法",collapsable:!0,children:[{title:"基础知识",collapsable:!0,children:[]},{title:"排序算法",collapsable:!0,children:[]},{title:"查找算法",collapsable:!0,children:[["03.数据结构与算法/03.查找算法/01.二分查找.md","二分查找的奇技淫巧","/pages/71fd4b/"]]},{title:"字符串算法",collapsable:!0,children:[]},{title:"位运算",collapsable:!0,children:[["03.数据结构与算法/05.位运算/01.位运算全面总结.md","位运算全面总结","/pages/41f1cd/"]]},{title:"数据结构",collapsable:!0,children:[["03.数据结构与算法/06.数据结构/01.线段树入门.md","线段树入门","/pages/088910/"]]},{title:"动态规划",collapsable:!0,children:[["03.数据结构与算法/07.动态规划/01.数位DP.md","数位DP学习整理","/pages/243023/"],["03.数据结构与算法/07.动态规划/02.状压DP.md","状压DP学习总结+经典例题精解","/pages/671a5d/"],["03.数据结构与算法/07.动态规划/03.HDU 4507 恨7不成妻 （数位DP套路题，详细解析）.md","03.HDU 4507 恨7不成妻 （数位DP套路题）","/pages/243024/"]]},{title:"图算法",collapsable:!0,children:[["03.数据结构与算法/08.图算法/01.Floyd算法教程.md","Floyd算法教程","/pages/3610c3/"],["03.数据结构与算法/08.图算法/02.Dijkstra算法教程.md","Dijkstra算法教程","/pages/180ec0/"],["03.数据结构与算法/08.图算法/03.Kruskal算法教程.md","Kruskal算法详解","/pages/a97764/"],["03.数据结构与算法/08.图算法/04.Prim算法教程.md","Prim算法详解","/pages/affd0f/"]]}]},{title:"数据存储",collapsable:!0,children:[]},{title:"系统架构",collapsable:!0,children:[{title:"Linux",collapsable:!0,children:[["05.系统架构/01.Linux/01.Linux常用命令、管道、环境变量.md","Linux常用命令、管道、环境变量","/pages/d66bf9/"],["05.系统架构/01.Linux/02.Linux常用文件管理命令.md","Linux常用文件管理命令","/pages/b04f81/"],["05.系统架构/01.Linux/03.Linux用户和用户组教程.md","Linux用户和用户组教程","/pages/419777/"],["05.系统架构/01.Linux/04.Linux_fork函数详解.md","Linux 系统调用函数fork、vfork、clone详解","/pages/64b48d/"],["05.系统架构/01.Linux/05.Linux execve函数详解.md","Linux execve函数详解","/pages/d8622e/"]]},{title:"操作系统",collapsable:!0,children:[["05.系统架构/02.操作系统/01.进程介绍.md","进程介绍","/pages/77a74b/"],["05.系统架构/02.操作系统/02.进程API.md","进程API","/pages/1d4493/"],["05.系统架构/02.操作系统/03.有限直接执行.md","有限直接执行","/pages/4b8a3a/"],["05.系统架构/02.操作系统/04.CPU调度.md","CPU调度","/pages/f0c724/"],["05.系统架构/02.操作系统/05.多级反馈队列.md","多级反馈队列","/pages/a1ad96/"],["05.系统架构/02.操作系统/06.比例份额调度.md","比例份额调度","/pages/40a229/"],["05.系统架构/02.操作系统/07.多CPU调度.md","多CPU调度","/pages/326999/"],["05.系统架构/02.操作系统/08.地址空间.md","地址空间","/pages/23b20c/"],["05.系统架构/02.操作系统/09.内存API.md","内存API","/pages/174348/"],["05.系统架构/02.操作系统/10.地址转换.md","地址转换","/pages/542fcd/"],["05.系统架构/02.操作系统/11.段.md","段","/pages/506cee/"],["05.系统架构/02.操作系统/12.空闲空间管理.md","空闲空间管理","/pages/d34e64/"],["05.系统架构/02.操作系统/13.页.md","页","/pages/69f0fb/"],["05.系统架构/02.操作系统/14.快表.md","快表","/pages/fe36b0/"],["05.系统架构/02.操作系统/15.高级页表.md","高级页表","/pages/165f2d/"],["05.系统架构/02.操作系统/16.页面交换.md","页面交换","/pages/65f57a/"],["05.系统架构/02.操作系统/17.交换策略.md","交换策略","/pages/aeb7cb/"],["05.系统架构/02.操作系统/18.完整VM系统.md","完整VM系统","/pages/9f0f28/"]]}]},{title:"计算机网络",collapsable:!0,children:[]},{title:"云原生",collapsable:!0,children:[{title:"容器化技术",collapsable:!0,children:[["07.云原生/01.容器化技术/01.Docker入门教程.md","Docker入门教程","/pages/12de46/"]]},{title:"微服务",collapsable:!0,children:[]}]}],"/02.工具/":[{title:"版本控制",collapsable:!0,children:[["01.版本控制/01.Git Commit 之道：规范化 Commit Message 写作指南.md","Git Commit 之道：规范化 Commit Message 写作指南","/pages/4f7ea8/"],["01.版本控制/02.Git教程.md","Git教程","/pages/992deb/"],["01.版本控制/03.Github搜索技巧.md","Github搜索技巧","/pages/031ffb/"]]},{title:"网络工具",collapsable:!0,children:[["02.网络工具/01.WireGuard组网教程.md","WireGuard组网教程","/pages/50ca39/"],["02.网络工具/02.SSH教程.md","SSH教程","/pages/975871/"]]},{title:"开发工具",collapsable:!0,children:[["03.开发工具/01.Shell教程.md","Shell教程","/pages/0fc47a/"],["03.开发工具/02.Tmux教程.md","Tmux教程","/pages/c81c74/"],["03.开发工具/03.Vim教程.md","Vim教程","/pages/e7b5a5/"]]}],"/03.学习笔记/":[{title:"学术搬砖",collapsable:!0,children:[]},{title:"实践项目",collapsable:!0,children:[]},{title:"讲座研讨",collapsable:!0,children:[]},{title:"闲杂文章",collapsable:!0,children:[["04.闲杂文章/01.AI时代下的GPU生存工具包：每个开发人员必须了解的最基本知识.md","AI时代下的GPU生存工具包：每个开发人员必须了解的最基本知识","/pages/df386a/"]]}],"/04.生活杂谈/":[{title:"随写编年",collapsable:!0,children:[{title:"年终总结",collapsable:!0,children:[["01.随写编年/01.年终总结/01.我的2023.md","2023年年终总结","/pages/a0354f/"]]},{title:"2023年",collapsable:!0,children:[["01.随写编年/02.2023年/01.雪韵初见·南京初雪.md","雪韵初见·南京初雪","/pages/608406/"]]}]},{title:"追忆青春",collapsable:!0,children:[]},{title:"旅行日记",collapsable:!0,children:[]},{title:"文艺时光",collapsable:!0,children:[]},{title:"烹调分享",collapsable:!0,children:[]}],"/05.资源收藏/":[{title:"实用网站",collapsable:!0,children:[["01.实用网站/01.系统相关.md","Mac工具","/pages/e6b9d0/"],["01.实用网站/02.镜像.md","镜像网站","/pages/04404f/"]]},{title:"优秀项目",collapsable:!0,children:[["02.优秀项目/01.算法实现模版.md","遵循最佳实践，各种语言实现数据结构和算法的模版","/pages/0070df/"],["02.优秀项目/02.设计模式实现模版.md","遵循最佳实践，各种语言实现设计模式的模版","/pages/7634df/"],["02.优秀项目/03.Go优秀资源.md","Go 语言优秀资源整理，为项目落地加速🏃","/pages/9fd05a/"]]}],"/06.更多/":[{title:"面试",collapsable:!0,children:[]},{title:"实用技巧",collapsable:!0,children:[]},{title:"博客相关",collapsable:!0,children:[]}],"/07.关于/":[["01.about.md","个人简介","/about/"]],"/08.友情链接/":[["01.友情链接.md","友链","/friend/"]]},author:{name:"Pursuit",link:"https://github.com/unique-pure"},blogger:{avatar:"/img/avatar.jpeg",name:"Pursuit",slogan:"但行好事，莫问前程"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:unique.hzf@gmail.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/unique-pure"},{iconClass:"icon-csdn",title:"My CSDN",link:"https://pursuit.blog.csdn.net/"}]},footer:{createYear:2020,copyrightInfo:'Pursuit | <a href="https://github.com/unique-pure/my-vdoing-blog-template/blob/main/LICENSE" target="_blank">MIT License</a>'},extendFrontmatter:{author:{name:"Pursuit",link:"https://github.com/unique-pure"}},htmlModules:{pageB:'<div class="donation">\n      <button>打赏</button>\n      <div class="main">\n        <div class="pic">\n          <img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/wechatpay.jpeg" alt="微信">\n          <img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/zhifubaopay.jpeg" alt="支付宝">\n        </div>\n      </div>  \n    </div>'}},locales:{"/":{lang:"zh-CN",title:"Pursuit's blog",description:"随便写写",path:"/"}}};var kl=t(99),_l=t(100),wl=t(11);var El={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:i}}=n;return!(e||!1===t||!0===i)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,i=e.frontmatter.sticky;return t&&i?t==i?Object(wl.a)(n,e):t-i:t&&!i?-1:!t&&i?1:Object(wl.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(wl.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let i=0,r=n.length;i<r;i++){const{frontmatter:{categories:r,tags:o}}=n[i];"array"===Object(wl.n)(r)&&r.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[i]))}),"array"===Object(wl.n)(o)&&o.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[i]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Ht.component(kl.default),Ht.component(_l.default);function Tl(n){return n.toString().padStart(2,"0")}t(248);Ht.component("GlobalTip",()=>Promise.all([t.e(0),t.e(20)]).then(t.bind(null,393))),Ht.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,99))),Ht.component("Badge",()=>Promise.all([t.e(0),t.e(6)]).then(t.bind(null,394))),Ht.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,100)));t(249);var Pl={render:()=>null},jl=Ht.extend({name:"CodeGroup",data:()=>({codeTabs:[],activeTabIndex:-1}),watch:{activeTabIndex(n){this.activateCodeTab(n)}},mounted(){this.loadTabs()},methods:{loadTabs(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>{const t=n.componentOptions.propsData;return"active"in t&&(this.activeTabIndex=e),{title:t.title,element:n.elm}}),-1===this.activeTabIndex&&this.codeTabs.length>0&&(this.activeTabIndex=0),this.activateCodeTab(0)},changeCodeTab(n){this.activeTabIndex=n},keyDownHandler(n,e){" "===n.key||"Enter"===n.key?(n.preventDefault(),this.activeTabIndex=e):"ArrowRight"===n.key?(n.preventDefault(),e+1<this.codeTabs.length&&(this.activeTabIndex=e+1,this.$refs.tab[e+1].focus())):"ArrowLeft"===n.key&&(n.preventDefault(),e-1>=0&&(this.activeTabIndex=e-1,this.$refs.tab[e-1].focus()))},activateCodeTab(n){this.codeTabs.forEach((e,t)=>{const{element:i}=e;i&&(n===t?i.classList.add("active"):i.classList.remove("active"))})}}}),Al=(t(250),Object(vl.a)(jl,(function(){var n=this,e=n._self._c;n._self._setupProxy;return e("ClientOnly",[e("div",{staticClass:"code-group"},[e("div",{staticClass:"code-group-nav",attrs:{"v:if":"codeTabs.length"}},n._l(n.codeTabs,(function(t,i){return e("button",{key:t.title,ref:"tab",refInFor:!0,staticClass:"code-group-nav-tab",class:{active:i===n.activeTabIndex},attrs:{"aria-pressed":i===n.activeTabIndex,"aria-expanded":i===n.activeTabIndex},domProps:{textContent:n._s(t.title)},on:{click:function(e){return n.changeCodeTab(i)},keydown:function(e){return n.keyDownHandler(e,i)}}})})),0),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length?n._e():e("pre",{staticClass:"hints",domProps:{textContent:n._s("// Make sure to add code blocks to your code group")}})],2)])}),[],!1,null,null,null).exports),Cl=Ht.extend({name:"CodeGroupItem",props:{title:{type:String,required:!0},active:{type:Boolean,required:!1,default:!1}},mounted(){this.$parent&&this.$parent.loadTabs&&this.$parent.loadTabs()}}),Sl=(t(251),Object(vl.a)(Cl,(function(){var n=this._self._c;this._self._setupProxy;return n("div",{staticClass:"code-group-item",class:{active:this.active},attrs:{"aria-selected":this.active}},[this._t("default")],2)}),[],!1,null,null,null).exports);var Bl=({Vue:n})=>{Promise.all([t.e(0),t.e(142)]).then(t.t.bind(null,380,7)),Promise.all([t.e(0),t.e(143)]).then(t.t.bind(null,381,7)),Pl.name&&n.component("ChartJS",Pl),Pl.name&&n.component("CodeDemo",Pl),Al.name&&n.component("CodeGroup",Al),Sl.name&&n.component("CodeGroupItem",Sl),Pl.name&&n.component("FlowChart",Pl),Pl.name&&n.component("Mermaid",Pl),Pl.name&&n.component("Presentation",Pl),Promise.all([t.e(0),t.e(144)]).then(t.t.bind(null,382,7)),Promise.all([t.e(0),t.e(145)]).then(t.t.bind(null,383,7)),Promise.all([t.e(0),t.e(147)]).then(t.t.bind(null,384,7))},Il={name:"ReadingProgress",data:()=>({readingTop:0,readingHeight:1,progressStyle:null,transform:void 0,running:!1}),watch:{$readingShow(){this.progressStyle=this.getProgressStyle(),this.$readingShow&&window.addEventListener("scroll",this.base)}},mounted(){this.transform=this.getTransform(),this.progressStyle=this.getProgressStyle(),this.$readingShow&&window.addEventListener("scroll",this.base)},beforeDestroy(){this.$readingShow&&window.removeEventListener("scroll",this.base)},methods:{base(){this.running||(this.running=!0,requestAnimationFrame(this.getReadingBase))},getReadingBase(){this.readingHeight=this.getReadingHeight()-this.getScreenHeight(),this.readingTop=this.getReadingTop(),this.progressStyle=this.getProgressStyle(),this.running=!1},getReadingHeight:()=>Math.max(document.body.scrollHeight,document.body.offsetHeight,0),getScreenHeight:()=>Math.max(window.innerHeight,document.documentElement.clientHeight,0),getReadingTop:()=>Math.max(window.pageYOffset,document.documentElement.scrollTop,0),getTransform(){const n=document.createElement("div");return["transform","-webkit-transform","-moz-transform","-o-transform","-ms-transform"].find(e=>e in n.style)||void 0},getProgressStyle(){const n=this.readingTop/this.readingHeight;switch(this.$readingShow){case"top":case"bottom":return this.transform?`${this.transform}: scaleX(${n})`:`width: ${100*n}%`;case"left":case"right":return this.transform?`${this.transform}: scaleY(${n})`:`height: ${100*n}%`;default:return null}}}},Ll=(t(252),Object(vl.a)(Il,(function(){var n=this._self._c;return n("ClientOnly",[this.$readingShow?n("div",{staticClass:"reading-progress",class:this.$readingShow},[n("div",{staticClass:"progress",style:this.progressStyle})]):this._e()])}),[],!1,null,"3640397f",null).exports),Dl=(t(253),t(98)),zl=t.n(Dl),Ol=t(27);let Ul,Nl;var Rl;"valine"===(Rl="gitalk")?t.e(148).then(t.t.bind(null,385,7)).then(n=>Nl=n.default):"gitalk"===Rl&&Promise.all([t.e(0),t.e(146)]).then(t.t.bind(null,386,7)).then(()=>t.e(141).then(t.t.bind(null,387,7))).then(n=>Ul=n.default);function ql(n,e){const t={};return Reflect.ownKeys(n).forEach(i=>{if("string"==typeof n[i])try{t[i]=zl.a.render(n[i],e)}catch(e){console.warn(`Comment config option error at key named "${i}"`),console.warn("More info: "+e.message),t[i]=n[i]}else t[i]=n[i]}),t}console.log(`How to use "gitalk" in ${Ol.name}@v${Ol.version}:`,Ol.homepage);const Fl={gitalk:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t);new Ul(ql({clientID:"9df5ccb0d1f027d3397a",clientSecret:"0a6854600c8094a650b26c310c78c061cb320480",repo:"commentRes",owner:"unique-pure",admin:["unique-pure"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n})).render(e)},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}},valine:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t),new Nl({...ql({clientID:"9df5ccb0d1f027d3397a",clientSecret:"0a6854600c8094a650b26c310c78c061cb320480",repo:"commentRes",owner:"unique-pure",admin:["unique-pure"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n}),el:"#"+e})},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}}},Ml="vuepress-plugin-comment";let Gl=null;function $l(n){return Fl.gitalk.clear(Ml)}function Vl(n){return!1!==n.comment&&!1!==n.comments}function Hl(n){clearTimeout(Gl);if(document.querySelector("main.page"))return Fl.gitalk.render(n,Ml);Gl=setTimeout(()=>Hl(n),200)}var Kl={mounted(){Gl=setTimeout(()=>{const n={to:{},from:{},...this.$frontmatter};$l()&&Vl(n)&&Hl(n)},1e3),this.$router.afterEach((n,e)=>{if(n&&e&&n.path===e.path)return;const t={to:n,from:e,...this.$frontmatter};$l()&&Vl(t)&&Hl(t)})}},Jl=Object(vl.a)(Kl,(function(){return(0,this._self._c)("div")}),[],!1,null,null,null).exports,Wl=[({Vue:n,options:e,router:t,siteData:i})=>{},({Vue:n,options:e,router:t,siteData:i})=>{i.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${Tl(n.getUTCMonth()+1)}-${Tl(n.getUTCDate())} ${Tl(n.getUTCHours())}:${Tl(n.getUTCMinutes())}:${Tl(n.getUTCSeconds())}`}(e)),t?n.author=t:i.themeConfig.author&&(n.author=i.themeConfig.author)}),n.mixin(El)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:n})=>{"undefined"!=typeof window&&function(){var n=document.createElement("script"),e=window.location.protocol.split(":")[0];n.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(n,t)}()},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?503f098e7e5b3a5b5d8c5fc2938af002";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))},Bl,({Vue:n})=>{n.component(Ll.name,Ll),n.mixin({computed:{$readingShow(){return this.$page.frontmatter.readingShow}}})},({Vue:n})=>{n.component("Comment",Jl)}],Ql=["ReadingProgress","GlobalTip","WebInfo","PageInfo","Comment"];class Yl extends class{constructor(){this.store=new Ht({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Ht.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Yl.prototype,{getPageAsyncComponent:as,getLayoutAsyncComponent:ss,getAsyncComponent:ls,getVueComponent:cs});var Xl={install(n){const e=new Yl;n.$vuepress=e,n.prototype.$vuepress=e}};function Zl(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var nc={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return us("pageKey",e),Ht.component(e)||Ht.component(e,as(e)),Ht.component(e)?n(e):n("")}},ec={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},tc={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},ic=(t(259),t(260),Object(vl.a)(tc,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),rc={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Ht.config.productionTip=!1,Ht.use($a),Ht.use(Xl),Ht.mixin(function(n,e,t=Ht){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const i=new(n(t.$vuepress.$get("siteData"))),r=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(i)),o={};return Object.keys(r).reduce((n,e)=>(e.startsWith("$")&&(n[e]=r[e].get),n),o),{computed:o}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const i in n)"/"===i?t=n[i]:0===this.$page.path.indexOf(i)&&(e=n[i]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,i=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?i?i+" | "+t:t:i||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const i=n[t];if(i.path.toLowerCase()===e.toLowerCase())return i}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},yl)),Ht.component("Content",nc),Ht.component("ContentSlotsDistributor",ec),Ht.component("OutboundLink",ic),Ht.component("ClientOnly",rc),Ht.component("Layout",ss("Layout")),Ht.component("NotFound",ss("NotFound")),Ht.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.10",hash:"5209f27"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:yl.routerBase||yl.base,t=new $a({base:e,mode:"history",fallback:!1,routes:xl,scrollBehavior:(n,e,t)=>t||(n.hash?!Ht.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,i)=>{if(Zl(n,e.path))i();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Zl(n,t)?i(t):i()}else i();else{const t=e.path+"/",r=e.path+".html";Zl(n,r)?i(r):Zl(n,t)?i(t):i()}})}(t);const i={};try{await Promise.all(Wl.filter(n=>"function"==typeof n).map(e=>e({Vue:Ht,options:i,router:t,siteData:yl,isServer:n})))}catch(n){console.error(n)}return{app:new Ht(Object.assign(i,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Ql.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);