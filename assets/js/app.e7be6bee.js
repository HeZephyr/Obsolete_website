(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var i,a,s=e[0],l=e[1],c=e[2],d=0,p=[];d<s.length;d++)a=s[d],Object.prototype.hasOwnProperty.call(r,a)&&r[a]&&p.push(r[a][0]),r[a]=0;for(i in l)Object.prototype.hasOwnProperty.call(l,i)&&(n[i]=l[i]);for(u&&u(e);p.length;)p.shift()();return o.push.apply(o,c||[]),t()}function t(){for(var n,e=0;e<o.length;e++){for(var t=o[e],i=!0,s=1;s<t.length;s++){var l=t[s];0!==r[l]&&(i=!1)}i&&(o.splice(e--,1),n=a(a.s=t[0]))}return n}var i={},r={8:0},o=[];function a(e){if(i[e])return i[e].exports;var t=i[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,a),t.l=!0,t.exports}a.e=function(n){var e=[],t=r[n];if(0!==t)if(t)e.push(t[2]);else{var i=new Promise((function(e,i){t=r[n]=[e,i]}));e.push(t[2]=i);var o,s=document.createElement("script");s.charset="utf-8",s.timeout=120,a.nc&&s.setAttribute("nonce",a.nc),s.src=function(n){return a.p+"assets/js/"+({9:"vendors~docsearch"}[n]||n)+"."+{1:"4a1189e9",2:"8e76b5b7",3:"bca043f9",4:"71a85121",5:"780a742d",6:"6c206683",7:"03420b55",9:"caeb3b49",10:"ce2d8b4d",11:"87208a0c",12:"7f5cceef",13:"f2cea533",14:"f8459573",15:"06cd6cc8",16:"33942615",17:"da2e0126",18:"a39b8ae2",19:"1760f287",20:"bc1029fc",21:"4b161474",22:"69d29451",23:"2a87052f",24:"6beeaf9b",25:"e9d4e312",26:"c128f1d5",27:"2bab9253",28:"0b0ea581",29:"71a2a1e9",30:"11fd1987",31:"92abb231",32:"27d7c672",33:"9f002fe8",34:"39abd7b3",35:"a54492ae",36:"1b3ef370",37:"3dda47b6",38:"3dc3656a",39:"33db5319",40:"b75abb2c",41:"b84ff437",42:"9b31e597",43:"2d69a52c",44:"f4b824cb",45:"62271286",46:"d2488a8c",47:"12a977cd",48:"f968ed88",49:"7d31c29b",50:"9779c691",51:"2f2c49f7",52:"8b67bfc4",53:"3e90e7f7",54:"dfe75294",55:"38d092c5",56:"7e333e13",57:"23b90d70",58:"9ad3667d",59:"0a608087",60:"3acec2d6",61:"4adcf980",62:"99e7c163",63:"a5b7db96",64:"78dead08",65:"25186e2e",66:"b23d0ea1",67:"e1d26df3",68:"7f5e2d0d",69:"6593d959",70:"8ee6159d",71:"231aaf01",72:"152ce738",73:"8c450ed3",74:"9ba00cbb",75:"d3075ec4",76:"7ae7b7e0",77:"f84b746b",78:"2e583f7b",79:"27a1a4c4",80:"0266a2b1",81:"2425fe08",82:"7eceba05",83:"6b6d6863",84:"b9499207",85:"fb3bd041",86:"3d812853",87:"251d46e4",88:"d061a842",89:"a34ccf6c",90:"d235b861",91:"5d1b64db",92:"f0625689",93:"12f9cffa",94:"7cea63ae",95:"085def87",96:"001f7bf6",97:"2cccc281",98:"d04ad8b8",99:"0fb760ea",100:"f0035ef5",101:"30c7515b",102:"0e94c987",103:"4195ee02",104:"22421b9e",105:"ba9fb8e9",106:"d320cfee",107:"58e1eac7",108:"c4a87b3c",109:"7db1d8c9",110:"01a0b4f2",111:"3f7a2d44",112:"5ddd9f5e",113:"5fbeb209",114:"5361e3e5",115:"064db2fd",116:"c9d97d9f",117:"6dd00476",118:"62b3a342",119:"121b788b",120:"9e70dc70",121:"58679167",122:"a7dda320"}[n]+".js"}(n);var l=new Error;o=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=r[n];if(0!==t){if(t){var i=e&&("load"===e.type?"missing":e.type),o=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+i+": "+o+")",l.name="ChunkLoadError",l.type=i,l.request=o,t[1](l)}r[n]=void 0}};var c=setTimeout((function(){o({type:"timeout",target:s})}),12e4);s.onerror=s.onload=o,document.head.appendChild(s)}return Promise.all(e)},a.m=n,a.c=i,a.d=function(n,e,t){a.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},a.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},a.t=function(n,e){if(1&e&&(n=a(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(a.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var i in n)a.d(t,i,function(e){return n[e]}.bind(null,i));return t},a.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return a.d(e,"a",e),e},a.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},a.p="/",a.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var u=l;o.push([110,0]),t()}([function(n,e,t){"use strict";function i(n,e,t,i,r,o,a,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),i&&(c.functional=!0),o&&(c._scopeId="data-v-"+o),a?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),r&&r.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(a)},c._ssrRegister=l):r&&(l=s?function(){r.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:r),l)if(c.functional){c._injectStyles=l;var u=c.render;c.render=function(n,e){return l.call(e),u(n,e)}}else{var d=c.beforeCreate;c.beforeCreate=d?[].concat(d,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return i}))},function(n,e,t){"use strict";var i=function(n){return n&&n.Math===Math&&n};n.exports=i("object"==typeof globalThis&&globalThis)||i("object"==typeof window&&window)||i("object"==typeof self&&self)||i("object"==typeof global&&global)||i("object"==typeof this&&this)||function(){return this}()||Function("return this")()},function(n,e,t){"use strict";var i=t(56),r=i.all;n.exports=i.IS_HTMLDDA?function(n){return"function"==typeof n||n===r}:function(n){return"function"==typeof n}},function(n,e,t){"use strict";var i=t(29),r=Function.prototype,o=r.call,a=i&&r.bind.bind(o,o);n.exports=i?a:function(n){return function(){return o.apply(n,arguments)}}},function(n,e,t){"use strict";n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){"use strict";var i=t(4);n.exports=!i((function(){return 7!==Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){"use strict";var i=t(3),r=t(33),o=i({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return o(r(n),e)}},function(n,e,t){var i=t(70),r="object"==typeof self&&self&&self.Object===Object&&self,o=i||r||Function("return this")();n.exports=o},function(n,e,t){"use strict";var i=t(2),r=t(56),o=r.all;n.exports=r.IS_HTMLDDA?function(n){return"object"==typeof n?null!==n:i(n)||n===o}:function(n){return"object"==typeof n?null!==n:i(n)}},function(n,e,t){var i=t(168),r=t(171);n.exports=function(n,e){var t=r(n,e);return i(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return i})),t.d(e,"b",(function(){return o})),t.d(e,"j",(function(){return a})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return u})),t.d(e,"c",(function(){return d})),t.d(e,"f",(function(){return p})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return g})),t.d(e,"k",(function(){return v})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return y}));t(17);const i=/#.*$/,r=/\.(md|html)$/,o=/\/$/,a=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(i,"").replace(r,"")}function l(n){return a.test(n)}function c(n){return/^mailto:/.test(n)}function u(n){return/^tel:/.test(n)}function d(n){if(l(n))return n;if(!n)return"404";const e=n.match(i),t=e?e[0]:"",r=s(n);return o.test(r)?n:r+".html"+t}function p(n,e){const t=n.hash,r=function(n){const e=n&&n.match(i);if(e)return e[0]}(e);if(r&&t!==r)return!1;return s(n.path)===s(e)}function m(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const i=n.charAt(0);if("/"===i)return n;if("?"===i||"#"===i)return e+n;const r=e.split("/");t&&r[r.length-1]||r.pop();const o=n.replace(/^\//,"").split("/");for(let n=0;n<o.length;n++){const e=o[n];".."===e?r.pop():"."!==e&&r.push(e)}""!==r[0]&&r.unshift("");return r.join("/")}(e,t));const i=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===i)return Object.assign({},n[e],{type:"page",path:d(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function h(n,e,t,i){const{pages:r,themeConfig:o}=t,a=i&&o.locales&&o.locales[i]||o;if("auto"===(n.frontmatter.sidebar||a.sidebar||o.sidebar))return f(n);const s=a.sidebar||o.sidebar;if(s){const{base:t,config:i}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const i in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(i)))return{base:i,config:e[i]};var t;return{}}(e,s);return"auto"===i?f(n):i?i.map(n=>function n(e,t,i,r=1){if("string"==typeof e)return m(t,e,i);if(Array.isArray(e))return Object.assign(m(t,e[0],i),{title:e[1]});{r>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const o=e.children||[];return 0===o.length&&e.path?Object.assign(m(t,e.path,i),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:o.map(e=>n(e,t,i,r+1)),collapsable:!1!==e.collapsable}}}(n,r,t)):[]}return[]}function f(n){const e=g(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function g(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function v(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function x(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function y(n,e){return x(e)-x(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){"use strict";var i=t(5),r=t(65),o=t(107),a=t(28),s=t(55),l=TypeError,c=Object.defineProperty,u=Object.getOwnPropertyDescriptor;e.f=i?o?function(n,e,t){if(a(n),e=s(e),a(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var i=u(n,e);i&&i.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:i.configurable,enumerable:"enumerable"in t?t.enumerable:i.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(a(n),e=s(e),a(t),r)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw new l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var i=t(16),r=t(153),o=t(154),a=i?i.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":a&&a in Object(n)?r(n):o(n)}},function(n,e,t){"use strict";var i=t(5),r=t(13),o=t(36);n.exports=i?function(n,e,t){return r.f(n,e,o(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var i=t(8).Symbol;n.exports=i},function(n,e,t){"use strict";var i=t(18),r=t(33),o=t(34),a=t(133),s=t(135);i({target:"Array",proto:!0,arity:1,forced:t(4)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=r(this),t=o(e),i=arguments.length;s(t+i);for(var l=0;l<i;l++)e[t]=arguments[l],t++;return a(e,t),t}})},function(n,e,t){"use strict";var i=t(1),r=t(52).f,o=t(15),a=t(101),s=t(38),l=t(66),c=t(129);n.exports=function(n,e){var t,u,d,p,m,h=n.target,f=n.global,g=n.stat;if(t=f?i:g?i[h]||s(h,{}):(i[h]||{}).prototype)for(u in e){if(p=e[u],d=n.dontCallGetSet?(m=r(t,u))&&m.value:t[u],!c(f?u:h+(g?".":"#")+u,n.forced)&&void 0!==d){if(typeof p==typeof d)continue;l(p,d)}(n.sham||d&&d.sham)&&o(p,"sham",!0),a(t,u,p,n)}}},function(n,e,t){"use strict";var i=t(3),r=i({}.toString),o=i("".slice);n.exports=function(n){return o(r(n),8,-1)}},function(n,e,t){"use strict";var i=t(1),r=t(62),o=t(7),a=t(64),s=t(60),l=t(59),c=i.Symbol,u=r("wks"),d=l?c.for||c:c&&c.withoutSetter||a;n.exports=function(n){return o(u,n)||(u[n]=s&&o(c,n)?c[n]:d("Symbol."+n)),u[n]}},function(n,e,t){var i=t(158),r=t(159),o=t(160),a=t(161),s=t(162);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var i=n[e];this.set(i[0],i[1])}}l.prototype.clear=i,l.prototype.delete=r,l.prototype.get=o,l.prototype.has=a,l.prototype.set=s,n.exports=l},function(n,e,t){var i=t(72);n.exports=function(n,e){for(var t=n.length;t--;)if(i(n[t][0],e))return t;return-1}},function(n,e,t){var i=t(10)(Object,"create");n.exports=i},function(n,e,t){var i=t(180);n.exports=function(n,e){var t=n.__data__;return i(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var i=t(46);n.exports=function(n){if("string"==typeof n||i(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var i,r;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(r="function"==typeof(i=function(){var n,e,t={version:"0.2.0"},i=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function r(n,e,t){return n<e?e:n>t?t:n}function o(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(i[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=r(n,i.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(i.barSelector),u=i.speed,d=i.easing;return l.offsetWidth,a((function(e){""===i.positionUsing&&(i.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var r;return(r="translate3d"===i.positionUsing?{transform:"translate3d("+o(n)+"%,0,0)"}:"translate"===i.positionUsing?{transform:"translate("+o(n)+"%,0)"}:{"margin-left":o(n)+"%"}).transition="all "+e+"ms "+t,r}(n,u,d)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+u+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),u)}),u)):setTimeout(e,u)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),i.trickleSpeed)};return i.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*r(Math.random()*e,.1,.95)),e=r(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*i.trickleRate)},n=0,e=0,t.promise=function(i){return i&&"resolved"!==i.state()?(0===e&&t.start(),n++,e++,i.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=i.template;var r,a=e.querySelector(i.barSelector),l=n?"-100":o(t.status||0),u=document.querySelector(i.parent);return s(a,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),i.showSpinner||(r=e.querySelector(i.spinnerSelector))&&p(r),u!=document.body&&c(u,"nprogress-custom-parent"),u.appendChild(e),e},t.remove=function(){u(document.documentElement,"nprogress-busy"),u(document.querySelector(i.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var a=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var i,r=n.length,o=e.charAt(0).toUpperCase()+e.slice(1);r--;)if((i=n[r]+o)in t)return i;return e}(t))}function i(n,e,i){e=t(e),n.style[e]=i}return function(n,e){var t,r,o=arguments;if(2==o.length)for(t in e)void 0!==(r=e[t])&&e.hasOwnProperty(t)&&i(n,t,r);else i(n,o[1],o[2])}}();function l(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=d(n),i=t+e;l(t,e)||(n.className=i.substring(1))}function u(n,e){var t,i=d(n);l(n,e)&&(t=i.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?i.call(e,t,e,n):i)||(n.exports=r)},function(n){n.exports=JSON.parse('{"name":"vuepress-plugin-comment","version":"0.7.3","description":"Comment plugin in vuepress, such as Gitalk, Valine...","main":"index.js","scripts":{"test":"echo \\"Error: no test specified\\" && exit 1"},"repository":{"type":"git","url":"git+ssh://git@github.com/dongyuanxin/vuepress-plugin-comment.git"},"keywords":["vuepress","comment","plugin","vue","gitalk","valine"],"author":"dongyuanxin","license":"MIT","bugs":{"url":"https://github.com/dongyuanxin/vuepress-plugin-comment/issues"},"homepage":"https://github.com/dongyuanxin/vuepress-plugin-comment#readme","dependencies":{"ejs":"^2.6.1","gitalk":"^1.5.0","gitalk-fix":"^1.5.2","i":"^0.3.6","npm":"^6.9.0","valine":"^1.3.9"}}')},function(n,e,t){"use strict";var i=t(9),r=String,o=TypeError;n.exports=function(n){if(i(n))return n;throw new o(r(n)+" is not an object")}},function(n,e,t){"use strict";var i=t(4);n.exports=!i((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){"use strict";var i=t(49),r=t(53);n.exports=function(n){return i(r(n))}},function(n,e,t){"use strict";var i=t(1),r=t(2),o=function(n){return r(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?o(i[n]):i[n]&&i[n][e]}},function(n,e,t){"use strict";var i=t(2),r=t(116),o=TypeError;n.exports=function(n){if(i(n))return n;throw new o(r(n)+" is not a function")}},function(n,e,t){"use strict";var i=t(53),r=Object;n.exports=function(n){return r(i(n))}},function(n,e,t){"use strict";var i=t(127);n.exports=function(n){return i(n.length)}},function(n,e,t){"use strict";var i=t(29),r=Function.prototype.call;n.exports=i?r.bind(r):function(){return r.apply(r,arguments)}},function(n,e,t){"use strict";n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){"use strict";var i=t(1),r=t(38),o=i["__core-js_shared__"]||r("__core-js_shared__",{});n.exports=o},function(n,e,t){"use strict";var i=t(1),r=Object.defineProperty;n.exports=function(n,e){try{r(i,n,{value:e,configurable:!0,writable:!0})}catch(t){i[n]=e}return e}},function(n,e,t){var i=t(152),r=t(12),o=Object.prototype,a=o.hasOwnProperty,s=o.propertyIsEnumerable,l=i(function(){return arguments}())?i:function(n){return r(n)&&a.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var i=t(10)(t(8),"Map");n.exports=i},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var i=t(172),r=t(179),o=t(181),a=t(182),s=t(183);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var i=n[e];this.set(i[0],i[1])}}l.prototype.clear=i,l.prototype.delete=r,l.prototype.get=o,l.prototype.has=a,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var i=t(6),r=t(46),o=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,a=/^\w*$/;n.exports=function(n,e){if(i(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!r(n))||(a.test(n)||!o.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var i=t(14),r=t(12);n.exports=function(n){return"symbol"==typeof n||r(n)&&"[object Symbol]"==i(n)}},function(n,e){n.exports=function(n){return n}},function(n,e){var t=/^\s+|\s+$/g,i=/^[-+]0x[0-9a-f]+$/i,r=/^0b[01]+$/i,o=/^0o[0-7]+$/i,a=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),u=Object.prototype.toString,d=Math.max,p=Math.min,m=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function f(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==u.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=r.test(n);return s||o.test(n)?a(n.slice(2),s?2:8):i.test(n)?NaN:+n}n.exports=function(n,e,t){var i,r,o,a,s,l,c=0,u=!1,g=!1,v=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=i,o=r;return i=r=void 0,c=e,a=n.apply(o,t)}function x(n){return c=n,s=setTimeout(k,e),u?b(n):a}function y(n){var t=n-l;return void 0===l||t>=e||t<0||g&&n-c>=o}function k(){var n=m();if(y(n))return w(n);s=setTimeout(k,function(n){var t=e-(n-l);return g?p(t,o-(n-c)):t}(n))}function w(n){return s=void 0,v&&i?b(n):(i=r=void 0,a)}function _(){var n=m(),t=y(n);if(i=arguments,r=this,l=n,t){if(void 0===s)return x(l);if(g)return s=setTimeout(k,e),b(l)}return void 0===s&&(s=setTimeout(k,e)),a}return e=f(e)||0,h(t)&&(u=!!t.leading,o=(g="maxWait"in t)?d(f(t.maxWait)||0,e):o,v="trailing"in t?!!t.trailing:v),_.cancel=function(){void 0!==s&&clearTimeout(s),c=0,i=l=r=s=void 0},_.flush=function(){return void 0===s?a:w(m())},_}},function(n,e,t){"use strict";var i=t(3),r=t(4),o=t(19),a=Object,s=i("".split);n.exports=r((function(){return!a("z").propertyIsEnumerable(0)}))?function(n){return"String"===o(n)?s(n,""):a(n)}:a},function(n,e,t){"use strict";n.exports={}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e,t){"use strict";var i=t(5),r=t(35),o=t(112),a=t(36),s=t(30),l=t(55),c=t(7),u=t(65),d=Object.getOwnPropertyDescriptor;e.f=i?d:function(n,e){if(n=s(n),e=l(e),u)try{return d(n,e)}catch(n){}if(c(n,e))return a(!r(o.f,n,e),n[e])}},function(n,e,t){"use strict";var i=t(54),r=TypeError;n.exports=function(n){if(i(n))throw new r("Can't call method on "+n);return n}},function(n,e,t){"use strict";n.exports=function(n){return null==n}},function(n,e,t){"use strict";var i=t(113),r=t(57);n.exports=function(n){var e=i(n,"string");return r(e)?e:e+""}},function(n,e,t){"use strict";var i="object"==typeof document&&document.all,r=void 0===i&&void 0!==i;n.exports={all:i,IS_HTMLDDA:r}},function(n,e,t){"use strict";var i=t(31),r=t(2),o=t(58),a=t(59),s=Object;n.exports=a?function(n){return"symbol"==typeof n}:function(n){var e=i("Symbol");return r(e)&&o(e.prototype,s(n))}},function(n,e,t){"use strict";var i=t(3);n.exports=i({}.isPrototypeOf)},function(n,e,t){"use strict";var i=t(60);n.exports=i&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){"use strict";var i=t(61),r=t(4),o=t(1).String;n.exports=!!Object.getOwnPropertySymbols&&!r((function(){var n=Symbol("symbol detection");return!o(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&i&&i<41}))},function(n,e,t){"use strict";var i,r,o=t(1),a=t(114),s=o.process,l=o.Deno,c=s&&s.versions||l&&l.version,u=c&&c.v8;u&&(r=(i=u.split("."))[0]>0&&i[0]<4?1:+(i[0]+i[1])),!r&&a&&(!(i=a.match(/Edge\/(\d+)/))||i[1]>=74)&&(i=a.match(/Chrome\/(\d+)/))&&(r=+i[1]),n.exports=r},function(n,e,t){"use strict";var i=t(63),r=t(37);(n.exports=function(n,e){return r[n]||(r[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.33.3",mode:i?"pure":"global",copyright:"© 2014-2023 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.33.3/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){"use strict";n.exports=!1},function(n,e,t){"use strict";var i=t(3),r=0,o=Math.random(),a=i(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+a(++r+o,36)}},function(n,e,t){"use strict";var i=t(5),r=t(4),o=t(106);n.exports=!i&&!r((function(){return 7!==Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){"use strict";var i=t(7),r=t(122),o=t(52),a=t(13);n.exports=function(n,e,t){for(var s=r(e),l=a.f,c=o.f,u=0;u<s.length;u++){var d=s[u];i(n,d)||t&&i(t,d)||l(n,d,c(e,d))}}},function(n,e,t){"use strict";var i=t(126);n.exports=function(n){var e=+n;return e!=e||0===e?0:i(e)}},function(n,e,t){"use strict";var i=t(139),r=t(28),o=t(140);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=i(Object.prototype,"__proto__","set"))(t,[]),e=t instanceof Array}catch(n){}return function(t,i){return r(t),o(i),e?n(t,i):t.__proto__=i,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,i=e.length,r=n.length;++t<i;)n[r+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var i=t(21),r=t(163),o=t(164),a=t(165),s=t(166),l=t(167);function c(n){var e=this.__data__=new i(n);this.size=e.size}c.prototype.clear=r,c.prototype.delete=o,c.prototype.get=a,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var i=t(14),r=t(41);n.exports=function(n){if(!r(n))return!1;var e=i(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var i=t(184),r=t(12);n.exports=function n(e,t,o,a,s){return e===t||(null==e||null==t||!r(e)&&!r(t)?e!=e&&t!=t:i(e,t,o,a,n,s))}},function(n,e,t){var i=t(77),r=t(187),o=t(78);n.exports=function(n,e,t,a,s,l){var c=1&t,u=n.length,d=e.length;if(u!=d&&!(c&&d>u))return!1;var p=l.get(n),m=l.get(e);if(p&&m)return p==e&&m==n;var h=-1,f=!0,g=2&t?new i:void 0;for(l.set(n,e),l.set(e,n);++h<u;){var v=n[h],b=e[h];if(a)var x=c?a(b,v,h,e,n,l):a(v,b,h,n,e,l);if(void 0!==x){if(x)continue;f=!1;break}if(g){if(!r(e,(function(n,e){if(!o(g,e)&&(v===n||s(v,n,t,a,l)))return g.push(e)}))){f=!1;break}}else if(v!==b&&!s(v,b,t,a,l)){f=!1;break}}return l.delete(n),l.delete(e),f}},function(n,e,t){var i=t(42),r=t(185),o=t(186);function a(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new i;++e<t;)this.add(n[e])}a.prototype.add=a.prototype.push=r,a.prototype.has=o,n.exports=a},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var i=t(197),r=t(203),o=t(83);n.exports=function(n){return o(n)?i(n):r(n)}},function(n,e,t){(function(n){var i=t(8),r=t(199),o=e&&!e.nodeType&&e,a=o&&"object"==typeof n&&n&&!n.nodeType&&n,s=a&&a.exports===o?i.Buffer:void 0,l=(s?s.isBuffer:void 0)||r;n.exports=l}).call(this,t(51)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var i=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==i||"symbol"!=i&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var i=t(200),r=t(201),o=t(202),a=o&&o.isTypedArray,s=a?r(a):i;n.exports=s},function(n,e,t){var i=t(73),r=t(44);n.exports=function(n){return null!=n&&r(n.length)&&!i(n)}},function(n,e,t){var i=t(10)(t(8),"Set");n.exports=i},function(n,e,t){var i=t(41);n.exports=function(n){return n==n&&!i(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var i=t(88),r=t(25);n.exports=function(n,e){for(var t=0,o=(e=i(e,n)).length;null!=n&&t<o;)n=n[r(e[t++])];return t&&t==o?n:void 0}},function(n,e,t){var i=t(6),r=t(45),o=t(214),a=t(217);n.exports=function(n,e){return i(n)?n:r(n,e)?[n]:o(a(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var i=t(150),r=t(155),o=t(226),a=t(234),s=t(243),l=t(103),c=o((function(n){var e=l(n);return s(e)&&(e=void 0),a(i(n,1,s,!0),r(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var i=/["'&<>]/;n.exports=function(n){var e,t=""+n,r=i.exec(t);if(!r)return t;var o="",a=0,s=0;for(a=r.index;a<t.length;a++){switch(t.charCodeAt(a)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==a&&(o+=t.substring(s,a)),s=a+1,o+=e}return s!==a?o+t.substring(s,a):o}},function(n,e,t){"use strict";
/**
 * @file Embedded JavaScript templating engine. {@link http://ejs.co}
 * @author Matthew Eernisse <mde@fleegix.org>
 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 * @project EJS
 * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
 */var i=t(255),r=t(256),o=t(257),a=!1,s=t(258).version,l=["delimiter","scope","context","debug","compileDebug","client","_with","rmWhitespace","strict","filename","async"],c=l.concat("cache"),u=/^\uFEFF/;function d(n,t){var r,o,a=t.views,s=/^[A-Za-z]+:\\|^\//.exec(n);if(s&&s.length)r=e.resolveInclude(n.replace(/^\/*/,""),t.root||"/",!0);else if(t.filename&&(o=e.resolveInclude(n,t.filename),i.existsSync(o)&&(r=o)),r||Array.isArray(a)&&a.some((function(t){return o=e.resolveInclude(n,t,!0),i.existsSync(o)}))&&(r=o),!r)throw new Error('Could not find the include file "'+t.escapeFunction(n)+'"');return r}function p(n,t){var i,r=n.filename,o=arguments.length>1;if(n.cache){if(!r)throw new Error("cache option requires a filename");if(i=e.cache.get(r))return i;o||(t=h(r).toString().replace(u,""))}else if(!o){if(!r)throw new Error("Internal EJS error: no file name or template provided");t=h(r).toString().replace(u,"")}return i=e.compile(t,n),n.cache&&e.cache.set(r,i),i}function m(n,t,i){var r;if(!i){if("function"==typeof e.promiseImpl)return new e.promiseImpl((function(e,i){try{e(r=p(n)(t))}catch(n){i(n)}}));throw new Error("Please provide a callback function")}try{r=p(n)(t)}catch(n){return i(n)}i(null,r)}function h(n){return e.fileLoader(n)}function f(n,e,t,i,r){var o=e.split("\n"),a=Math.max(i-3,0),s=Math.min(o.length,i+3),l=r(t),c=o.slice(a,s).map((function(n,e){var t=e+a+1;return(t==i?" >> ":"    ")+t+"| "+n})).join("\n");throw n.path=l,n.message=(l||"ejs")+":"+i+"\n"+c+"\n\n"+n.message,n}function g(n){return n.replace(/;(\s*$)/,"$1")}function v(n,t){t=t||{};var i={};this.templateText=n,this.mode=null,this.truncate=!1,this.currentLine=1,this.source="",this.dependencies=[],i.client=t.client||!1,i.escapeFunction=t.escape||t.escapeFunction||o.escapeXML,i.compileDebug=!1!==t.compileDebug,i.debug=!!t.debug,i.filename=t.filename,i.openDelimiter=t.openDelimiter||e.openDelimiter||"<",i.closeDelimiter=t.closeDelimiter||e.closeDelimiter||">",i.delimiter=t.delimiter||e.delimiter||"%",i.strict=t.strict||!1,i.context=t.context,i.cache=t.cache||!1,i.rmWhitespace=t.rmWhitespace,i.root=t.root,i.outputFunctionName=t.outputFunctionName,i.localsName=t.localsName||e.localsName||"locals",i.views=t.views,i.async=t.async,i.destructuredLocals=t.destructuredLocals,i.legacyInclude=void 0===t.legacyInclude||!!t.legacyInclude,i.strict?i._with=!1:i._with=void 0===t._with||t._with,this.opts=i,this.regex=this.createRegex()}e.cache=o.cache,e.fileLoader=i.readFileSync,e.localsName="locals",e.promiseImpl=new Function("return this;")().Promise,e.resolveInclude=function(n,e,t){var i=r.dirname,o=r.extname,a=(0,r.resolve)(t?e:i(e),n);return o(n)||(a+=".ejs"),a},e.compile=function(n,e){return e&&e.scope&&(a||(console.warn("`scope` option is deprecated and will be removed in EJS 3"),a=!0),e.context||(e.context=e.scope),delete e.scope),new v(n,e).compile()},e.render=function(n,e,t){var i=e||{},r=t||{};return 2==arguments.length&&o.shallowCopyFromList(r,i,l),p(r,n)(i)},e.renderFile=function(){var n,e,t,i=Array.prototype.slice.call(arguments),r=i.shift(),a={filename:r};return"function"==typeof arguments[arguments.length-1]&&(n=i.pop()),i.length?(e=i.shift(),i.length?o.shallowCopy(a,i.pop()):(e.settings&&(e.settings.views&&(a.views=e.settings.views),e.settings["view cache"]&&(a.cache=!0),(t=e.settings["view options"])&&o.shallowCopy(a,t)),o.shallowCopyFromList(a,e,c)),a.filename=r):e={},m(a,e,n)},e.Template=v,e.clearCache=function(){e.cache.reset()},v.modes={EVAL:"eval",ESCAPED:"escaped",RAW:"raw",COMMENT:"comment",LITERAL:"literal"},v.prototype={createRegex:function(){var n="(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)",e=o.escapeRegExpChars(this.opts.delimiter),t=o.escapeRegExpChars(this.opts.openDelimiter),i=o.escapeRegExpChars(this.opts.closeDelimiter);return n=n.replace(/%/g,e).replace(/</g,t).replace(/>/g,i),new RegExp(n)},compile:function(){var n,e,t,i=this.opts,a="",s="",l=i.escapeFunction;if(!this.source){if(this.generateSource(),a+='  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n',i.outputFunctionName&&(a+="  var "+i.outputFunctionName+" = __append;\n"),i.destructuredLocals&&i.destructuredLocals.length){for(var c="  var __locals = ("+i.localsName+" || {}),\n",u=0;u<i.destructuredLocals.length;u++){var m=i.destructuredLocals[u];u>0&&(c+=",\n  "),c+=m+" = __locals."+m}a+=c+";\n"}!1!==i._with&&(a+="  with ("+i.localsName+" || {}) {\n",s+="  }\n"),s+="  return __output;\n",this.source=a+this.source+s}n=i.compileDebug?"var __line = 1\n  , __lines = "+JSON.stringify(this.templateText)+"\n  , __filename = "+(i.filename?JSON.stringify(i.filename):"undefined")+";\ntry {\n"+this.source+"} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n":this.source,i.client&&(n="escapeFn = escapeFn || "+l.toString()+";\n"+n,i.compileDebug&&(n="rethrow = rethrow || "+f.toString()+";\n"+n)),i.strict&&(n='"use strict";\n'+n),i.debug&&console.log(n),i.compileDebug&&i.filename&&(n=n+"\n//# sourceURL="+i.filename+"\n");try{if(i.async)try{t=new Function("return (async function(){}).constructor;")()}catch(n){throw n instanceof SyntaxError?new Error("This environment does not support async/await"):n}else t=Function;e=new t(i.localsName+", escapeFn, include, rethrow",n)}catch(n){throw n instanceof SyntaxError&&(i.filename&&(n.message+=" in "+i.filename),n.message+=" while compiling ejs\n\n",n.message+="If the above error is not helpful, you may want to try EJS-Lint:\n",n.message+="https://github.com/RyanZim/EJS-Lint",i.async||(n.message+="\n",n.message+="Or, if you meant to create an async function, pass `async: true` as an option.")),n}var h=i.client?e:function(n){return e.apply(i.context,[n||{},l,function(e,t){var r=o.shallowCopy({},n);return t&&(r=o.shallowCopy(r,t)),function(n,e){var t=o.shallowCopy({},e);return t.filename=d(n,t),p(t)}(e,i)(r)},f])};if(h.dependencies=this.dependencies,i.filename&&"function"==typeof Object.defineProperty){var g=i.filename,v=r.basename(g,r.extname(g));try{Object.defineProperty(h,"name",{value:v,writable:!1,enumerable:!1,configurable:!0})}catch(n){}}return h},generateSource:function(){var n=this.opts;n.rmWhitespace&&(this.templateText=this.templateText.replace(/[\r\n]+/g,"\n").replace(/^\s+|\s+$/gm,"")),this.templateText=this.templateText.replace(/[ \t]*<%_/gm,"<%_").replace(/_%>[ \t]*/gm,"_%>");var t=this,i=this.parseTemplateText(),r=this.opts.delimiter,a=this.opts.openDelimiter,s=this.opts.closeDelimiter;i&&i.length&&i.forEach((function(l,c){var p,m,f,g,b,x;if(0===l.indexOf(a+r)&&0!==l.indexOf(a+r+r)&&(m=i[c+2])!=r+s&&m!="-"+r+s&&m!="_"+r+s)throw new Error('Could not find matching close tag for "'+l+'".');if(n.legacyInclude&&(f=l.match(/^\s*include\s+(\S+)/))&&(p=i[c-1])&&(p==a+r||p==a+r+"-"||p==a+r+"_"))return g=o.shallowCopy({},t.opts),b=function(n,e){var t,i,r=o.shallowCopy({},e);i=h(t=d(n,r)).toString().replace(u,""),r.filename=t;var a=new v(i,r);return a.generateSource(),{source:a.source,filename:t,template:i}}(f[1],g),x=t.opts.compileDebug?"    ; (function(){\n      var __line = 1\n      , __lines = "+JSON.stringify(b.template)+"\n      , __filename = "+JSON.stringify(b.filename)+";\n      try {\n"+b.source+"      } catch (e) {\n        rethrow(e, __lines, __filename, __line, escapeFn);\n      }\n    ; }).call(this)\n":"    ; (function(){\n"+b.source+"    ; }).call(this)\n",t.source+=x,void t.dependencies.push(e.resolveInclude(f[1],g.filename));t.scanLine(l)}))},parseTemplateText:function(){for(var n,e=this.templateText,t=this.regex,i=t.exec(e),r=[];i;)0!==(n=i.index)&&(r.push(e.substring(0,n)),e=e.slice(n)),r.push(i[0]),e=e.slice(i[0].length),i=t.exec(e);return e&&r.push(e),r},_addOutput:function(n){if(this.truncate&&(n=n.replace(/^(?:\r\n|\r|\n)/,""),this.truncate=!1),!n)return n;n=(n=(n=(n=n.replace(/\\/g,"\\\\")).replace(/\n/g,"\\n")).replace(/\r/g,"\\r")).replace(/"/g,'\\"'),this.source+='    ; __append("'+n+'")\n'},scanLine:function(n){var e,t=this.opts.delimiter,i=this.opts.openDelimiter,r=this.opts.closeDelimiter;switch(e=n.split("\n").length-1,n){case i+t:case i+t+"_":this.mode=v.modes.EVAL;break;case i+t+"=":this.mode=v.modes.ESCAPED;break;case i+t+"-":this.mode=v.modes.RAW;break;case i+t+"#":this.mode=v.modes.COMMENT;break;case i+t+t:this.mode=v.modes.LITERAL,this.source+='    ; __append("'+n.replace(i+t+t,i+t)+'")\n';break;case t+t+r:this.mode=v.modes.LITERAL,this.source+='    ; __append("'+n.replace(t+t+r,t+r)+'")\n';break;case t+r:case"-"+t+r:case"_"+t+r:this.mode==v.modes.LITERAL&&this._addOutput(n),this.mode=null,this.truncate=0===n.indexOf("-")||0===n.indexOf("_");break;default:if(this.mode){switch(this.mode){case v.modes.EVAL:case v.modes.ESCAPED:case v.modes.RAW:n.lastIndexOf("//")>n.lastIndexOf("\n")&&(n+="\n")}switch(this.mode){case v.modes.EVAL:this.source+="    ; "+n+"\n";break;case v.modes.ESCAPED:this.source+="    ; __append(escapeFn("+g(n)+"))\n";break;case v.modes.RAW:this.source+="    ; __append("+g(n)+")\n";break;case v.modes.COMMENT:break;case v.modes.LITERAL:this._addOutput(n)}}else this._addOutput(n)}this.opts.compileDebug&&e&&(this.currentLine+=e,this.source+="    ; __line = "+this.currentLine+"\n")}},e.escapeXML=o.escapeXML,e.__express=e.renderFile,e.VERSION=s,e.name="ejs","undefined"!=typeof window&&(window.ejs=e)},function(n,e,t){"use strict";t.r(e);var i={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},r=(t(246),t(0)),o=Object(r.a)(i,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=o.exports},function(n,e,t){"use strict";t.r(e);var i={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},r=(t(247),t(0)),o=Object(r.a)(i,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,i){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":i===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(i)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=o.exports},function(n,e,t){"use strict";var i=t(2),r=t(13),o=t(104),a=t(38);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,c=void 0!==s.name?s.name:e;if(i(t)&&o(t,c,s),s.global)l?n[e]=t:a(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:r.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){"use strict";var i=t(144),r=String;n.exports=function(n){if("Symbol"===i(n))throw new TypeError("Cannot convert a Symbol value to a string");return r(n)}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){"use strict";var i=t(3),r=t(4),o=t(2),a=t(7),s=t(5),l=t(118).CONFIGURABLE,c=t(119),u=t(120),d=u.enforce,p=u.get,m=String,h=Object.defineProperty,f=i("".slice),g=i("".replace),v=i([].join),b=s&&!r((function(){return 8!==h((function(){}),"length",{value:8}).length})),x=String(String).split("String"),y=n.exports=function(n,e,t){"Symbol("===f(m(e),0,7)&&(e="["+g(m(e),/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!a(n,"name")||l&&n.name!==e)&&(s?h(n,"name",{value:e,configurable:!0}):n.name=e),b&&t&&a(t,"arity")&&n.length!==t.arity&&h(n,"length",{value:t.arity});try{t&&a(t,"constructor")&&t.constructor?s&&h(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var i=d(n);return a(i,"source")||(i.source=v(x,"string"==typeof e?e:"")),n};Function.prototype.toString=y((function(){return o(this)&&p(this).source||c(this)}),"toString")},function(n,e,t){"use strict";n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){"use strict";var i=t(1),r=t(9),o=i.document,a=r(o)&&r(o.createElement);n.exports=function(n){return a?o.createElement(n):{}}},function(n,e,t){"use strict";var i=t(5),r=t(4);n.exports=i&&r((function(){return 42!==Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){"use strict";var i=t(62),r=t(64),o=i("keys");n.exports=function(n){return o[n]||(o[n]=r(n))}},function(n,e,t){"use strict";var i=t(3),r=t(7),o=t(30),a=t(124).indexOf,s=t(50),l=i([].push);n.exports=function(n,e){var t,i=o(n),c=0,u=[];for(t in i)!r(s,t)&&r(i,t)&&l(u,t);for(;e.length>c;)r(i,t=e[c++])&&(~a(u,t)||l(u,t));return u}},function(n,e,t){n.exports=t(261)},function(n,e,t){"use strict";var i=t(18),r=t(130).left,o=t(131),a=t(61);i({target:"Array",proto:!0,forced:!t(132)&&a>79&&a<83||!o("reduce")},{reduce:function(n){var e=arguments.length;return r(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var i={}.propertyIsEnumerable,r=Object.getOwnPropertyDescriptor,o=r&&!i.call({1:2},1);e.f=o?function(n){var e=r(this,n);return!!e&&e.enumerable}:i},function(n,e,t){"use strict";var i=t(35),r=t(9),o=t(57),a=t(115),s=t(117),l=t(20),c=TypeError,u=l("toPrimitive");n.exports=function(n,e){if(!r(n)||o(n))return n;var t,l=a(n,u);if(l){if(void 0===e&&(e="default"),t=i(l,n,e),!r(t)||o(t))return t;throw new c("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e,t){"use strict";n.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},function(n,e,t){"use strict";var i=t(32),r=t(54);n.exports=function(n,e){var t=n[e];return r(t)?void 0:i(t)}},function(n,e,t){"use strict";var i=String;n.exports=function(n){try{return i(n)}catch(n){return"Object"}}},function(n,e,t){"use strict";var i=t(35),r=t(2),o=t(9),a=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&r(t=n.toString)&&!o(s=i(t,n)))return s;if(r(t=n.valueOf)&&!o(s=i(t,n)))return s;if("string"!==e&&r(t=n.toString)&&!o(s=i(t,n)))return s;throw new a("Can't convert object to primitive value")}},function(n,e,t){"use strict";var i=t(5),r=t(7),o=Function.prototype,a=i&&Object.getOwnPropertyDescriptor,s=r(o,"name"),l=s&&"something"===function(){}.name,c=s&&(!i||i&&a(o,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){"use strict";var i=t(3),r=t(2),o=t(37),a=i(Function.toString);r(o.inspectSource)||(o.inspectSource=function(n){return a(n)}),n.exports=o.inspectSource},function(n,e,t){"use strict";var i,r,o,a=t(121),s=t(1),l=t(9),c=t(15),u=t(7),d=t(37),p=t(108),m=t(50),h=s.TypeError,f=s.WeakMap;if(a||d.state){var g=d.state||(d.state=new f);g.get=g.get,g.has=g.has,g.set=g.set,i=function(n,e){if(g.has(n))throw new h("Object already initialized");return e.facade=n,g.set(n,e),e},r=function(n){return g.get(n)||{}},o=function(n){return g.has(n)}}else{var v=p("state");m[v]=!0,i=function(n,e){if(u(n,v))throw new h("Object already initialized");return e.facade=n,c(n,v,e),e},r=function(n){return u(n,v)?n[v]:{}},o=function(n){return u(n,v)}}n.exports={set:i,get:r,has:o,enforce:function(n){return o(n)?r(n):i(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=r(e)).type!==n)throw new h("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){"use strict";var i=t(1),r=t(2),o=i.WeakMap;n.exports=r(o)&&/native code/.test(String(o))},function(n,e,t){"use strict";var i=t(31),r=t(3),o=t(123),a=t(128),s=t(28),l=r([].concat);n.exports=i("Reflect","ownKeys")||function(n){var e=o.f(s(n)),t=a.f;return t?l(e,t(n)):e}},function(n,e,t){"use strict";var i=t(109),r=t(105).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return i(n,r)}},function(n,e,t){"use strict";var i=t(30),r=t(125),o=t(34),a=function(n){return function(e,t,a){var s,l=i(e),c=o(l),u=r(a,c);if(n&&t!=t){for(;c>u;)if((s=l[u++])!=s)return!0}else for(;c>u;u++)if((n||u in l)&&l[u]===t)return n||u||0;return!n&&-1}};n.exports={includes:a(!0),indexOf:a(!1)}},function(n,e,t){"use strict";var i=t(67),r=Math.max,o=Math.min;n.exports=function(n,e){var t=i(n);return t<0?r(t+e,0):o(t,e)}},function(n,e,t){"use strict";var i=Math.ceil,r=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?r:i)(e)}},function(n,e,t){"use strict";var i=t(67),r=Math.min;n.exports=function(n){return n>0?r(i(n),9007199254740991):0}},function(n,e,t){"use strict";e.f=Object.getOwnPropertySymbols},function(n,e,t){"use strict";var i=t(4),r=t(2),o=/#|\.prototype\./,a=function(n,e){var t=l[s(n)];return t===u||t!==c&&(r(e)?i(e):!!e)},s=a.normalize=function(n){return String(n).replace(o,".").toLowerCase()},l=a.data={},c=a.NATIVE="N",u=a.POLYFILL="P";n.exports=a},function(n,e,t){"use strict";var i=t(32),r=t(33),o=t(49),a=t(34),s=TypeError,l=function(n){return function(e,t,l,c){i(t);var u=r(e),d=o(u),p=a(u),m=n?p-1:0,h=n?-1:1;if(l<2)for(;;){if(m in d){c=d[m],m+=h;break}if(m+=h,n?m<0:p<=m)throw new s("Reduce of empty array with no initial value")}for(;n?m>=0:p>m;m+=h)m in d&&(c=t(c,d[m],m,u));return c}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var i=t(4);n.exports=function(n,e){var t=[][n];return!!t&&i((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){"use strict";var i=t(1),r=t(19);n.exports="process"===r(i.process)},function(n,e,t){"use strict";var i=t(5),r=t(134),o=TypeError,a=Object.getOwnPropertyDescriptor,s=i&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,e){if(r(n)&&!a(n,"length").writable)throw new o("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){"use strict";var i=t(19);n.exports=Array.isArray||function(n){return"Array"===i(n)}},function(n,e,t){"use strict";var i=TypeError;n.exports=function(n){if(n>9007199254740991)throw i("Maximum allowed index exceeded");return n}},function(n,e,t){"use strict";var i=t(18),r=t(1),o=t(137),a=t(138),s=r.WebAssembly,l=7!==new Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=a(n,e,l),i({global:!0,constructor:!0,arity:1,forced:l},t)},u=function(n,e){if(s&&s[n]){var t={};t[n]=a("WebAssembly."+n,e,l),i({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return o(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return o(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return o(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return o(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return o(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return o(n,this,arguments)}})),c("URIError",(function(n){return function(e){return o(n,this,arguments)}})),u("CompileError",(function(n){return function(e){return o(n,this,arguments)}})),u("LinkError",(function(n){return function(e){return o(n,this,arguments)}})),u("RuntimeError",(function(n){return function(e){return o(n,this,arguments)}}))},function(n,e,t){"use strict";var i=t(29),r=Function.prototype,o=r.apply,a=r.call;n.exports="object"==typeof Reflect&&Reflect.apply||(i?a.bind(o):function(){return a.apply(o,arguments)})},function(n,e,t){"use strict";var i=t(31),r=t(7),o=t(15),a=t(58),s=t(68),l=t(66),c=t(141),u=t(142),d=t(143),p=t(146),m=t(147),h=t(5),f=t(63);n.exports=function(n,e,t,g){var v=g?2:1,b=n.split("."),x=b[b.length-1],y=i.apply(null,b);if(y){var k=y.prototype;if(!f&&r(k,"cause")&&delete k.cause,!t)return y;var w=i("Error"),_=e((function(n,e){var t=d(g?e:n,void 0),i=g?new y(n):new y;return void 0!==t&&o(i,"message",t),m(i,_,i.stack,2),this&&a(k,this)&&u(i,this,_),arguments.length>v&&p(i,arguments[v]),i}));if(_.prototype=k,"Error"!==x?s?s(_,w):l(_,w,{name:!0}):h&&"stackTraceLimit"in y&&(c(_,y,"stackTraceLimit"),c(_,y,"prepareStackTrace")),l(_,y),!f)try{k.name!==x&&o(k,"name",x),k.constructor=_}catch(n){}return _}}},function(n,e,t){"use strict";var i=t(3),r=t(32);n.exports=function(n,e,t){try{return i(r(Object.getOwnPropertyDescriptor(n,e)[t]))}catch(n){}}},function(n,e,t){"use strict";var i=t(2),r=String,o=TypeError;n.exports=function(n){if("object"==typeof n||i(n))return n;throw new o("Can't set "+r(n)+" as a prototype")}},function(n,e,t){"use strict";var i=t(13).f;n.exports=function(n,e,t){t in n||i(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){"use strict";var i=t(2),r=t(9),o=t(68);n.exports=function(n,e,t){var a,s;return o&&i(a=e.constructor)&&a!==t&&r(s=a.prototype)&&s!==t.prototype&&o(n,s),n}},function(n,e,t){"use strict";var i=t(102);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:i(n)}},function(n,e,t){"use strict";var i=t(145),r=t(2),o=t(19),a=t(20)("toStringTag"),s=Object,l="Arguments"===o(function(){return arguments}());n.exports=i?o:function(n){var e,t,i;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),a))?t:l?o(e):"Object"===(i=o(e))&&r(e.callee)?"Arguments":i}},function(n,e,t){"use strict";var i={};i[t(20)("toStringTag")]="z",n.exports="[object z]"===String(i)},function(n,e,t){"use strict";var i=t(9),r=t(15);n.exports=function(n,e){i(e)&&"cause"in e&&r(n,"cause",e.cause)}},function(n,e,t){"use strict";var i=t(15),r=t(148),o=t(149),a=Error.captureStackTrace;n.exports=function(n,e,t,s){o&&(a?a(n,e):i(n,"stack",r(t,s)))}},function(n,e,t){"use strict";var i=t(3),r=Error,o=i("".replace),a=String(new r("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(a);n.exports=function(n,e){if(l&&"string"==typeof n&&!r.prepareStackTrace)for(;e--;)n=o(n,s,"");return n}},function(n,e,t){"use strict";var i=t(4),r=t(36);n.exports=!i((function(){var n=new Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",r(1,7)),7!==n.stack)}))},function(n,e,t){var i=t(69),r=t(151);n.exports=function n(e,t,o,a,s){var l=-1,c=e.length;for(o||(o=r),s||(s=[]);++l<c;){var u=e[l];t>0&&o(u)?t>1?n(u,t-1,o,a,s):i(s,u):a||(s[s.length]=u)}return s}},function(n,e,t){var i=t(16),r=t(39),o=t(6),a=i?i.isConcatSpreadable:void 0;n.exports=function(n){return o(n)||r(n)||!!(a&&n&&n[a])}},function(n,e,t){var i=t(14),r=t(12);n.exports=function(n){return r(n)&&"[object Arguments]"==i(n)}},function(n,e,t){var i=t(16),r=Object.prototype,o=r.hasOwnProperty,a=r.toString,s=i?i.toStringTag:void 0;n.exports=function(n){var e=o.call(n,s),t=n[s];try{n[s]=void 0;var i=!0}catch(n){}var r=a.call(n);return i&&(e?n[s]=t:delete n[s]),r}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var i=t(156),r=t(212),o=t(47),a=t(6),s=t(223);n.exports=function(n){return"function"==typeof n?n:null==n?o:"object"==typeof n?a(n)?r(n[0],n[1]):i(n):s(n)}},function(n,e,t){var i=t(157),r=t(211),o=t(86);n.exports=function(n){var e=r(n);return 1==e.length&&e[0][2]?o(e[0][0],e[0][1]):function(t){return t===n||i(t,n,e)}}},function(n,e,t){var i=t(71),r=t(75);n.exports=function(n,e,t,o){var a=t.length,s=a,l=!o;if(null==n)return!s;for(n=Object(n);a--;){var c=t[a];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++a<s;){var u=(c=t[a])[0],d=n[u],p=c[1];if(l&&c[2]){if(void 0===d&&!(u in n))return!1}else{var m=new i;if(o)var h=o(d,p,u,n,e,m);if(!(void 0===h?r(p,d,3,o,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var i=t(22),r=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=i(e,n);return!(t<0)&&(t==e.length-1?e.pop():r.call(e,t,1),--this.size,!0)}},function(n,e,t){var i=t(22);n.exports=function(n){var e=this.__data__,t=i(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var i=t(22);n.exports=function(n){return i(this.__data__,n)>-1}},function(n,e,t){var i=t(22);n.exports=function(n,e){var t=this.__data__,r=i(t,n);return r<0?(++this.size,t.push([n,e])):t[r][1]=e,this}},function(n,e,t){var i=t(21);n.exports=function(){this.__data__=new i,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var i=t(21),r=t(40),o=t(42);n.exports=function(n,e){var t=this.__data__;if(t instanceof i){var a=t.__data__;if(!r||a.length<199)return a.push([n,e]),this.size=++t.size,this;t=this.__data__=new o(a)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var i=t(73),r=t(169),o=t(41),a=t(74),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,u=l.toString,d=c.hasOwnProperty,p=RegExp("^"+u.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!o(n)||r(n))&&(i(n)?p:s).test(a(n))}},function(n,e,t){var i,r=t(170),o=(i=/[^.]+$/.exec(r&&r.keys&&r.keys.IE_PROTO||""))?"Symbol(src)_1."+i:"";n.exports=function(n){return!!o&&o in n}},function(n,e,t){var i=t(8)["__core-js_shared__"];n.exports=i},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var i=t(173),r=t(21),o=t(40);n.exports=function(){this.size=0,this.__data__={hash:new i,map:new(o||r),string:new i}}},function(n,e,t){var i=t(174),r=t(175),o=t(176),a=t(177),s=t(178);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var i=n[e];this.set(i[0],i[1])}}l.prototype.clear=i,l.prototype.delete=r,l.prototype.get=o,l.prototype.has=a,l.prototype.set=s,n.exports=l},function(n,e,t){var i=t(23);n.exports=function(){this.__data__=i?i(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var i=t(23),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(i){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return r.call(e,n)?e[n]:void 0}},function(n,e,t){var i=t(23),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return i?void 0!==e[n]:r.call(e,n)}},function(n,e,t){var i=t(23);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=i&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var i=t(24);n.exports=function(n){var e=i(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var i=t(24);n.exports=function(n){return i(this,n).get(n)}},function(n,e,t){var i=t(24);n.exports=function(n){return i(this,n).has(n)}},function(n,e,t){var i=t(24);n.exports=function(n,e){var t=i(this,n),r=t.size;return t.set(n,e),this.size+=t.size==r?0:1,this}},function(n,e,t){var i=t(71),r=t(76),o=t(188),a=t(191),s=t(207),l=t(6),c=t(80),u=t(82),d="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,f){var g=l(n),v=l(e),b=g?"[object Array]":s(n),x=v?"[object Array]":s(e),y=(b="[object Arguments]"==b?d:b)==d,k=(x="[object Arguments]"==x?d:x)==d,w=b==x;if(w&&c(n)){if(!c(e))return!1;g=!0,y=!1}if(w&&!y)return f||(f=new i),g||u(n)?r(n,e,t,m,h,f):o(n,e,b,t,m,h,f);if(!(1&t)){var _=y&&p.call(n,"__wrapped__"),E=k&&p.call(e,"__wrapped__");if(_||E){var j=_?n.value():n,T=E?e.value():e;return f||(f=new i),h(j,T,t,m,f)}}return!!w&&(f||(f=new i),a(n,e,t,m,h,f))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,i=null==n?0:n.length;++t<i;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var i=t(16),r=t(189),o=t(72),a=t(76),s=t(190),l=t(43),c=i?i.prototype:void 0,u=c?c.valueOf:void 0;n.exports=function(n,e,t,i,c,d,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new r(n),new r(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return o(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=s;case"[object Set]":var h=1&i;if(m||(m=l),n.size!=e.size&&!h)return!1;var f=p.get(n);if(f)return f==e;i|=2,p.set(n,e);var g=a(m(n),m(e),i,c,d,p);return p.delete(n),g;case"[object Symbol]":if(u)return u.call(n)==u.call(e)}return!1}},function(n,e,t){var i=t(8).Uint8Array;n.exports=i},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,i){t[++e]=[i,n]})),t}},function(n,e,t){var i=t(192),r=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,o,a,s){var l=1&t,c=i(n),u=c.length;if(u!=i(e).length&&!l)return!1;for(var d=u;d--;){var p=c[d];if(!(l?p in e:r.call(e,p)))return!1}var m=s.get(n),h=s.get(e);if(m&&h)return m==e&&h==n;var f=!0;s.set(n,e),s.set(e,n);for(var g=l;++d<u;){var v=n[p=c[d]],b=e[p];if(o)var x=l?o(b,v,p,e,n,s):o(v,b,p,n,e,s);if(!(void 0===x?v===b||a(v,b,t,o,s):x)){f=!1;break}g||(g="constructor"==p)}if(f&&!g){var y=n.constructor,k=e.constructor;y==k||!("constructor"in n)||!("constructor"in e)||"function"==typeof y&&y instanceof y&&"function"==typeof k&&k instanceof k||(f=!1)}return s.delete(n),s.delete(e),f}},function(n,e,t){var i=t(193),r=t(194),o=t(79);n.exports=function(n){return i(n,o,r)}},function(n,e,t){var i=t(69),r=t(6);n.exports=function(n,e,t){var o=e(n);return r(n)?o:i(o,t(n))}},function(n,e,t){var i=t(195),r=t(196),o=Object.prototype.propertyIsEnumerable,a=Object.getOwnPropertySymbols,s=a?function(n){return null==n?[]:(n=Object(n),i(a(n),(function(e){return o.call(n,e)})))}:r;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,i=null==n?0:n.length,r=0,o=[];++t<i;){var a=n[t];e(a,t,n)&&(o[r++]=a)}return o}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var i=t(198),r=t(39),o=t(6),a=t(80),s=t(81),l=t(82),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=o(n),u=!t&&r(n),d=!t&&!u&&a(n),p=!t&&!u&&!d&&l(n),m=t||u||d||p,h=m?i(n.length,String):[],f=h.length;for(var g in n)!e&&!c.call(n,g)||m&&("length"==g||d&&("offset"==g||"parent"==g)||p&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||s(g,f))||h.push(g);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,i=Array(n);++t<n;)i[t]=e(t);return i}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var i=t(14),r=t(44),o=t(12),a={};a["[object Float32Array]"]=a["[object Float64Array]"]=a["[object Int8Array]"]=a["[object Int16Array]"]=a["[object Int32Array]"]=a["[object Uint8Array]"]=a["[object Uint8ClampedArray]"]=a["[object Uint16Array]"]=a["[object Uint32Array]"]=!0,a["[object Arguments]"]=a["[object Array]"]=a["[object ArrayBuffer]"]=a["[object Boolean]"]=a["[object DataView]"]=a["[object Date]"]=a["[object Error]"]=a["[object Function]"]=a["[object Map]"]=a["[object Number]"]=a["[object Object]"]=a["[object RegExp]"]=a["[object Set]"]=a["[object String]"]=a["[object WeakMap]"]=!1,n.exports=function(n){return o(n)&&r(n.length)&&!!a[i(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var i=t(70),r=e&&!e.nodeType&&e,o=r&&"object"==typeof n&&n&&!n.nodeType&&n,a=o&&o.exports===r&&i.process,s=function(){try{var n=o&&o.require&&o.require("util").types;return n||a&&a.binding&&a.binding("util")}catch(n){}}();n.exports=s}).call(this,t(51)(n))},function(n,e,t){var i=t(204),r=t(205),o=Object.prototype.hasOwnProperty;n.exports=function(n){if(!i(n))return r(n);var e=[];for(var t in Object(n))o.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var i=t(206)(Object.keys,Object);n.exports=i},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var i=t(208),r=t(40),o=t(209),a=t(84),s=t(210),l=t(14),c=t(74),u=c(i),d=c(r),p=c(o),m=c(a),h=c(s),f=l;(i&&"[object DataView]"!=f(new i(new ArrayBuffer(1)))||r&&"[object Map]"!=f(new r)||o&&"[object Promise]"!=f(o.resolve())||a&&"[object Set]"!=f(new a)||s&&"[object WeakMap]"!=f(new s))&&(f=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,i=t?c(t):"";if(i)switch(i){case u:return"[object DataView]";case d:return"[object Map]";case p:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=f},function(n,e,t){var i=t(10)(t(8),"DataView");n.exports=i},function(n,e,t){var i=t(10)(t(8),"Promise");n.exports=i},function(n,e,t){var i=t(10)(t(8),"WeakMap");n.exports=i},function(n,e,t){var i=t(85),r=t(79);n.exports=function(n){for(var e=r(n),t=e.length;t--;){var o=e[t],a=n[o];e[t]=[o,a,i(a)]}return e}},function(n,e,t){var i=t(75),r=t(213),o=t(220),a=t(45),s=t(85),l=t(86),c=t(25);n.exports=function(n,e){return a(n)&&s(e)?l(c(n),e):function(t){var a=r(t,n);return void 0===a&&a===e?o(t,n):i(e,a,3)}}},function(n,e,t){var i=t(87);n.exports=function(n,e,t){var r=null==n?void 0:i(n,e);return void 0===r?t:r}},function(n,e,t){var i=t(215),r=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,o=/\\(\\)?/g,a=i((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(r,(function(n,t,i,r){e.push(i?r.replace(o,"$1"):t||n)})),e}));n.exports=a},function(n,e,t){var i=t(216);n.exports=function(n){var e=i(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var i=t(42);function r(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var i=arguments,r=e?e.apply(this,i):i[0],o=t.cache;if(o.has(r))return o.get(r);var a=n.apply(this,i);return t.cache=o.set(r,a)||o,a};return t.cache=new(r.Cache||i),t}r.Cache=i,n.exports=r},function(n,e,t){var i=t(218);n.exports=function(n){return null==n?"":i(n)}},function(n,e,t){var i=t(16),r=t(219),o=t(6),a=t(46),s=i?i.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(o(e))return r(e,n)+"";if(a(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,i=null==n?0:n.length,r=Array(i);++t<i;)r[t]=e(n[t],t,n);return r}},function(n,e,t){var i=t(221),r=t(222);n.exports=function(n,e){return null!=n&&r(n,e,i)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var i=t(88),r=t(39),o=t(6),a=t(81),s=t(44),l=t(25);n.exports=function(n,e,t){for(var c=-1,u=(e=i(e,n)).length,d=!1;++c<u;){var p=l(e[c]);if(!(d=null!=n&&t(n,p)))break;n=n[p]}return d||++c!=u?d:!!(u=null==n?0:n.length)&&s(u)&&a(p,u)&&(o(n)||r(n))}},function(n,e,t){var i=t(224),r=t(225),o=t(45),a=t(25);n.exports=function(n){return o(n)?i(a(n)):r(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var i=t(87);n.exports=function(n){return function(e){return i(e,n)}}},function(n,e,t){var i=t(47),r=t(227),o=t(229);n.exports=function(n,e){return o(r(n,e,i),n+"")}},function(n,e,t){var i=t(228),r=Math.max;n.exports=function(n,e,t){return e=r(void 0===e?n.length-1:e,0),function(){for(var o=arguments,a=-1,s=r(o.length-e,0),l=Array(s);++a<s;)l[a]=o[e+a];a=-1;for(var c=Array(e+1);++a<e;)c[a]=o[a];return c[e]=t(l),i(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var i=t(230),r=t(233)(i);n.exports=r},function(n,e,t){var i=t(231),r=t(232),o=t(47),a=r?function(n,e){return r(n,"toString",{configurable:!0,enumerable:!1,value:i(e),writable:!0})}:o;n.exports=a},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var i=t(10),r=function(){try{var n=i(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=r},function(n,e){var t=Date.now;n.exports=function(n){var e=0,i=0;return function(){var r=t(),o=16-(r-i);if(i=r,o>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var i=t(77),r=t(235),o=t(240),a=t(78),s=t(241),l=t(43);n.exports=function(n,e,t){var c=-1,u=r,d=n.length,p=!0,m=[],h=m;if(t)p=!1,u=o;else if(d>=200){var f=e?null:s(n);if(f)return l(f);p=!1,u=a,h=new i}else h=e?[]:m;n:for(;++c<d;){var g=n[c],v=e?e(g):g;if(g=t||0!==g?g:0,p&&v==v){for(var b=h.length;b--;)if(h[b]===v)continue n;e&&h.push(v),m.push(g)}else u(h,v,t)||(h!==m&&h.push(v),m.push(g))}return m}},function(n,e,t){var i=t(236);n.exports=function(n,e){return!!(null==n?0:n.length)&&i(n,e,0)>-1}},function(n,e,t){var i=t(237),r=t(238),o=t(239);n.exports=function(n,e,t){return e==e?o(n,e,t):i(n,r,t)}},function(n,e){n.exports=function(n,e,t,i){for(var r=n.length,o=t+(i?1:-1);i?o--:++o<r;)if(e(n[o],o,n))return o;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var i=t-1,r=n.length;++i<r;)if(n[i]===e)return i;return-1}},function(n,e){n.exports=function(n,e,t){for(var i=-1,r=null==n?0:n.length;++i<r;)if(t(e,n[i]))return!0;return!1}},function(n,e,t){var i=t(84),r=t(242),o=t(43),a=i&&1/o(new i([,-0]))[1]==1/0?function(n){return new i(n)}:r;n.exports=a},function(n,e){n.exports=function(){}},function(n,e,t){var i=t(83),r=t(12);n.exports=function(n){return r(n)&&i(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(89)},function(n,e,t){"use strict";t(90)},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(91)},function(n,e,t){"use strict";t(92)},function(n,e,t){"use strict";t(93)},function(n,e,t){"use strict";var i=t(18),r=t(1),o=t(254);i({global:!0},{Reflect:{}}),o(r.Reflect,"Reflect",!0)},function(n,e,t){"use strict";var i=t(13).f,r=t(7),o=t(20)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!r(n,o)&&i(n,o,{configurable:!0,value:e})}},function(n,e){},function(n,e){function t(n,e){for(var t=0,i=n.length-1;i>=0;i--){var r=n[i];"."===r?n.splice(i,1):".."===r?(n.splice(i,1),t++):t&&(n.splice(i,1),t--)}if(e)for(;t--;t)n.unshift("..");return n}function i(n,e){if(n.filter)return n.filter(e);for(var t=[],i=0;i<n.length;i++)e(n[i],i,n)&&t.push(n[i]);return t}e.resolve=function(){for(var n="",e=!1,r=arguments.length-1;r>=-1&&!e;r--){var o=r>=0?arguments[r]:process.cwd();if("string"!=typeof o)throw new TypeError("Arguments to path.resolve must be strings");o&&(n=o+"/"+n,e="/"===o.charAt(0))}return(e?"/":"")+(n=t(i(n.split("/"),(function(n){return!!n})),!e).join("/"))||"."},e.normalize=function(n){var o=e.isAbsolute(n),a="/"===r(n,-1);return(n=t(i(n.split("/"),(function(n){return!!n})),!o).join("/"))||o||(n="."),n&&a&&(n+="/"),(o?"/":"")+n},e.isAbsolute=function(n){return"/"===n.charAt(0)},e.join=function(){var n=Array.prototype.slice.call(arguments,0);return e.normalize(i(n,(function(n,e){if("string"!=typeof n)throw new TypeError("Arguments to path.join must be strings");return n})).join("/"))},e.relative=function(n,t){function i(n){for(var e=0;e<n.length&&""===n[e];e++);for(var t=n.length-1;t>=0&&""===n[t];t--);return e>t?[]:n.slice(e,t-e+1)}n=e.resolve(n).substr(1),t=e.resolve(t).substr(1);for(var r=i(n.split("/")),o=i(t.split("/")),a=Math.min(r.length,o.length),s=a,l=0;l<a;l++)if(r[l]!==o[l]){s=l;break}var c=[];for(l=s;l<r.length;l++)c.push("..");return(c=c.concat(o.slice(s))).join("/")},e.sep="/",e.delimiter=":",e.dirname=function(n){if("string"!=typeof n&&(n+=""),0===n.length)return".";for(var e=n.charCodeAt(0),t=47===e,i=-1,r=!0,o=n.length-1;o>=1;--o)if(47===(e=n.charCodeAt(o))){if(!r){i=o;break}}else r=!1;return-1===i?t?"/":".":t&&1===i?"/":n.slice(0,i)},e.basename=function(n,e){var t=function(n){"string"!=typeof n&&(n+="");var e,t=0,i=-1,r=!0;for(e=n.length-1;e>=0;--e)if(47===n.charCodeAt(e)){if(!r){t=e+1;break}}else-1===i&&(r=!1,i=e+1);return-1===i?"":n.slice(t,i)}(n);return e&&t.substr(-1*e.length)===e&&(t=t.substr(0,t.length-e.length)),t},e.extname=function(n){"string"!=typeof n&&(n+="");for(var e=-1,t=0,i=-1,r=!0,o=0,a=n.length-1;a>=0;--a){var s=n.charCodeAt(a);if(47!==s)-1===i&&(r=!1,i=a+1),46===s?-1===e?e=a:1!==o&&(o=1):-1!==e&&(o=-1);else if(!r){t=a+1;break}}return-1===e||-1===i||0===o||1===o&&e===i-1&&e===t+1?"":n.slice(e,i)};var r="b"==="ab".substr(-1)?function(n,e,t){return n.substr(e,t)}:function(n,e,t){return e<0&&(e=n.length+e),n.substr(e,t)}},function(n,e,t){"use strict";var i=/[|\\{}()[\]^$+*?.]/g;e.escapeRegExpChars=function(n){return n?String(n).replace(i,"\\$&"):""};var r={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&#34;","'":"&#39;"},o=/[&<>'"]/g;function a(n){return r[n]||n}e.escapeXML=function(n){return null==n?"":String(n).replace(o,a)},e.escapeXML.toString=function(){return Function.prototype.toString.call(this)+';\nvar _ENCODE_HTML_RULES = {\n      "&": "&amp;"\n    , "<": "&lt;"\n    , ">": "&gt;"\n    , \'"\': "&#34;"\n    , "\'": "&#39;"\n    }\n  , _MATCH_HTML = /[&<>\'"]/g;\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n};\n'},e.shallowCopy=function(n,e){for(var t in e=e||{})n[t]=e[t];return n},e.shallowCopyFromList=function(n,e,t){for(var i=0;i<t.length;i++){var r=t[i];void 0!==e[r]&&(n[r]=e[r])}return n},e.cache={_data:{},set:function(n,e){this._data[n]=e},get:function(n){return this._data[n]},remove:function(n){delete this._data[n]},reset:function(){this._data={}}}},function(n){n.exports=JSON.parse('{"name":"ejs","description":"Embedded JavaScript templates","keywords":["template","engine","ejs"],"version":"2.7.4","author":"Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)","license":"Apache-2.0","main":"./lib/ejs.js","repository":{"type":"git","url":"git://github.com/mde/ejs.git"},"bugs":"https://github.com/mde/ejs/issues","homepage":"https://github.com/mde/ejs","dependencies":{},"devDependencies":{"browserify":"^13.1.1","eslint":"^4.14.0","git-directory-deploy":"^1.5.1","jake":"^10.3.1","jsdoc":"^3.4.0","lru-cache":"^4.0.1","mocha":"^5.0.5","uglify-js":"^3.3.16"},"engines":{"node":">=0.10.0"},"scripts":{"test":"mocha","postinstall":"node ./postinstall.js"}}')},function(n,e,t){"use strict";t(94)},function(n,e,t){"use strict";t(95)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.15
 * (c) 2014-2023 Evan You
 * Released under the MIT License.
 */
var i=Object.freeze({}),r=Array.isArray;function o(n){return null==n}function a(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function u(n){return null!==n&&"object"==typeof n}var d=Object.prototype.toString;function p(n){return"[object Object]"===d.call(n)}function m(n){return"[object RegExp]"===d.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function f(n){return a(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function g(n){return null==n?"":Array.isArray(n)||p(n)&&n.toString===d?JSON.stringify(n,null,2):String(n)}function v(n){var e=parseFloat(n);return isNaN(e)?n:e}function b(n,e){for(var t=Object.create(null),i=n.split(","),r=0;r<i.length;r++)t[i[r]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}b("slot,component",!0);var x=b("key,ref,slot,slot-scope,is");function y(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var i=n.indexOf(e);if(i>-1)return n.splice(i,1)}}var k=Object.prototype.hasOwnProperty;function w(n,e){return k.call(n,e)}function _(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var E=/-(\w)/g,j=_((function(n){return n.replace(E,(function(n,e){return e?e.toUpperCase():""}))})),T=_((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),S=/\B([A-Z])/g,A=_((function(n){return n.replace(S,"-$1").toLowerCase()}));var C=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var i=arguments.length;return i?i>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function P(n,e){e=e||0;for(var t=n.length-e,i=new Array(t);t--;)i[t]=n[t+e];return i}function I(n,e){for(var t in e)n[t]=e[t];return n}function z(n){for(var e={},t=0;t<n.length;t++)n[t]&&I(e,n[t]);return e}function B(n,e,t){}var D=function(n,e,t){return!1},L=function(n){return n};function $(n,e){if(n===e)return!0;var t=u(n),i=u(e);if(!t||!i)return!t&&!i&&String(n)===String(e);try{var r=Array.isArray(n),o=Array.isArray(e);if(r&&o)return n.length===e.length&&n.every((function(n,t){return $(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(r||o)return!1;var a=Object.keys(n),s=Object.keys(e);return a.length===s.length&&a.every((function(t){return $(n[t],e[t])}))}catch(n){return!1}}function O(n,e){for(var t=0;t<n.length;t++)if($(n[t],e))return t;return-1}function G(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function q(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var N=["component","directive","filter"],M=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],F={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:D,isReservedAttr:D,isUnknownElement:D,getTagNamespace:B,parsePlatformTagName:L,mustUseProp:D,async:!0,_lifecycleHooks:M},U=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function R(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function H(n,e,t,i){Object.defineProperty(n,e,{value:t,enumerable:!!i,writable:!0,configurable:!0})}var V=new RegExp("[^".concat(U.source,".$_\\d]"));var J="__proto__"in{},W="undefined"!=typeof window,K=W&&window.navigator.userAgent.toLowerCase(),Q=K&&/msie|trident/.test(K),Z=K&&K.indexOf("msie 9.0")>0,X=K&&K.indexOf("edge/")>0;K&&K.indexOf("android");var Y=K&&/iphone|ipad|ipod|ios/.test(K);K&&/chrome\/\d+/.test(K),K&&/phantomjs/.test(K);var nn,en=K&&K.match(/firefox\/(\d+)/),tn={}.watch,rn=!1;if(W)try{var on={};Object.defineProperty(on,"passive",{get:function(){rn=!0}}),window.addEventListener("test-passive",null,on)}catch(n){}var an=function(){return void 0===nn&&(nn=!W&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},sn=W&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,un="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);cn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var dn=null;function pn(n){void 0===n&&(n=null),n||dn&&dn._scope.off(),dn=n,n&&n._scope.on()}var mn=function(){function n(n,e,t,i,r,o,a,s){this.tag=n,this.data=e,this.children=t,this.text=i,this.elm=r,this.ns=void 0,this.context=o,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=a,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),hn=function(n){void 0===n&&(n="");var e=new mn;return e.text=n,e.isComment=!0,e};function fn(n){return new mn(void 0,void 0,void 0,String(n))}function gn(n){var e=new mn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var vn=0,bn=[],xn=function(){function n(){this._pending=!1,this.id=vn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,bn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,i=e.length;t<i;t++){0,e[t].update()}},n}();xn.target=null;var yn=[];function kn(n){yn.push(n),xn.target=n}function wn(){yn.pop(),xn.target=yn[yn.length-1]}var _n=Array.prototype,En=Object.create(_n);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=_n[n];H(En,n,(function(){for(var t=[],i=0;i<arguments.length;i++)t[i]=arguments[i];var r,o=e.apply(this,t),a=this.__ob__;switch(n){case"push":case"unshift":r=t;break;case"splice":r=t.slice(2)}return r&&a.observeArray(r),a.dep.notify(),o}))}));var jn=Object.getOwnPropertyNames(En),Tn={},Sn=!0;function An(n){Sn=n}var Cn={notify:B,depend:B,addSub:B,removeSub:B},Pn=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?Cn:new xn,this.vmCount=0,H(n,"__ob__",this),r(n)){if(!t)if(J)n.__proto__=En;else for(var i=0,o=jn.length;i<o;i++){H(n,s=jn[i],En[s])}e||this.observeArray(n)}else{var a=Object.keys(n);for(i=0;i<a.length;i++){var s;zn(n,s=a[i],Tn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)In(n[e],!1,this.mock)},n}();function In(n,e,t){return n&&w(n,"__ob__")&&n.__ob__ instanceof Pn?n.__ob__:!Sn||!t&&an()||!r(n)&&!p(n)||!Object.isExtensible(n)||n.__v_skip||qn(n)||n instanceof mn?void 0:new Pn(n,e,t)}function zn(n,e,t,i,o,a){var s=new xn,l=Object.getOwnPropertyDescriptor(n,e);if(!l||!1!==l.configurable){var c=l&&l.get,u=l&&l.set;c&&!u||t!==Tn&&2!==arguments.length||(t=n[e]);var d=!o&&In(t,!1,a);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=c?c.call(n):t;return xn.target&&(s.depend(),d&&(d.dep.depend(),r(e)&&Ln(e))),qn(e)&&!o?e.value:e},set:function(e){var i=c?c.call(n):t;if(q(i,e)){if(u)u.call(n,e);else{if(c)return;if(!o&&qn(i)&&!qn(e))return void(i.value=e);t=e}d=!o&&In(e,!1,a),s.notify()}}}),s}}function Bn(n,e,t){if(!Gn(n)){var i=n.__ob__;return r(n)&&h(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),i&&!i.shallow&&i.mock&&In(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||i&&i.vmCount?t:i?(zn(i.value,e,t,void 0,i.shallow,i.mock),i.dep.notify(),t):(n[e]=t,t)}}function Dn(n,e){if(r(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Gn(n)||w(n,e)&&(delete n[e],t&&t.dep.notify())}}function Ln(n){for(var e=void 0,t=0,i=n.length;t<i;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),r(e)&&Ln(e)}function $n(n){return On(n,!0),H(n,"__v_isShallow",!0),n}function On(n,e){if(!Gn(n)){In(n,e,an());0}}function Gn(n){return!(!n||!n.__v_isReadonly)}function qn(n){return!(!n||!0!==n.__v_isRef)}function Nn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(qn(n))return n.value;var i=n&&n.__ob__;return i&&i.dep.depend(),n},set:function(n){var i=e[t];qn(i)&&!qn(n)?i.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Mn;var Fn=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Mn,!n&&Mn&&(this.index=(Mn.scopes||(Mn.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Mn;try{return Mn=this,n()}finally{Mn=e}}else 0},n.prototype.on=function(){Mn=this},n.prototype.off=function(){Mn=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var i=this.parent.scopes.pop();i&&i!==this&&(this.parent.scopes[this.index]=i,i.index=this.index)}this.parent=void 0,this.active=!1}},n}();function Un(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Rn=_((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),i="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=i?n.slice(1):n,once:t,capture:i,passive:e}}));function Hn(n,e){function t(){var n=t.fns;if(!r(n))return Se(n,null,arguments,e,"v-on handler");for(var i=n.slice(),o=0;o<i.length;o++)Se(i[o],null,arguments,e,"v-on handler")}return t.fns=n,t}function Vn(n,e,t,i,r,a){var l,c,u,d;for(l in n)c=n[l],u=e[l],d=Rn(l),o(c)||(o(u)?(o(c.fns)&&(c=n[l]=Hn(c,a)),s(d.once)&&(c=n[l]=r(d.name,c,d.capture)),t(d.name,c,d.capture,d.passive,d.params)):c!==u&&(u.fns=c,n[l]=u));for(l in e)o(n[l])&&i((d=Rn(l)).name,e[l],d.capture)}function Jn(n,e,t){var i;n instanceof mn&&(n=n.data.hook||(n.data.hook={}));var r=n[e];function l(){t.apply(this,arguments),y(i.fns,l)}o(r)?i=Hn([l]):a(r.fns)&&s(r.merged)?(i=r).fns.push(l):i=Hn([r,l]),i.merged=!0,n[e]=i}function Wn(n,e,t,i,r){if(a(e)){if(w(e,t))return n[t]=e[t],r||delete e[t],!0;if(w(e,i))return n[t]=e[i],r||delete e[i],!0}return!1}function Kn(n){return l(n)?[fn(n)]:r(n)?function n(e,t){var i,c,u,d,p=[];for(i=0;i<e.length;i++)o(c=e[i])||"boolean"==typeof c||(u=p.length-1,d=p[u],r(c)?c.length>0&&(Qn((c=n(c,"".concat(t||"","_").concat(i)))[0])&&Qn(d)&&(p[u]=fn(d.text+c[0].text),c.shift()),p.push.apply(p,c)):l(c)?Qn(d)?p[u]=fn(d.text+c):""!==c&&p.push(fn(c)):Qn(c)&&Qn(d)?p[u]=fn(d.text+c.text):(s(e._isVList)&&a(c.tag)&&o(c.key)&&a(t)&&(c.key="__vlist".concat(t,"_").concat(i,"__")),p.push(c)));return p}(n):void 0}function Qn(n){return a(n)&&a(n.text)&&!1===n.isComment}function Zn(n,e){var t,i,o,s,l=null;if(r(n)||"string"==typeof n)for(l=new Array(n.length),t=0,i=n.length;t<i;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(u(n))if(un&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),d=c.next();!d.done;)l.push(e(d.value,l.length)),d=c.next()}else for(o=Object.keys(n),l=new Array(o.length),t=0,i=o.length;t<i;t++)s=o[t],l[t]=e(n[s],s,t);return a(l)||(l=[]),l._isVList=!0,l}function Xn(n,e,t,i){var r,o=this.$scopedSlots[n];o?(t=t||{},i&&(t=I(I({},i),t)),r=o(t)||(c(e)?e():e)):r=this.$slots[n]||(c(e)?e():e);var a=t&&t.slot;return a?this.$createElement("template",{slot:a},r):r}function Yn(n){return Pt(this.$options,"filters",n,!0)||L}function ne(n,e){return r(n)?-1===n.indexOf(e):n!==e}function ee(n,e,t,i,r){var o=F.keyCodes[e]||t;return r&&i&&!F.keyCodes[e]?ne(r,i):o?ne(o,n):i?A(i)!==e:void 0===n}function te(n,e,t,i,o){if(t)if(u(t)){r(t)&&(t=z(t));var a=void 0,s=function(r){if("class"===r||"style"===r||x(r))a=n;else{var s=n.attrs&&n.attrs.type;a=i||F.mustUseProp(e,s,r)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=j(r),c=A(r);l in a||c in a||(a[r]=t[r],o&&((n.on||(n.on={}))["update:".concat(r)]=function(n){t[r]=n}))};for(var l in t)s(l)}else;return n}function ie(n,e){var t=this._staticTrees||(this._staticTrees=[]),i=t[n];return i&&!e||oe(i=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),i}function re(n,e,t){return oe(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function oe(n,e,t){if(r(n))for(var i=0;i<n.length;i++)n[i]&&"string"!=typeof n[i]&&ae(n[i],"".concat(e,"_").concat(i),t);else ae(n,e,t)}function ae(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function se(n,e){if(e)if(p(e)){var t=n.on=n.on?I({},n.on):{};for(var i in e){var r=t[i],o=e[i];t[i]=r?[].concat(r,o):o}}else;return n}function le(n,e,t,i){e=e||{$stable:!t};for(var o=0;o<n.length;o++){var a=n[o];r(a)?le(a,e,t):a&&(a.proxy&&(a.fn.proxy=!0),e[a.key]=a.fn)}return i&&(e.$key=i),e}function ce(n,e){for(var t=0;t<e.length;t+=2){var i=e[t];"string"==typeof i&&i&&(n[e[t]]=e[t+1])}return n}function ue(n,e){return"string"==typeof n?e+n:n}function de(n){n._o=re,n._n=v,n._s=g,n._l=Zn,n._t=Xn,n._q=$,n._i=O,n._m=ie,n._f=Yn,n._k=ee,n._b=te,n._v=fn,n._e=hn,n._u=le,n._g=se,n._d=ce,n._p=ue}function pe(n,e){if(!n||!n.length)return{};for(var t={},i=0,r=n.length;i<r;i++){var o=n[i],a=o.data;if(a&&a.attrs&&a.attrs.slot&&delete a.attrs.slot,o.context!==e&&o.fnContext!==e||!a||null==a.slot)(t.default||(t.default=[])).push(o);else{var s=a.slot,l=t[s]||(t[s]=[]);"template"===o.tag?l.push.apply(l,o.children||[]):l.push(o)}}for(var c in t)t[c].every(me)&&delete t[c];return t}function me(n){return n.isComment&&!n.asyncFactory||" "===n.text}function he(n){return n.isComment&&n.asyncFactory}function fe(n,e,t,r){var o,a=Object.keys(t).length>0,s=e?!!e.$stable:!a,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&r&&r!==i&&l===r.$key&&!a&&!r.$hasNormal)return r;for(var c in o={},e)e[c]&&"$"!==c[0]&&(o[c]=ge(n,t,c,e[c]))}else o={};for(var u in t)u in o||(o[u]=ve(t,u));return e&&Object.isExtensible(e)&&(e._normalized=o),H(o,"$stable",s),H(o,"$key",l),H(o,"$hasNormal",a),o}function ge(n,e,t,i){var o=function(){var e=dn;pn(n);var t=arguments.length?i.apply(null,arguments):i({}),o=(t=t&&"object"==typeof t&&!r(t)?[t]:Kn(t))&&t[0];return pn(e),t&&(!o||1===t.length&&o.isComment&&!he(o))?void 0:t};return i.proxy&&Object.defineProperty(e,t,{get:o,enumerable:!0,configurable:!0}),o}function ve(n,e){return function(){return n[e]}}function be(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};H(e,"_v_attr_proxy",!0),xe(e,n.$attrs,i,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||xe(n._listenersProxy={},n.$listeners,i,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||ke(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:C(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Nn(n,e,t)}))}}}function xe(n,e,t,i,r){var o=!1;for(var a in e)a in n?e[a]!==t[a]&&(o=!0):(o=!0,ye(n,a,i,r));for(var a in n)a in e||(o=!0,delete n[a]);return o}function ye(n,e,t,i){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[i][e]}})}function ke(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var we=null;function _e(n,e){return(n.__esModule||un&&"Module"===n[Symbol.toStringTag])&&(n=n.default),u(n)?e.extend(n):n}function Ee(n){if(r(n))for(var e=0;e<n.length;e++){var t=n[e];if(a(t)&&(a(t.componentOptions)||he(t)))return t}}function je(n,e,t,i,d,p){return(r(t)||l(t))&&(d=i,i=t,t=void 0),s(p)&&(d=2),function(n,e,t,i,l){if(a(t)&&a(t.__ob__))return hn();a(t)&&a(t.is)&&(e=t.is);if(!e)return hn();0;r(i)&&c(i[0])&&((t=t||{}).scopedSlots={default:i[0]},i.length=0);2===l?i=Kn(i):1===l&&(i=function(n){for(var e=0;e<n.length;e++)if(r(n[e]))return Array.prototype.concat.apply([],n);return n}(i));var d,p;if("string"==typeof e){var m=void 0;p=n.$vnode&&n.$vnode.ns||F.getTagNamespace(e),d=F.isReservedTag(e)?new mn(F.parsePlatformTagName(e),t,i,void 0,void 0,n):t&&t.pre||!a(m=Pt(n.$options,"components",e))?new mn(e,t,i,void 0,void 0,n):yt(m,t,n,i,e)}else d=yt(e,t,n,i);return r(d)?d:a(d)?(a(p)&&function n(e,t,i){e.ns=t,"foreignObject"===e.tag&&(t=void 0,i=!0);if(a(e.children))for(var r=0,l=e.children.length;r<l;r++){var c=e.children[r];a(c.tag)&&(o(c.ns)||s(i)&&"svg"!==c.tag)&&n(c,t,i)}}(d,p),a(t)&&function(n){u(n.style)&&Fe(n.style);u(n.class)&&Fe(n.class)}(t),d):hn()}(n,e,t,i,d)}function Te(n,e,t){kn();try{if(e)for(var i=e;i=i.$parent;){var r=i.$options.errorCaptured;if(r)for(var o=0;o<r.length;o++)try{if(!1===r[o].call(i,n,e,t))return}catch(n){Ae(n,i,"errorCaptured hook")}}Ae(n,e,t)}finally{wn()}}function Se(n,e,t,i,r){var o;try{(o=t?n.apply(e,t):n.call(e))&&!o._isVue&&f(o)&&!o._handled&&(o.catch((function(n){return Te(n,i,r+" (Promise/async)")})),o._handled=!0)}catch(n){Te(n,i,r)}return o}function Ae(n,e,t){if(F.errorHandler)try{return F.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Ce(e,null,"config.errorHandler")}Ce(n,e,t)}function Ce(n,e,t){if(!W||"undefined"==typeof console)throw n;console.error(n)}var Pe,Ie=!1,ze=[],Be=!1;function De(){Be=!1;var n=ze.slice(0);ze.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var Le=Promise.resolve();Pe=function(){Le.then(De),Y&&setTimeout(B)},Ie=!0}else if(Q||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Pe="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(De)}:function(){setTimeout(De,0)};else{var $e=1,Oe=new MutationObserver(De),Ge=document.createTextNode(String($e));Oe.observe(Ge,{characterData:!0}),Pe=function(){$e=($e+1)%2,Ge.data=String($e)},Ie=!0}function qe(n,e){var t;if(ze.push((function(){if(n)try{n.call(e)}catch(n){Te(n,e,"nextTick")}else t&&t(e)})),Be||(Be=!0,Pe()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Ne(n){return function(e,t){if(void 0===t&&(t=dn),t)return function(n,e,t){var i=n.$options;i[e]=Tt(i[e],t)}(t,n,e)}}Ne("beforeMount"),Ne("mounted"),Ne("beforeUpdate"),Ne("updated"),Ne("beforeDestroy"),Ne("destroyed"),Ne("activated"),Ne("deactivated"),Ne("serverPrefetch"),Ne("renderTracked"),Ne("renderTriggered"),Ne("errorCaptured");var Me=new cn;function Fe(n){return function n(e,t){var i,o,a=r(e);if(!a&&!u(e)||e.__v_skip||Object.isFrozen(e)||e instanceof mn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(a)for(i=e.length;i--;)n(e[i],t);else if(qn(e))n(e.value,t);else for(o=Object.keys(e),i=o.length;i--;)n(e[o[i]],t)}(n,Me),Me.clear(),n}var Ue,Re=0,He=function(){function n(n,e,t,i,r){var o,a;o=this,void 0===(a=Mn&&!Mn._vm?Mn:n?n._scope:void 0)&&(a=Mn),a&&a.active&&a.effects.push(o),(this.vm=n)&&r&&(n._watcher=this),i?(this.deep=!!i.deep,this.user=!!i.user,this.lazy=!!i.lazy,this.sync=!!i.sync,this.before=i.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Re,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!V.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=B)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;kn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Te(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Fe(n),wn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():pt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||u(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Se(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&y(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Ve(n,e){Ue.$on(n,e)}function Je(n,e){Ue.$off(n,e)}function We(n,e){var t=Ue;return function i(){var r=e.apply(null,arguments);null!==r&&t.$off(n,i)}}function Ke(n,e,t){Ue=n,Vn(e,t||{},Ve,Je,We,n),Ue=void 0}var Qe=null;function Ze(n){var e=Qe;return Qe=n,function(){Qe=e}}function Xe(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Ye(n,e){if(e){if(n._directInactive=!1,Xe(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Ye(n.$children[t]);nt(n,"activated")}}function nt(n,e,t,i){void 0===i&&(i=!0),kn();var r=dn,o=Mn;i&&pn(n);var a=n.$options[e],s="".concat(e," hook");if(a)for(var l=0,c=a.length;l<c;l++)Se(a[l],n,t||null,n,s);n._hasHookEvent&&n.$emit("hook:"+e),i&&(pn(r),o&&o.on()),wn()}var et=[],tt=[],it={},rt=!1,ot=!1,at=0;var st=0,lt=Date.now;if(W&&!Q){var ct=window.performance;ct&&"function"==typeof ct.now&&lt()>document.createEvent("Event").timeStamp&&(lt=function(){return ct.now()})}var ut=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function dt(){var n,e;for(st=lt(),ot=!0,et.sort(ut),at=0;at<et.length;at++)(n=et[at]).before&&n.before(),e=n.id,it[e]=null,n.run();var t=tt.slice(),i=et.slice();at=et.length=tt.length=0,it={},rt=ot=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Ye(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],i=t.vm;i&&i._watcher===t&&i._isMounted&&!i._isDestroyed&&nt(i,"updated")}}(i),function(){for(var n=0;n<bn.length;n++){var e=bn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}bn.length=0}(),sn&&F.devtools&&sn.emit("flush")}function pt(n){var e=n.id;if(null==it[e]&&(n!==xn.target||!n.noRecurse)){if(it[e]=!0,ot){for(var t=et.length-1;t>at&&et[t].id>n.id;)t--;et.splice(t+1,0,n)}else et.push(n);rt||(rt=!0,qe(dt))}}function mt(n,e){if(n){for(var t=Object.create(null),i=un?Reflect.ownKeys(n):Object.keys(n),r=0;r<i.length;r++){var o=i[r];if("__ob__"!==o){var a=n[o].from;if(a in e._provided)t[o]=e._provided[a];else if("default"in n[o]){var s=n[o].default;t[o]=c(s)?s.call(e):s}else 0}}return t}}function ht(n,e,t,o,a){var l,c=this,u=a.options;w(o,"_uid")?(l=Object.create(o))._original=o:(l=o,o=o._original);var d=s(u._compiled),p=!d;this.data=n,this.props=e,this.children=t,this.parent=o,this.listeners=n.on||i,this.injections=mt(u.inject,o),this.slots=function(){return c.$slots||fe(o,n.scopedSlots,c.$slots=pe(t,o)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return fe(o,n.scopedSlots,this.slots())}}),d&&(this.$options=u,this.$slots=this.slots(),this.$scopedSlots=fe(o,n.scopedSlots,this.$slots)),u._scopeId?this._c=function(n,e,t,i){var a=je(l,n,e,t,i,p);return a&&!r(a)&&(a.fnScopeId=u._scopeId,a.fnContext=o),a}:this._c=function(n,e,t,i){return je(l,n,e,t,i,p)}}function ft(n,e,t,i,r){var o=gn(n);return o.fnContext=t,o.fnOptions=i,e.slot&&((o.data||(o.data={})).slot=e.slot),o}function gt(n,e){for(var t in e)n[j(t)]=e[t]}function vt(n){return n.name||n.__name||n._componentTag}de(ht.prototype);var bt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;bt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},i=n.data.inlineTemplate;a(i)&&(t.render=i.render,t.staticRenderFns=i.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Qe)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,o){var a=r.data.scopedSlots,s=n.$scopedSlots,l=!!(a&&!a.$stable||s!==i&&!s.$stable||a&&n.$scopedSlots.$key!==a.$key||!a&&n.$scopedSlots.$key),c=!!(o||n.$options._renderChildren||l),u=n.$vnode;n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r),n.$options._renderChildren=o;var d=r.data.attrs||i;n._attrsProxy&&xe(n._attrsProxy,d,u.data&&u.data.attrs||i,n,"$attrs")&&(c=!0),n.$attrs=d,t=t||i;var p=n.$options._parentListeners;if(n._listenersProxy&&xe(n._listenersProxy,t,p||i,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Ke(n,t,p),e&&n.$options.props){An(!1);for(var m=n._props,h=n.$options._propKeys||[],f=0;f<h.length;f++){var g=h[f],v=n.$options.props;m[g]=It(g,v,e,n)}An(!0),n.$options.propsData=e}c&&(n.$slots=pe(o,r.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,i=n.componentInstance;i._isMounted||(i._isMounted=!0,nt(i,"mounted")),n.data.keepAlive&&(t._isMounted?((e=i)._inactive=!1,tt.push(e)):Ye(i,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Xe(e))||e._inactive)){e._inactive=!0;for(var i=0;i<e.$children.length;i++)n(e.$children[i]);nt(e,"deactivated")}}(e,!0):e.$destroy())}},xt=Object.keys(bt);function yt(n,e,t,l,c){if(!o(n)){var d=t.$options._base;if(u(n)&&(n=d.extend(n)),"function"==typeof n){var p;if(o(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&a(n.errorComp))return n.errorComp;if(a(n.resolved))return n.resolved;var t=we;if(t&&a(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&a(n.loadingComp))return n.loadingComp;if(t&&!a(n.owners)){var i=n.owners=[t],r=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return y(i,t)}));var d=function(n){for(var e=0,t=i.length;e<t;e++)i[e].$forceUpdate();n&&(i.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},p=G((function(t){n.resolved=_e(t,e),r?i.length=0:d(!0)})),m=G((function(e){a(n.errorComp)&&(n.error=!0,d(!0))})),h=n(p,m);return u(h)&&(f(h)?o(n.resolved)&&h.then(p,m):f(h.component)&&(h.component.then(p,m),a(h.error)&&(n.errorComp=_e(h.error,e)),a(h.loading)&&(n.loadingComp=_e(h.loading,e),0===h.delay?n.loading=!0:l=setTimeout((function(){l=null,o(n.resolved)&&o(n.error)&&(n.loading=!0,d(!1))}),h.delay||200)),a(h.timeout)&&(c=setTimeout((function(){c=null,o(n.resolved)&&m(null)}),h.timeout)))),r=!1,n.loading?n.loadingComp:n.resolved}}(p=n,d)))return function(n,e,t,i,r){var o=hn();return o.asyncFactory=n,o.asyncMeta={data:e,context:t,children:i,tag:r},o}(p,e,t,l,c);e=e||{},Ht(n),a(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",i=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var o=e.on||(e.on={}),s=o[i],l=e.model.callback;a(s)?(r(s)?-1===s.indexOf(l):s!==l)&&(o[i]=[l].concat(s)):o[i]=l}(n.options,e);var m=function(n,e,t){var i=e.options.props;if(!o(i)){var r={},s=n.attrs,l=n.props;if(a(s)||a(l))for(var c in i){var u=A(c);Wn(r,l,c,u,!0)||Wn(r,s,c,u,!1)}return r}}(e,n);if(s(n.options.functional))return function(n,e,t,o,s){var l=n.options,c={},u=l.props;if(a(u))for(var d in u)c[d]=It(d,u,e||i);else a(t.attrs)&&gt(c,t.attrs),a(t.props)&&gt(c,t.props);var p=new ht(t,c,s,o,n),m=l.render.call(null,p._c,p);if(m instanceof mn)return ft(m,t,p.parent,l,p);if(r(m)){for(var h=Kn(m)||[],f=new Array(h.length),g=0;g<h.length;g++)f[g]=ft(h[g],t,p.parent,l,p);return f}}(n,m,e,t,l);var h=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var g=e.slot;e={},g&&(e.slot=g)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<xt.length;t++){var i=xt[t],r=e[i],o=bt[i];r===o||r&&r._merged||(e[i]=r?kt(o,r):o)}}(e);var v=vt(n.options)||c;return new mn("vue-component-".concat(n.cid).concat(v?"-".concat(v):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:m,listeners:h,tag:c,children:l},p)}}}function kt(n,e){var t=function(t,i){n(t,i),e(t,i)};return t._merged=!0,t}var wt=B,_t=F.optionMergeStrategies;function Et(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var i,r,o,a=un?Reflect.ownKeys(e):Object.keys(e),s=0;s<a.length;s++)"__ob__"!==(i=a[s])&&(r=n[i],o=e[i],t&&w(n,i)?r!==o&&p(r)&&p(o)&&Et(r,o):Bn(n,i,o));return n}function jt(n,e,t){return t?function(){var i=c(e)?e.call(t,t):e,r=c(n)?n.call(t,t):n;return i?Et(i,r):r}:e?n?function(){return Et(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function Tt(n,e){var t=e?n?n.concat(e):r(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function St(n,e,t,i){var r=Object.create(n||null);return e?I(r,e):r}_t.data=function(n,e,t){return t?jt(n,e,t):e&&"function"!=typeof e?n:jt(n,e)},M.forEach((function(n){_t[n]=Tt})),N.forEach((function(n){_t[n+"s"]=St})),_t.watch=function(n,e,t,i){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var o={};for(var a in I(o,n),e){var s=o[a],l=e[a];s&&!r(s)&&(s=[s]),o[a]=s?s.concat(l):r(l)?l:[l]}return o},_t.props=_t.methods=_t.inject=_t.computed=function(n,e,t,i){if(!n)return e;var r=Object.create(null);return I(r,n),e&&I(r,e),r},_t.provide=function(n,e){return n?function(){var t=Object.create(null);return Et(t,c(n)?n.call(this):n),e&&Et(t,c(e)?e.call(this):e,!1),t}:e};var At=function(n,e){return void 0===e?n:e};function Ct(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var i,o,a={};if(r(t))for(i=t.length;i--;)"string"==typeof(o=t[i])&&(a[j(o)]={type:null});else if(p(t))for(var s in t)o=t[s],a[j(s)]=p(o)?o:{type:o};else 0;n.props=a}}(e),function(n,e){var t=n.inject;if(t){var i=n.inject={};if(r(t))for(var o=0;o<t.length;o++)i[t[o]]={from:t[o]};else if(p(t))for(var a in t){var s=t[a];i[a]=p(s)?I({from:a},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var i=e[t];c(i)&&(e[t]={bind:i,update:i})}}(e),!e._base&&(e.extends&&(n=Ct(n,e.extends,t)),e.mixins))for(var i=0,o=e.mixins.length;i<o;i++)n=Ct(n,e.mixins[i],t);var a,s={};for(a in n)l(a);for(a in e)w(n,a)||l(a);function l(i){var r=_t[i]||At;s[i]=r(n[i],e[i],t,i)}return s}function Pt(n,e,t,i){if("string"==typeof t){var r=n[e];if(w(r,t))return r[t];var o=j(t);if(w(r,o))return r[o];var a=T(o);return w(r,a)?r[a]:r[t]||r[o]||r[a]}}function It(n,e,t,i){var r=e[n],o=!w(t,n),a=t[n],s=Lt(Boolean,r.type);if(s>-1)if(o&&!w(r,"default"))a=!1;else if(""===a||a===A(n)){var l=Lt(String,r.type);(l<0||s<l)&&(a=!0)}if(void 0===a){a=function(n,e,t){if(!w(e,"default"))return;var i=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(i)&&"Function"!==Bt(e.type)?i.call(n):i}(i,r,n);var u=Sn;An(!0),In(a),An(u)}return a}var zt=/^\s*function (\w+)/;function Bt(n){var e=n&&n.toString().match(zt);return e?e[1]:""}function Dt(n,e){return Bt(n)===Bt(e)}function Lt(n,e){if(!r(e))return Dt(e,n)?0:-1;for(var t=0,i=e.length;t<i;t++)if(Dt(e[t],n))return t;return-1}var $t={enumerable:!0,configurable:!0,get:B,set:B};function Ot(n,e,t){$t.get=function(){return this[e][t]},$t.set=function(n){this[e][t]=n},Object.defineProperty(n,t,$t)}function Gt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},i=n._props=$n({}),r=n.$options._propKeys=[];n.$parent&&An(!1);var o=function(o){r.push(o);var a=It(o,e,t,n);zn(i,o,a),o in n||Ot(n,"_props",o)};for(var a in e)o(a);An(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var i=n._setupContext=be(n);pn(n),kn();var r=Se(t,null,[n._props||$n({}),i],n,"setup");if(wn(),pn(),c(r))e.render=r;else if(u(r))if(n._setupState=r,r.__sfc){var o=n._setupProxy={};for(var a in r)"__sfc"!==a&&Nn(o,r,a)}else for(var a in r)R(a)||Nn(n,r,a);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?B:C(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;p(e=n._data=c(e)?function(n,e){kn();try{return n.call(e,e)}catch(n){return Te(n,e,"data()"),{}}finally{wn()}}(e,n):e||{})||(e={});var t=Object.keys(e),i=n.$options.props,r=(n.$options.methods,t.length);for(;r--;){var o=t[r];0,i&&w(i,o)||R(o)||Ot(n,"_data",o)}var a=In(e);a&&a.vmCount++}(n);else{var t=In(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),i=an();for(var r in e){var o=e[r],a=c(o)?o:o.get;0,i||(t[r]=new He(n,a||B,B,qt)),r in n||Nt(n,r,o)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var i=e[t];if(r(i))for(var o=0;o<i.length;o++)Ut(n,t,i[o]);else Ut(n,t,i)}}(n,e.watch)}var qt={lazy:!0};function Nt(n,e,t){var i=!an();c(t)?($t.get=i?Mt(e):Ft(t),$t.set=B):($t.get=t.get?i&&!1!==t.cache?Mt(e):Ft(t.get):B,$t.set=t.set||B),Object.defineProperty(n,e,$t)}function Mt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),xn.target&&e.depend(),e.value}}function Ft(n){return function(){return n.call(this,this)}}function Ut(n,e,t,i){return p(t)&&(i=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,i)}var Rt=0;function Ht(n){var e=n.options;if(n.super){var t=Ht(n.super);if(t!==n.superOptions){n.superOptions=t;var i=function(n){var e,t=n.options,i=n.sealedOptions;for(var r in t)t[r]!==i[r]&&(e||(e={}),e[r]=t[r]);return e}(n);i&&I(n.extendOptions,i),(e=n.options=Ct(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Vt(n){this._init(n)}function Jt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,i=t.cid,r=n._Ctor||(n._Ctor={});if(r[i])return r[i];var o=vt(n)||vt(t.options);var a=function(n){this._init(n)};return(a.prototype=Object.create(t.prototype)).constructor=a,a.cid=e++,a.options=Ct(t.options,n),a.super=t,a.options.props&&function(n){var e=n.options.props;for(var t in e)Ot(n.prototype,"_props",t)}(a),a.options.computed&&function(n){var e=n.options.computed;for(var t in e)Nt(n.prototype,t,e[t])}(a),a.extend=t.extend,a.mixin=t.mixin,a.use=t.use,N.forEach((function(n){a[n]=t[n]})),o&&(a.options.components[o]=a),a.superOptions=t.options,a.extendOptions=n,a.sealedOptions=I({},a.options),r[i]=a,a}}function Wt(n){return n&&(vt(n.Ctor.options)||n.tag)}function Kt(n,e){return r(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!m(n)&&n.test(e)}function Qt(n,e){var t=n.cache,i=n.keys,r=n._vnode;for(var o in t){var a=t[o];if(a){var s=a.name;s&&!e(s)&&Zt(t,o,i,r)}}}function Zt(n,e,t,i){var r=n[e];!r||i&&r.tag===i.tag||r.componentInstance.$destroy(),n[e]=null,y(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Rt++,e._isVue=!0,e.__v_skip=!0,e._scope=new Fn(!0),e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),i=e._parentVnode;t.parent=e.parent,t._parentVnode=i;var r=i.componentOptions;t.propsData=r.propsData,t._parentListeners=r.listeners,t._renderChildren=r.children,t._componentTag=r.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Ct(Ht(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ke(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=pe(e._renderChildren,r),n.$scopedSlots=t?fe(n.$parent,t.data.scopedSlots,n.$slots):i,n._c=function(e,t,i,r){return je(n,e,t,i,r,!1)},n.$createElement=function(e,t,i,r){return je(n,e,t,i,r,!0)};var o=t&&t.data;zn(n,"$attrs",o&&o.attrs||i,null,!0),zn(n,"$listeners",e._parentListeners||i,null,!0)}(e),nt(e,"beforeCreate",void 0,!1),function(n){var e=mt(n.$options.inject,n);e&&(An(!1),Object.keys(e).forEach((function(t){zn(n,t,e[t])})),An(!0))}(e),Gt(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!u(t))return;for(var i=Un(n),r=un?Reflect.ownKeys(t):Object.keys(t),o=0;o<r.length;o++){var a=r[o];Object.defineProperty(i,a,Object.getOwnPropertyDescriptor(t,a))}}}(e),nt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Vt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Bn,n.prototype.$delete=Dn,n.prototype.$watch=function(n,e,t){if(p(e))return Ut(this,n,e,t);(t=t||{}).user=!0;var i=new He(this,n,e,t);if(t.immediate){var r='callback for immediate watcher "'.concat(i.expression,'"');kn(),Se(e,this,[i.value],this,r),wn()}return function(){i.teardown()}}}(Vt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var i=this;if(r(n))for(var o=0,a=n.length;o<a;o++)i.$on(n[o],t);else(i._events[n]||(i._events[n]=[])).push(t),e.test(n)&&(i._hasHookEvent=!0);return i},n.prototype.$once=function(n,e){var t=this;function i(){t.$off(n,i),e.apply(t,arguments)}return i.fn=e,t.$on(n,i),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(r(n)){for(var i=0,o=n.length;i<o;i++)t.$off(n[i],e);return t}var a,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((a=s[l])===e||a.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?P(t):t;for(var i=P(arguments,1),r='event handler for "'.concat(n,'"'),o=0,a=t.length;o<a;o++)Se(t[o],e,i,e,r)}return e}}(Vt),function(n){n.prototype._update=function(n,e){var t=this,i=t.$el,r=t._vnode,o=Ze(t);t._vnode=n,t.$el=r?t.__patch__(r,n):t.__patch__(t.$el,n,e,!1),o(),i&&(i.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var a=t;a&&a.$vnode&&a.$parent&&a.$vnode===a.$parent._vnode;)a.$parent.$el=a.$el,a=a.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){nt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||y(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),nt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Vt),function(n){de(n.prototype),n.prototype.$nextTick=function(n){return qe(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,i=t.render,o=t._parentVnode;o&&e._isMounted&&(e.$scopedSlots=fe(e.$parent,o.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&ke(e._slotsProxy,e.$scopedSlots)),e.$vnode=o;try{pn(e),we=e,n=i.call(e._renderProxy,e.$createElement)}catch(t){Te(t,e,"render"),n=e._vnode}finally{we=null,pn()}return r(n)&&1===n.length&&(n=n[0]),n instanceof mn||(n=hn()),n.parent=o,n}}(Vt);var Xt=[String,RegExp,Array],Yt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Xt,exclude:Xt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,i=this.keyToCache;if(t){var r=t.tag,o=t.componentInstance,a=t.componentOptions;n[i]={name:Wt(a),tag:r,componentInstance:o},e.push(i),this.max&&e.length>parseInt(this.max)&&Zt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Zt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Qt(n,(function(n){return Kt(e,n)}))})),this.$watch("exclude",(function(e){Qt(n,(function(n){return!Kt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Ee(n),t=e&&e.componentOptions;if(t){var i=Wt(t),r=this.include,o=this.exclude;if(r&&(!i||!Kt(r,i))||o&&i&&Kt(o,i))return e;var a=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;a[l]?(e.componentInstance=a[l].componentInstance,y(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return F}};Object.defineProperty(n,"config",e),n.util={warn:wt,extend:I,mergeOptions:Ct,defineReactive:zn},n.set=Bn,n.delete=Dn,n.nextTick=qe,n.observable=function(n){return In(n),n},n.options=Object.create(null),N.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,I(n.options.components,Yt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=P(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Ct(this.options,n),this}}(n),Jt(n),function(n){N.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&p(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Vt),Object.defineProperty(Vt.prototype,"$isServer",{get:an}),Object.defineProperty(Vt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Vt,"FunctionalRenderContext",{value:ht}),Vt.version="2.7.15";var ni=b("style,class"),ei=b("input,textarea,option,select,progress"),ti=b("contenteditable,draggable,spellcheck"),ii=b("events,caret,typing,plaintext-only"),ri=b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),oi="http://www.w3.org/1999/xlink",ai=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},si=function(n){return ai(n)?n.slice(6,n.length):""},li=function(n){return null==n||!1===n};function ci(n){for(var e=n.data,t=n,i=n;a(i.componentInstance);)(i=i.componentInstance._vnode)&&i.data&&(e=ui(i.data,e));for(;a(t=t.parent);)t&&t.data&&(e=ui(e,t.data));return function(n,e){if(a(n)||a(e))return di(n,pi(e));return""}(e.staticClass,e.class)}function ui(n,e){return{staticClass:di(n.staticClass,e.staticClass),class:a(n.class)?[n.class,e.class]:e.class}}function di(n,e){return n?e?n+" "+e:n:e||""}function pi(n){return Array.isArray(n)?function(n){for(var e,t="",i=0,r=n.length;i<r;i++)a(e=pi(n[i]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):u(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var mi={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},hi=b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),fi=b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),gi=function(n){return hi(n)||fi(n)};var vi=Object.create(null);var bi=b("text,number,password,search,email,tel,url");var xi=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(mi[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),yi={create:function(n,e){ki(e)},update:function(n,e){n.data.ref!==e.data.ref&&(ki(n,!0),ki(e))},destroy:function(n){ki(n,!0)}};function ki(n,e){var t=n.data.ref;if(a(t)){var i=n.context,o=n.componentInstance||n.elm,s=e?null:o,l=e?void 0:o;if(c(t))Se(t,i,[s],i,"template ref function");else{var u=n.data.refInFor,d="string"==typeof t||"number"==typeof t,p=qn(t),m=i.$refs;if(d||p)if(u){var h=d?m[t]:t.value;e?r(h)&&y(h,o):r(h)?h.includes(o)||h.push(o):d?(m[t]=[o],wi(i,t,m[t])):t.value=[o]}else if(d){if(e&&m[t]!==o)return;m[t]=l,wi(i,t,s)}else if(p){if(e&&t.value!==o)return;t.value=s}else 0}}}function wi(n,e,t){var i=n._setupState;i&&w(i,e)&&(qn(i[e])?i[e].value=t:i[e]=t)}var _i=new mn("",{},[]),Ei=["create","activate","update","remove","destroy"];function ji(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&a(n.data)===a(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,i=a(t=n.data)&&a(t=t.attrs)&&t.type,r=a(t=e.data)&&a(t=t.attrs)&&t.type;return i===r||bi(i)&&bi(r)}(n,e)||s(n.isAsyncPlaceholder)&&o(e.asyncFactory.error))}function Ti(n,e,t){var i,r,o={};for(i=e;i<=t;++i)a(r=n[i].key)&&(o[r]=i);return o}var Si={create:Ai,update:Ai,destroy:function(n){Ai(n,_i)}};function Ai(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,i,r,o=n===_i,a=e===_i,s=Pi(n.data.directives,n.context),l=Pi(e.data.directives,e.context),c=[],u=[];for(t in l)i=s[t],r=l[t],i?(r.oldValue=i.value,r.oldArg=i.arg,zi(r,"update",e,n),r.def&&r.def.componentUpdated&&u.push(r)):(zi(r,"bind",e,n),r.def&&r.def.inserted&&c.push(r));if(c.length){var d=function(){for(var t=0;t<c.length;t++)zi(c[t],"inserted",e,n)};o?Jn(e,"insert",d):d()}u.length&&Jn(e,"postpatch",(function(){for(var t=0;t<u.length;t++)zi(u[t],"componentUpdated",e,n)}));if(!o)for(t in s)l[t]||zi(s[t],"unbind",n,n,a)}(n,e)}var Ci=Object.create(null);function Pi(n,e){var t,i,r=Object.create(null);if(!n)return r;for(t=0;t<n.length;t++){if((i=n[t]).modifiers||(i.modifiers=Ci),r[Ii(i)]=i,e._setupState&&e._setupState.__sfc){var o=i.def||Pt(e,"_setupState","v-"+i.name);i.def="function"==typeof o?{bind:o,update:o}:o}i.def=i.def||Pt(e.$options,"directives",i.name)}return r}function Ii(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function zi(n,e,t,i,r){var o=n.def&&n.def[e];if(o)try{o(t.elm,n,t,i,r)}catch(i){Te(i,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Bi=[yi,Si];function Di(n,e){var t=e.componentOptions;if(!(a(t)&&!1===t.Ctor.options.inheritAttrs||o(n.data.attrs)&&o(e.data.attrs))){var i,r,l=e.elm,c=n.data.attrs||{},u=e.data.attrs||{};for(i in(a(u.__ob__)||s(u._v_attr_proxy))&&(u=e.data.attrs=I({},u)),u)r=u[i],c[i]!==r&&Li(l,i,r,e.data.pre);for(i in(Q||X)&&u.value!==c.value&&Li(l,"value",u.value),c)o(u[i])&&(ai(i)?l.removeAttributeNS(oi,si(i)):ti(i)||l.removeAttribute(i))}}function Li(n,e,t,i){i||n.tagName.indexOf("-")>-1?$i(n,e,t):ri(e)?li(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):ti(e)?n.setAttribute(e,function(n,e){return li(e)||"false"===e?"false":"contenteditable"===n&&ii(e)?e:"true"}(e,t)):ai(e)?li(t)?n.removeAttributeNS(oi,si(e)):n.setAttributeNS(oi,e,t):$i(n,e,t)}function $i(n,e,t){if(li(t))n.removeAttribute(e);else{if(Q&&!Z&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var i=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",i)};n.addEventListener("input",i),n.__ieph=!0}n.setAttribute(e,t)}}var Oi={create:Di,update:Di};function Gi(n,e){var t=e.elm,i=e.data,r=n.data;if(!(o(i.staticClass)&&o(i.class)&&(o(r)||o(r.staticClass)&&o(r.class)))){var s=ci(e),l=t._transitionClasses;a(l)&&(s=di(s,pi(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var qi,Ni={create:Gi,update:Gi};function Mi(n,e,t){var i=qi;return function r(){var o=e.apply(null,arguments);null!==o&&Ri(n,r,t,i)}}var Fi=Ie&&!(en&&Number(en[1])<=53);function Ui(n,e,t,i){if(Fi){var r=st,o=e;e=o._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=r||n.timeStamp<=0||n.target.ownerDocument!==document)return o.apply(this,arguments)}}qi.addEventListener(n,e,rn?{capture:t,passive:i}:t)}function Ri(n,e,t,i){(i||qi).removeEventListener(n,e._wrapper||e,t)}function Hi(n,e){if(!o(n.data.on)||!o(e.data.on)){var t=e.data.on||{},i=n.data.on||{};qi=e.elm||n.elm,function(n){if(a(n.__r)){var e=Q?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}a(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Vn(t,i,Ui,Ri,Mi,e.context),qi=void 0}}var Vi,Ji={create:Hi,update:Hi,destroy:function(n){return Hi(n,_i)}};function Wi(n,e){if(!o(n.data.domProps)||!o(e.data.domProps)){var t,i,r=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(a(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.domProps=I({},c)),l)t in c||(r[t]="");for(t in c){if(i=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),i===l[t])continue;1===r.childNodes.length&&r.removeChild(r.childNodes[0])}if("value"===t&&"PROGRESS"!==r.tagName){r._value=i;var u=o(i)?"":String(i);Ki(r,u)&&(r.value=u)}else if("innerHTML"===t&&fi(r.tagName)&&o(r.innerHTML)){(Vi=Vi||document.createElement("div")).innerHTML="<svg>".concat(i,"</svg>");for(var d=Vi.firstChild;r.firstChild;)r.removeChild(r.firstChild);for(;d.firstChild;)r.appendChild(d.firstChild)}else if(i!==l[t])try{r[t]=i}catch(n){}}}}function Ki(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,i=n._vModifiers;if(a(i)){if(i.number)return v(t)!==v(e);if(i.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Qi={create:Wi,update:Wi},Zi=_((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var i=n.split(t);i.length>1&&(e[i[0].trim()]=i[1].trim())}})),e}));function Xi(n){var e=Yi(n.style);return n.staticStyle?I(n.staticStyle,e):e}function Yi(n){return Array.isArray(n)?z(n):"string"==typeof n?Zi(n):n}var nr,er=/^--/,tr=/\s*!important$/,ir=function(n,e,t){if(er.test(e))n.style.setProperty(e,t);else if(tr.test(t))n.style.setProperty(A(e),t.replace(tr,""),"important");else{var i=or(e);if(Array.isArray(t))for(var r=0,o=t.length;r<o;r++)n.style[i]=t[r];else n.style[i]=t}},rr=["Webkit","Moz","ms"],or=_((function(n){if(nr=nr||document.createElement("div").style,"filter"!==(n=j(n))&&n in nr)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<rr.length;t++){var i=rr[t]+e;if(i in nr)return i}}));function ar(n,e){var t=e.data,i=n.data;if(!(o(t.staticStyle)&&o(t.style)&&o(i.staticStyle)&&o(i.style))){var r,s,l=e.elm,c=i.staticStyle,u=i.normalizedStyle||i.style||{},d=c||u,p=Yi(e.data.style)||{};e.data.normalizedStyle=a(p.__ob__)?I({},p):p;var m=function(n,e){var t,i={};if(e)for(var r=n;r.componentInstance;)(r=r.componentInstance._vnode)&&r.data&&(t=Xi(r.data))&&I(i,t);(t=Xi(n.data))&&I(i,t);for(var o=n;o=o.parent;)o.data&&(t=Xi(o.data))&&I(i,t);return i}(e,!0);for(s in d)o(m[s])&&ir(l,s,"");for(s in m)(r=m[s])!==d[s]&&ir(l,s,null==r?"":r)}}var sr={create:ar,update:ar},lr=/\s+/;function cr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(lr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function ur(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(lr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),i=" "+e+" ";t.indexOf(i)>=0;)t=t.replace(i," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function dr(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&I(e,pr(n.name||"v")),I(e,n),e}return"string"==typeof n?pr(n):void 0}}var pr=_((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),mr=W&&!Z,hr="transition",fr="transitionend",gr="animation",vr="animationend";mr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(hr="WebkitTransition",fr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(gr="WebkitAnimation",vr="webkitAnimationEnd"));var br=W?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function xr(n){br((function(){br(n)}))}function yr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),cr(n,e))}function kr(n,e){n._transitionClasses&&y(n._transitionClasses,e),ur(n,e)}function wr(n,e,t){var i=Er(n,e),r=i.type,o=i.timeout,a=i.propCount;if(!r)return t();var s="transition"===r?fr:vr,l=0,c=function(){n.removeEventListener(s,u),t()},u=function(e){e.target===n&&++l>=a&&c()};setTimeout((function(){l<a&&c()}),o+1),n.addEventListener(s,u)}var _r=/\b(transform|all)(,|$)/;function Er(n,e){var t,i=window.getComputedStyle(n),r=(i[hr+"Delay"]||"").split(", "),o=(i[hr+"Duration"]||"").split(", "),a=jr(r,o),s=(i[gr+"Delay"]||"").split(", "),l=(i[gr+"Duration"]||"").split(", "),c=jr(s,l),u=0,d=0;return"transition"===e?a>0&&(t="transition",u=a,d=o.length):"animation"===e?c>0&&(t="animation",u=c,d=l.length):d=(t=(u=Math.max(a,c))>0?a>c?"transition":"animation":null)?"transition"===t?o.length:l.length:0,{type:t,timeout:u,propCount:d,hasTransform:"transition"===t&&_r.test(i[hr+"Property"])}}function jr(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Tr(e)+Tr(n[t])})))}function Tr(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Sr(n,e){var t=n.elm;a(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var i=dr(n.data.transition);if(!o(i)&&!a(t._enterCb)&&1===t.nodeType){for(var r=i.css,s=i.type,l=i.enterClass,d=i.enterToClass,p=i.enterActiveClass,m=i.appearClass,h=i.appearToClass,f=i.appearActiveClass,g=i.beforeEnter,b=i.enter,x=i.afterEnter,y=i.enterCancelled,k=i.beforeAppear,w=i.appear,_=i.afterAppear,E=i.appearCancelled,j=i.duration,T=Qe,S=Qe.$vnode;S&&S.parent;)T=S.context,S=S.parent;var A=!T._isMounted||!n.isRootInsert;if(!A||w||""===w){var C=A&&m?m:l,P=A&&f?f:p,I=A&&h?h:d,z=A&&k||g,B=A&&c(w)?w:b,D=A&&_||x,L=A&&E||y,$=v(u(j)?j.enter:j);0;var O=!1!==r&&!Z,q=Pr(B),N=t._enterCb=G((function(){O&&(kr(t,I),kr(t,P)),N.cancelled?(O&&kr(t,C),L&&L(t)):D&&D(t),t._enterCb=null}));n.data.show||Jn(n,"insert",(function(){var e=t.parentNode,i=e&&e._pending&&e._pending[n.key];i&&i.tag===n.tag&&i.elm._leaveCb&&i.elm._leaveCb(),B&&B(t,N)})),z&&z(t),O&&(yr(t,C),yr(t,P),xr((function(){kr(t,C),N.cancelled||(yr(t,I),q||(Cr($)?setTimeout(N,$):wr(t,s,N)))}))),n.data.show&&(e&&e(),B&&B(t,N)),O||q||N()}}}function Ar(n,e){var t=n.elm;a(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var i=dr(n.data.transition);if(o(i)||1!==t.nodeType)return e();if(!a(t._leaveCb)){var r=i.css,s=i.type,l=i.leaveClass,c=i.leaveToClass,d=i.leaveActiveClass,p=i.beforeLeave,m=i.leave,h=i.afterLeave,f=i.leaveCancelled,g=i.delayLeave,b=i.duration,x=!1!==r&&!Z,y=Pr(m),k=v(u(b)?b.leave:b);0;var w=t._leaveCb=G((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),x&&(kr(t,c),kr(t,d)),w.cancelled?(x&&kr(t,l),f&&f(t)):(e(),h&&h(t)),t._leaveCb=null}));g?g(_):_()}function _(){w.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),x&&(yr(t,l),yr(t,d),xr((function(){kr(t,l),w.cancelled||(yr(t,c),y||(Cr(k)?setTimeout(w,k):wr(t,s,w)))}))),m&&m(t,w),x||y||w())}}function Cr(n){return"number"==typeof n&&!isNaN(n)}function Pr(n){if(o(n))return!1;var e=n.fns;return a(e)?Pr(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Ir(n,e){!0!==e.data.show&&Sr(e)}var zr=function(n){var e,t,i={},c=n.modules,u=n.nodeOps;for(e=0;e<Ei.length;++e)for(i[Ei[e]]=[],t=0;t<c.length;++t)a(c[t][Ei[e]])&&i[Ei[e]].push(c[t][Ei[e]]);function d(n){var e=u.parentNode(n);a(e)&&u.removeChild(e,n)}function p(n,e,t,r,o,l,c){if(a(n.elm)&&a(l)&&(n=l[c]=gn(n)),n.isRootInsert=!o,!function(n,e,t,r){var o=n.data;if(a(o)){var l=a(n.componentInstance)&&o.keepAlive;if(a(o=o.hook)&&a(o=o.init)&&o(n,!1),a(n.componentInstance))return m(n,e),h(t,n.elm,r),s(l)&&function(n,e,t,r){var o,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,a(o=s.data)&&a(o=o.transition)){for(o=0;o<i.activate.length;++o)i.activate[o](_i,s);e.push(s);break}h(t,n.elm,r)}(n,e,t,r),!0}}(n,e,t,r)){var d=n.data,p=n.children,g=n.tag;a(g)?(n.elm=n.ns?u.createElementNS(n.ns,g):u.createElement(g,n),x(n),f(n,p,e),a(d)&&v(n,e),h(t,n.elm,r)):s(n.isComment)?(n.elm=u.createComment(n.text),h(t,n.elm,r)):(n.elm=u.createTextNode(n.text),h(t,n.elm,r))}}function m(n,e){a(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(v(n,e),x(n)):(ki(n),e.push(n))}function h(n,e,t){a(n)&&(a(t)?u.parentNode(t)===n&&u.insertBefore(n,e,t):u.appendChild(n,e))}function f(n,e,t){if(r(e)){0;for(var i=0;i<e.length;++i)p(e[i],t,n.elm,null,!0,e,i)}else l(n.text)&&u.appendChild(n.elm,u.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return a(n.tag)}function v(n,t){for(var r=0;r<i.create.length;++r)i.create[r](_i,n);a(e=n.data.hook)&&(a(e.create)&&e.create(_i,n),a(e.insert)&&t.push(n))}function x(n){var e;if(a(e=n.fnScopeId))u.setStyleScope(n.elm,e);else for(var t=n;t;)a(e=t.context)&&a(e=e.$options._scopeId)&&u.setStyleScope(n.elm,e),t=t.parent;a(e=Qe)&&e!==n.context&&e!==n.fnContext&&a(e=e.$options._scopeId)&&u.setStyleScope(n.elm,e)}function y(n,e,t,i,r,o){for(;i<=r;++i)p(t[i],o,n,e,!1,t,i)}function k(n){var e,t,r=n.data;if(a(r))for(a(e=r.hook)&&a(e=e.destroy)&&e(n),e=0;e<i.destroy.length;++e)i.destroy[e](n);if(a(e=n.children))for(t=0;t<n.children.length;++t)k(n.children[t])}function w(n,e,t){for(;e<=t;++e){var i=n[e];a(i)&&(a(i.tag)?(_(i),k(i)):d(i.elm))}}function _(n,e){if(a(e)||a(n.data)){var t,r=i.remove.length+1;for(a(e)?e.listeners+=r:e=function(n,e){function t(){0==--t.listeners&&d(n)}return t.listeners=e,t}(n.elm,r),a(t=n.componentInstance)&&a(t=t._vnode)&&a(t.data)&&_(t,e),t=0;t<i.remove.length;++t)i.remove[t](n,e);a(t=n.data.hook)&&a(t=t.remove)?t(n,e):e()}else d(n.elm)}function E(n,e,t,i){for(var r=t;r<i;r++){var o=e[r];if(a(o)&&ji(n,o))return r}}function j(n,e,t,r,l,c){if(n!==e){a(e.elm)&&a(r)&&(e=r[l]=gn(e));var d=e.elm=n.elm;if(s(n.isAsyncPlaceholder))a(e.asyncFactory.resolved)?A(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;a(h)&&a(m=h.hook)&&a(m=m.prepatch)&&m(n,e);var f=n.children,v=e.children;if(a(h)&&g(e)){for(m=0;m<i.update.length;++m)i.update[m](n,e);a(m=h.hook)&&a(m=m.update)&&m(n,e)}o(e.text)?a(f)&&a(v)?f!==v&&function(n,e,t,i,r){var s,l,c,d=0,m=0,h=e.length-1,f=e[0],g=e[h],v=t.length-1,b=t[0],x=t[v],k=!r;for(0;d<=h&&m<=v;)o(f)?f=e[++d]:o(g)?g=e[--h]:ji(f,b)?(j(f,b,i,t,m),f=e[++d],b=t[++m]):ji(g,x)?(j(g,x,i,t,v),g=e[--h],x=t[--v]):ji(f,x)?(j(f,x,i,t,v),k&&u.insertBefore(n,f.elm,u.nextSibling(g.elm)),f=e[++d],x=t[--v]):ji(g,b)?(j(g,b,i,t,m),k&&u.insertBefore(n,g.elm,f.elm),g=e[--h],b=t[++m]):(o(s)&&(s=Ti(e,d,h)),o(l=a(b.key)?s[b.key]:E(b,e,d,h))?p(b,i,n,f.elm,!1,t,m):ji(c=e[l],b)?(j(c,b,i,t,m),e[l]=void 0,k&&u.insertBefore(n,c.elm,f.elm)):p(b,i,n,f.elm,!1,t,m),b=t[++m]);d>h?y(n,o(t[v+1])?null:t[v+1].elm,t,m,v,i):m>v&&w(e,d,h)}(d,f,v,t,c):a(v)?(a(n.text)&&u.setTextContent(d,""),y(d,null,v,0,v.length-1,t)):a(f)?w(f,0,f.length-1):a(n.text)&&u.setTextContent(d,""):n.text!==e.text&&u.setTextContent(d,e.text),a(h)&&a(m=h.hook)&&a(m=m.postpatch)&&m(n,e)}}}function T(n,e,t){if(s(t)&&a(n.parent))n.parent.data.pendingInsert=e;else for(var i=0;i<e.length;++i)e[i].data.hook.insert(e[i])}var S=b("attrs,class,staticClass,staticStyle,key");function A(n,e,t,i){var r,o=e.tag,l=e.data,c=e.children;if(i=i||l&&l.pre,e.elm=n,s(e.isComment)&&a(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(a(l)&&(a(r=l.hook)&&a(r=r.init)&&r(e,!0),a(r=e.componentInstance)))return m(e,t),!0;if(a(o)){if(a(c))if(n.hasChildNodes())if(a(r=l)&&a(r=r.domProps)&&a(r=r.innerHTML)){if(r!==n.innerHTML)return!1}else{for(var u=!0,d=n.firstChild,p=0;p<c.length;p++){if(!d||!A(d,c[p],t,i)){u=!1;break}d=d.nextSibling}if(!u||d)return!1}else f(e,c,t);if(a(l)){var h=!1;for(var g in l)if(!S(g)){h=!0,v(e,t);break}!h&&l.class&&Fe(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,r){if(!o(e)){var l,c=!1,d=[];if(o(n))c=!0,p(e,d);else{var m=a(n.nodeType);if(!m&&ji(n,e))j(n,e,d,null,null,r);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&A(n,e,d))return T(e,d,!0),n;l=n,n=new mn(u.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,f=u.parentNode(h);if(p(e,d,h._leaveCb?null:f,u.nextSibling(h)),a(e.parent))for(var v=e.parent,b=g(e);v;){for(var x=0;x<i.destroy.length;++x)i.destroy[x](v);if(v.elm=e.elm,b){for(var y=0;y<i.create.length;++y)i.create[y](_i,v);var _=v.data.hook.insert;if(_.merged)for(var E=_.fns.slice(1),S=0;S<E.length;S++)E[S]()}else ki(v);v=v.parent}a(f)?w([n],0,0):a(n.tag)&&k(n)}}return T(e,d,c),e.elm}a(n)&&k(n)}}({nodeOps:xi,modules:[Oi,Ni,Ji,Qi,sr,W?{create:Ir,activate:Ir,remove:function(n,e){!0!==n.data.show?Ar(n,e):e()}}:{}].concat(Bi)});Z&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Nr(n,"input")}));var Br={inserted:function(n,e,t,i){"select"===t.tag?(i.elm&&!i.elm._vOptions?Jn(t,"postpatch",(function(){Br.componentUpdated(n,e,t)})):Dr(n,e,t.context),n._vOptions=[].map.call(n.options,Or)):("textarea"===t.tag||bi(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Gr),n.addEventListener("compositionend",qr),n.addEventListener("change",qr),Z&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Dr(n,e,t.context);var i=n._vOptions,r=n._vOptions=[].map.call(n.options,Or);if(r.some((function(n,e){return!$(n,i[e])})))(n.multiple?e.value.some((function(n){return $r(n,r)})):e.value!==e.oldValue&&$r(e.value,r))&&Nr(n,"change")}}};function Dr(n,e,t){Lr(n,e,t),(Q||X)&&setTimeout((function(){Lr(n,e,t)}),0)}function Lr(n,e,t){var i=e.value,r=n.multiple;if(!r||Array.isArray(i)){for(var o,a,s=0,l=n.options.length;s<l;s++)if(a=n.options[s],r)o=O(i,Or(a))>-1,a.selected!==o&&(a.selected=o);else if($(Or(a),i))return void(n.selectedIndex!==s&&(n.selectedIndex=s));r||(n.selectedIndex=-1)}}function $r(n,e){return e.every((function(e){return!$(e,n)}))}function Or(n){return"_value"in n?n._value:n.value}function Gr(n){n.target.composing=!0}function qr(n){n.target.composing&&(n.target.composing=!1,Nr(n.target,"input"))}function Nr(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Mr(n){return!n.componentInstance||n.data&&n.data.transition?n:Mr(n.componentInstance._vnode)}var Fr={model:Br,show:{bind:function(n,e,t){var i=e.value,r=(t=Mr(t)).data&&t.data.transition,o=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;i&&r?(t.data.show=!0,Sr(t,(function(){n.style.display=o}))):n.style.display=i?o:"none"},update:function(n,e,t){var i=e.value;!i!=!e.oldValue&&((t=Mr(t)).data&&t.data.transition?(t.data.show=!0,i?Sr(t,(function(){n.style.display=n.__vOriginalDisplay})):Ar(t,(function(){n.style.display="none"}))):n.style.display=i?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,i,r){r||(n.style.display=n.__vOriginalDisplay)}}},Ur={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Rr(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Rr(Ee(e.children)):n}function Hr(n){var e={},t=n.$options;for(var i in t.propsData)e[i]=n[i];var r=t._parentListeners;for(var i in r)e[j(i)]=r[i];return e}function Vr(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Jr=function(n){return n.tag||he(n)},Wr=function(n){return"show"===n.name},Kr={name:"transition",props:Ur,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Jr)).length){0;var i=this.mode;0;var r=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return r;var o=Rr(r);if(!o)return r;if(this._leaving)return Vr(n,r);var a="__transition-".concat(this._uid,"-");o.key=null==o.key?o.isComment?a+"comment":a+o.tag:l(o.key)?0===String(o.key).indexOf(a)?o.key:a+o.key:o.key;var s=(o.data||(o.data={})).transition=Hr(this),c=this._vnode,u=Rr(c);if(o.data.directives&&o.data.directives.some(Wr)&&(o.data.show=!0),u&&u.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(o,u)&&!he(u)&&(!u.componentInstance||!u.componentInstance._vnode.isComment)){var d=u.data.transition=I({},s);if("out-in"===i)return this._leaving=!0,Jn(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Vr(n,r);if("in-out"===i){if(he(o))return c;var p,m=function(){p()};Jn(s,"afterEnter",m),Jn(s,"enterCancelled",m),Jn(d,"delayLeave",(function(n){p=n}))}}return r}}},Qr=I({tag:String,moveClass:String},Ur);function Zr(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Xr(n){n.data.newPos=n.elm.getBoundingClientRect()}function Yr(n){var e=n.data.pos,t=n.data.newPos,i=e.left-t.left,r=e.top-t.top;if(i||r){n.data.moved=!0;var o=n.elm.style;o.transform=o.WebkitTransform="translate(".concat(i,"px,").concat(r,"px)"),o.transitionDuration="0s"}}delete Qr.mode;var no={Transition:Kr,TransitionGroup:{props:Qr,beforeMount:function(){var n=this,e=this._update;this._update=function(t,i){var r=Ze(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,r(),e.call(n,t,i)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),i=this.prevChildren=this.children,r=this.$slots.default||[],o=this.children=[],a=Hr(this),s=0;s<r.length;s++){if((u=r[s]).tag)if(null!=u.key&&0!==String(u.key).indexOf("__vlist"))o.push(u),t[u.key]=u,(u.data||(u.data={})).transition=a;else;}if(i){var l=[],c=[];for(s=0;s<i.length;s++){var u;(u=i[s]).data.transition=a,u.data.pos=u.elm.getBoundingClientRect(),t[u.key]?l.push(u):c.push(u)}this.kept=n(e,null,l),this.removed=c}return n(e,null,o)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Zr),n.forEach(Xr),n.forEach(Yr),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,i=t.style;yr(t,e),i.transform=i.WebkitTransform=i.transitionDuration="",t.addEventListener(fr,t._moveCb=function n(i){i&&i.target!==t||i&&!/transform$/.test(i.propertyName)||(t.removeEventListener(fr,n),t._moveCb=null,kr(t,e))})}})))},methods:{hasMove:function(n,e){if(!mr)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){ur(t,n)})),cr(t,e),t.style.display="none",this.$el.appendChild(t);var i=Er(t);return this.$el.removeChild(t),this._hasMove=i.hasTransform}}}};function eo(n,e){for(var t in e)n[t]=e[t];return n}Vt.config.mustUseProp=function(n,e,t){return"value"===t&&ei(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Vt.config.isReservedTag=gi,Vt.config.isReservedAttr=ni,Vt.config.getTagNamespace=function(n){return fi(n)?"svg":"math"===n?"math":void 0},Vt.config.isUnknownElement=function(n){if(!W)return!0;if(gi(n))return!1;if(n=n.toLowerCase(),null!=vi[n])return vi[n];var e=document.createElement(n);return n.indexOf("-")>-1?vi[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:vi[n]=/HTMLUnknownElement/.test(e.toString())},I(Vt.options.directives,Fr),I(Vt.options.components,no),Vt.prototype.__patch__=W?zr:B,Vt.prototype.$mount=function(n,e){return function(n,e,t){var i;n.$el=e,n.$options.render||(n.$options.render=hn),nt(n,"beforeMount"),i=function(){n._update(n._render(),t)},new He(n,i,B,{before:function(){n._isMounted&&!n._isDestroyed&&nt(n,"beforeUpdate")}},!0),t=!1;var r=n._preWatchers;if(r)for(var o=0;o<r.length;o++)r[o].run();return null==n.$vnode&&(n._isMounted=!0,nt(n,"mounted")),n}(this,n=n&&W?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},W&&setTimeout((function(){F.devtools&&sn&&sn.emit("init",Vt)}),0);var to=/[!'()*]/g,io=function(n){return"%"+n.charCodeAt(0).toString(16)},ro=/%2C/g,oo=function(n){return encodeURIComponent(n).replace(to,io).replace(ro,",")};function ao(n){try{return decodeURIComponent(n)}catch(n){0}return n}var so=function(n){return null==n||"object"==typeof n?n:String(n)};function lo(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),i=ao(t.shift()),r=t.length>0?ao(t.join("=")):null;void 0===e[i]?e[i]=r:Array.isArray(e[i])?e[i].push(r):e[i]=[e[i],r]})),e):e}function co(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return oo(e);if(Array.isArray(t)){var i=[];return t.forEach((function(n){void 0!==n&&(null===n?i.push(oo(e)):i.push(oo(e)+"="+oo(n)))})),i.join("&")}return oo(e)+"="+oo(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var uo=/\/?$/;function po(n,e,t,i){var r=i&&i.options.stringifyQuery,o=e.query||{};try{o=mo(o)}catch(n){}var a={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:o,params:e.params||{},fullPath:go(e,r),matched:n?fo(n):[]};return t&&(a.redirectedFrom=go(t,r)),Object.freeze(a)}function mo(n){if(Array.isArray(n))return n.map(mo);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=mo(n[t]);return e}return n}var ho=po(null,{path:"/"});function fo(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function go(n,e){var t=n.path,i=n.query;void 0===i&&(i={});var r=n.hash;return void 0===r&&(r=""),(t||"/")+(e||co)(i)+r}function vo(n,e,t){return e===ho?n===e:!!e&&(n.path&&e.path?n.path.replace(uo,"")===e.path.replace(uo,"")&&(t||n.hash===e.hash&&bo(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&bo(n.query,e.query)&&bo(n.params,e.params))))}function bo(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),i=Object.keys(e).sort();return t.length===i.length&&t.every((function(t,r){var o=n[t];if(i[r]!==t)return!1;var a=e[t];return null==o||null==a?o===a:"object"==typeof o&&"object"==typeof a?bo(o,a):String(o)===String(a)}))}function xo(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var i in t.instances){var r=t.instances[i],o=t.enteredCbs[i];if(r&&o){delete t.enteredCbs[i];for(var a=0;a<o.length;a++)r._isBeingDestroyed||o[a](r)}}}}var yo={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,i=e.children,r=e.parent,o=e.data;o.routerView=!0;for(var a=r.$createElement,s=t.name,l=r.$route,c=r._routerViewCache||(r._routerViewCache={}),u=0,d=!1;r&&r._routerRoot!==r;){var p=r.$vnode?r.$vnode.data:{};p.routerView&&u++,p.keepAlive&&r._directInactive&&r._inactive&&(d=!0),r=r.$parent}if(o.routerViewDepth=u,d){var m=c[s],h=m&&m.component;return h?(m.configProps&&ko(h,o,m.route,m.configProps),a(h,o,i)):a()}var f=l.matched[u],g=f&&f.components[s];if(!f||!g)return c[s]=null,a();c[s]={component:g},o.registerRouteInstance=function(n,e){var t=f.instances[s];(e&&t!==n||!e&&t===n)&&(f.instances[s]=e)},(o.hook||(o.hook={})).prepatch=function(n,e){f.instances[s]=e.componentInstance},o.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==f.instances[s]&&(f.instances[s]=n.componentInstance),xo(l)};var v=f.props&&f.props[s];return v&&(eo(c[s],{route:l,configProps:v}),ko(g,o,l,v)),a(g,o,i)}};function ko(n,e,t,i){var r=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,i);if(r){r=e.props=eo({},r);var o=e.attrs=e.attrs||{};for(var a in r)n.props&&a in n.props||(o[a]=r[a],delete r[a])}}function wo(n,e,t){var i=n.charAt(0);if("/"===i)return n;if("?"===i||"#"===i)return e+n;var r=e.split("/");t&&r[r.length-1]||r.pop();for(var o=n.replace(/^\//,"").split("/"),a=0;a<o.length;a++){var s=o[a];".."===s?r.pop():"."!==s&&r.push(s)}return""!==r[0]&&r.unshift(""),r.join("/")}function _o(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var Eo=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},jo=qo,To=Io,So=function(n,e){return Bo(Io(n,e),e)},Ao=Bo,Co=Go,Po=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Io(n,e){for(var t,i=[],r=0,o=0,a="",s=e&&e.delimiter||"/";null!=(t=Po.exec(n));){var l=t[0],c=t[1],u=t.index;if(a+=n.slice(o,u),o=u+l.length,c)a+=c[1];else{var d=n[o],p=t[2],m=t[3],h=t[4],f=t[5],g=t[6],v=t[7];a&&(i.push(a),a="");var b=null!=p&&null!=d&&d!==p,x="+"===g||"*"===g,y="?"===g||"*"===g,k=t[2]||s,w=h||f;i.push({name:m||r++,prefix:p||"",delimiter:k,optional:y,repeat:x,partial:b,asterisk:!!v,pattern:w?Lo(w):v?".*":"[^"+Do(k)+"]+?"})}}return o<n.length&&(a+=n.substr(o)),a&&i.push(a),i}function zo(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function Bo(n,e){for(var t=new Array(n.length),i=0;i<n.length;i++)"object"==typeof n[i]&&(t[i]=new RegExp("^(?:"+n[i].pattern+")$",Oo(e)));return function(e,i){for(var r="",o=e||{},a=(i||{}).pretty?zo:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,u=o[l.name];if(null==u){if(l.optional){l.partial&&(r+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(Eo(u)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(u)+"`");if(0===u.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<u.length;d++){if(c=a(u[d]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");r+=(0===d?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(u).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):a(u),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');r+=l.prefix+c}}else r+=l}return r}}function Do(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Lo(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function $o(n,e){return n.keys=e,n}function Oo(n){return n&&n.sensitive?"":"i"}function Go(n,e,t){Eo(e)||(t=e||t,e=[]);for(var i=(t=t||{}).strict,r=!1!==t.end,o="",a=0;a<n.length;a++){var s=n[a];if("string"==typeof s)o+=Do(s);else{var l=Do(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),o+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var u=Do(t.delimiter||"/"),d=o.slice(-u.length)===u;return i||(o=(d?o.slice(0,-u.length):o)+"(?:"+u+"(?=$))?"),o+=r?"$":i&&d?"":"(?="+u+"|$)",$o(new RegExp("^"+o,Oo(t)),e)}function qo(n,e,t){return Eo(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var i=0;i<t.length;i++)e.push({name:i,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return $o(n,e)}(n,e):Eo(n)?function(n,e,t){for(var i=[],r=0;r<n.length;r++)i.push(qo(n[r],e,t).source);return $o(new RegExp("(?:"+i.join("|")+")",Oo(t)),e)}(n,e,t):function(n,e,t){return Go(Io(n,t),e,t)}(n,e,t)}jo.parse=To,jo.compile=So,jo.tokensToFunction=Ao,jo.tokensToRegExp=Co;var No=Object.create(null);function Mo(n,e,t){e=e||{};try{var i=No[n]||(No[n]=jo.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),i(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Fo(n,e,t,i){var r="string"==typeof n?{path:n}:n;if(r._normalized)return r;if(r.name){var o=(r=eo({},n)).params;return o&&"object"==typeof o&&(r.params=eo({},o)),r}if(!r.path&&r.params&&e){(r=eo({},r))._normalized=!0;var a=eo(eo({},e.params),r.params);if(e.name)r.name=e.name,r.params=a;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;r.path=Mo(s,a,e.path)}else 0;return r}var l=function(n){var e="",t="",i=n.indexOf("#");i>=0&&(e=n.slice(i),n=n.slice(0,i));var r=n.indexOf("?");return r>=0&&(t=n.slice(r+1),n=n.slice(0,r)),{path:n,query:t,hash:e}}(r.path||""),c=e&&e.path||"/",u=l.path?wo(l.path,c,t||r.append):c,d=function(n,e,t){void 0===e&&(e={});var i,r=t||lo;try{i=r(n||"")}catch(n){i={}}for(var o in e){var a=e[o];i[o]=Array.isArray(a)?a.map(so):so(a)}return i}(l.query,r.query,i&&i.options.parseQuery),p=r.hash||l.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:u,query:d,hash:p}}var Uo,Ro=function(){},Ho={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,i=this.$route,r=t.resolve(this.to,i,this.append),o=r.location,a=r.route,s=r.href,l={},c=t.options.linkActiveClass,u=t.options.linkExactActiveClass,d=null==c?"router-link-active":c,p=null==u?"router-link-exact-active":u,m=null==this.activeClass?d:this.activeClass,h=null==this.exactActiveClass?p:this.exactActiveClass,f=a.redirectedFrom?po(null,Fo(a.redirectedFrom),null,t):a;l[h]=vo(i,f,this.exactPath),l[m]=this.exact||this.exactPath?l[h]:function(n,e){return 0===n.path.replace(uo,"/").indexOf(e.path.replace(uo,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(i,f);var g=l[h]?this.ariaCurrentValue:null,v=function(n){Vo(n)&&(e.replace?t.replace(o,Ro):t.push(o,Ro))},b={click:Vo};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=v})):b[this.event]=v;var x={class:l},y=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:a,navigate:v,isActive:l[m],isExactActive:l[h]});if(y){if(1===y.length)return y[0];if(y.length>1||!y.length)return 0===y.length?n():n("span",{},y)}if("a"===this.tag)x.on=b,x.attrs={href:s,"aria-current":g};else{var k=function n(e){var t;if(e)for(var i=0;i<e.length;i++){if("a"===(t=e[i]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(k){k.isStatic=!1;var w=k.data=eo({},k.data);for(var _ in w.on=w.on||{},w.on){var E=w.on[_];_ in b&&(w.on[_]=Array.isArray(E)?E:[E])}for(var j in b)j in w.on?w.on[j].push(b[j]):w.on[j]=v;var T=k.data.attrs=eo({},k.data.attrs);T.href=s,T["aria-current"]=g}else x.on=b}return n(this.tag,x,this.$slots.default)}};function Vo(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Jo="undefined"!=typeof window;function Wo(n,e,t,i,r){var o=e||[],a=t||Object.create(null),s=i||Object.create(null);n.forEach((function(n){!function n(e,t,i,r,o,a){var s=r.path,l=r.name;0;var c=r.pathToRegexpOptions||{},u=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return _o(e.path+"/"+n)}(s,o,c.strict);"boolean"==typeof r.caseSensitive&&(c.sensitive=r.caseSensitive);var d={path:u,regex:Ko(u,c),components:r.components||{default:r.component},alias:r.alias?"string"==typeof r.alias?[r.alias]:r.alias:[],instances:{},enteredCbs:{},name:l,parent:o,matchAs:a,redirect:r.redirect,beforeEnter:r.beforeEnter,meta:r.meta||{},props:null==r.props?{}:r.components?r.props:{default:r.props}};r.children&&r.children.forEach((function(r){var o=a?_o(a+"/"+r.path):void 0;n(e,t,i,r,d,o)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==r.alias)for(var p=Array.isArray(r.alias)?r.alias:[r.alias],m=0;m<p.length;++m){0;var h={path:p[m],children:r.children};n(e,t,i,h,o,d.path||"/")}l&&(i[l]||(i[l]=d))}(o,a,s,n,r)}));for(var l=0,c=o.length;l<c;l++)"*"===o[l]&&(o.push(o.splice(l,1)[0]),c--,l--);return{pathList:o,pathMap:a,nameMap:s}}function Ko(n,e){return jo(n,[],e)}function Qo(n,e){var t=Wo(n),i=t.pathList,r=t.pathMap,o=t.nameMap;function a(n,t,a){var s=Fo(n,t,!1,e),c=s.name;if(c){var u=o[c];if(!u)return l(null,s);var d=u.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in s.params)&&d.indexOf(p)>-1&&(s.params[p]=t.params[p]);return s.path=Mo(u.path,s.params),l(u,s,a)}if(s.path){s.params={};for(var m=0;m<i.length;m++){var h=i[m],f=r[h];if(Zo(f.regex,s.path,s.params))return l(f,s,a)}}return l(null,s)}function s(n,t){var i=n.redirect,r="function"==typeof i?i(po(n,t,null,e)):i;if("string"==typeof r&&(r={path:r}),!r||"object"!=typeof r)return l(null,t);var s=r,c=s.name,u=s.path,d=t.query,p=t.hash,m=t.params;if(d=s.hasOwnProperty("query")?s.query:d,p=s.hasOwnProperty("hash")?s.hash:p,m=s.hasOwnProperty("params")?s.params:m,c){o[c];return a({_normalized:!0,name:c,query:d,hash:p,params:m},void 0,t)}if(u){var h=function(n,e){return wo(n,e.parent?e.parent.path:"/",!0)}(u,n);return a({_normalized:!0,path:Mo(h,m),query:d,hash:p},void 0,t)}return l(null,t)}function l(n,t,i){return n&&n.redirect?s(n,i||t):n&&n.matchAs?function(n,e,t){var i=a({_normalized:!0,path:Mo(t,e.params)});if(i){var r=i.matched,o=r[r.length-1];return e.params=i.params,l(o,e)}return l(null,e)}(0,t,n.matchAs):po(n,t,i,e)}return{match:a,addRoute:function(n,e){var t="object"!=typeof n?o[n]:void 0;Wo([e||n],i,r,o,t),t&&t.alias.length&&Wo(t.alias.map((function(n){return{path:n,children:[e]}})),i,r,o,t)},getRoutes:function(){return i.map((function(n){return r[n]}))},addRoutes:function(n){Wo(n,i,r,o)}}}function Zo(n,e,t){var i=e.match(n);if(!i)return!1;if(!t)return!0;for(var r=1,o=i.length;r<o;++r){var a=n.keys[r-1];a&&(t[a.name||"pathMatch"]="string"==typeof i[r]?ao(i[r]):i[r])}return!0}var Xo=Jo&&window.performance&&window.performance.now?window.performance:Date;function Yo(){return Xo.now().toFixed(3)}var na=Yo();function ea(){return na}function ta(n){return na=n}var ia=Object.create(null);function ra(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=eo({},window.history.state);return t.key=ea(),window.history.replaceState(t,"",e),window.addEventListener("popstate",sa),function(){window.removeEventListener("popstate",sa)}}function oa(n,e,t,i){if(n.app){var r=n.options.scrollBehavior;r&&n.app.$nextTick((function(){var o=function(){var n=ea();if(n)return ia[n]}(),a=r.call(n,e,t,i?o:null);a&&("function"==typeof a.then?a.then((function(n){pa(n,o)})).catch((function(n){0})):pa(a,o))}))}}function aa(){var n=ea();n&&(ia[n]={x:window.pageXOffset,y:window.pageYOffset})}function sa(n){aa(),n.state&&n.state.key&&ta(n.state.key)}function la(n){return ua(n.x)||ua(n.y)}function ca(n){return{x:ua(n.x)?n.x:window.pageXOffset,y:ua(n.y)?n.y:window.pageYOffset}}function ua(n){return"number"==typeof n}var da=/^#\d/;function pa(n,e){var t,i="object"==typeof n;if(i&&"string"==typeof n.selector){var r=da.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(r){var o=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),i=n.getBoundingClientRect();return{x:i.left-t.left-e.x,y:i.top-t.top-e.y}}(r,o={x:ua((t=o).x)?t.x:0,y:ua(t.y)?t.y:0})}else la(n)&&(e=ca(n))}else i&&la(n)&&(e=ca(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var ma,ha=Jo&&((-1===(ma=window.navigator.userAgent).indexOf("Android 2.")&&-1===ma.indexOf("Android 4.0")||-1===ma.indexOf("Mobile Safari")||-1!==ma.indexOf("Chrome")||-1!==ma.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function fa(n,e){aa();var t=window.history;try{if(e){var i=eo({},t.state);i.key=ea(),t.replaceState(i,"",n)}else t.pushState({key:ta(Yo())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function ga(n){fa(n,!0)}var va={redirected:2,aborted:4,cancelled:8,duplicated:16};function ba(n,e){return ya(n,e,va.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return ka.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function xa(n,e){return ya(n,e,va.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function ya(n,e,t,i){var r=new Error(i);return r._isRouter=!0,r.from=n,r.to=e,r.type=t,r}var ka=["params","query","hash"];function wa(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function _a(n,e){return wa(n)&&n._isRouter&&(null==e||n.type===e)}function Ea(n,e,t){var i=function(r){r>=n.length?t():n[r]?e(n[r],(function(){i(r+1)})):i(r+1)};i(0)}function ja(n){return function(e,t,i){var r=!1,o=0,a=null;Ta(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){r=!0,o++;var l,c=Ca((function(e){var r;((r=e).__esModule||Aa&&"Module"===r[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Uo.extend(e),t.components[s]=e,--o<=0&&i()})),u=Ca((function(n){var e="Failed to resolve async component "+s+": "+n;a||(a=wa(n)?n:new Error(e),i(a))}));try{l=n(c,u)}catch(n){u(n)}if(l)if("function"==typeof l.then)l.then(c,u);else{var d=l.component;d&&"function"==typeof d.then&&d.then(c,u)}}})),r||i()}}function Ta(n,e){return Sa(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Sa(n){return Array.prototype.concat.apply([],n)}var Aa="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Ca(n){var e=!1;return function(){for(var t=[],i=arguments.length;i--;)t[i]=arguments[i];if(!e)return e=!0,n.apply(this,t)}}var Pa=function(n,e){this.router=n,this.base=function(n){if(!n)if(Jo){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=ho,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Ia(n,e,t,i){var r=Ta(n,(function(n,i,r,o){var a=function(n,e){"function"!=typeof n&&(n=Uo.extend(n));return n.options[e]}(n,e);if(a)return Array.isArray(a)?a.map((function(n){return t(n,i,r,o)})):t(a,i,r,o)}));return Sa(i?r.reverse():r)}function za(n,e){if(e)return function(){return n.apply(e,arguments)}}Pa.prototype.listen=function(n){this.cb=n},Pa.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Pa.prototype.onError=function(n){this.errorCbs.push(n)},Pa.prototype.transitionTo=function(n,e,t){var i,r=this;try{i=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var o=this.current;this.confirmTransition(i,(function(){r.updateRoute(i),e&&e(i),r.ensureURL(),r.router.afterHooks.forEach((function(n){n&&n(i,o)})),r.ready||(r.ready=!0,r.readyCbs.forEach((function(n){n(i)})))}),(function(n){t&&t(n),n&&!r.ready&&(_a(n,va.redirected)&&o===ho||(r.ready=!0,r.readyErrorCbs.forEach((function(e){e(n)}))))}))},Pa.prototype.confirmTransition=function(n,e,t){var i=this,r=this.current;this.pending=n;var o,a,s=function(n){!_a(n)&&wa(n)&&(i.errorCbs.length?i.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=r.matched.length-1;if(vo(n,r)&&l===c&&n.matched[l]===r.matched[c])return this.ensureURL(),n.hash&&oa(this.router,r,n,!1),s(((a=ya(o=r,n,va.duplicated,'Avoided redundant navigation to current location: "'+o.fullPath+'".')).name="NavigationDuplicated",a));var u=function(n,e){var t,i=Math.max(n.length,e.length);for(t=0;t<i&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),d=u.updated,p=u.deactivated,m=u.activated,h=[].concat(function(n){return Ia(n,"beforeRouteLeave",za,!0)}(p),this.router.beforeHooks,function(n){return Ia(n,"beforeRouteUpdate",za)}(d),m.map((function(n){return n.beforeEnter})),ja(m)),f=function(e,t){if(i.pending!==n)return s(xa(r,n));try{e(n,r,(function(e){!1===e?(i.ensureURL(!0),s(function(n,e){return ya(n,e,va.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(r,n))):wa(e)?(i.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(ba(r,n)),"object"==typeof e&&e.replace?i.replace(e):i.push(e)):t(e)}))}catch(n){s(n)}};Ea(h,f,(function(){Ea(function(n){return Ia(n,"beforeRouteEnter",(function(n,e,t,i){return function(n,e,t){return function(i,r,o){return n(i,r,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),o(n)}))}}(n,t,i)}))}(m).concat(i.router.resolveHooks),f,(function(){if(i.pending!==n)return s(xa(r,n));i.pending=null,e(n),i.router.app&&i.router.app.$nextTick((function(){xo(n)}))}))}))},Pa.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Pa.prototype.setupListeners=function(){},Pa.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=ho,this.pending=null};var Ba=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Da(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,i=ha&&t;i&&this.listeners.push(ra());var r=function(){var t=n.current,r=Da(n.base);n.current===ho&&r===n._startLocation||n.transitionTo(r,(function(n){i&&oa(e,n,t,!0)}))};window.addEventListener("popstate",r),this.listeners.push((function(){window.removeEventListener("popstate",r)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var i=this,r=this.current;this.transitionTo(n,(function(n){fa(_o(i.base+n.fullPath)),oa(i.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var i=this,r=this.current;this.transitionTo(n,(function(n){ga(_o(i.base+n.fullPath)),oa(i.router,n,r,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Da(this.base)!==this.current.fullPath){var e=_o(this.base+this.current.fullPath);n?fa(e):ga(e)}},e.prototype.getCurrentLocation=function(){return Da(this.base)},e}(Pa);function Da(n){var e=window.location.pathname,t=e.toLowerCase(),i=n.toLowerCase();return!n||t!==i&&0!==t.indexOf(_o(i+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var La=function(n){function e(e,t,i){n.call(this,e,t),i&&function(n){var e=Da(n);if(!/^\/#/.test(e))return window.location.replace(_o(n+"/#"+e)),!0}(this.base)||$a()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=ha&&e;t&&this.listeners.push(ra());var i=function(){var e=n.current;$a()&&n.transitionTo(Oa(),(function(i){t&&oa(n.router,i,e,!0),ha||Na(i.fullPath)}))},r=ha?"popstate":"hashchange";window.addEventListener(r,i),this.listeners.push((function(){window.removeEventListener(r,i)}))}},e.prototype.push=function(n,e,t){var i=this,r=this.current;this.transitionTo(n,(function(n){qa(n.fullPath),oa(i.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var i=this,r=this.current;this.transitionTo(n,(function(n){Na(n.fullPath),oa(i.router,n,r,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Oa()!==e&&(n?qa(e):Na(e))},e.prototype.getCurrentLocation=function(){return Oa()},e}(Pa);function $a(){var n=Oa();return"/"===n.charAt(0)||(Na("/"+n),!1)}function Oa(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Ga(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function qa(n){ha?fa(Ga(n)):window.location.hash=n}function Na(n){ha?ga(Ga(n)):window.location.replace(Ga(n))}var Ma=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var i=this;this.transitionTo(n,(function(n){i.stack=i.stack.slice(0,i.index+1).concat(n),i.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var i=this;this.transitionTo(n,(function(n){i.stack=i.stack.slice(0,i.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var i=this.stack[t];this.confirmTransition(i,(function(){var n=e.current;e.index=t,e.updateRoute(i),e.router.afterHooks.forEach((function(e){e&&e(i,n)}))}),(function(n){_a(n,va.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Pa),Fa=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Qo(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!ha&&!1!==n.fallback,this.fallback&&(e="hash"),Jo||(e="abstract"),this.mode=e,e){case"history":this.history=new Ba(this,n.base);break;case"hash":this.history=new La(this,n.base,this.fallback);break;case"abstract":this.history=new Ma(this,n.base);break;default:0}},Ua={currentRoute:{configurable:!0}};Fa.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Ua.currentRoute.get=function(){return this.history&&this.history.current},Fa.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Ba||t instanceof La){var i=function(n){t.setupListeners(),function(n){var i=t.current,r=e.options.scrollBehavior;ha&&r&&"fullPath"in n&&oa(e,n,i,!1)}(n)};t.transitionTo(t.getCurrentLocation(),i,i)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Fa.prototype.beforeEach=function(n){return Ha(this.beforeHooks,n)},Fa.prototype.beforeResolve=function(n){return Ha(this.resolveHooks,n)},Fa.prototype.afterEach=function(n){return Ha(this.afterHooks,n)},Fa.prototype.onReady=function(n,e){this.history.onReady(n,e)},Fa.prototype.onError=function(n){this.history.onError(n)},Fa.prototype.push=function(n,e,t){var i=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){i.history.push(n,e,t)}));this.history.push(n,e,t)},Fa.prototype.replace=function(n,e,t){var i=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){i.history.replace(n,e,t)}));this.history.replace(n,e,t)},Fa.prototype.go=function(n){this.history.go(n)},Fa.prototype.back=function(){this.go(-1)},Fa.prototype.forward=function(){this.go(1)},Fa.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Fa.prototype.resolve=function(n,e,t){var i=Fo(n,e=e||this.history.current,t,this),r=this.match(i,e),o=r.redirectedFrom||r.fullPath;return{location:i,route:r,href:function(n,e,t){var i="hash"===t?"#"+e:e;return n?_o(n+"/"+i):i}(this.history.base,o,this.mode),normalizedTo:i,resolved:r}},Fa.prototype.getRoutes=function(){return this.matcher.getRoutes()},Fa.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==ho&&this.history.transitionTo(this.history.getCurrentLocation())},Fa.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==ho&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Fa.prototype,Ua);var Ra=Fa;function Ha(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Fa.install=function n(e){if(!n.installed||Uo!==e){n.installed=!0,Uo=e;var t=function(n){return void 0!==n},i=function(n,e){var i=n.$options._parentVnode;t(i)&&t(i=i.data)&&t(i=i.registerRouteInstance)&&i(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,i(this,this)},destroyed:function(){i(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",yo),e.component("RouterLink",Ho);var r=e.config.optionMergeStrategies;r.beforeRouteEnter=r.beforeRouteLeave=r.beforeRouteUpdate=r.created}},Fa.version="3.6.5",Fa.isNavigationFailure=_a,Fa.NavigationFailureType=va,Fa.START_LOCATION=ho,Jo&&window.Vue&&window.Vue.use(Fa);t(111);t(17),t(136);var Va={"components/AlgoliaSearchBox":()=>Promise.all([t.e(0),t.e(14)]).then(t.bind(null,390)),"components/ArchivesPage":()=>Promise.all([t.e(0),t.e(17)]).then(t.bind(null,344)),"components/ArticleInfo":()=>Promise.all([t.e(0),t.e(21)]).then(t.bind(null,345)),"components/BloggerBar":()=>Promise.all([t.e(0),t.e(22)]).then(t.bind(null,346)),"components/BodyBgImg":()=>Promise.all([t.e(0),t.e(23)]).then(t.bind(null,347)),"components/Buttons":()=>Promise.all([t.e(0),t.e(18)]).then(t.bind(null,348)),"components/Catalogue":()=>Promise.all([t.e(0),t.e(24)]).then(t.bind(null,349)),"components/CategoriesBar":()=>Promise.all([t.e(0),t.e(25)]).then(t.bind(null,308)),"components/CategoriesPage":()=>Promise.all([t.e(0),t.e(11)]).then(t.bind(null,350)),"components/DropdownLink":()=>Promise.all([t.e(0),t.e(15)]).then(t.bind(null,286)),"components/DropdownTransition":()=>Promise.all([t.e(0),t.e(26)]).then(t.bind(null,264)),"components/Footer":()=>Promise.all([t.e(0),t.e(27)]).then(t.bind(null,351)),"components/Home":()=>Promise.all([t.e(0),t.e(2),t.e(37)]).then(t.bind(null,378)),"components/MainLayout":()=>Promise.all([t.e(0),t.e(28)]).then(t.bind(null,278)),"components/NavLink":()=>t.e(38).then(t.bind(null,263)),"components/NavLinks":()=>Promise.all([t.e(0),t.e(13)]).then(t.bind(null,310)),"components/Navbar":()=>Promise.all([t.e(0),t.e(1)]).then(t.bind(null,377)),"components/Page":()=>Promise.all([t.e(0),t.e(3),t.e(35)]).then(t.bind(null,379)),"components/PageEdit":()=>Promise.all([t.e(0),t.e(19)]).then(t.bind(null,352)),"components/PageNav":()=>Promise.all([t.e(0),t.e(16)]).then(t.bind(null,353)),"components/Pagination":()=>Promise.all([t.e(0),t.e(29)]).then(t.bind(null,277)),"components/PostList":()=>Promise.all([t.e(0),t.e(30)]).then(t.bind(null,276)),"components/RightMenu":()=>Promise.all([t.e(0),t.e(31)]).then(t.bind(null,354)),"components/Sidebar":()=>Promise.all([t.e(0),t.e(10)]).then(t.bind(null,355)),"components/SidebarButton":()=>Promise.all([t.e(0),t.e(32)]).then(t.bind(null,357)),"components/SidebarGroup":()=>Promise.all([t.e(0),t.e(5)]).then(t.bind(null,311)),"components/SidebarLink":()=>Promise.all([t.e(0),t.e(33)]).then(t.bind(null,287)),"components/SidebarLinks":()=>Promise.all([t.e(0),t.e(5)]).then(t.bind(null,284)),"components/TagsBar":()=>Promise.all([t.e(0),t.e(34)]).then(t.bind(null,309)),"components/TagsPage":()=>Promise.all([t.e(0),t.e(12)]).then(t.bind(null,356)),"components/UpdateArticle":()=>Promise.all([t.e(0),t.e(36)]).then(t.bind(null,314)),"global-components/Badge":()=>Promise.all([t.e(0),t.e(6)]).then(t.bind(null,394)),"global-components/CodeBlock":()=>Promise.resolve().then(t.bind(null,99)),"global-components/CodeGroup":()=>Promise.resolve().then(t.bind(null,100)),"layouts/404":()=>Promise.all([t.e(0),t.e(7)]).then(t.bind(null,391)),"layouts/Layout":()=>Promise.all([t.e(0),t.e(1),t.e(2),t.e(3),t.e(4)]).then(t.bind(null,392)),NotFound:()=>Promise.all([t.e(0),t.e(7)]).then(t.bind(null,391)),Layout:()=>Promise.all([t.e(0),t.e(1),t.e(2),t.e(3),t.e(4)]).then(t.bind(null,392))},Ja={"v-3c5cb278":()=>t.e(40).then(t.bind(null,395)),"v-16a9958e":()=>t.e(41).then(t.bind(null,396)),"v-1139bec1":()=>t.e(42).then(t.bind(null,397)),"v-e6d91580":()=>t.e(43).then(t.bind(null,398)),"v-5df34b59":()=>t.e(44).then(t.bind(null,399)),"v-0c3eb4e8":()=>t.e(45).then(t.bind(null,400)),"v-aa898bb4":()=>t.e(46).then(t.bind(null,401)),"v-1e46750d":()=>t.e(47).then(t.bind(null,402)),"v-ccee1a68":()=>t.e(48).then(t.bind(null,403)),"v-48703727":()=>t.e(49).then(t.bind(null,404)),"v-288e6001":()=>t.e(50).then(t.bind(null,405)),"v-a45883c2":()=>t.e(52).then(t.bind(null,406)),"v-bd714042":()=>t.e(53).then(t.bind(null,407)),"v-f15f1ada":()=>t.e(51).then(t.bind(null,408)),"v-6668a861":()=>t.e(54).then(t.bind(null,409)),"v-dd6d37e4":()=>t.e(39).then(t.bind(null,410)),"v-1f12d3c2":()=>t.e(56).then(t.bind(null,411)),"v-0dd17318":()=>t.e(57).then(t.bind(null,412)),"v-466444aa":()=>t.e(58).then(t.bind(null,413)),"v-3f115c5a":()=>t.e(59).then(t.bind(null,414)),"v-486047ee":()=>t.e(60).then(t.bind(null,415)),"v-0295a8c0":()=>t.e(62).then(t.bind(null,416)),"v-319af327":()=>t.e(63).then(t.bind(null,417)),"v-ecc968b6":()=>t.e(66).then(t.bind(null,418)),"v-1bc814a4":()=>t.e(65).then(t.bind(null,419)),"v-0d1f7517":()=>t.e(64).then(t.bind(null,420)),"v-45eaf67a":()=>t.e(67).then(t.bind(null,421)),"v-7f8094fc":()=>t.e(68).then(t.bind(null,422)),"v-7cd58e9b":()=>t.e(69).then(t.bind(null,423)),"v-0cf5f5ce":()=>t.e(70).then(t.bind(null,424)),"v-0bc1b9b4":()=>t.e(72).then(t.bind(null,425)),"v-79e3d1ae":()=>t.e(73).then(t.bind(null,426)),"v-c3099e10":()=>t.e(71).then(t.bind(null,427)),"v-0373c099":()=>t.e(74).then(t.bind(null,428)),"v-4dbea03d":()=>t.e(76).then(t.bind(null,429)),"v-a521f62a":()=>t.e(75).then(t.bind(null,430)),"v-f177b3e6":()=>t.e(77).then(t.bind(null,431)),"v-527901ce":()=>t.e(79).then(t.bind(null,432)),"v-4a7c7cef":()=>t.e(78).then(t.bind(null,433)),"v-49e30f62":()=>t.e(61).then(t.bind(null,434)),"v-cecf59c6":()=>t.e(81).then(t.bind(null,435)),"v-1f62b379":()=>t.e(83).then(t.bind(null,436)),"v-ab6c5552":()=>t.e(82).then(t.bind(null,437)),"v-66f80783":()=>t.e(84).then(t.bind(null,438)),"v-66f28a6e":()=>t.e(86).then(t.bind(null,439)),"v-39ec134c":()=>t.e(85).then(t.bind(null,440)),"v-1081ce44":()=>t.e(87).then(t.bind(null,441)),"v-857b513e":()=>t.e(89).then(t.bind(null,442)),"v-49401e23":()=>t.e(88).then(t.bind(null,443)),"v-7f5cbb59":()=>t.e(90).then(t.bind(null,444)),"v-28760263":()=>t.e(91).then(t.bind(null,445)),"v-4aec2599":()=>t.e(92).then(t.bind(null,446)),"v-e792ddf8":()=>t.e(93).then(t.bind(null,447)),"v-0b3ccae2":()=>t.e(94).then(t.bind(null,448)),"v-7f9d059f":()=>t.e(96).then(t.bind(null,449)),"v-38c4edfa":()=>t.e(95).then(t.bind(null,450)),"v-476ed16d":()=>t.e(97).then(t.bind(null,451)),"v-3a3276c2":()=>t.e(98).then(t.bind(null,452)),"v-279b57f8":()=>t.e(99).then(t.bind(null,453)),"v-0c700bb1":()=>t.e(100).then(t.bind(null,454)),"v-2472c4c6":()=>t.e(101).then(t.bind(null,455)),"v-1e268ac6":()=>t.e(103).then(t.bind(null,456)),"v-1a482803":()=>t.e(104).then(t.bind(null,457)),"v-59070e48":()=>t.e(105).then(t.bind(null,458)),"v-509f409b":()=>t.e(102).then(t.bind(null,459)),"v-6cf98a73":()=>t.e(106).then(t.bind(null,460)),"v-47fabeb6":()=>t.e(107).then(t.bind(null,461)),"v-4a02579b":()=>t.e(109).then(t.bind(null,462)),"v-30e085c9":()=>t.e(110).then(t.bind(null,463)),"v-3a888ae4":()=>t.e(108).then(t.bind(null,464)),"v-7587d3fc":()=>t.e(80).then(t.bind(null,465)),"v-1e09ee2b":()=>t.e(113).then(t.bind(null,466)),"v-6097fb0b":()=>t.e(112).then(t.bind(null,467)),"v-10f2e34e":()=>t.e(55).then(t.bind(null,468)),"v-3fce6544":()=>t.e(114).then(t.bind(null,469)),"v-0e8002ab":()=>t.e(111).then(t.bind(null,470))};function Wa(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Ka=/-(\w)/g,Qa=Wa(n=>n.replace(Ka,(n,e)=>e?e.toUpperCase():"")),Za=/\B([A-Z])/g,Xa=Wa(n=>n.replace(Za,"-$1").toLowerCase()),Ya=Wa(n=>n.charAt(0).toUpperCase()+n.slice(1));function ns(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Ya(Qa(e))):n(Ya(e))||n(Xa(e))}const es=Object.assign({},Va,Ja),ts=n=>es[n],is=n=>Ja[n],rs=n=>Va[n],os=n=>Vt.component(n);function as(n){return ns(is,n)}function ss(n){return ns(rs,n)}function ls(n){return ns(ts,n)}function cs(n){return ns(os,n)}function us(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!cs(n)&&ls(n)){const e=await ls(n)();Vt.component(n,e.default)}}))}function ds(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var ps=t(96),ms=t.n(ps),hs=t(97),fs=t.n(hs),gs={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${fs()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=bs(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=xs(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return ms()([{name:"description",content:this.$description}],n,this.siteMeta,ys)},updateCanonicalLink(){vs(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",bs(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){xs(null,this.currentMetaTags),vs()}};function vs(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function bs(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function xs(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function ys(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var ks=t(48),ws={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(ks)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),i=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),r=window.innerHeight+t;for(let n=0;n<e.length;n++){const o=e[n],a=e[n+1],s=0===n&&0===t||t>=o.parentElement.offsetTop+10&&(!a||t<a.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(o.hash)){const t=o;if(r===i)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},_s=t(26),Es=t.n(_s),js={mounted(){Es.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Vt.component(n.name)||Es.a.start(),t()}),this.$router.afterEach(()=>{Es.a.done(),this.isSidebarOpen=!1})}};t(244),t(245);class Ts{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var Ss={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new Ts).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var i=document.head||document.getElementsByTagName("head")[0],r=document.createElement("style");r.type="text/css","top"===t&&i.firstChild?i.insertBefore(r,i.firstChild):i.appendChild(r),r.styleSheet?r.styleSheet.cssText=n:r.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var As={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},Cs={},Ps=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},Is=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:As[n]},zs=function n(e,t,i){var r=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))r[n]=t[n];else{var e=n.replace("data","");r.dataset[e]=t[n]}})),i&&i.forEach((function(e){var t=e.tag,i=e.attrs,o=e.children;r.appendChild(n(t,i,o))})),r},Bs=function(n,e,t){var i,r=(i=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(i));return 1!==r.length||t?r:r[0]},Ds=function(n,e){var t,i,r=n.match(/<style>([\s\S]+)<\/style>/),o=n.match(/<template>([\s\S]+)<\/template>/),a=n.match(/<script>([\s\S]+)<\/script>/),s={css:r&&r[1].replace(/^\n|\n$/g,""),html:o&&o[1].replace(/^\n|\n$/g,""),js:a&&a[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=Ps(s.html),s.jsTpl=(t=s.js,i=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(i,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),i="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),r=window.Babel?window.Babel.transform(i,{presets:["es2015"]}).code:i,o=[eval][0](r);return o.template=e,o}(s.js,s.html);var l=Is("vue");return s.jsLib.unshift(l),s},Ls=function(n,e){var t,i=n.match(/<style>([\s\S]+)<\/style>/),r=n.match(/<html>([\s\S]+)<\/html>/),o=n.match(/<script>([\s\S]+)<\/script>/),a={css:i&&i[1].replace(/^\n|\n$/g,""),html:r&&r[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return a.htmlTpl=a.html,a.jsTpl=a.js,a.script=(t=a.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),a},$s=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Os(){var n=Bs(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=Bs(n,"vuepress-plugin-demo-block__code"),t=Bs(n,"vuepress-plugin-demo-block__display"),i=Bs(n,"vuepress-plugin-demo-block__footer"),r=Bs(t,"vuepress-plugin-demo-block__app"),o=decodeURIComponent(n.dataset.code),a=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);a=a?JSON.parse(a):{};var l=e.querySelector("div").clientHeight,c="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,i="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),r=new Function("return ".concat(i))(),o={js:r,css:r.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:$s(n),htmlTpl:Ps("")},a=Is("react"),s=Is("reactDOM");return o.jsLib.unshift(a,s),o}(o,a):"vanilla"===s?Ls(o,a):Ds(o,a),u=zs("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(i.appendChild(u),u.addEventListener("click",Gs.bind(null,u,l,e,i)),Is("jsfiddle")&&i.appendChild(function(n){var e=n.css,t=n.htmlTpl,i=n.jsTpl,r=n.jsLib,o=n.cssLib,a=r.concat(o).concat(Is("cssLib")).concat(Is("jsLib")).join(",");return zs("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:i}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:a}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),Is("codepen")&&i.appendChild(function(n){var e=n.css,t=n.htmlTpl,i=n.jsTpl,r=n.jsLib,o=n.cssLib,a=JSON.stringify({css:e,html:t,js:i,js_external:r.concat(Is("jsLib")).join(";"),css_external:o.concat(Is("cssLib")).join(";"),layout:Is("codepenLayout"),js_pre_processor:Is("codepenJsProcessor"),editors:Is("codepenEditors")});return zs("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:a}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==a.horizontal?a.horizontal:Is("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var d=e.firstChild.cloneNode(!0);d.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(d)}if(c.css&&function(n){if(!Cs[n]){var e=zs("style",{innerHTML:n});document.body.appendChild(e),Cs[n]=!0}}(c.css),"react"===s)ReactDOM.render(React.createElement(c.js),r);else if("vue"===s){var p=(new(Vue.extend(c.script))).$mount();r.appendChild(p.$el)}else"vanilla"===s&&(r.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Os()}),300)}function Gs(n,e,t,i){var r="1"!==n.dataset.isExpand;t.style.height=r?"".concat(e,"px"):0,r?i.classList.add("vuepress-plugin-demo-block__show-link"):i.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=r?"1":"0"}var qs={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Os()},updated:function(){Os()}},Ns="auto",Ms="zoom-in",Fs="zoom-out",Us="grab",Rs="move";function Hs(n,e,t){var i=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r={passive:!1};i?n.addEventListener(e,t,r):n.removeEventListener(e,t,r)}function Vs(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Js(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Ws(n,e,t){!function(n){var e=Ks,t=Qs;if(n.transition){var i=n.transition;delete n.transition,n[e]=i}if(n.transform){var r=n.transform;delete n.transform,n[t]=r}}(e);var i=n.style,r={};for(var o in e)t&&(r[o]=i[o]||""),i[o]=e[o];return r}var Ks="transition",Qs="transform",Zs="transform",Xs="transitionend";var Ys=function(){},nl={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Ys,onClose:Ys,onGrab:Ys,onMove:Ys,onRelease:Ys,onBeforeOpen:Ys,onBeforeClose:Ys,onBeforeGrab:Ys,onBeforeRelease:Ys,onImageLoading:Ys,onImageLoaded:Ys},el={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),il(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var i=this.lastScrollPosition.x-e,r=this.lastScrollPosition.y-t,o=this.options.scrollThreshold;(Math.abs(r)>=o||Math.abs(i)>=o)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(tl(n)&&!il(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){tl(n)&&!il(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,i=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,i)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,i=e.clientY;this.move(t,i)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function tl(n){return 0===n.button}function il(n){return n.metaKey||n.ctrlKey}var rl={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Ws(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Hs(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Ws(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},ol="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},al=function(){function n(n,e){for(var t=0;t<e.length;t++){var i=e[t];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(n,i.key,i)}}return function(e,t,i){return t&&n(e.prototype,t),i&&n(e,i),e}}(),sl=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(n[i]=t[i])}return n},ll={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Js(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,i=n.transitionDuration,r=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Us:Fs,transition:Zs+"\n        "+i+"s\n        "+r,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Ws(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Ws(this.el,{transform:"none"})},grab:function(n,e,t){var i=cl(),r=i.x-n,o=i.y-e;Ws(this.el,{cursor:Rs,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var i=cl(),r=i.x-n,o=i.y-e;Ws(this.el,{transition:Zs,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Ws(this.el,this.styleClose)},restoreOpenStyle:function(){Ws(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=cl(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,i=this.instance.options,r=i.customSize,o=i.scaleBase;if(!r&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(r&&"object"===(void 0===r?"undefined":ol(r)))return{x:r.width/this.rect.width,y:r.height/this.rect.height};var a=this.rect.width/2,s=this.rect.height/2,l=cl(),c={x:l.x-a,y:l.y-s},u=c.x/a,d=c.y/s,p=o+Math.min(u,d);if(r&&"string"==typeof r){var m=t||this.el.naturalWidth,h=e||this.el.naturalHeight,f=parseFloat(r)*m/(100*this.rect.width),g=parseFloat(r)*h/(100*this.rect.height);if(p>f||p>g)return{x:f,y:g}}return{x:p,y:p}}};function cl(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function ul(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(i){Hs(n,i,e[i],t)}))}var dl=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(ll),this.overlay=Object.create(rl),this.handler=Object.create(el),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=sl({},nl,e),this.overlay.init(this),this.handler.init(this)}return al(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Ms,Hs(n,"click",this.handler.click),this.options.preloadImage&&Vs(Js(n)));return this}},{key:"config",value:function(n){return n?(sl(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var i="string"==typeof n?document.querySelector(n):n;if("IMG"===i.tagName){if(this.options.onBeforeOpen(i),this.target.init(i,this),!this.options.preloadImage){var r=this.target.srcOriginal;null!=r&&(this.options.onImageLoading(i),Vs(r,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Hs(document,"scroll",this.handler.scroll),Hs(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Hs(window,"resize",this.handler.resizeWindow);var o=function n(){Hs(i,Xs,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&ul(document,e.handler,!0),t(i)};return Hs(i,Xs,o),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Ns,this.overlay.fadeOut(),this.target.zoomOut(),Hs(document,"scroll",this.handler.scroll,!1),Hs(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Hs(window,"resize",this.handler.resizeWindow,!1);var i=function i(){Hs(t,Xs,i,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&ul(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Hs(t,Xs,i),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var r=this.target.el;this.options.onBeforeGrab(r),this.released=!1,this.target.grab(n,e,t);var o=function n(){Hs(r,Xs,n,!1),i(r)};return Hs(r,Xs,o),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Rs,this.target.move(n,e,t);var r=this.target.el,o=function n(){Hs(r,Xs,n,!1),i(r)};return Hs(r,Xs,o),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Ns,this.target.restoreOpenStyle();var i=function i(){Hs(t,Xs,i,!1),n.lock=!1,n.released=!0,e(t)};return Hs(t,Xs,i),this}}}]),n}();const pl=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),ml=Number("500");class hl{constructor(){this.instance=new dl(pl)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=ml){setTimeout(()=>this.update(n),e)}}var fl=[gs,ws,js,Ss,qs,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new hl,this.$vuepress.zooming.updateDelay()}}],gl={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return ds("layout",n),Vt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},vl=t(0),bl=Object(vl.a)(gl,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(bl,"mixins",fl);const xl=[{name:"v-3c5cb278",path:"/develop/framework/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-3c5cb278").then(t)}},{path:"/develop/framework/index.html",redirect:"/develop/framework/"},{path:"/00.目录页/01.sub02.开发框架.html",redirect:"/develop/framework/"},{name:"v-16a9958e",path:"/develop/algorithm/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-16a9958e").then(t)}},{path:"/develop/algorithm/index.html",redirect:"/develop/algorithm/"},{path:"/00.目录页/01.sub03.数据结构与算法.html",redirect:"/develop/algorithm/"},{name:"v-1139bec1",path:"/develop/storage/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-1139bec1").then(t)}},{path:"/develop/storage/index.html",redirect:"/develop/storage/"},{path:"/00.目录页/01.sub04.数据存储.html",redirect:"/develop/storage/"},{name:"v-e6d91580",path:"/develop/system/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-e6d91580").then(t)}},{path:"/develop/system/index.html",redirect:"/develop/system/"},{path:"/00.目录页/01.sub05.系统架构.html",redirect:"/develop/system/"},{name:"v-5df34b59",path:"/develop/network/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-5df34b59").then(t)}},{path:"/develop/network/index.html",redirect:"/develop/network/"},{path:"/00.目录页/01.sub06.计算机网络.html",redirect:"/develop/network/"},{name:"v-0c3eb4e8",path:"/develop/cloud/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-0c3eb4e8").then(t)}},{path:"/develop/cloud/index.html",redirect:"/develop/cloud/"},{path:"/00.目录页/01.sub07.云原生.html",redirect:"/develop/cloud/"},{name:"v-aa898bb4",path:"/develop/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-aa898bb4").then(t)}},{path:"/develop/index.html",redirect:"/develop/"},{path:"/00.目录页/01.开发.html",redirect:"/develop/"},{name:"v-1e46750d",path:"/tool/vcs/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-1e46750d").then(t)}},{path:"/tool/vcs/index.html",redirect:"/tool/vcs/"},{path:"/00.目录页/02.sub01版本控制.html",redirect:"/tool/vcs/"},{name:"v-ccee1a68",path:"/tool/network/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-ccee1a68").then(t)}},{path:"/tool/network/index.html",redirect:"/tool/network/"},{path:"/00.目录页/02.sub02网络工具.html",redirect:"/tool/network/"},{name:"v-48703727",path:"/tool/develop/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-48703727").then(t)}},{path:"/tool/develop/index.html",redirect:"/tool/develop/"},{path:"/00.目录页/02.sub03.开发工具.html",redirect:"/tool/develop/"},{name:"v-288e6001",path:"/tool/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-288e6001").then(t)}},{path:"/tool/index.html",redirect:"/tool/"},{path:"/00.目录页/02.工具.html",redirect:"/tool/"},{name:"v-a45883c2",path:"/note/project/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-a45883c2").then(t)}},{path:"/note/project/index.html",redirect:"/note/project/"},{path:"/00.目录页/03.sub02.实践项目.html",redirect:"/note/project/"},{name:"v-bd714042",path:"/note/lecture/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-bd714042").then(t)}},{path:"/note/lecture/index.html",redirect:"/note/lecture/"},{path:"/00.目录页/03.sub03.讲座研讨.html",redirect:"/note/lecture/"},{name:"v-f15f1ada",path:"/note/paper/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-f15f1ada").then(t)}},{path:"/note/paper/index.html",redirect:"/note/paper/"},{path:"/00.目录页/03.sub01.学术搬砖.html",redirect:"/note/paper/"},{name:"v-6668a861",path:"/note/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-6668a861").then(t)}},{path:"/note/index.html",redirect:"/note/"},{path:"/00.目录页/03.学习笔记.html",redirect:"/note/"},{name:"v-dd6d37e4",path:"/develop/language/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-dd6d37e4").then(t)}},{path:"/develop/language/index.html",redirect:"/develop/language/"},{path:"/00.目录页/01.sub01.编程语言.html",redirect:"/develop/language/"},{name:"v-1f12d3c2",path:"/life/youth/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-1f12d3c2").then(t)}},{path:"/life/youth/index.html",redirect:"/life/youth/"},{path:"/00.目录页/04.sub02.追忆青春.html",redirect:"/life/youth/"},{name:"v-0dd17318",path:"/life/travel/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-0dd17318").then(t)}},{path:"/life/travel/index.html",redirect:"/life/travel/"},{path:"/00.目录页/04.sub03.旅行日记.html",redirect:"/life/travel/"},{name:"v-466444aa",path:"/life/art/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-466444aa").then(t)}},{path:"/life/art/index.html",redirect:"/life/art/"},{path:"/00.目录页/04.sub04.文艺时光.html",redirect:"/life/art/"},{name:"v-3f115c5a",path:"/life/cook/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-3f115c5a").then(t)}},{path:"/life/cook/index.html",redirect:"/life/cook/"},{path:"/00.目录页/04.sub05.烹调分享.html",redirect:"/life/cook/"},{name:"v-486047ee",path:"/life/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-486047ee").then(t)}},{path:"/life/index.html",redirect:"/life/"},{path:"/00.目录页/04.生活杂谈.html",redirect:"/life/"},{name:"v-0295a8c0",path:"/resource/project/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-0295a8c0").then(t)}},{path:"/resource/project/index.html",redirect:"/resource/project/"},{path:"/00.目录页/05.sub02优秀项目.html",redirect:"/resource/project/"},{name:"v-319af327",path:"/resource/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-319af327").then(t)}},{path:"/resource/index.html",redirect:"/resource/"},{path:"/00.目录页/05.资源收藏.html",redirect:"/resource/"},{name:"v-ecc968b6",path:"/more/blog/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-ecc968b6").then(t)}},{path:"/more/blog/index.html",redirect:"/more/blog/"},{path:"/00.目录页/06.sub03.博客相关.html",redirect:"/more/blog/"},{name:"v-1bc814a4",path:"/more/tip/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-1bc814a4").then(t)}},{path:"/more/tip/index.html",redirect:"/more/tip/"},{path:"/00.目录页/06.sub02.实用技巧.html",redirect:"/more/tip/"},{name:"v-0d1f7517",path:"/more/interview/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-0d1f7517").then(t)}},{path:"/more/interview/index.html",redirect:"/more/interview/"},{path:"/00.目录页/06.sub01.面试.html",redirect:"/more/interview/"},{name:"v-45eaf67a",path:"/more/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-45eaf67a").then(t)}},{path:"/more/index.html",redirect:"/more/"},{path:"/00.目录页/06.更多.html",redirect:"/more/"},{name:"v-7f8094fc",path:"/pages/03e0a8/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-7f8094fc").then(t)}},{path:"/pages/03e0a8/index.html",redirect:"/pages/03e0a8/"},{path:"/01.开发/02.开发框架/01.前端/01.Vite构建工具介绍.html",redirect:"/pages/03e0a8/"},{name:"v-7cd58e9b",path:"/pages/f4cb7a/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-7cd58e9b").then(t)}},{path:"/pages/f4cb7a/index.html",redirect:"/pages/f4cb7a/"},{path:"/01.开发/02.开发框架/03.设计模式/01.设计模式之工厂模式详解（Java实现）.html",redirect:"/pages/f4cb7a/"},{name:"v-0cf5f5ce",path:"/pages/04c857/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-0cf5f5ce").then(t)}},{path:"/pages/04c857/index.html",redirect:"/pages/04c857/"},{path:"/01.开发/02.开发框架/03.设计模式/02.设计模式之建造者模式详解（Java实现）.html",redirect:"/pages/04c857/"},{name:"v-0bc1b9b4",path:"/pages/a1ff4f/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-0bc1b9b4").then(t)}},{path:"/pages/a1ff4f/index.html",redirect:"/pages/a1ff4f/"},{path:"/01.开发/02.开发框架/03.设计模式/04.设计模式之单例模式详解（Java实现）.html",redirect:"/pages/a1ff4f/"},{name:"v-79e3d1ae",path:"/pages/2bc5dd/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-79e3d1ae").then(t)}},{path:"/pages/2bc5dd/index.html",redirect:"/pages/2bc5dd/"},{path:"/01.开发/02.开发框架/03.设计模式/05.设计模式之适配器模式详解（Java实现）.html",redirect:"/pages/2bc5dd/"},{name:"v-c3099e10",path:"/pages/2d97a5/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-c3099e10").then(t)}},{path:"/pages/2d97a5/index.html",redirect:"/pages/2d97a5/"},{path:"/01.开发/02.开发框架/03.设计模式/03.设计模式之原型模式详解（Java实现）.html",redirect:"/pages/2d97a5/"},{name:"v-0373c099",path:"/pages/aab372/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-0373c099").then(t)}},{path:"/pages/aab372/index.html",redirect:"/pages/aab372/"},{path:"/01.开发/02.开发框架/03.设计模式/06.设计模式之桥接模式详解（Java实现）.html",redirect:"/pages/aab372/"},{name:"v-4dbea03d",path:"/pages/c49acf/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-4dbea03d").then(t)}},{path:"/pages/c49acf/index.html",redirect:"/pages/c49acf/"},{path:"/01.开发/02.开发框架/03.设计模式/08.设计模式之装饰模式详解（Java实现）.html",redirect:"/pages/c49acf/"},{name:"v-a521f62a",path:"/pages/eac75e/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-a521f62a").then(t)}},{path:"/pages/eac75e/index.html",redirect:"/pages/eac75e/"},{path:"/01.开发/02.开发框架/03.设计模式/07.设计模式之组合模式详解（Java实现）.html",redirect:"/pages/eac75e/"},{name:"v-f177b3e6",path:"/pages/e40609/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-f177b3e6").then(t)}},{path:"/pages/e40609/index.html",redirect:"/pages/e40609/"},{path:"/01.开发/02.开发框架/03.设计模式/09.设计模式之外观模式详解（Java实现）.html",redirect:"/pages/e40609/"},{name:"v-527901ce",path:"/pages/31f81b/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-527901ce").then(t)}},{path:"/pages/31f81b/index.html",redirect:"/pages/31f81b/"},{path:"/01.开发/02.开发框架/03.设计模式/11.设计模式之命令模式详解（Java实现）.html",redirect:"/pages/31f81b/"},{name:"v-4a7c7cef",path:"/pages/933a7d/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-4a7c7cef").then(t)}},{path:"/pages/933a7d/index.html",redirect:"/pages/933a7d/"},{path:"/01.开发/02.开发框架/03.设计模式/10.设计模式之代理模式详解（Java实现）.html",redirect:"/pages/933a7d/"},{name:"v-49e30f62",path:"/resource/website/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-49e30f62").then(t)}},{path:"/resource/website/index.html",redirect:"/resource/website/"},{path:"/00.目录页/05.sub01实用网站.html",redirect:"/resource/website/"},{name:"v-cecf59c6",path:"/pages/b22ffc/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-cecf59c6").then(t)}},{path:"/pages/b22ffc/index.html",redirect:"/pages/b22ffc/"},{path:"/01.开发/02.开发框架/03.设计模式/13.设计模式之策略模式详解（Java）实现.html",redirect:"/pages/b22ffc/"},{name:"v-1f62b379",path:"/pages/71fd4b/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-1f62b379").then(t)}},{path:"/pages/71fd4b/index.html",redirect:"/pages/71fd4b/"},{path:"/01.开发/03.数据结构与算法/03.查找算法/01.二分查找.html",redirect:"/pages/71fd4b/"},{name:"v-ab6c5552",path:"/pages/2aa461/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-ab6c5552").then(t)}},{path:"/pages/2aa461/index.html",redirect:"/pages/2aa461/"},{path:"/01.开发/02.开发框架/03.设计模式/14.设计模式之模板方法模式详解（Java实现）.html",redirect:"/pages/2aa461/"},{name:"v-66f80783",path:"/pages/41f1cd/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-66f80783").then(t)}},{path:"/pages/41f1cd/index.html",redirect:"/pages/41f1cd/"},{path:"/01.开发/03.数据结构与算法/05.位运算/01.位运算全面总结.html",redirect:"/pages/41f1cd/"},{name:"v-66f28a6e",path:"/pages/243023/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-66f28a6e").then(t)}},{path:"/pages/243023/index.html",redirect:"/pages/243023/"},{path:"/01.开发/03.数据结构与算法/07.动态规划/01.数位DP.html",redirect:"/pages/243023/"},{name:"v-39ec134c",path:"/pages/088910/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-39ec134c").then(t)}},{path:"/pages/088910/index.html",redirect:"/pages/088910/"},{path:"/01.开发/03.数据结构与算法/06.数据结构/01.线段树入门.html",redirect:"/pages/088910/"},{name:"v-1081ce44",path:"/pages/671a5d/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-1081ce44").then(t)}},{path:"/pages/671a5d/index.html",redirect:"/pages/671a5d/"},{path:"/01.开发/03.数据结构与算法/07.动态规划/02.状压DP.html",redirect:"/pages/671a5d/"},{name:"v-857b513e",path:"/pages/3610c3/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-857b513e").then(t)}},{path:"/pages/3610c3/index.html",redirect:"/pages/3610c3/"},{path:"/01.开发/03.数据结构与算法/08.图算法/01.Floyd算法教程.html",redirect:"/pages/3610c3/"},{name:"v-49401e23",path:"/pages/243024/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-49401e23").then(t)}},{path:"/pages/243024/index.html",redirect:"/pages/243024/"},{path:"/01.开发/03.数据结构与算法/07.动态规划/03.HDU 4507 恨7不成妻 （数位DP套路题，详细解析）.html",redirect:"/pages/243024/"},{name:"v-7f5cbb59",path:"/pages/180ec0/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-7f5cbb59").then(t)}},{path:"/pages/180ec0/index.html",redirect:"/pages/180ec0/"},{path:"/01.开发/03.数据结构与算法/08.图算法/02.Dijkstra算法教程.html",redirect:"/pages/180ec0/"},{name:"v-28760263",path:"/pages/a97764/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-28760263").then(t)}},{path:"/pages/a97764/index.html",redirect:"/pages/a97764/"},{path:"/01.开发/03.数据结构与算法/08.图算法/03.Kruskal算法教程.html",redirect:"/pages/a97764/"},{name:"v-4aec2599",path:"/pages/affd0f/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-4aec2599").then(t)}},{path:"/pages/affd0f/index.html",redirect:"/pages/affd0f/"},{path:"/01.开发/03.数据结构与算法/08.图算法/04.Prim算法教程.html",redirect:"/pages/affd0f/"},{name:"v-e792ddf8",path:"/pages/d66bf9/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-e792ddf8").then(t)}},{path:"/pages/d66bf9/index.html",redirect:"/pages/d66bf9/"},{path:"/01.开发/05.系统架构/01.Linux/01.Linux常用命令、管道、环境变量.html",redirect:"/pages/d66bf9/"},{name:"v-0b3ccae2",path:"/pages/b04f81/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-0b3ccae2").then(t)}},{path:"/pages/b04f81/index.html",redirect:"/pages/b04f81/"},{path:"/01.开发/05.系统架构/01.Linux/02.Linux常用文件管理命令.html",redirect:"/pages/b04f81/"},{name:"v-7f9d059f",path:"/pages/12de46/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-7f9d059f").then(t)}},{path:"/pages/12de46/index.html",redirect:"/pages/12de46/"},{path:"/01.开发/07.云原生/01.容器化技术/01.Docker入门教程.html",redirect:"/pages/12de46/"},{name:"v-38c4edfa",path:"/pages/419777/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-38c4edfa").then(t)}},{path:"/pages/419777/index.html",redirect:"/pages/419777/"},{path:"/01.开发/05.系统架构/01.Linux/03.Linux用户和用户组教程.html",redirect:"/pages/419777/"},{name:"v-476ed16d",path:"/pages/4f7ea8/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-476ed16d").then(t)}},{path:"/pages/4f7ea8/index.html",redirect:"/pages/4f7ea8/"},{path:"/02.工具/01.版本控制/01.Git Commit 之道：规范化 Commit Message 写作指南.html",redirect:"/pages/4f7ea8/"},{name:"v-3a3276c2",path:"/pages/992deb/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-3a3276c2").then(t)}},{path:"/pages/992deb/index.html",redirect:"/pages/992deb/"},{path:"/02.工具/01.版本控制/02.Git教程.html",redirect:"/pages/992deb/"},{name:"v-279b57f8",path:"/pages/031ffb/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-279b57f8").then(t)}},{path:"/pages/031ffb/index.html",redirect:"/pages/031ffb/"},{path:"/02.工具/01.版本控制/03.Github搜索技巧.html",redirect:"/pages/031ffb/"},{name:"v-0c700bb1",path:"/pages/50ca39/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-0c700bb1").then(t)}},{path:"/pages/50ca39/index.html",redirect:"/pages/50ca39/"},{path:"/02.工具/02.网络工具/01.WireGuard组网教程.html",redirect:"/pages/50ca39/"},{name:"v-2472c4c6",path:"/pages/975871/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-2472c4c6").then(t)}},{path:"/pages/975871/index.html",redirect:"/pages/975871/"},{path:"/02.工具/02.网络工具/02.SSH教程.html",redirect:"/pages/975871/"},{name:"v-1e268ac6",path:"/pages/c81c74/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-1e268ac6").then(t)}},{path:"/pages/c81c74/index.html",redirect:"/pages/c81c74/"},{path:"/02.工具/03.开发工具/02.Tmux教程.html",redirect:"/pages/c81c74/"},{name:"v-1a482803",path:"/pages/e7b5a5/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-1a482803").then(t)}},{path:"/pages/e7b5a5/index.html",redirect:"/pages/e7b5a5/"},{path:"/02.工具/03.开发工具/03.Vim教程.html",redirect:"/pages/e7b5a5/"},{name:"v-59070e48",path:"/pages/608406/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-59070e48").then(t)}},{path:"/pages/608406/index.html",redirect:"/pages/608406/"},{path:"/04.生活杂谈/01.随写编年/02.2023年/01.雪韵初见·南京初雪.html",redirect:"/pages/608406/"},{name:"v-509f409b",path:"/pages/0fc47a/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-509f409b").then(t)}},{path:"/pages/0fc47a/index.html",redirect:"/pages/0fc47a/"},{path:"/02.工具/03.开发工具/01.Shell教程.html",redirect:"/pages/0fc47a/"},{name:"v-6cf98a73",path:"/pages/0070df/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-6cf98a73").then(t)}},{path:"/pages/0070df/index.html",redirect:"/pages/0070df/"},{path:"/05.资源收藏/02.优秀项目/01.算法实现模版.html",redirect:"/pages/0070df/"},{name:"v-47fabeb6",path:"/pages/7634df/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-47fabeb6").then(t)}},{path:"/pages/7634df/index.html",redirect:"/pages/7634df/"},{path:"/05.资源收藏/02.优秀项目/02.设计模式实现模版.html",redirect:"/pages/7634df/"},{name:"v-4a02579b",path:"/about/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-4a02579b").then(t)}},{path:"/about/index.html",redirect:"/about/"},{path:"/07.关于/01.about.html",redirect:"/about/"},{name:"v-30e085c9",path:"/friend/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-30e085c9").then(t)}},{path:"/friend/index.html",redirect:"/friend/"},{path:"/08.友情链接/01.友情链接.html",redirect:"/friend/"},{name:"v-3a888ae4",path:"/pages/9fd05a/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-3a888ae4").then(t)}},{path:"/pages/9fd05a/index.html",redirect:"/pages/9fd05a/"},{path:"/05.资源收藏/02.优秀项目/03.Go优秀资源.html",redirect:"/pages/9fd05a/"},{name:"v-7587d3fc",path:"/pages/e1f6d9/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-7587d3fc").then(t)}},{path:"/pages/e1f6d9/index.html",redirect:"/pages/e1f6d9/"},{path:"/01.开发/02.开发框架/03.设计模式/12.设计模式之观察者模式详解（Java实现）.html",redirect:"/pages/e1f6d9/"},{name:"v-1e09ee2b",path:"/tags/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-1e09ee2b").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-6097fb0b",path:"/categories/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-6097fb0b").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-10f2e34e",path:"/life/year/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-10f2e34e").then(t)}},{path:"/life/year/index.html",redirect:"/life/year/"},{path:"/00.目录页/04.sub01.随写编年.html",redirect:"/life/year/"},{name:"v-3fce6544",path:"/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-3fce6544").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-0e8002ab",path:"/archives/",component:bl,beforeEnter:(n,e,t)=>{us("Layout","v-0e8002ab").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{path:"*",component:bl}],yl={title:"",description:"",base:"/",headTags:[["link",{rel:"icon",href:"/img/favicon.ico"}],["meta",{name:"keywords",content:"python,Go,C++,git,github,markdown,database,mysql,redis"}],["meta",{name:"baidu-site-verification",content:"7F55weZDDc"}],["meta",{name:"theme-color",content:"#11a8cd"}]],pages:[{title:"开发框架",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.开发/02.开发框架",description:"开发框架"}},title:"开发框架",permalink:"/develop/framework/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T14:10:02.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.sub02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6.html",relativePath:"00.目录页/01.sub02.开发框架.md",key:"v-3c5cb278",path:"/develop/framework/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:27:24",lastUpdatedTimestamp:1700821644e3},{title:"数据结构与算法",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.开发/03.数据结构与算法",description:"数据结构与算法"}},title:"数据结构与算法",permalink:"/develop/algorithm/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T14:10:05.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.sub03.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html",relativePath:"00.目录页/01.sub03.数据结构与算法.md",key:"v-16a9958e",path:"/develop/algorithm/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:27:24",lastUpdatedTimestamp:1700821644e3},{title:"数据存储",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.开发/04.数据存储",description:"数据存储"}},title:"数据存储",permalink:"/develop/storage/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T14:10:00.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.sub04.%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8.html",relativePath:"00.目录页/01.sub04.数据存储.md",key:"v-1139bec1",path:"/develop/storage/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:27:24",lastUpdatedTimestamp:1700821644e3},{title:"系统架构",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.开发/05.系统架构",description:"系统架构"}},title:"系统架构",permalink:"/develop/system/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T14:10:02.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.sub05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.html",relativePath:"00.目录页/01.sub05.系统架构.md",key:"v-e6d91580",path:"/develop/system/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:27:24",lastUpdatedTimestamp:1700821644e3},{title:"计算机网络",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.开发/06.计算机网络",description:"计算机网络"}},title:"计算机网络",permalink:"/develop/network/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T14:10:02.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.sub06.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html",relativePath:"00.目录页/01.sub06.计算机网络.md",key:"v-5df34b59",path:"/develop/network/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:27:24",lastUpdatedTimestamp:1700821644e3},{title:"云原生",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.开发/07.云原生",description:"云原生"}},title:"云原生",permalink:"/develop/cloud/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T14:10:02.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.sub07.%E4%BA%91%E5%8E%9F%E7%94%9F.html",relativePath:"00.目录页/01.sub07.云原生.md",key:"v-0c3eb4e8",path:"/develop/cloud/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:27:24",lastUpdatedTimestamp:1700821644e3},{title:"开发",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.开发",imgUrl:"/img/web.png",description:"技术文章"}},title:"开发",date:"2020-03-11T21:50:53.000Z",permalink:"/develop/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.%E5%BC%80%E5%8F%91.html",relativePath:"00.目录页/01.开发.md",key:"v-aa898bb4",path:"/develop/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/23, 11:20:11",lastUpdatedTimestamp:1700709611e3},{title:"版本控制",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"02.工具/01.版本控制",description:"版本控制相关文章"}},title:"版本控制",permalink:"/tool/vcs/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T15:36:50.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.sub01%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6.html",relativePath:"00.目录页/02.sub01版本控制.md",key:"v-1e46750d",path:"/tool/vcs/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:39:24",lastUpdatedTimestamp:1700822364e3},{title:"网络工具",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"02.工具/02.网络工具",description:"网络工具介绍"}},title:"网络工具",permalink:"/tool/network/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T15:36:49.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.sub02%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7.html",relativePath:"00.目录页/02.sub02网络工具.md",key:"v-ccee1a68",path:"/tool/network/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:39:24",lastUpdatedTimestamp:1700822364e3},{title:"开发工具",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"02.工具/03.开发工具",description:"开发工具介绍"}},title:"开发工具",permalink:"/tool/develop/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T15:36:52.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.sub03.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7.html",relativePath:"00.目录页/02.sub03.开发工具.md",key:"v-48703727",path:"/tool/develop/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:39:24",lastUpdatedTimestamp:1700822364e3},{title:"工具",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"02.工具",imgUrl:"/img/web.png",description:"工具使用教程"}},title:"工具",permalink:"/tool/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-23T10:57:08.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.%E5%B7%A5%E5%85%B7.html",relativePath:"00.目录页/02.工具.md",key:"v-288e6001",path:"/tool/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:39:24",lastUpdatedTimestamp:1700822364e3},{title:"实践项目",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"03.学习笔记/02.实践项目",description:"实践项目"}},title:"实践项目",permalink:"/note/project/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-23T10:58:20.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.sub02.%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE.html",relativePath:"00.目录页/03.sub02.实践项目.md",key:"v-a45883c2",path:"/note/project/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 19:47:19",lastUpdatedTimestamp:1700826439e3},{title:"学习笔记",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"03.学习笔记/03.讲座研讨",description:"讲座研讨"}},title:"学习笔记",permalink:"/note/lecture/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-23T10:58:20.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.sub03.%E8%AE%B2%E5%BA%A7%E7%A0%94%E8%AE%A8.html",relativePath:"00.目录页/03.sub03.讲座研讨.md",key:"v-bd714042",path:"/note/lecture/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 19:47:19",lastUpdatedTimestamp:1700826439e3},{title:"学术搬砖",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"03.学习笔记/学术搬砖",description:"学术搬砖"}},title:"学术搬砖",permalink:"/note/paper/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-23T10:58:20.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.sub01.%E5%AD%A6%E6%9C%AF%E6%90%AC%E7%A0%96.html",relativePath:"00.目录页/03.sub01.学术搬砖.md",key:"v-f15f1ada",path:"/note/paper/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 19:47:19",lastUpdatedTimestamp:1700826439e3},{title:"学习笔记",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"03.学习笔记",imgUrl:"/img/other.png",description:"论文或者讲座等笔记"}},title:"学习笔记",permalink:"/note/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-23T10:58:20.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html",relativePath:"00.目录页/03.学习笔记.md",key:"v-6668a861",path:"/note/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:39:24",lastUpdatedTimestamp:1700822364e3},{title:"编程语言",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.开发/01.编程语言",description:"编程语言"}},title:"编程语言",permalink:"/develop/language/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T14:08:35.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.sub01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80.html",relativePath:"00.目录页/01.sub01.编程语言.md",key:"v-dd6d37e4",path:"/develop/language/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:27:24",lastUpdatedTimestamp:1700821644e3},{title:"追忆青春",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"04.生活杂谈/02.追忆青春",description:"追忆青春"}},title:"追忆青春",permalink:"/life/youth/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T16:04:42.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.sub02.%E8%BF%BD%E5%BF%86%E9%9D%92%E6%98%A5.html",relativePath:"00.目录页/04.sub02.追忆青春.md",key:"v-1f12d3c2",path:"/life/youth/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:45:17",lastUpdatedTimestamp:1700822717e3},{title:"旅行日记",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"04.生活杂谈/03.旅行日记",description:"记录旅行"}},title:"旅行日记",permalink:"/life/travel/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T16:04:40.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.sub03.%E6%97%85%E8%A1%8C%E6%97%A5%E8%AE%B0.html",relativePath:"00.目录页/04.sub03.旅行日记.md",key:"v-0dd17318",path:"/life/travel/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:45:17",lastUpdatedTimestamp:1700822717e3},{title:"文艺时光",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"04.生活杂谈/04.文艺时光",description:"记录书影音"}},title:"文艺时光",permalink:"/life/art/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T16:18:37.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.sub04.%E6%96%87%E8%89%BA%E6%97%B6%E5%85%89.html",relativePath:"00.目录页/04.sub04.文艺时光.md",key:"v-466444aa",path:"/life/art/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:45:17",lastUpdatedTimestamp:1700822717e3},{title:"烹调分享",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"04.生活杂谈/05.烹调分享",description:"烹调分享"}},title:"烹调分享",permalink:"/life/cook/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T16:18:37.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.sub05.%E7%83%B9%E8%B0%83%E5%88%86%E4%BA%AB.html",relativePath:"00.目录页/04.sub05.烹调分享.md",key:"v-3f115c5a",path:"/life/cook/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:45:17",lastUpdatedTimestamp:1700822717e3},{title:"生活杂谈",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"04.生活杂谈",imgUrl:"/img/other.png",description:"记录生活"}},title:"生活杂谈",permalink:"/life/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T15:43:02.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88.html",relativePath:"00.目录页/04.生活杂谈.md",key:"v-486047ee",path:"/life/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:39:24",lastUpdatedTimestamp:1700822364e3},{title:"优秀项目",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"05.资源收藏/02.优秀项目",description:"优秀项目汇总"}},title:"优秀项目",permalink:"/resource/project/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-23T11:18:33.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/05.sub02%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE.html",relativePath:"00.目录页/05.sub02优秀项目.md",key:"v-0295a8c0",path:"/resource/project/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 19:47:19",lastUpdatedTimestamp:1700826439e3},{title:"资源收藏",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"05.资源收藏",imgUrl:"/img/other.png",description:"相关资源收藏"}},title:"资源收藏",permalink:"/resource/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-23T11:18:33.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/05.%E8%B5%84%E6%BA%90%E6%94%B6%E8%97%8F.html",relativePath:"00.目录页/05.资源收藏.md",key:"v-319af327",path:"/resource/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:39:24",lastUpdatedTimestamp:1700822364e3},{title:"更多",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"06.更多/03.博客相关"}},title:"更多",permalink:"/more/blog/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T16:24:22.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/06.sub03.%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3.html",relativePath:"00.目录页/06.sub03.博客相关.md",key:"v-ecc968b6",path:"/more/blog/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:45:17",lastUpdatedTimestamp:1700822717e3},{title:"更多",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"06.更多/02.实用技巧"}},title:"更多",permalink:"/more/tip/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T16:24:23.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/06.sub02.%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7.html",relativePath:"00.目录页/06.sub02.实用技巧.md",key:"v-1bc814a4",path:"/more/tip/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:45:17",lastUpdatedTimestamp:1700822717e3},{title:"面试",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"06.更多/01.面试"}},title:"面试",permalink:"/more/interview/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T16:24:20.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/06.sub01.%E9%9D%A2%E8%AF%95.html",relativePath:"00.目录页/06.sub01.面试.md",key:"v-0d1f7517",path:"/more/interview/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:45:17",lastUpdatedTimestamp:1700822717e3},{title:"更多",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"06.更多",imgUrl:"/img/other.png"}},title:"更多",permalink:"/more/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T16:11:05.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/06.%E6%9B%B4%E5%A4%9A.html",relativePath:"00.目录页/06.更多.md",key:"v-45eaf67a",path:"/more/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:39:24",lastUpdatedTimestamp:1700822364e3},{title:"vite构建工具介绍",frontmatter:{title:"vite构建工具介绍",date:"2023-11-12T22:52:13.000Z",tags:["Vite"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/03e0a8/",categories:["开发","开发框架","前端"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/01.%E5%89%8D%E7%AB%AF/01.Vite%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D.html",relativePath:"01.开发/02.开发框架/01.前端/01.Vite构建工具介绍.md",key:"v-7f8094fc",path:"/pages/03e0a8/",headers:[{level:2,title:"1 构建工具",slug:"_1-构建工具",normalizedTitle:"1 构建工具",charIndex:2},{level:3,title:"1.1 什么是构建工具",slug:"_1-1-什么是构建工具",normalizedTitle:"1.1 什么是构建工具",charIndex:13},{level:3,title:"1.2 主流构建工具",slug:"_1-2-主流构建工具",normalizedTitle:"1.2 主流构建工具",charIndex:1058},{level:3,title:"1.3 vite相较于webpack的优势",slug:"_1-3-vite相较于webpack的优势",normalizedTitle:"1.3 vite相较于webpack的优势",charIndex:1172},{level:2,title:"2 vite启动项目初体验",slug:"_2-vite启动项目初体验",normalizedTitle:"2 vite启动项目初体验",charIndex:2555},{level:3,title:"2.1 你必须要理解的vite脚手架和vite",slug:"_2-1-你必须要理解的vite脚手架和vite",normalizedTitle:"2.1 你必须要理解的vite脚手架和vite",charIndex:2573},{level:3,title:"2.2 vite开箱即用",slug:"_2-2-vite开箱即用",normalizedTitle:"2.2 vite开箱即用",charIndex:3123},{level:3,title:"2.3 vite的预加载",slug:"_2-3-vite的预加载",normalizedTitle:"2.3 vite的预加载",charIndex:3568},{level:3,title:"2.4 vite配置文件处理细节",slug:"_2-4-vite配置文件处理细节",normalizedTitle:"2.4 vite配置文件处理细节",charIndex:4447},{level:3,title:"2.5 vue环境变量配置",slug:"_2-5-vue环境变量配置",normalizedTitle:"2.5 vue环境变量配置",charIndex:4741},{level:2,title:"3 vite 原理篇",slug:"_3-vite-原理篇",normalizedTitle:"3 vite 原理篇",charIndex:6801},{level:3,title:"3.1 vite是怎么让浏览器可以识别.vue文件呢",slug:"_3-1-vite是怎么让浏览器可以识别-vue文件呢",normalizedTitle:"3.1 vite是怎么让浏览器可以识别.vue文件呢",charIndex:6816},{level:3,title:"3.2 使用path.resolve的原因",slug:"_3-2-使用path-resolve的原因",normalizedTitle:"3.2 使用path.resolve的原因",charIndex:7452},{level:2,title:"4 vite与css",slug:"_4-vite与css",normalizedTitle:"4 vite与css",charIndex:7996},{level:3,title:"4.1 在vite中处理css",slug:"_4-1-在vite中处理css",normalizedTitle:"4.1 在vite中处理css",charIndex:8011},{level:3,title:"4.2 css文件类型",slug:"_4-2-css文件类型",normalizedTitle:"4.2 css文件类型",charIndex:8729},{level:3,title:"4.3 vite.config.js中css配置",slug:"_4-3-vite-config-js中css配置",normalizedTitle:"4.3 vite.config.js中css配置",charIndex:10064},{level:4,title:"4.3.1 module篇",slug:"_4-3-1-module篇",normalizedTitle:"4.3.1 module篇",charIndex:10140},{level:4,title:"4.3.2 preprocessorOption篇",slug:"_4-3-2-preprocessoroption篇",normalizedTitle:"4.3.2 preprocessoroption篇",charIndex:11017},{level:4,title:"4.3.2 postcss篇",slug:"_4-3-2-postcss篇",normalizedTitle:"4.3.2 postcss篇",charIndex:11469},{level:2,title:"5 vite相关知识",slug:"_5-vite相关知识",normalizedTitle:"5 vite相关知识",charIndex:12117},{level:3,title:"5.1 vite加载静态资源",slug:"_5-1-vite加载静态资源",normalizedTitle:"5.1 vite加载静态资源",charIndex:12132},{level:3,title:"5.2 vite在生产环境中对静态资源的处理",slug:"_5-2-vite在生产环境中对静态资源的处理",normalizedTitle:"5.2 vite在生产环境中对静态资源的处理",charIndex:12748},{level:3,title:"5.3 vite常用插件",slug:"_5-3-vite常用插件",normalizedTitle:"5.3 vite常用插件",charIndex:13312},{level:4,title:"5.3.1 vite-aliases",slug:"_5-3-1-vite-aliases",normalizedTitle:"5.3.1 vite-aliases",charIndex:13400},{level:4,title:"5.3.2 vite-plugin-html",slug:"_5-3-2-vite-plugin-html",normalizedTitle:"5.3.2 vite-plugin-html",charIndex:15411},{level:4,title:"5.3.3 vite-plugin-mock",slug:"_5-3-3-vite-plugin-mock",normalizedTitle:"5.3.3 vite-plugin-mock",charIndex:17533},{level:4,title:"5.3.4 其他插件",slug:"_5-3-4-其他插件",normalizedTitle:"5.3.4 其他插件",charIndex:17906}],headersStr:"1 构建工具 1.1 什么是构建工具 1.2 主流构建工具 1.3 vite相较于webpack的优势 2 vite启动项目初体验 2.1 你必须要理解的vite脚手架和vite 2.2 vite开箱即用 2.3 vite的预加载 2.4 vite配置文件处理细节 2.5 vue环境变量配置 3 vite 原理篇 3.1 vite是怎么让浏览器可以识别.vue文件呢 3.2 使用path.resolve的原因 4 vite与css 4.1 在vite中处理css 4.2 css文件类型 4.3 vite.config.js中css配置 4.3.1 module篇 4.3.2 preprocessorOption篇 4.3.2 postcss篇 5 vite相关知识 5.1 vite加载静态资源 5.2 vite在生产环境中对静态资源的处理 5.3 vite常用插件 5.3.1 vite-aliases 5.3.2 vite-plugin-html 5.3.3 vite-plugin-mock 5.3.4 其他插件",content:'# 1 构建工具\n\n\n# 1.1 什么是构建工具\n\n> 浏览器它只认识html，css，js\n\n企业级项目里都可能具备哪些功能？\n\n 1. typescript：使用tsc工具将ts代码转换为js代码；\n 2. React/Vue：安装react-compiler/vue-compiler，将我们写的jsx文件或者.vue文件转换为render函数；\n 3. less/sass/postcss/component-style：我们有需要安装less-loader,sass-loader等一系列编译工具转换为css代码；\n 4. 语法降级：babel可以将es的新语法转换旧版浏览器可以接受的语法；\n 5. 体积优化：uglifyjs可以将我们的代码进行压缩变成体积更小性能更高的文件。\n\n> 以上稍微改一点，就会很麻烦，所以我们希望有一个构建工具可以将以上工具全部集成到一起，实现上述功能，我们只需要关注我们写的代码即可。即构建工具可以帮我们自动去tsc，react-comiler，less，babel，uglifyjs全部走一遍，让我们不用每次关心我们的代码在浏览器运行。\n\n> 打包：将我们写的浏览器不认识的代码，交给构建工具进行编译处理的过程就叫做打包，打包完成以后会给我们一个浏览器可以认识的文件。\n\n构建工具承担了以下脏活累活：\n\n 1. 模块化开发支持：支持直接从node_modules里引入代码 + 多种模块化支持\n 2. 处理代码兼容性：比如babel语法降级，less，ts语法转换（不是构建工具做的，构建工具将这些语法对应的处理工具集成进来自动化处理）\n 3. 提高项目性能：压缩文件，代码分割\n 4. 优化开发体验：\n    * 构建工具会帮你自动监听文件的变化，当文件变化以后自动帮你调用对应的集成工具进行重新打包，然后再浏览器重新运行（整个过程叫做热更新，hot replacement）\n    * 开发服务器：跨域的问题，用react-cli create-react-element vue-cli解决跨域的问题\n\n> 我们只需要首次给构建工具提供一个配置文件（这个配置文件也不是必须的，没有它也会默认处理），有了集成的配置文件以后，我们就可以在下次需要更新的时候调用一次对应的命令即可，如果再结合热更新，我们就更加不需要管任何东西，这就是构建工具去做的事情，它让我们不用关心生产的带啊吗也不用关心代码如何在浏览器运行，只需要关心我们的开发怎么写的爽怎么写就好了。\n\n\n# 1.2 主流构建工具\n\n * webpack\n * vite\n * parcel\n * esbuild\n * rollup\n * grunt\n * gulp\n\n> 国内主流还是webpack，vite和esbuild。\n\n\n# 1.3 vite相较于webpack的优势\n\n> 然而，当我们开始构建越来越大型的应用时，需要处理的 JavaScript 代码量也呈指数级增长。包含数千个模块的大型项目相当普遍。基于 JavaScript 开发的工具就会开始遇到性能瓶颈：==通常需要很长时间（甚至是几分钟！）才能启动开发服务器，即使使用模块热替换（HMR），文件修改后的效果也需要几秒钟才能在浏览器中反映出来。==如此循环往复，迟钝的反馈会极大地影响开发者的开发效率和幸福感。\n\n起因：我们的项目越大，构建工具（webpack）所要处理的js代码就越多【跟webpack的一个构建过程（工作流程有关）】\n\n造成的结果：构建工具需要很长时间才能启动开发服务器（把项目跑起来）\n\nyarn start\nyarn dev\n\nnpm run dev\nnpm run start\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n> webpack不能改，如果要改，则会动到webpack的大动脉。\n> \n> // 这段代码最终回到浏览器里去运行\n> const lodash = require("lodash"); // commonjs 规范\n> import Vue from "vue"; // es6 module\n> \n> // webpack是允许我们这么写的，webpack会这样转换\n> const lodash = webpack_require("loadsh");\n> const Vue = webpack_require("vue");\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> \n> webpack的编译原理，AST抽象语法分析的工具，分析出js文件有哪些导入导出操作\n> \n> 构建工具是运行在服务端的\n> \n> (function(modules) {\n>     function webpack_require() {}\n>     // 入口是index.js\n>     // 通过webpack的配置文件得来的：webpack.config.js ./src/index.js\n>     modules[entry](webpack_require);\n> }, ({\n>     "index.js": (webpack_require) => {\n>         const lodash = webpack_require("lodash");\n> \t\tconst Vue = webpack_require("vue");\n>     }\n> }))\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> \n> \n> 因为webpack支持模块化，它一开始就必须要统一模块化代码，所以意味着它需要将所有的依赖读一遍。\n> \n> vite会不会直接把webpack干翻？vite是基于es modules的，侧重点不一样，webpack更多的关注兼容性，而vite关注浏览器端的开发体验。\n\n\n# 2 vite启动项目初体验\n\n\n# 2.1 你必须要理解的vite脚手架和vite\n\n> vite官网搭建vite项目文档教程：https://cn.vitejs.dev/guide/#scaffolding-your-first-vite-project\n\n比如我们敲了yarn create vite\n\n 1. 帮我们全局安装了一个东西：create-vite（vite的脚手架）\n 2. 直接运行这个create-vite bin目录下的一个执行配置\n\n误区：认为官网中使用对应的yarn create构建项目的过程也是vite在做的事情\n\n> 我们之前接触过vue-cli，create-vite和vite的关系是：create-vite内置了vite。使用vue-cli会内置webpack\n\n先学习的就是vite，暂时不会使用yarn create vite my-vue-app --template vue。vue-cli可以和webpack分的很清楚。\n\n> vue-cli给我们提供已经精装修的模板。\n> \n> 我们自己搭建一个项目：下载vite，vue，post-css，less，label\n> \n> vue-cli/create-vite给了一套精装修的模板：什么都下好了，并且给你做了最佳实践的配置\n\n\n# 2.2 vite开箱即用\n\n> 开箱即用（out of box）：不需要做任何额外的配置就可以使用vite来帮你处理构建工作\n\n在默认情况下，我们的esmodule去导入资源的时候，要么是绝对路径，要么是相对路径，既然我们现在的最佳实践是node_modules，那么为什么es官方在我们导入非绝对路径和非相对路径的资源的时候不默认帮我们搜寻node_modules？\n\n> 浏览器环境中的安全性原因是一个主要考虑因素。如果浏览器默认搜索node_modules目录，那么恶意的代码可能会利用这个功能访问和执行不受信任的模块代码，从而导致安全风险。通过限制导入路径，浏览器可以更好地控制模块的来源和访问权限。\n> \n> 另外，性能也是一个重要的考虑因素。浏览器默认只支持绝对路径和相对路径的导入，可以在编译时静态解析模块依赖关系，从而提高加载和执行模块的效率。如果浏览器要搜索node_modules目录，可能需要进行额外的文件系统操作和路径解析，增加了加载模块的时间和资源消耗。\n\n\n# 2.3 vite的预加载\n\nimport _ from "lodash"; // lodash可能也import了其他的东西\n\nimport _vite_cjsImport0_lodash from "/node_modules/.vite/deps/loadsh.js?v=ebe57916";\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n在处理的过程中如果说看到了有非绝对路径或者相对路径的引用，则会尝试开启路径补全\n\n找寻依赖的过程是自当前目录依次向上查找的过程，直到搜寻到根目录或者搜寻到对应依赖为止 /user/node_modules/lodash, ../\n\n> 区分生产环境和开发环境：\n> \n> yarn dev ----\x3e 开发（每次依赖预构建所重新构建的相对路径都是正确的）\n> \n> vite会全权交给一个叫做rollup的库去完成生产环境的打包\n> \n> 缓存 ----\x3e\n> \n> 实际上vite在考虑另外一个问题的时候就顺便把这个问题解决了\n> \n> commonjs 规范的导出 module.exports\n> \n> 有的包是以commonjs规范的格式导出 axios\n> \n> 依赖预构建：首先vite会找到对应的依赖，然后调用esbuild（对js语法进行处理的一个库），将其他规范的代码转换成esmodule规范，然后放到当前目录下的node_modules/.vite/deps，同时对esmodule规范的各个模块进行统一集成\n\n所以它解决了3个问题：\n\n 1. 不同的第三方包会有不同的导出格式（这个是vite没法约束人家的事情）\n 2. 对路径的处理上可以直接使用.vite/deps，方便路径重写\n 3. 叫做网络多包传输的性能问题（也是原生esmodule规范不敢支持node_modules的原因之一），有了依赖预构建以后无论它有多少的额外的export和import，vite都会尽可能的将他们集成最后只生成一个或者几个模块\n\nvite.config.js === webpack.config.js\n\n\n# 2.4 vite配置文件处理细节\n\n 1. vite配置文件的语法提示\n    \n    1. 如果你使用的是webstorm，那你可以得到很好的语法补全\n    2. 如果你使用的是vscode或者其他编辑器，则需要做一些特殊处理\n\n 2. 关于环境的处理\n    \n    > 过去我们使用webpack的时候，我们需要区分配置文件的一个环境：\n    > \n    >  * webpack.dev.config\n    >  * webpack.prod.config\n    >  * webpack.base.config\n    >  * webpackmerge\n\n\n# 2.5 vue环境变量配置\n\n> 环境变量：会根据当前的代码环境产生值的变化的变量就叫做环境变量\n> \n> 代码环境：\n> \n>  1. 开发环境：开发环境是开发人员进行软件开发和调试的地方。在开发环境中，开发人员可以进行代码编写、调试、测试和验证。这个环境通常是本地的开发机器，开发人员可以通过使用 Vite 的开发服务器（dev server）来提供实时的重新加载（live reloading）和模块热替换（hot module replacement）功能，以便更快地进行开发和调试。\n>  2. 测试环境：测试环境是用于进行软件测试的环境。在测试环境中，开发人员和测试人员可以对软件进行不同类型的测试，例如单元测试、集成测试和端到端测试。在测试环境中，可以使用 Vite 构建工具生成测试所需的构建文件，并在模拟的环境中进行测试。\n>  3. 预发布环境：预发布环境是在软件发布之前进行最后测试和验证的环境。在预发布环境中，可以对软件进行更全面的测试，以确保它符合发布的质量标准。这个环境通常是一个类似于生产环境的环境，但在实际发布之前，可能会使用一些模拟数据和模拟系统进行测试。\n>  4. 灰度环境：灰度环境是在软件发布后逐步向用户群体推出新功能或更新的环境。在灰度环境中，新的软件版本或功能将部署到一小部分用户中，以便测试其稳定性和兼容性。这个环境类似于生产环境，但只有一部分用户能够访问新的功能或更新。\n>  5. 生产环境：生产环境是最终向用户提供服务的环境。在生产环境中，已经通过了开发、测试、预发布和灰度环境的验证，并且已准备好为最终用户提供稳定、可靠的服务。在生产环境中，通常会使用 Vite 构建工具生成用于部署的生产级别的构建文件，并进行必要的优化和压缩，以提供最佳的性能和用户体验。\n\n我们在和后端同学对接的时候，前端在开发环境中请求的后端API地址和生产环境请求的后端API地址是一个吗？肯定不是一个\n\n * 开发和测试：http://test.api/\n * 生产：https://api/\n\n> 在vite中的环境变量处理：\n> \n> vite内置了dotenv这个第三方库，会自动读取.env文件，并解析这个文件中的对应的环境变量，并将其注入到process对象下（但是vite考虑到和其他配置的一些冲突问题，它不会直接注入到process对象下）\n> \n> 涉及到vite.config.js中的一些配置：\n> \n>  * root\n>  * envDir：用来配置当前环境变量的文件地址\n> \n> vite给我们提供了一些补偿措施：我们可以调用vite的loadEnv来手动确认env文件\n> \n> porcess.cwd方法：返回node进程的工作目录\n\n> 小知识：为什么vite.config.js可以书写成esmodule的形式，这是因为vite他在读取这个vite.config.js的时候会率先node去解析文件语法，如果发现你是esmodule规范则会直接将你的esmodule规范替换成common js规范\n\n> .env：所有环境都需要用到的环境变量\n> \n> .env.development：开发环境需要用到的环境变量（默认情况下vite将我们的开发环境取名为development）\n> \n> .env.production：生产环境需要用到的环境变量（默认情况下vite将我们的生产环境取名为production）\n> \n> yarn dev --mode development 会将mode设置为development传递进来\n> \n> 当我们调用loadenv的时候，它会做如下几件事情：\n> \n>  1. 直接找到.env文件不解释，并解析其中的环境变量，放到一个对象里\n> \n>  2. 会将传进来的mode这个变量的值进行拼接：env.development，并根据我们提供的目录去取对应配置文件并进行解析，并放进一个对象\n> \n>  3. 我们可以理解为\n>     \n>     const baseEnvConfig = 读取.env配置\n>     const modeEnvConfig = 读取env相关配置\n>     const lastEnvConfig = {...baseEnvConfig, ...modeEnvConfig}\n>     \n>     \n>     1\n>     2\n>     3\n>     \n>     1\n>     2\n>     3\n>     \n\n如果是客户端，vite会将对应的环境变量注入到import.meta.env里去\n\nvite做了一个拦截，为了防止我们将隐私性的变量直接送到import.meta.env中，所以做了一层拦截，如果你的环境变量不是以VITE开头的，他就不会帮你注入到客户端中去，如果我们想要更改这个前缀，可以去使用envPrefix配置。\n\n\n# 3 vite 原理篇\n\n\n# 3.1 vite是怎么让浏览器可以识别.vue文件呢\n\nVite 是一个现代化的前端构建工具，它使用了一种名为单文件组件（Single File Components）的技术来让浏览器能够识别和加载 .vue 文件。\n\n在传统的前端开发中，浏览器无法直接识别和加载 .vue 文件，因为 .vue 文件包含了 HTML、CSS 和 JavaScript 代码，而浏览器只能识别和执行 JavaScript 文件。\n\nVite 利用了构建工具和打包器的能力，在开发阶段将 .vue 文件转换为浏览器可以识别的形式。它借助特定的编译器（如 Vue 编译器）将 .vue 文件的模板、样式和脚本部分分别提取出来，并将它们转换为浏览器可以理解的代码。\n\n具体地说，Vite 使用了名为 "vue-loader" 的工具来解析和转换 .vue 文件。这个工具会解析 .vue 文件的内容，提取出其中的模板、样式和脚本，并将它们转化为独立的代码块。然后，Vite 使用浏览器原生的 ES 模块导入机制，通过 <script type="module"> 标签将这些代码块加载到浏览器中。\n\n当浏览器遇到 <script type="module"> 标签时，它会将标签中的 JavaScript 代码作为一个独立的模块加载和执行。Vite 利用这个特性，将 .vue 文件中的模板、样式和脚本部分分别作为独立的模块加载到浏览器中，并在浏览器中动态组合它们，构建出最终的组件。\n\n\n# 3.2 使用path.resolve的原因\n\n> 在使用路径时，尽量使用 path.resolve 方法可以确保路径的可靠性和跨平台性。以下是几个使用 path.resolve 方法的好处：\n> \n>  1. 处理相对路径和绝对路径：path.resolve 方法可以接受多个参数，将它们解析为一个绝对路径。这意味着你可以使用相对路径作为参数，并将其解析为相对于当前工作目录的绝对路径。这对于确定准确的文件路径非常有用。\n>  2. 解决跨平台路径问题：在不同的操作系统中，对于路径分隔符和路径表示法有所差异。使用 path.resolve 方法可以确保生成的路径在不同的操作系统下都是有效的，因为它会自动根据当前操作系统调整路径分隔符和表示法。\n>  3. 处理路径拼接和规范化：path.resolve 方法会将传入的路径片段进行拼接，并返回一个规范化的路径。这意味着它会解析和处理路径中的 ..、. 等相对路径符号，确保生成的路径是规范化的、干净的路径。\n>  4. 确保路径的存在性：使用 path.resolve 方法生成的路径是确保存在的，它不会检查路径是否有效或文件是否存在，但会确保路径的格式正确。这可以帮助你在操作文件系统时提供正确的路径，避免出现错误或异常。\n\n\n# 4 vite与css\n\n\n# 4.1 在vite中处理css\n\n> vite天生就支持对css文件的直接处理\n\n 1. vite在读取到main.js文件中引用到了index.css\n 2. 直接使用fs模块去读取index.css中文件内容\n 3. 直接创建一个style标签，将index.css中文件内容直接copy到style标签里\n 4. 将style标签插入到index.html的head中\n 5. 将css文件中的内容直接替换为js脚本（方便热更新或者css模块化），同时设置Content-Type为js，从而让浏览器以JS脚本的形式来执行该css后缀的文件\n\n> 场景：\n> \n>  * 一个组件最外层的元素类名一般取名： wrapper\n>  * 一个组件最底层的元素类名一般取名：footer\n> \n> 但你取了footer这个名字，别人因为没有看过你这个组件的源代码，也可能去取名footer这个类名，最后可能会导致样式被覆盖（因为类名重复），这就是我们在协同开发很容易出现的问题\n\ncssmodule就是来解决这个问题的：\n\n 1. module.css（module是一种约定，表示需要开启css模块化）\n 2. 他会将你的所有类名进行一定规则的替换（将footer替换为_footer_i22st_1）\n 3. 同时创建一个映射对象{ footer: "_footer_i22st_1"}\n 4. 将替换过后的内容塞进style标签里然后放入到head标签中（能够读到index.html的文件内容）\n 5. 将componentA.module.css内容全部抹除，替换为JS脚本\n 6. 将创建的映射对象在脚本中默认导出\n\n\n# 4.2 css文件类型\n\n>  1. CSS（.css）：CSS 是层叠样式表的标准文件格式，它使用类似于选择器和属性的语法来描述网页的样式。CSS 是前端开发中最常见的样式表语言，浏览器原生支持。\n>  2. LESS（.less）：LESS 是 CSS 的拓展，它引入了变量、嵌套规则、Mixin（混入）等功能，以简化 CSS 的编写和维护。LESS 文件需要在开发阶段通过 LESS 编译器转换为标准的 CSS 文件，然后在浏览器中加载。\n>  3. SCSS/SASS（.scss/.sass）：SCSS（Sassy CSS）和 SASS（Syntactically Awesome Style Sheets）也是 CSS 的拓展，提供了类似 LESS 的功能，如变量、嵌套规则和 Mixin。SCSS 与 SASS 的语法略有不同，但都需要通过编译器将其转换为标准的 CSS 文件。\n\n/* SCSS */\n.container {\n  width: 100%;\n\n  .header {\n    background-color: #333;\n    color: #fff;\n    padding: 10px;\n  }\n\n  .content {\n    padding: 20px;\n\n    p {\n      margin-bottom: 10px;\n    }\n\n    a {\n      color: #f00;\n      text-decoration: none;\n\n      &:hover {\n        text-decoration: underline;\n      }\n    }\n  }\n\n  .footer {\n    background-color: #333;\n    color: #fff;\n    padding: 10px;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n在这个示例中，.container 是最外层的容器选择器，它包含了 .header、.content 和 .footer 子选择器。通过嵌套定义，我们可以更直观地表示这些选择器之间的层次结构。\n\n此外，嵌套定义还可以减少重复代码的编写。在上述示例中，.header 和 .footer 具有相同的背景颜色、文字颜色和内边距，通过嵌套定义，我们只需在父选择器中指定一次即可，避免了重复的样式声明。\n\n另外，嵌套定义还可以方便地应用伪类和伪元素样式。在示例中，嵌套定义了 a 元素的样式，并使用 &:hover 表示其悬停状态下的样式，这样可以更直观地表示选择器之间的关系。\n\n通过使用嵌套定义，我们可以更清晰地组织和维护样式代码，减少了冗余和重复的工作，提高了代码的可读性和可维护性。\n\n\n# 4.3 vite.config.js中css配置\n\n> 在vite.config.js中我们通过css属性去控制整个vite对于css的处理行为\n\n# 4.3.1 module篇\n\ncss: { \n    \n    modules: { \n    }\n}\ncss: { // 对css的行为进行配置\n  // modules配置最终会丢给postcss modules\n  modules: { // 是对css模块化的默认行为进行覆盖\n    localsConvention: \'camelCase\', // 修改生成的配置对象的 key 的展示形式为驼峰命名\n    scopeBehaviour: \'global\', // 配置当前的模块化行为为全局化\n    generateScopedName: \'[name]__[local]___[hash:base64:5]\', // 指定生成的类名的命名规则\n    hashPrefix: \'my-app\', // 生成的 hash 的前缀\n    globalModulePaths: [\'path/to/global/styles\'] // 不参与 CSS 模块化的路径\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * localsConvention：修改生成的配置对象的key的展示形式（驼峰还是中划线形式）\n * scopeBehaviour：配置当前的模块化行为是模块化还是全局化（有hash就是开启了模块化的一个标志，因为它可以保证产生不同的hash值来控制我们的样式类名不被覆盖）\n * generateScopedName：[name_[local]_[hash:5]]，指定生成的类名的命名规则（可以配置为函数，也可以配置成字符串规则）\n * hashPrefix：生成的hash会根据你的类名进行生成，如果想要你生成的hash更加的独特一点，你可以配置hashPrefix，你配置的这个字符串会参与到最终的hash生成\n * globalModulePaths：代表你不想参与到css模块化的路径\n\n# 4.3.2 preprocessorOption篇\n\n> 主要是用来配置css预处理的一些全局参数\n\ncss: {\n  preprocessorOptions: {\n    // 配置 CSS 预处理器的全局参数\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n在 preprocessorOptions 中，你可以配置 CSS 预处理器的一些全局参数，具体参数的配置取决于你使用的预处理器（如 Sass、Less 等）。这里可以配置一些通用的选项，比如：\n\n * additionalData：额外的全局样式数据，可以在每个 CSS 文件的顶部注入，例如共享的变量、混合器等。\n * sass：用于配置 Sass 预处理器的选项，如 sass 选项中的 indentedSyntax 表示是否使用缩进语法。\n * less：用于配置 Less 预处理器的选项，如 less 选项中的 javascriptEnabled 表示是否启用 Less 中的 JavaScript 表达式。\n\n# 4.3.2 postcss篇\n\nimport autoprefixer from \'autoprefixer\';\n\nexport default {\n  // ...\n  css: {\n    postcss: {\n      plugins: [\n        autoprefixer(), // 配置 PostCSS 插件，例如 Autoprefixer\n        // 其他的 PostCSS 插件...\n      ]\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在 postcss 配置项中，你可以指定要使用的 PostCSS 插件。在示例中，我们使用了一个常见的插件 Autoprefixer，它用于自动添加 CSS 浏览器前缀，以提供跨浏览器兼容性。\n\n你可以根据需要，将其他的 PostCSS 插件添加到 plugins 数组中。这些插件可以用于执行各种 CSS 处理任务，例如压缩、优化、转换等。\n\n需要注意的是，为了使用特定的 PostCSS 插件，你需要在项目中安装这些插件的相应依赖，并在 vite.config.js 文件中进行正确的导入和配置。\n\n此外，你还可以在 postcss 配置项中设置其他选项，例如 config、sourceMap 等，以满足特定的需求。具体的配置选项和语法规则可以参考 PostCSS 插件的文档或相关资源。\n\n\n# 5 vite相关知识\n\n\n# 5.1 vite加载静态资源\n\n> 什么是静态资源？\n> \n> 静态资源是指不需要经过构建处理的文件，例如图片、视频、字体等，除了动态API以外，百分之九十九的资源都被视作静态资源\n\nvite对静态资源基本上是开箱即用的，除了一些特殊情况（svg）\n\n要加载静态资源，你可以将它们放置在你的项目目录中的任何位置。通常，你可以将这些静态资源放置在你的项目根目录下的 public 文件夹中，这是一个预定义的静态资源文件夹。当你在代码中引用这些静态资源时，Vite 会自动将它们提供给你的应用程序。\n\n例如，如果在你的项目中有一个名为 public 的文件夹，并且在其中有一个图片文件 logo.png，你可以在代码中像下面这样引用它：\n\n<img src="/logo.png" alt="Logo" />\n\n\n1\n\n1\n\n\nVite 会自动将此路径解析为相应的静态资源，并将其提供给你的应用程序。\n\n需要注意的是，在 Vite 中，你可以使用相对于根目录的绝对路径来引用静态资源，而无需考虑模块化的路径解析。这是因为 Vite 使用自己的开发服务器，能够在运行时动态处理这些静态资源的请求。\n\n对于某些特殊的静态资源，如 SVG 文件，你可能需要额外的配置来确保正确加载。对于 SVG 文件，你可以使用 @vitejs/plugin-svg 插件来处理。你可以按照 Vite 官方文档中的说明，添加该插件并进行相应的配置。\n\n\n# 5.2 vite在生产环境中对静态资源的处理\n\n>  1. 静态资源的导入和处理： 在你的代码中，如果有静态资源的导入语句（如图片、字体、CSS 文件等），Vite 会根据这些导入语句自动处理这些资源。\n>  2. 资源优化和压缩： Vite 会对导入的静态资源进行优化和压缩，以减小文件大小并提升加载性能。这包括但不限于压缩图片、压缩和合并 CSS 文件等操作。\n>  3. 指纹化文件名： 为了更好的缓存管理和更新机制，Vite 会为处理后的静态资源生成带有指纹的文件名。这意味着每个文件都会有一个唯一的哈希值作为文件名的一部分，例如 logo.8e4c5f7b.png。当文件内容发生变化时，哈希值也会发生变化，从而确保客户端能够正确地缓存和更新静态资源。\n>  4. 输出静态资源： 处理后的静态资源会被输出到构建目录（默认为 dist）中。Vite 会根据资源类型生成相应的文件，如图片会生成 .png、.jpg 等文件，CSS 文件会生成 .css 文件等。\n>  5. 引用静态资源： 在你的 HTML 文件或生成的代码中，Vite 会自动更新静态资源的引用路径，以指向构建目录中的正确文件。这样，在生产环境中，你可以直接使用相对于构建目录的路径来引用静态资源，而无需关心开发环境中的模块解析和路径处理。\n\n\n# 5.3 vite常用插件\n\n> 插件是什么？\n> \n> vite会在生命周期的不同阶段中调用不同的插件以达到不同的目的\n> \n> 生命周期：vite从开始执行到执行结束\n\n# 5.3.1 vite-aliases\n\n> 作用：别名自动生成\n> \n> 安装：yarn add vite-aliases -D\n> \n> 将其添加到vite.config.js中\n> \n> // vite.config.js\n> import { ViteAliases } from \'vite-aliases\'\n> \n> export default {\n>   plugins: [\n>     ViteAliases()\n>   ]\n> };\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n\nvite-aliases的可选配置项如下：\n\nViteAliases({\n  /**\n  * Relative path to the project directory\n  */\n  dir: \'src\',\n\n  /**\n  * Prefix symbol for the aliases\n  */\n  prefix: \'~\',\n\n  /**\n  * Allow searching for subdirectories\n  */\n  deep: true,\n\n  /**\n  * Search depthlevel for subdirectories\n  */\n  depth: 1,\n\n  /**\n  * Creates a Logfile\n  * use `logPath` to change the location\n  */\n  createLog: false,\n\n  /**\n  * Path for Logfile\n  */\n  logPath: \'src/logs\',\n\n  /**\n  * Create global project directory alias\n  */\n  createGlobalAlias: true,\n\n  /**\n  * Turns duplicates into camelCased path aliases\n  */\n  adjustDuplicates: false,\n\n  /**\n  * Used paths in JS/TS configs will now be relative to baseUrl\n  */\n  useAbsolute: false,\n\n  /**\n  * Adds seperate index paths\n  * approach created by @davidohlin\n  */\n  useIndexes: false,\n\n  /**\n  * Generates paths in IDE config file\n  * works with JS or TS\n  */\n  useConfig: true,\n\n  /**\n  * Override config paths\n  */\n  ovrConfig: false,\n\n  /**\n  * Will generate Paths in tsconfig\n  * used in combination with `useConfig`\n  * Typescript will be auto detected\n  */\n  dts: false,\n\n  /**\n  * Disables any terminal output\n  */\n  silent: true,\n\n  /**\n  * Root path of Vite project\n  */\n  root: process.cwd()\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n\n# 5.3.2 vite-plugin-html\n\n> 功能：\n> \n>  1. HTML 压缩能力\n>  2. EJS 模版能力\n>  3. 多页应用支持\n>  4. 支持自定义entry\n>  5. 支持自定义template\n> \n> 安装：yarn add vite-plugin-html -D\n> \n> 将其添加到vite.config.js中\n\n> 用法：\n> \n> 将EJS标签添加到index.html中\n> \n> <head>\n>   <meta charset="UTF-8" />\n>   <link rel="icon" href="/favicon.ico" />\n>   <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n>   <title><%- title %></title>\n>   <%- injectScript %>\n> </head>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> \n> 在vite.config.js中配置，该方法可以根据需要引入需要的功能\n> \n> import { defineConfig, Plugin } from \'vite\'\n> import vue from \'@vitejs/plugin-vue\'\n> \n> import { createHtmlPlugin } from \'vite-plugin-html\'\n> \n> export default defineConfig({\n>   plugins: [\n>     vue(),\n>     createHtmlPlugin({\n>       minify: true,\n>       /**\n>        * After writing entry here, you will not need to add script tags in `index.html`, the original tags need to be deleted\n>        * @default src/main.ts\n>        */\n>       entry: \'src/main.ts\',\n>       /**\n>        * If you want to store `index.html` in the specified folder, you can modify it, otherwise no configuration is required\n>        * @default index.html\n>        */\n>       template: \'public/index.html\',\n> \n>       /**\n>        * Data that needs to be injected into the index.html ejs template\n>        */\n>       inject: {\n>         data: {\n>           title: \'index\',\n>           injectScript: `<script src="./inject.js"><\/script>`,\n>         },\n>         tags: [\n>           {\n>             injectTo: \'body-prepend\',\n>             tag: \'div\',\n>             attrs: {\n>               id: \'tag\',\n>             },\n>           },\n>         ],\n>       },\n>     }),\n>   ],\n> })\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n> 19\n> 20\n> 21\n> 22\n> 23\n> 24\n> 25\n> 26\n> 27\n> 28\n> 29\n> 30\n> 31\n> 32\n> 33\n> 34\n> 35\n> 36\n> 37\n> 38\n> 39\n> 40\n> 41\n> 42\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n> 19\n> 20\n> 21\n> 22\n> 23\n> 24\n> 25\n> 26\n> 27\n> 28\n> 29\n> 30\n> 31\n> 32\n> 33\n> 34\n> 35\n> 36\n> 37\n> 38\n> 39\n> 40\n> 41\n> 42\n\n# 5.3.3 vite-plugin-mock\n\n> mock数据：模拟数据\n> \n> 前后端一般是并行开发，用户列表（接口文档）\n> \n> mock数据，去做你前端的工作\n> \n>  1. 简单方式：直接去写死一两个数据，方便调试。\n>     * 缺陷：没法做海量数据测试\n>     * 没法获得一些标准数据\n>     * 没法去感知http的异常\n>  2. mockjs：模拟海量数据的，vite-plugin-mock的依赖项是mockjs\n\n> 安装：\n> \n> yarn add mockjs -D\n> yarn add vite-plugin-mock -D\n> \n> \n> 1\n> 2\n> \n> 1\n> 2\n> \n> \n> 使用方法：https://github.com/vbenjs/vite-plugin-mock\n\n# 5.3.4 其他插件\n\n插件地址',normalizedContent:'# 1 构建工具\n\n\n# 1.1 什么是构建工具\n\n> 浏览器它只认识html，css，js\n\n企业级项目里都可能具备哪些功能？\n\n 1. typescript：使用tsc工具将ts代码转换为js代码；\n 2. react/vue：安装react-compiler/vue-compiler，将我们写的jsx文件或者.vue文件转换为render函数；\n 3. less/sass/postcss/component-style：我们有需要安装less-loader,sass-loader等一系列编译工具转换为css代码；\n 4. 语法降级：babel可以将es的新语法转换旧版浏览器可以接受的语法；\n 5. 体积优化：uglifyjs可以将我们的代码进行压缩变成体积更小性能更高的文件。\n\n> 以上稍微改一点，就会很麻烦，所以我们希望有一个构建工具可以将以上工具全部集成到一起，实现上述功能，我们只需要关注我们写的代码即可。即构建工具可以帮我们自动去tsc，react-comiler，less，babel，uglifyjs全部走一遍，让我们不用每次关心我们的代码在浏览器运行。\n\n> 打包：将我们写的浏览器不认识的代码，交给构建工具进行编译处理的过程就叫做打包，打包完成以后会给我们一个浏览器可以认识的文件。\n\n构建工具承担了以下脏活累活：\n\n 1. 模块化开发支持：支持直接从node_modules里引入代码 + 多种模块化支持\n 2. 处理代码兼容性：比如babel语法降级，less，ts语法转换（不是构建工具做的，构建工具将这些语法对应的处理工具集成进来自动化处理）\n 3. 提高项目性能：压缩文件，代码分割\n 4. 优化开发体验：\n    * 构建工具会帮你自动监听文件的变化，当文件变化以后自动帮你调用对应的集成工具进行重新打包，然后再浏览器重新运行（整个过程叫做热更新，hot replacement）\n    * 开发服务器：跨域的问题，用react-cli create-react-element vue-cli解决跨域的问题\n\n> 我们只需要首次给构建工具提供一个配置文件（这个配置文件也不是必须的，没有它也会默认处理），有了集成的配置文件以后，我们就可以在下次需要更新的时候调用一次对应的命令即可，如果再结合热更新，我们就更加不需要管任何东西，这就是构建工具去做的事情，它让我们不用关心生产的带啊吗也不用关心代码如何在浏览器运行，只需要关心我们的开发怎么写的爽怎么写就好了。\n\n\n# 1.2 主流构建工具\n\n * webpack\n * vite\n * parcel\n * esbuild\n * rollup\n * grunt\n * gulp\n\n> 国内主流还是webpack，vite和esbuild。\n\n\n# 1.3 vite相较于webpack的优势\n\n> 然而，当我们开始构建越来越大型的应用时，需要处理的 javascript 代码量也呈指数级增长。包含数千个模块的大型项目相当普遍。基于 javascript 开发的工具就会开始遇到性能瓶颈：==通常需要很长时间（甚至是几分钟！）才能启动开发服务器，即使使用模块热替换（hmr），文件修改后的效果也需要几秒钟才能在浏览器中反映出来。==如此循环往复，迟钝的反馈会极大地影响开发者的开发效率和幸福感。\n\n起因：我们的项目越大，构建工具（webpack）所要处理的js代码就越多【跟webpack的一个构建过程（工作流程有关）】\n\n造成的结果：构建工具需要很长时间才能启动开发服务器（把项目跑起来）\n\nyarn start\nyarn dev\n\nnpm run dev\nnpm run start\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n> webpack不能改，如果要改，则会动到webpack的大动脉。\n> \n> // 这段代码最终回到浏览器里去运行\n> const lodash = require("lodash"); // commonjs 规范\n> import vue from "vue"; // es6 module\n> \n> // webpack是允许我们这么写的，webpack会这样转换\n> const lodash = webpack_require("loadsh");\n> const vue = webpack_require("vue");\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> \n> webpack的编译原理，ast抽象语法分析的工具，分析出js文件有哪些导入导出操作\n> \n> 构建工具是运行在服务端的\n> \n> (function(modules) {\n>     function webpack_require() {}\n>     // 入口是index.js\n>     // 通过webpack的配置文件得来的：webpack.config.js ./src/index.js\n>     modules[entry](webpack_require);\n> }, ({\n>     "index.js": (webpack_require) => {\n>         const lodash = webpack_require("lodash");\n> \t\tconst vue = webpack_require("vue");\n>     }\n> }))\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> \n> \n> 因为webpack支持模块化，它一开始就必须要统一模块化代码，所以意味着它需要将所有的依赖读一遍。\n> \n> vite会不会直接把webpack干翻？vite是基于es modules的，侧重点不一样，webpack更多的关注兼容性，而vite关注浏览器端的开发体验。\n\n\n# 2 vite启动项目初体验\n\n\n# 2.1 你必须要理解的vite脚手架和vite\n\n> vite官网搭建vite项目文档教程：https://cn.vitejs.dev/guide/#scaffolding-your-first-vite-project\n\n比如我们敲了yarn create vite\n\n 1. 帮我们全局安装了一个东西：create-vite（vite的脚手架）\n 2. 直接运行这个create-vite bin目录下的一个执行配置\n\n误区：认为官网中使用对应的yarn create构建项目的过程也是vite在做的事情\n\n> 我们之前接触过vue-cli，create-vite和vite的关系是：create-vite内置了vite。使用vue-cli会内置webpack\n\n先学习的就是vite，暂时不会使用yarn create vite my-vue-app --template vue。vue-cli可以和webpack分的很清楚。\n\n> vue-cli给我们提供已经精装修的模板。\n> \n> 我们自己搭建一个项目：下载vite，vue，post-css，less，label\n> \n> vue-cli/create-vite给了一套精装修的模板：什么都下好了，并且给你做了最佳实践的配置\n\n\n# 2.2 vite开箱即用\n\n> 开箱即用（out of box）：不需要做任何额外的配置就可以使用vite来帮你处理构建工作\n\n在默认情况下，我们的esmodule去导入资源的时候，要么是绝对路径，要么是相对路径，既然我们现在的最佳实践是node_modules，那么为什么es官方在我们导入非绝对路径和非相对路径的资源的时候不默认帮我们搜寻node_modules？\n\n> 浏览器环境中的安全性原因是一个主要考虑因素。如果浏览器默认搜索node_modules目录，那么恶意的代码可能会利用这个功能访问和执行不受信任的模块代码，从而导致安全风险。通过限制导入路径，浏览器可以更好地控制模块的来源和访问权限。\n> \n> 另外，性能也是一个重要的考虑因素。浏览器默认只支持绝对路径和相对路径的导入，可以在编译时静态解析模块依赖关系，从而提高加载和执行模块的效率。如果浏览器要搜索node_modules目录，可能需要进行额外的文件系统操作和路径解析，增加了加载模块的时间和资源消耗。\n\n\n# 2.3 vite的预加载\n\nimport _ from "lodash"; // lodash可能也import了其他的东西\n\nimport _vite_cjsimport0_lodash from "/node_modules/.vite/deps/loadsh.js?v=ebe57916";\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n在处理的过程中如果说看到了有非绝对路径或者相对路径的引用，则会尝试开启路径补全\n\n找寻依赖的过程是自当前目录依次向上查找的过程，直到搜寻到根目录或者搜寻到对应依赖为止 /user/node_modules/lodash, ../\n\n> 区分生产环境和开发环境：\n> \n> yarn dev ----\x3e 开发（每次依赖预构建所重新构建的相对路径都是正确的）\n> \n> vite会全权交给一个叫做rollup的库去完成生产环境的打包\n> \n> 缓存 ----\x3e\n> \n> 实际上vite在考虑另外一个问题的时候就顺便把这个问题解决了\n> \n> commonjs 规范的导出 module.exports\n> \n> 有的包是以commonjs规范的格式导出 axios\n> \n> 依赖预构建：首先vite会找到对应的依赖，然后调用esbuild（对js语法进行处理的一个库），将其他规范的代码转换成esmodule规范，然后放到当前目录下的node_modules/.vite/deps，同时对esmodule规范的各个模块进行统一集成\n\n所以它解决了3个问题：\n\n 1. 不同的第三方包会有不同的导出格式（这个是vite没法约束人家的事情）\n 2. 对路径的处理上可以直接使用.vite/deps，方便路径重写\n 3. 叫做网络多包传输的性能问题（也是原生esmodule规范不敢支持node_modules的原因之一），有了依赖预构建以后无论它有多少的额外的export和import，vite都会尽可能的将他们集成最后只生成一个或者几个模块\n\nvite.config.js === webpack.config.js\n\n\n# 2.4 vite配置文件处理细节\n\n 1. vite配置文件的语法提示\n    \n    1. 如果你使用的是webstorm，那你可以得到很好的语法补全\n    2. 如果你使用的是vscode或者其他编辑器，则需要做一些特殊处理\n\n 2. 关于环境的处理\n    \n    > 过去我们使用webpack的时候，我们需要区分配置文件的一个环境：\n    > \n    >  * webpack.dev.config\n    >  * webpack.prod.config\n    >  * webpack.base.config\n    >  * webpackmerge\n\n\n# 2.5 vue环境变量配置\n\n> 环境变量：会根据当前的代码环境产生值的变化的变量就叫做环境变量\n> \n> 代码环境：\n> \n>  1. 开发环境：开发环境是开发人员进行软件开发和调试的地方。在开发环境中，开发人员可以进行代码编写、调试、测试和验证。这个环境通常是本地的开发机器，开发人员可以通过使用 vite 的开发服务器（dev server）来提供实时的重新加载（live reloading）和模块热替换（hot module replacement）功能，以便更快地进行开发和调试。\n>  2. 测试环境：测试环境是用于进行软件测试的环境。在测试环境中，开发人员和测试人员可以对软件进行不同类型的测试，例如单元测试、集成测试和端到端测试。在测试环境中，可以使用 vite 构建工具生成测试所需的构建文件，并在模拟的环境中进行测试。\n>  3. 预发布环境：预发布环境是在软件发布之前进行最后测试和验证的环境。在预发布环境中，可以对软件进行更全面的测试，以确保它符合发布的质量标准。这个环境通常是一个类似于生产环境的环境，但在实际发布之前，可能会使用一些模拟数据和模拟系统进行测试。\n>  4. 灰度环境：灰度环境是在软件发布后逐步向用户群体推出新功能或更新的环境。在灰度环境中，新的软件版本或功能将部署到一小部分用户中，以便测试其稳定性和兼容性。这个环境类似于生产环境，但只有一部分用户能够访问新的功能或更新。\n>  5. 生产环境：生产环境是最终向用户提供服务的环境。在生产环境中，已经通过了开发、测试、预发布和灰度环境的验证，并且已准备好为最终用户提供稳定、可靠的服务。在生产环境中，通常会使用 vite 构建工具生成用于部署的生产级别的构建文件，并进行必要的优化和压缩，以提供最佳的性能和用户体验。\n\n我们在和后端同学对接的时候，前端在开发环境中请求的后端api地址和生产环境请求的后端api地址是一个吗？肯定不是一个\n\n * 开发和测试：http://test.api/\n * 生产：https://api/\n\n> 在vite中的环境变量处理：\n> \n> vite内置了dotenv这个第三方库，会自动读取.env文件，并解析这个文件中的对应的环境变量，并将其注入到process对象下（但是vite考虑到和其他配置的一些冲突问题，它不会直接注入到process对象下）\n> \n> 涉及到vite.config.js中的一些配置：\n> \n>  * root\n>  * envdir：用来配置当前环境变量的文件地址\n> \n> vite给我们提供了一些补偿措施：我们可以调用vite的loadenv来手动确认env文件\n> \n> porcess.cwd方法：返回node进程的工作目录\n\n> 小知识：为什么vite.config.js可以书写成esmodule的形式，这是因为vite他在读取这个vite.config.js的时候会率先node去解析文件语法，如果发现你是esmodule规范则会直接将你的esmodule规范替换成common js规范\n\n> .env：所有环境都需要用到的环境变量\n> \n> .env.development：开发环境需要用到的环境变量（默认情况下vite将我们的开发环境取名为development）\n> \n> .env.production：生产环境需要用到的环境变量（默认情况下vite将我们的生产环境取名为production）\n> \n> yarn dev --mode development 会将mode设置为development传递进来\n> \n> 当我们调用loadenv的时候，它会做如下几件事情：\n> \n>  1. 直接找到.env文件不解释，并解析其中的环境变量，放到一个对象里\n> \n>  2. 会将传进来的mode这个变量的值进行拼接：env.development，并根据我们提供的目录去取对应配置文件并进行解析，并放进一个对象\n> \n>  3. 我们可以理解为\n>     \n>     const baseenvconfig = 读取.env配置\n>     const modeenvconfig = 读取env相关配置\n>     const lastenvconfig = {...baseenvconfig, ...modeenvconfig}\n>     \n>     \n>     1\n>     2\n>     3\n>     \n>     1\n>     2\n>     3\n>     \n\n如果是客户端，vite会将对应的环境变量注入到import.meta.env里去\n\nvite做了一个拦截，为了防止我们将隐私性的变量直接送到import.meta.env中，所以做了一层拦截，如果你的环境变量不是以vite开头的，他就不会帮你注入到客户端中去，如果我们想要更改这个前缀，可以去使用envprefix配置。\n\n\n# 3 vite 原理篇\n\n\n# 3.1 vite是怎么让浏览器可以识别.vue文件呢\n\nvite 是一个现代化的前端构建工具，它使用了一种名为单文件组件（single file components）的技术来让浏览器能够识别和加载 .vue 文件。\n\n在传统的前端开发中，浏览器无法直接识别和加载 .vue 文件，因为 .vue 文件包含了 html、css 和 javascript 代码，而浏览器只能识别和执行 javascript 文件。\n\nvite 利用了构建工具和打包器的能力，在开发阶段将 .vue 文件转换为浏览器可以识别的形式。它借助特定的编译器（如 vue 编译器）将 .vue 文件的模板、样式和脚本部分分别提取出来，并将它们转换为浏览器可以理解的代码。\n\n具体地说，vite 使用了名为 "vue-loader" 的工具来解析和转换 .vue 文件。这个工具会解析 .vue 文件的内容，提取出其中的模板、样式和脚本，并将它们转化为独立的代码块。然后，vite 使用浏览器原生的 es 模块导入机制，通过 <script type="module"> 标签将这些代码块加载到浏览器中。\n\n当浏览器遇到 <script type="module"> 标签时，它会将标签中的 javascript 代码作为一个独立的模块加载和执行。vite 利用这个特性，将 .vue 文件中的模板、样式和脚本部分分别作为独立的模块加载到浏览器中，并在浏览器中动态组合它们，构建出最终的组件。\n\n\n# 3.2 使用path.resolve的原因\n\n> 在使用路径时，尽量使用 path.resolve 方法可以确保路径的可靠性和跨平台性。以下是几个使用 path.resolve 方法的好处：\n> \n>  1. 处理相对路径和绝对路径：path.resolve 方法可以接受多个参数，将它们解析为一个绝对路径。这意味着你可以使用相对路径作为参数，并将其解析为相对于当前工作目录的绝对路径。这对于确定准确的文件路径非常有用。\n>  2. 解决跨平台路径问题：在不同的操作系统中，对于路径分隔符和路径表示法有所差异。使用 path.resolve 方法可以确保生成的路径在不同的操作系统下都是有效的，因为它会自动根据当前操作系统调整路径分隔符和表示法。\n>  3. 处理路径拼接和规范化：path.resolve 方法会将传入的路径片段进行拼接，并返回一个规范化的路径。这意味着它会解析和处理路径中的 ..、. 等相对路径符号，确保生成的路径是规范化的、干净的路径。\n>  4. 确保路径的存在性：使用 path.resolve 方法生成的路径是确保存在的，它不会检查路径是否有效或文件是否存在，但会确保路径的格式正确。这可以帮助你在操作文件系统时提供正确的路径，避免出现错误或异常。\n\n\n# 4 vite与css\n\n\n# 4.1 在vite中处理css\n\n> vite天生就支持对css文件的直接处理\n\n 1. vite在读取到main.js文件中引用到了index.css\n 2. 直接使用fs模块去读取index.css中文件内容\n 3. 直接创建一个style标签，将index.css中文件内容直接copy到style标签里\n 4. 将style标签插入到index.html的head中\n 5. 将css文件中的内容直接替换为js脚本（方便热更新或者css模块化），同时设置content-type为js，从而让浏览器以js脚本的形式来执行该css后缀的文件\n\n> 场景：\n> \n>  * 一个组件最外层的元素类名一般取名： wrapper\n>  * 一个组件最底层的元素类名一般取名：footer\n> \n> 但你取了footer这个名字，别人因为没有看过你这个组件的源代码，也可能去取名footer这个类名，最后可能会导致样式被覆盖（因为类名重复），这就是我们在协同开发很容易出现的问题\n\ncssmodule就是来解决这个问题的：\n\n 1. module.css（module是一种约定，表示需要开启css模块化）\n 2. 他会将你的所有类名进行一定规则的替换（将footer替换为_footer_i22st_1）\n 3. 同时创建一个映射对象{ footer: "_footer_i22st_1"}\n 4. 将替换过后的内容塞进style标签里然后放入到head标签中（能够读到index.html的文件内容）\n 5. 将componenta.module.css内容全部抹除，替换为js脚本\n 6. 将创建的映射对象在脚本中默认导出\n\n\n# 4.2 css文件类型\n\n>  1. css（.css）：css 是层叠样式表的标准文件格式，它使用类似于选择器和属性的语法来描述网页的样式。css 是前端开发中最常见的样式表语言，浏览器原生支持。\n>  2. less（.less）：less 是 css 的拓展，它引入了变量、嵌套规则、mixin（混入）等功能，以简化 css 的编写和维护。less 文件需要在开发阶段通过 less 编译器转换为标准的 css 文件，然后在浏览器中加载。\n>  3. scss/sass（.scss/.sass）：scss（sassy css）和 sass（syntactically awesome style sheets）也是 css 的拓展，提供了类似 less 的功能，如变量、嵌套规则和 mixin。scss 与 sass 的语法略有不同，但都需要通过编译器将其转换为标准的 css 文件。\n\n/* scss */\n.container {\n  width: 100%;\n\n  .header {\n    background-color: #333;\n    color: #fff;\n    padding: 10px;\n  }\n\n  .content {\n    padding: 20px;\n\n    p {\n      margin-bottom: 10px;\n    }\n\n    a {\n      color: #f00;\n      text-decoration: none;\n\n      &:hover {\n        text-decoration: underline;\n      }\n    }\n  }\n\n  .footer {\n    background-color: #333;\n    color: #fff;\n    padding: 10px;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n在这个示例中，.container 是最外层的容器选择器，它包含了 .header、.content 和 .footer 子选择器。通过嵌套定义，我们可以更直观地表示这些选择器之间的层次结构。\n\n此外，嵌套定义还可以减少重复代码的编写。在上述示例中，.header 和 .footer 具有相同的背景颜色、文字颜色和内边距，通过嵌套定义，我们只需在父选择器中指定一次即可，避免了重复的样式声明。\n\n另外，嵌套定义还可以方便地应用伪类和伪元素样式。在示例中，嵌套定义了 a 元素的样式，并使用 &:hover 表示其悬停状态下的样式，这样可以更直观地表示选择器之间的关系。\n\n通过使用嵌套定义，我们可以更清晰地组织和维护样式代码，减少了冗余和重复的工作，提高了代码的可读性和可维护性。\n\n\n# 4.3 vite.config.js中css配置\n\n> 在vite.config.js中我们通过css属性去控制整个vite对于css的处理行为\n\n# 4.3.1 module篇\n\ncss: { \n    \n    modules: { \n    }\n}\ncss: { // 对css的行为进行配置\n  // modules配置最终会丢给postcss modules\n  modules: { // 是对css模块化的默认行为进行覆盖\n    localsconvention: \'camelcase\', // 修改生成的配置对象的 key 的展示形式为驼峰命名\n    scopebehaviour: \'global\', // 配置当前的模块化行为为全局化\n    generatescopedname: \'[name]__[local]___[hash:base64:5]\', // 指定生成的类名的命名规则\n    hashprefix: \'my-app\', // 生成的 hash 的前缀\n    globalmodulepaths: [\'path/to/global/styles\'] // 不参与 css 模块化的路径\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * localsconvention：修改生成的配置对象的key的展示形式（驼峰还是中划线形式）\n * scopebehaviour：配置当前的模块化行为是模块化还是全局化（有hash就是开启了模块化的一个标志，因为它可以保证产生不同的hash值来控制我们的样式类名不被覆盖）\n * generatescopedname：[name_[local]_[hash:5]]，指定生成的类名的命名规则（可以配置为函数，也可以配置成字符串规则）\n * hashprefix：生成的hash会根据你的类名进行生成，如果想要你生成的hash更加的独特一点，你可以配置hashprefix，你配置的这个字符串会参与到最终的hash生成\n * globalmodulepaths：代表你不想参与到css模块化的路径\n\n# 4.3.2 preprocessoroption篇\n\n> 主要是用来配置css预处理的一些全局参数\n\ncss: {\n  preprocessoroptions: {\n    // 配置 css 预处理器的全局参数\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n在 preprocessoroptions 中，你可以配置 css 预处理器的一些全局参数，具体参数的配置取决于你使用的预处理器（如 sass、less 等）。这里可以配置一些通用的选项，比如：\n\n * additionaldata：额外的全局样式数据，可以在每个 css 文件的顶部注入，例如共享的变量、混合器等。\n * sass：用于配置 sass 预处理器的选项，如 sass 选项中的 indentedsyntax 表示是否使用缩进语法。\n * less：用于配置 less 预处理器的选项，如 less 选项中的 javascriptenabled 表示是否启用 less 中的 javascript 表达式。\n\n# 4.3.2 postcss篇\n\nimport autoprefixer from \'autoprefixer\';\n\nexport default {\n  // ...\n  css: {\n    postcss: {\n      plugins: [\n        autoprefixer(), // 配置 postcss 插件，例如 autoprefixer\n        // 其他的 postcss 插件...\n      ]\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在 postcss 配置项中，你可以指定要使用的 postcss 插件。在示例中，我们使用了一个常见的插件 autoprefixer，它用于自动添加 css 浏览器前缀，以提供跨浏览器兼容性。\n\n你可以根据需要，将其他的 postcss 插件添加到 plugins 数组中。这些插件可以用于执行各种 css 处理任务，例如压缩、优化、转换等。\n\n需要注意的是，为了使用特定的 postcss 插件，你需要在项目中安装这些插件的相应依赖，并在 vite.config.js 文件中进行正确的导入和配置。\n\n此外，你还可以在 postcss 配置项中设置其他选项，例如 config、sourcemap 等，以满足特定的需求。具体的配置选项和语法规则可以参考 postcss 插件的文档或相关资源。\n\n\n# 5 vite相关知识\n\n\n# 5.1 vite加载静态资源\n\n> 什么是静态资源？\n> \n> 静态资源是指不需要经过构建处理的文件，例如图片、视频、字体等，除了动态api以外，百分之九十九的资源都被视作静态资源\n\nvite对静态资源基本上是开箱即用的，除了一些特殊情况（svg）\n\n要加载静态资源，你可以将它们放置在你的项目目录中的任何位置。通常，你可以将这些静态资源放置在你的项目根目录下的 public 文件夹中，这是一个预定义的静态资源文件夹。当你在代码中引用这些静态资源时，vite 会自动将它们提供给你的应用程序。\n\n例如，如果在你的项目中有一个名为 public 的文件夹，并且在其中有一个图片文件 logo.png，你可以在代码中像下面这样引用它：\n\n<img src="/logo.png" alt="logo" />\n\n\n1\n\n1\n\n\nvite 会自动将此路径解析为相应的静态资源，并将其提供给你的应用程序。\n\n需要注意的是，在 vite 中，你可以使用相对于根目录的绝对路径来引用静态资源，而无需考虑模块化的路径解析。这是因为 vite 使用自己的开发服务器，能够在运行时动态处理这些静态资源的请求。\n\n对于某些特殊的静态资源，如 svg 文件，你可能需要额外的配置来确保正确加载。对于 svg 文件，你可以使用 @vitejs/plugin-svg 插件来处理。你可以按照 vite 官方文档中的说明，添加该插件并进行相应的配置。\n\n\n# 5.2 vite在生产环境中对静态资源的处理\n\n>  1. 静态资源的导入和处理： 在你的代码中，如果有静态资源的导入语句（如图片、字体、css 文件等），vite 会根据这些导入语句自动处理这些资源。\n>  2. 资源优化和压缩： vite 会对导入的静态资源进行优化和压缩，以减小文件大小并提升加载性能。这包括但不限于压缩图片、压缩和合并 css 文件等操作。\n>  3. 指纹化文件名： 为了更好的缓存管理和更新机制，vite 会为处理后的静态资源生成带有指纹的文件名。这意味着每个文件都会有一个唯一的哈希值作为文件名的一部分，例如 logo.8e4c5f7b.png。当文件内容发生变化时，哈希值也会发生变化，从而确保客户端能够正确地缓存和更新静态资源。\n>  4. 输出静态资源： 处理后的静态资源会被输出到构建目录（默认为 dist）中。vite 会根据资源类型生成相应的文件，如图片会生成 .png、.jpg 等文件，css 文件会生成 .css 文件等。\n>  5. 引用静态资源： 在你的 html 文件或生成的代码中，vite 会自动更新静态资源的引用路径，以指向构建目录中的正确文件。这样，在生产环境中，你可以直接使用相对于构建目录的路径来引用静态资源，而无需关心开发环境中的模块解析和路径处理。\n\n\n# 5.3 vite常用插件\n\n> 插件是什么？\n> \n> vite会在生命周期的不同阶段中调用不同的插件以达到不同的目的\n> \n> 生命周期：vite从开始执行到执行结束\n\n# 5.3.1 vite-aliases\n\n> 作用：别名自动生成\n> \n> 安装：yarn add vite-aliases -d\n> \n> 将其添加到vite.config.js中\n> \n> // vite.config.js\n> import { vitealiases } from \'vite-aliases\'\n> \n> export default {\n>   plugins: [\n>     vitealiases()\n>   ]\n> };\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n\nvite-aliases的可选配置项如下：\n\nvitealiases({\n  /**\n  * relative path to the project directory\n  */\n  dir: \'src\',\n\n  /**\n  * prefix symbol for the aliases\n  */\n  prefix: \'~\',\n\n  /**\n  * allow searching for subdirectories\n  */\n  deep: true,\n\n  /**\n  * search depthlevel for subdirectories\n  */\n  depth: 1,\n\n  /**\n  * creates a logfile\n  * use `logpath` to change the location\n  */\n  createlog: false,\n\n  /**\n  * path for logfile\n  */\n  logpath: \'src/logs\',\n\n  /**\n  * create global project directory alias\n  */\n  createglobalalias: true,\n\n  /**\n  * turns duplicates into camelcased path aliases\n  */\n  adjustduplicates: false,\n\n  /**\n  * used paths in js/ts configs will now be relative to baseurl\n  */\n  useabsolute: false,\n\n  /**\n  * adds seperate index paths\n  * approach created by @davidohlin\n  */\n  useindexes: false,\n\n  /**\n  * generates paths in ide config file\n  * works with js or ts\n  */\n  useconfig: true,\n\n  /**\n  * override config paths\n  */\n  ovrconfig: false,\n\n  /**\n  * will generate paths in tsconfig\n  * used in combination with `useconfig`\n  * typescript will be auto detected\n  */\n  dts: false,\n\n  /**\n  * disables any terminal output\n  */\n  silent: true,\n\n  /**\n  * root path of vite project\n  */\n  root: process.cwd()\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n\n# 5.3.2 vite-plugin-html\n\n> 功能：\n> \n>  1. html 压缩能力\n>  2. ejs 模版能力\n>  3. 多页应用支持\n>  4. 支持自定义entry\n>  5. 支持自定义template\n> \n> 安装：yarn add vite-plugin-html -d\n> \n> 将其添加到vite.config.js中\n\n> 用法：\n> \n> 将ejs标签添加到index.html中\n> \n> <head>\n>   <meta charset="utf-8" />\n>   <link rel="icon" href="/favicon.ico" />\n>   <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n>   <title><%- title %></title>\n>   <%- injectscript %>\n> </head>\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> \n> \n> 在vite.config.js中配置，该方法可以根据需要引入需要的功能\n> \n> import { defineconfig, plugin } from \'vite\'\n> import vue from \'@vitejs/plugin-vue\'\n> \n> import { createhtmlplugin } from \'vite-plugin-html\'\n> \n> export default defineconfig({\n>   plugins: [\n>     vue(),\n>     createhtmlplugin({\n>       minify: true,\n>       /**\n>        * after writing entry here, you will not need to add script tags in `index.html`, the original tags need to be deleted\n>        * @default src/main.ts\n>        */\n>       entry: \'src/main.ts\',\n>       /**\n>        * if you want to store `index.html` in the specified folder, you can modify it, otherwise no configuration is required\n>        * @default index.html\n>        */\n>       template: \'public/index.html\',\n> \n>       /**\n>        * data that needs to be injected into the index.html ejs template\n>        */\n>       inject: {\n>         data: {\n>           title: \'index\',\n>           injectscript: `<script src="./inject.js"><\/script>`,\n>         },\n>         tags: [\n>           {\n>             injectto: \'body-prepend\',\n>             tag: \'div\',\n>             attrs: {\n>               id: \'tag\',\n>             },\n>           },\n>         ],\n>       },\n>     }),\n>   ],\n> })\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n> 19\n> 20\n> 21\n> 22\n> 23\n> 24\n> 25\n> 26\n> 27\n> 28\n> 29\n> 30\n> 31\n> 32\n> 33\n> 34\n> 35\n> 36\n> 37\n> 38\n> 39\n> 40\n> 41\n> 42\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n> 19\n> 20\n> 21\n> 22\n> 23\n> 24\n> 25\n> 26\n> 27\n> 28\n> 29\n> 30\n> 31\n> 32\n> 33\n> 34\n> 35\n> 36\n> 37\n> 38\n> 39\n> 40\n> 41\n> 42\n\n# 5.3.3 vite-plugin-mock\n\n> mock数据：模拟数据\n> \n> 前后端一般是并行开发，用户列表（接口文档）\n> \n> mock数据，去做你前端的工作\n> \n>  1. 简单方式：直接去写死一两个数据，方便调试。\n>     * 缺陷：没法做海量数据测试\n>     * 没法获得一些标准数据\n>     * 没法去感知http的异常\n>  2. mockjs：模拟海量数据的，vite-plugin-mock的依赖项是mockjs\n\n> 安装：\n> \n> yarn add mockjs -d\n> yarn add vite-plugin-mock -d\n> \n> \n> 1\n> 2\n> \n> 1\n> 2\n> \n> \n> 使用方法：https://github.com/vbenjs/vite-plugin-mock\n\n# 5.3.4 其他插件\n\n插件地址',charsets:{cjk:!0}},{title:"设计模式之工厂模式详解（Java实现）",frontmatter:{title:"设计模式之工厂模式详解（Java实现）",date:"2022-04-21T21:37:32.000Z",tags:["工厂模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/f4cb7a/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89.html",relativePath:"01.开发/02.开发框架/03.设计模式/01.设计模式之工厂模式详解（Java实现）.md",key:"v-7cd58e9b",path:"/pages/f4cb7a/",headers:[{level:2,title:"1 工厂模式介绍",slug:"_1-工厂模式介绍",normalizedTitle:"1 工厂模式介绍",charIndex:2},{level:2,title:"2 工厂模式详解",slug:"_2-工厂模式详解",normalizedTitle:"2 工厂模式详解",charIndex:730},{level:3,title:"2.1 简单工厂模式",slug:"_2-1-简单工厂模式",normalizedTitle:"2.1 简单工厂模式",charIndex:743},{level:4,title:"2.1.1 简单工厂模式结构",slug:"_2-1-1-简单工厂模式结构",normalizedTitle:"2.1.1 简单工厂模式结构",charIndex:757},{level:4,title:"2.1.2 简单工厂模式实现",slug:"_2-1-2-简单工厂模式实现",normalizedTitle:"2.1.2 简单工厂模式实现",charIndex:1078},{level:4,title:"2.1.3 简单工厂模式应用举例",slug:"_2-1-3-简单工厂模式应用举例",normalizedTitle:"2.1.3 简单工厂模式应用举例",charIndex:1961},{level:3,title:"2.2 工厂方法模式",slug:"_2-2-工厂方法模式",normalizedTitle:"2.2 工厂方法模式",charIndex:2270},{level:4,title:"2.2.1 工厂方法模式结构",slug:"_2-2-1-工厂方法模式结构",normalizedTitle:"2.2.1 工厂方法模式结构",charIndex:2284},{level:4,title:"2.2.2 工厂方法模式实现",slug:"_2-2-2-工厂方法模式实现",normalizedTitle:"2.2.2 工厂方法模式实现",charIndex:2739},{level:4,title:"2.2.3 工厂方法模式应用举例",slug:"_2-2-3-工厂方法模式应用举例",normalizedTitle:"2.2.3 工厂方法模式应用举例",charIndex:3443},{level:3,title:"2.3 抽象工厂模式",slug:"_2-3-抽象工厂模式",normalizedTitle:"2.3 抽象工厂模式",charIndex:3875},{level:4,title:"2.3.1 抽象工厂模式结构",slug:"_2-3-1-抽象工厂模式结构",normalizedTitle:"2.3.1 抽象工厂模式结构",charIndex:3889},{level:4,title:"2.3.2 抽象工厂模式实现",slug:"_2-3-2-抽象工厂模式实现",normalizedTitle:"2.3.2 抽象工厂模式实现",charIndex:4438},{level:4,title:"2.2.3 抽象工厂模式应用举例",slug:"_2-2-3-抽象工厂模式应用举例",normalizedTitle:"2.2.3 抽象工厂模式应用举例",charIndex:4955}],headersStr:"1 工厂模式介绍 2 工厂模式详解 2.1 简单工厂模式 2.1.1 简单工厂模式结构 2.1.2 简单工厂模式实现 2.1.3 简单工厂模式应用举例 2.2 工厂方法模式 2.2.1 工厂方法模式结构 2.2.2 工厂方法模式实现 2.2.3 工厂方法模式应用举例 2.3 抽象工厂模式 2.3.1 抽象工厂模式结构 2.3.2 抽象工厂模式实现 2.2.3 抽象工厂模式应用举例",content:'# 1 工厂模式介绍\n\n工厂顾名思义就是创建产品，根据产品是具体产品还是具体工厂可分为简单工厂模式（Simple Factory Pattern）和工厂方法模式（Factory Method Pattern），根据工厂的抽象程度可分为工厂方法模式和抽象工厂模式（Abstract Factory Pattern）。该模式用于封装和管理对象的创建，是一种创建型模式。\n\n这样看我们工厂模式（Factory Pattern）可以分为三类，但其中简单工厂其实不是一个标准的的设计模式。GOF 23 种设计模式中只有「工厂方法模式」与「抽象工厂模式」。简单工厂模式可以看为工厂方法模式的一种特例。\n\n在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。\n\n它的优点如下：\n\n * 可以使代码结构清晰，有效地封装变化。\n * 对调用者屏蔽具体的产品类\n * 降低耦合度。\n\n> 适用场景：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。\n> \n> 其次，工厂模式是一种典型的解耦模式，迪米特法则在工厂模式中表现的尤为明显。假如调用者自己组装产品需要增加依赖关系时，可以考虑使用工厂模式，将会大大降低对象之间的耦合度。再次，由于工厂模式是依靠抽象架构的，它把实例化产品的任务交由实现类完成，扩展性比较好。也就是说，当需要系统有比较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装。\n\n\n# 2 工厂模式详解\n\n\n# 2.1 简单工厂模式\n\n# 2.1.1 简单工厂模式结构\n\n该模式对对象创建管理方式最为简单，因为其仅仅简单的对不同类对象的创建进行了一层薄薄的封装。该模式通过向工厂传递类型来指定要创建的对象，其UML类图如下：\n\n\n\n其中根据上图可知，简单工厂模式包含以下3个角色。\n\n 1. Factory（工厂角色）：即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；其可以被外界直接调用，创建所需的产品对象。\n 2. AbstractProduct（抽象产品角色）：它是工厂类创建的所有对象的父类，封装了各种产品对象的共有方法。\n 3. Product1（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。\n\n# 2.1.2 简单工厂模式实现\n\n典型的抽象产品类代码如下：\n\npublic abstract class AbstractProduct {\n    // 所有产品类的公共业务方法\n    public void methodSame() {\n        // 公有方法的实现\n    }\n    // 声明抽象业务方法\n    public abstract void methodDiff() {\n        \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n典型的具体产品类的代码如下：\n\npublic class Product1 extends AbstractProduct {\n    // 实现业务方法\n    public void methodDiff() {\n        // 业务方法的实现\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n典型的工厂类的代码如下：\n\npublic class Factory {\n    // 静态工厂方法\n    public static AbstractProduct createProduct(String arg) {\n        AbstractProduct product = null;\n        if (arg.equalsIgnoreCase("1")) {\n            product = new Product1();\n        } else if (arg.equalsIgnoreCase("2")) {\n            product = new Product2();\n        }\n        return product;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n客户端代码中，通过调用工厂类的工厂方法即可得到产品对象。\n\n# 2.1.3 简单工厂模式应用举例\n\n * 题目描述\n   \n   > 使用简单工厂模式设计一个可以创建不同几何图形（Shape），如Circle，Rectangle，Triangle等绘图工具类，每个几何图形均具有绘制draw()和擦除erase()两个方法；要求在绘制不支持的几何图形时，抛出一个UnsuppShapeException异常，绘制类图并使用Java语言实现。\n\n * UML类图\n   \n   \n   \n   其中，Shape接口充当抽象产品，其子类Circle、Rectangle、Triangle等充当具体产品，ShapeFactory充当工厂类。\n\n * 代码\n   \n   代码地址\n\n\n# 2.2 工厂方法模式\n\n# 2.2.1 工厂方法模式结构\n\n和简单工厂模式中工厂负责生产所有产品相比，工厂方法模式将生成具体产品的任务分发给具体的产品工厂，也就是定义一个抽象工厂，其定义了产品的生产接口，但不负责具体的产品，将生产任务交给不同的派生类工厂。这样不用通过指定类型来创建对象了。其UML类图如下：\n\n\n\n由上图可知，工厂方法模式包含以下四个角色。\n\n 1. AbstractProduct（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的公共父类。\n 2. Product1（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。\n 3. AbstractFactory（抽象工厂）：在抽象工厂类中声明了工厂方法，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。\n 4. ConcreteFactory1（具体工厂）：它是抽象工厂类的子类，实现了在抽象工厂中声明的工厂方法，并可由客户端调用，返回一个具体产品类的实例。\n\n# 2.2.2 工厂方法模式实现\n\n典型的抽象产品类代码如下：\n\npublic abstract class AbstractProduct {\n    // 所有产品类的公共业务方法\n    public void methodSame() {\n        // 公有方法的实现\n    }\n    // 声明抽象业务方法\n    public abstract void methodDiff() {\n        \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n典型的具体产品类的代码如下：\n\npublic class Product1 extends AbstractProduct {\n    // 实现业务方法\n    public void methodDiff() {\n        // 业务方法的实现\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n典型的抽象工厂代码如下：\n\npublic interface AbstractFactory {\n    public Product createProduct();\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n典型的具体工厂代码如下：\n\npublic class ConcreteFactory1 implements Factory {\n    public Product createProduct() {\n        return new Product1();\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n# 2.2.3 工厂方法模式应用举例\n\n * 题目描述\n   \n   > 现需要设计一个程序来读取多种不同类型的图片格式，针对每一种图片格式都设计一个图片读取器（ImgReader），如gif图片读取器（GifReader）用于读取gif格式的图片,jpg图片读取器（JpgReader）用于读取jpg格式的图片。图片读取器对象通过图片读取器工厂ImgReaderFactory来创建。ImgReaderFactory是一个抽象类，用于定义创建图片读取器的工厂方法，其GifReaderFactory和JpgReaderFactory用于创建具体的图片读取器对象。\n\n * UML类图\n\n\n\n其中，接口ImageReaderFactory充当抽象工厂，GifReaderFactory和JpgReaderFactory充当具体工厂，ImageReader充当抽象产品，GifReader和JpgReader充当具体产品。\n\n * 代码\n   \n   代码地址\n\n\n# 2.3 抽象工厂模式\n\n# 2.3.1 抽象工厂模式结构\n\n上面两种模式不管工厂怎么拆分抽象，都只是针对一类产品（AbstractProduct），应该怎么表示呢？\n\n最简单的方式是把2中介绍的工厂方法模式完全复制一份，不过这次生产的是另一类产品。但同时也就意味着我们要完全复制和修改原来生产管理的所有代码，显然这是一个笨办法，并不利于扩展和维护。\n\n抽象工厂模式通过在AbstarctFactory中增加创建产品的接口，并在具体子工厂中实现新加产品的创建，当然前提是子工厂支持生产该产品。否则继承的这个接口可以什么也不干。其UML图如下：\n\n\n\n由上图可知，抽象工厂模式包含以下四个角色。\n\n 1. AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。\n 2. Product1（具体产品）：它定义具体工厂生产的具体产品的具体产品对象，实现抽象产品接口中声明的业务方法。\n 3. AbstractFactory（抽象工厂）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。\n 4. ConcreteFactory1（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。\n\n# 2.3.2 抽象工厂模式实现\n\n抽象工厂类典型代码如下：\n\npublic interface AbstractFactory {\n    public AbstractProduct1 createProduct1(); // 工厂方法一\n    public AbstractProduct2 createProduct2(); // 工厂方法、二\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n具体工厂类典型代码如下：\n\npublic class ConcreteFactory1 implements AbstractFactory {\n    // 工厂方法一\n    public AbstractProduct1 createProduct1() {\n        return new Product1();\n    }\n    // 工厂方法二\n    public AbstractProduct2 createProduct2() {\n        return new Product2();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 2.2.3 抽象工厂模式应用举例\n\n * 题目描述\n   \n   > 抽象工厂模式最早的应用是用于创建分属于不同操作系统的视窗构建。比如:命令按键(Button)与文字框(Text)都是视窗构件，在Unix、Windows和Linux操作系统的视窗环境中，这两个构件有不同的本地实现，它们的细节也有所不同。试使用抽象工厂模式来设计并模拟实现该结构。\n\n * UML类图\n   \n   \n   \n   其中，接口AbstractFactory充当抽象工厂，其子类WindowsFactory、UnixFactory和LinuxFactory充当具体工厂；Text和Button充当抽象产品，其子类WindowsText、UnixText、LinuxText和WindowsButton、UnixButton、LinuxButton充当具体产品。\n\n * 代码\n   \n   代码地址',normalizedContent:'# 1 工厂模式介绍\n\n工厂顾名思义就是创建产品，根据产品是具体产品还是具体工厂可分为简单工厂模式（simple factory pattern）和工厂方法模式（factory method pattern），根据工厂的抽象程度可分为工厂方法模式和抽象工厂模式（abstract factory pattern）。该模式用于封装和管理对象的创建，是一种创建型模式。\n\n这样看我们工厂模式（factory pattern）可以分为三类，但其中简单工厂其实不是一个标准的的设计模式。gof 23 种设计模式中只有「工厂方法模式」与「抽象工厂模式」。简单工厂模式可以看为工厂方法模式的一种特例。\n\n在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。\n\n它的优点如下：\n\n * 可以使代码结构清晰，有效地封装变化。\n * 对调用者屏蔽具体的产品类\n * 降低耦合度。\n\n> 适用场景：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。\n> \n> 其次，工厂模式是一种典型的解耦模式，迪米特法则在工厂模式中表现的尤为明显。假如调用者自己组装产品需要增加依赖关系时，可以考虑使用工厂模式，将会大大降低对象之间的耦合度。再次，由于工厂模式是依靠抽象架构的，它把实例化产品的任务交由实现类完成，扩展性比较好。也就是说，当需要系统有比较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装。\n\n\n# 2 工厂模式详解\n\n\n# 2.1 简单工厂模式\n\n# 2.1.1 简单工厂模式结构\n\n该模式对对象创建管理方式最为简单，因为其仅仅简单的对不同类对象的创建进行了一层薄薄的封装。该模式通过向工厂传递类型来指定要创建的对象，其uml类图如下：\n\n\n\n其中根据上图可知，简单工厂模式包含以下3个角色。\n\n 1. factory（工厂角色）：即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；其可以被外界直接调用，创建所需的产品对象。\n 2. abstractproduct（抽象产品角色）：它是工厂类创建的所有对象的父类，封装了各种产品对象的共有方法。\n 3. product1（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。\n\n# 2.1.2 简单工厂模式实现\n\n典型的抽象产品类代码如下：\n\npublic abstract class abstractproduct {\n    // 所有产品类的公共业务方法\n    public void methodsame() {\n        // 公有方法的实现\n    }\n    // 声明抽象业务方法\n    public abstract void methoddiff() {\n        \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n典型的具体产品类的代码如下：\n\npublic class product1 extends abstractproduct {\n    // 实现业务方法\n    public void methoddiff() {\n        // 业务方法的实现\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n典型的工厂类的代码如下：\n\npublic class factory {\n    // 静态工厂方法\n    public static abstractproduct createproduct(string arg) {\n        abstractproduct product = null;\n        if (arg.equalsignorecase("1")) {\n            product = new product1();\n        } else if (arg.equalsignorecase("2")) {\n            product = new product2();\n        }\n        return product;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n客户端代码中，通过调用工厂类的工厂方法即可得到产品对象。\n\n# 2.1.3 简单工厂模式应用举例\n\n * 题目描述\n   \n   > 使用简单工厂模式设计一个可以创建不同几何图形（shape），如circle，rectangle，triangle等绘图工具类，每个几何图形均具有绘制draw()和擦除erase()两个方法；要求在绘制不支持的几何图形时，抛出一个unsuppshapeexception异常，绘制类图并使用java语言实现。\n\n * uml类图\n   \n   \n   \n   其中，shape接口充当抽象产品，其子类circle、rectangle、triangle等充当具体产品，shapefactory充当工厂类。\n\n * 代码\n   \n   代码地址\n\n\n# 2.2 工厂方法模式\n\n# 2.2.1 工厂方法模式结构\n\n和简单工厂模式中工厂负责生产所有产品相比，工厂方法模式将生成具体产品的任务分发给具体的产品工厂，也就是定义一个抽象工厂，其定义了产品的生产接口，但不负责具体的产品，将生产任务交给不同的派生类工厂。这样不用通过指定类型来创建对象了。其uml类图如下：\n\n\n\n由上图可知，工厂方法模式包含以下四个角色。\n\n 1. abstractproduct（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的公共父类。\n 2. product1（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。\n 3. abstractfactory（抽象工厂）：在抽象工厂类中声明了工厂方法，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。\n 4. concretefactory1（具体工厂）：它是抽象工厂类的子类，实现了在抽象工厂中声明的工厂方法，并可由客户端调用，返回一个具体产品类的实例。\n\n# 2.2.2 工厂方法模式实现\n\n典型的抽象产品类代码如下：\n\npublic abstract class abstractproduct {\n    // 所有产品类的公共业务方法\n    public void methodsame() {\n        // 公有方法的实现\n    }\n    // 声明抽象业务方法\n    public abstract void methoddiff() {\n        \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n典型的具体产品类的代码如下：\n\npublic class product1 extends abstractproduct {\n    // 实现业务方法\n    public void methoddiff() {\n        // 业务方法的实现\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n典型的抽象工厂代码如下：\n\npublic interface abstractfactory {\n    public product createproduct();\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n典型的具体工厂代码如下：\n\npublic class concretefactory1 implements factory {\n    public product createproduct() {\n        return new product1();\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n# 2.2.3 工厂方法模式应用举例\n\n * 题目描述\n   \n   > 现需要设计一个程序来读取多种不同类型的图片格式，针对每一种图片格式都设计一个图片读取器（imgreader），如gif图片读取器（gifreader）用于读取gif格式的图片,jpg图片读取器（jpgreader）用于读取jpg格式的图片。图片读取器对象通过图片读取器工厂imgreaderfactory来创建。imgreaderfactory是一个抽象类，用于定义创建图片读取器的工厂方法，其gifreaderfactory和jpgreaderfactory用于创建具体的图片读取器对象。\n\n * uml类图\n\n\n\n其中，接口imagereaderfactory充当抽象工厂，gifreaderfactory和jpgreaderfactory充当具体工厂，imagereader充当抽象产品，gifreader和jpgreader充当具体产品。\n\n * 代码\n   \n   代码地址\n\n\n# 2.3 抽象工厂模式\n\n# 2.3.1 抽象工厂模式结构\n\n上面两种模式不管工厂怎么拆分抽象，都只是针对一类产品（abstractproduct），应该怎么表示呢？\n\n最简单的方式是把2中介绍的工厂方法模式完全复制一份，不过这次生产的是另一类产品。但同时也就意味着我们要完全复制和修改原来生产管理的所有代码，显然这是一个笨办法，并不利于扩展和维护。\n\n抽象工厂模式通过在abstarctfactory中增加创建产品的接口，并在具体子工厂中实现新加产品的创建，当然前提是子工厂支持生产该产品。否则继承的这个接口可以什么也不干。其uml图如下：\n\n\n\n由上图可知，抽象工厂模式包含以下四个角色。\n\n 1. abstractproduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。\n 2. product1（具体产品）：它定义具体工厂生产的具体产品的具体产品对象，实现抽象产品接口中声明的业务方法。\n 3. abstractfactory（抽象工厂）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。\n 4. concretefactory1（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。\n\n# 2.3.2 抽象工厂模式实现\n\n抽象工厂类典型代码如下：\n\npublic interface abstractfactory {\n    public abstractproduct1 createproduct1(); // 工厂方法一\n    public abstractproduct2 createproduct2(); // 工厂方法、二\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n具体工厂类典型代码如下：\n\npublic class concretefactory1 implements abstractfactory {\n    // 工厂方法一\n    public abstractproduct1 createproduct1() {\n        return new product1();\n    }\n    // 工厂方法二\n    public abstractproduct2 createproduct2() {\n        return new product2();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 2.2.3 抽象工厂模式应用举例\n\n * 题目描述\n   \n   > 抽象工厂模式最早的应用是用于创建分属于不同操作系统的视窗构建。比如:命令按键(button)与文字框(text)都是视窗构件，在unix、windows和linux操作系统的视窗环境中，这两个构件有不同的本地实现，它们的细节也有所不同。试使用抽象工厂模式来设计并模拟实现该结构。\n\n * uml类图\n   \n   \n   \n   其中，接口abstractfactory充当抽象工厂，其子类windowsfactory、unixfactory和linuxfactory充当具体工厂；text和button充当抽象产品，其子类windowstext、unixtext、linuxtext和windowsbutton、unixbutton、linuxbutton充当具体产品。\n\n * 代码\n   \n   代码地址',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"设计模式之建造者模式详解（Java实现）",frontmatter:{title:"设计模式之建造者模式详解（Java实现）",date:"2022-04-24T09:20:17.000Z",tags:["建造者模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/04c857/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89.html",relativePath:"01.开发/02.开发框架/03.设计模式/02.设计模式之建造者模式详解（Java实现）.md",key:"v-0cf5f5ce",path:"/pages/04c857/",headers:[{level:2,title:"1 建造者模式介绍",slug:"_1-建造者模式介绍",normalizedTitle:"1 建造者模式介绍",charIndex:2},{level:2,title:"2 建造者模式详解",slug:"_2-建造者模式详解",normalizedTitle:"2 建造者模式详解",charIndex:655},{level:3,title:"2.1 建造者模式结构",slug:"_2-1-建造者模式结构",normalizedTitle:"2.1 建造者模式结构",charIndex:669},{level:3,title:"2.2 建造者模式实现",slug:"_2-2-建造者模式实现",normalizedTitle:"2.2 建造者模式实现",charIndex:1182},{level:3,title:"2.3 建造者模式应用举例",slug:"_2-3-建造者模式应用举例",normalizedTitle:"2.3 建造者模式应用举例",charIndex:2619}],headersStr:"1 建造者模式介绍 2 建造者模式详解 2.1 建造者模式结构 2.2 建造者模式实现 2.3 建造者模式应用举例",content:'# 1 建造者模式介绍\n\n建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n\n一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。\n\n> 意图： 将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。\n> \n> 主要解决： 主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。\n> \n> 何时使用： 一些基本部件不会变，而其组合经常变化的时候。\n> \n> 如何解决： 将变与不变分离开。\n> \n> 关键代码： 建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。\n> \n> 应用实例： 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。 2、JAVA 中的 StringBuilder。\n> \n> 优点： 1、建造者独立，易扩展。 2、便于控制细节风险。\n> \n> 缺点： 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。\n> \n> 使用场景： 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。\n> \n> 注意事项： 与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。\n\n\n# 2 建造者模式详解\n\n\n# 2.1 建造者模式结构\n\n建造者模式的UML类图如下：\n\n\n\n由上图可知，建造者模式包含以下4个角色。\n\n 1. Builder（抽象建造者）：它为创建一个产品对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildPartX()（如图中的buildPartA()、buildPathB()等），它们用于创建复杂对象的各个部件；另一类方法是getResult（），它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。\n 2. ConcreteBuilder（具体建造者）：它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确所创建的复杂对象，还可以提供一个方法返回创建好的复杂产品对象（该方法也可以由抽象建造者实现）。\n 3. Product（产品）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。\n 4. Director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。\n\n\n# 2.2 建造者模式实现\n\n典型的复杂对象类的代码如下：\n\npublic class Product {\n    private String partA; // 定义部件，部件可以是任意类型，包括值类型和引用类型\n    private String partB;\n    private String partC;\n    // 属性的Getter和Setter方法省略\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n典型的抽象建造者类的代码如下：\n\npublic abstract class Builder {\n    // 创建产品对象\n    protected Product product = new Product();\n    \n    public abstract void buildPartA();\n    public abstract void buildPartB();\n    public abstract void buildPartC();\n    \n    // 返回产品对象\n    public Product getResult() {\n        return product;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n典型的具体建造者类的代码如下：\n\npublic class ConcreteBuilder1 extends Builder {\n    public void buildPartA() {\n        product.setPartA("A1");\n    }\n    public void buildPartB() {\n        product.setPartA("B1");\n    }\n    public void buildPartC() {\n        product.setPartA("C1");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n典型的指挥者类的代码如下：\n\npublic class Director {\n    private Builder builder;\n    \n    public Director(Builder builder) {\n        this.builder = builder;\n    }\n    public void setBuilder(Builder builder) {\n        this.builder = builder;\n    }\n    // 产品的构建与组装方法\n    public Product construct() {\n        builder.buildPartA();\n        builder.buildPartB();\n        builder.buildPartC();\n        return builder.getResult();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 2.3 建造者模式应用举例\n\n * 题目描述\n   \n   > 计算机组装工厂可以将CPU、内存、硬盘、主机、显示器等硬件设备组装在一起构成一台完整的计算机，且构成的计算机可以是笔记本，也可以是台式机，还可以是不提供显示器的服务器主机。对于用户而言，无须关心计算机的组成设备和组装过程，工厂返回给用户的。是完整的计算机对象，使用建造者模式实现计算机组装过程。\n\n * UML类图\n   \n   \n   \n   其中，Computer充当符合产品，ComputerBuilder充当抽象建造者，Notebook、Desktop和Server充当具体建造者，ComputerAssembleDirector充当指挥者，其assemble()方法用于定义产品的构造过程。\n\n * 代码\n   \n   代码地址',normalizedContent:'# 1 建造者模式介绍\n\n建造者模式（builder pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n\n一个 builder 类会一步一步构造最终的对象。该 builder 类是独立于其他对象的。\n\n> 意图： 将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。\n> \n> 主要解决： 主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。\n> \n> 何时使用： 一些基本部件不会变，而其组合经常变化的时候。\n> \n> 如何解决： 将变与不变分离开。\n> \n> 关键代码： 建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。\n> \n> 应用实例： 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。 2、java 中的 stringbuilder。\n> \n> 优点： 1、建造者独立，易扩展。 2、便于控制细节风险。\n> \n> 缺点： 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。\n> \n> 使用场景： 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。\n> \n> 注意事项： 与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。\n\n\n# 2 建造者模式详解\n\n\n# 2.1 建造者模式结构\n\n建造者模式的uml类图如下：\n\n\n\n由上图可知，建造者模式包含以下4个角色。\n\n 1. builder（抽象建造者）：它为创建一个产品对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildpartx()（如图中的buildparta()、buildpathb()等），它们用于创建复杂对象的各个部件；另一类方法是getresult（），它们用于返回复杂对象。builder既可以是抽象类，也可以是接口。\n 2. concretebuilder（具体建造者）：它实现了builder接口，实现各个部件的具体构造和装配方法，定义并明确所创建的复杂对象，还可以提供一个方法返回创建好的复杂产品对象（该方法也可以由抽象建造者实现）。\n 3. product（产品）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。\n 4. director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。\n\n\n# 2.2 建造者模式实现\n\n典型的复杂对象类的代码如下：\n\npublic class product {\n    private string parta; // 定义部件，部件可以是任意类型，包括值类型和引用类型\n    private string partb;\n    private string partc;\n    // 属性的getter和setter方法省略\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n典型的抽象建造者类的代码如下：\n\npublic abstract class builder {\n    // 创建产品对象\n    protected product product = new product();\n    \n    public abstract void buildparta();\n    public abstract void buildpartb();\n    public abstract void buildpartc();\n    \n    // 返回产品对象\n    public product getresult() {\n        return product;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n典型的具体建造者类的代码如下：\n\npublic class concretebuilder1 extends builder {\n    public void buildparta() {\n        product.setparta("a1");\n    }\n    public void buildpartb() {\n        product.setparta("b1");\n    }\n    public void buildpartc() {\n        product.setparta("c1");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n典型的指挥者类的代码如下：\n\npublic class director {\n    private builder builder;\n    \n    public director(builder builder) {\n        this.builder = builder;\n    }\n    public void setbuilder(builder builder) {\n        this.builder = builder;\n    }\n    // 产品的构建与组装方法\n    public product construct() {\n        builder.buildparta();\n        builder.buildpartb();\n        builder.buildpartc();\n        return builder.getresult();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 2.3 建造者模式应用举例\n\n * 题目描述\n   \n   > 计算机组装工厂可以将cpu、内存、硬盘、主机、显示器等硬件设备组装在一起构成一台完整的计算机，且构成的计算机可以是笔记本，也可以是台式机，还可以是不提供显示器的服务器主机。对于用户而言，无须关心计算机的组成设备和组装过程，工厂返回给用户的。是完整的计算机对象，使用建造者模式实现计算机组装过程。\n\n * uml类图\n   \n   \n   \n   其中，computer充当符合产品，computerbuilder充当抽象建造者，notebook、desktop和server充当具体建造者，computerassembledirector充当指挥者，其assemble()方法用于定义产品的构造过程。\n\n * 代码\n   \n   代码地址',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"设计模式之单例模式详解（Java实现）",frontmatter:{title:"设计模式之单例模式详解（Java实现）",date:"2022-04-24T09:19:38.000Z",tags:["单例模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/a1ff4f/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/04.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89.html",relativePath:"01.开发/02.开发框架/03.设计模式/04.设计模式之单例模式详解（Java实现）.md",key:"v-0bc1b9b4",path:"/pages/a1ff4f/",headers:[{level:2,title:"1 单例模式介绍",slug:"_1-单例模式介绍",normalizedTitle:"1 单例模式介绍",charIndex:2},{level:2,title:"2 单例模式详解",slug:"_2-单例模式详解",normalizedTitle:"2 单例模式详解",charIndex:849},{level:3,title:"2.1 单例模式结构",slug:"_2-1-单例模式结构",normalizedTitle:"2.1 单例模式结构",charIndex:862},{level:3,title:"2.2 单例模式实现",slug:"_2-2-单例模式实现",normalizedTitle:"2.2 单例模式实现",charIndex:1098},{level:3,title:"2.3 单例模式应用举例",slug:"_2-3-单例模式应用举例",normalizedTitle:"2.3 单例模式应用举例",charIndex:1514},{level:2,title:"3 饿汉式单例与懒汉式单例",slug:"_3-饿汉式单例与懒汉式单例",normalizedTitle:"3 饿汉式单例与懒汉式单例",charIndex:1931},{level:3,title:"3.1 饿汉式单例",slug:"_3-1-饿汉式单例",normalizedTitle:"3.1 饿汉式单例",charIndex:1949},{level:3,title:"3.2 懒汉式单例与双重检查锁定",slug:"_3-2-懒汉式单例与双重检查锁定",normalizedTitle:"3.2 懒汉式单例与双重检查锁定",charIndex:2382},{level:3,title:"3.3 饿汉式单例类与懒汉式单例类的比较",slug:"_3-3-饿汉式单例类与懒汉式单例类的比较",normalizedTitle:"3.3 饿汉式单例类与懒汉式单例类的比较",charIndex:4340},{level:2,title:"4 使用静态内部类实现单例模式",slug:"_4-使用静态内部类实现单例模式",normalizedTitle:"4 使用静态内部类实现单例模式",charIndex:4504}],headersStr:"1 单例模式介绍 2 单例模式详解 2.1 单例模式结构 2.2 单例模式实现 2.3 单例模式应用举例 3 饿汉式单例与懒汉式单例 3.1 饿汉式单例 3.2 懒汉式单例与双重检查锁定 3.3 饿汉式单例类与懒汉式单例类的比较 4 使用静态内部类实现单例模式",content:"# 1 单例模式介绍\n\n单例模式（Singleton Pattern）确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。\n\n例如Windows任务管理器，在正常情况下只能打开唯一一个任务管理器。\n\n\n\n单例模式是一种对象创建型模式，其有三个要点：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。\n\n> 主要解决： 一个全局使用的类频繁地创建与销毁。\n> \n> 何时使用： 当您想控制实例数目，节省系统资源的时候。\n> \n> 如何解决： 判断系统是否已经有这个单例，如果有则返回，如果没有则创建。\n> \n> 关键代码： 构造函数是私有的。\n> \n> 应用实例：\n> \n>  * 1、一个班级只有一个班主任。\n>  * 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。\n>  * 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。\n> \n> 优点：\n> \n>  * 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。\n>  * 2、避免对资源的多重占用（比如写文件操作）。\n> \n> 缺点： 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。\n> \n> 使用场景：\n> \n>  * 1、要求生产唯一序列号。\n>  * 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。\n>  * 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。\n> \n> 注意事项： getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。\n\n\n# 2 单例模式详解\n\n\n# 2.1 单例模式结构\n\n单例模式是结构最简单的设计模式，它只包含一个类，即单例类。单例模式的结构图如下。\n\n\n\n由图可知，单例模式只包含一个单例角色，也就是Singleton。对于Singleton（单例），在单例类的内部创建它的唯一实例，并通过静态方法getInstance()让客户端可以使用它的唯一实例；为了防止在外部对单例类实例化，将其构造函数的可见性设为private；在单例类内部定义了一个Singleton类型的静态对象作为可供外部访问的唯一实例。\n\n\n# 2.2 单例模式实现\n\n典型的单例模式的实现代码如下：\n\npublic class Singleton {\n    // 静态私有成员变量\n    private static Singleton instance = null;  \n    // 私有构造函数\n    private Singleton() {   \n    }\n    \n    // 静态公有工厂方法，返回唯一实例\n    public static Singleton getInstance() {\n        if(instance == null)\n            instance = new Singleton(); \n        return instance;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 2.3 单例模式应用举例\n\n * 题目描述\n   \n   > 某软件公司承接了一个服务器负载均衡(Load Balance)软件的开发工作，该软件运行在一台负载均衡服务器上，可以将并发访问和数据流量分发到服务器集群中的多台设备上进行并发处理，提高了系统的整体处理能力，缩短了响应时间。由于集群中的服务器需要动态删减，且客户端请求需要统一分发，因此需要确保负载均衡器的唯一性，只能有一个负载均衡器来负责服务器的管理和请求的分发，否则将会带来服务器状态的不一致以及请求分配冲突等问题。如何确保负载均衡器的唯一性是该软件成功的关键，试使用单例模式设计服务器负载均衡器。\n\n * UML类图\n   \n   \n   \n   其中将负载均衡器LoadBalance设计为单例类，其中包含一个存储服务器信息的集合serverList，每次在serverList中随机选择一台服务器来响应客户端的请求。\n\n * 代码\n   \n   代码地址\n\n\n# 3 饿汉式单例与懒汉式单例\n\n\n# 3.1 饿汉式单例\n\n饿汉式单例（Eager Singleton）是实现起来最简单的单例类，饿汉式单例类结构图如下。\n\n\n\n有图中我们可以看出，由于在定义静态变量的时候实例化单例类，因此在类加载时单例对象就已创建，代码如下：\n\npublic class EagerSingleton { \n    private static final EagerSingleton instance = new EagerSingleton(); \n    private EagerSingleton() { } \n\n    public static EagerSingleton getInstance() {\n        return instance; \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n当类被加载时，静态变量instance会被初始化，此时类的私有构造函数就会被调用，单例类的唯一实例将被创建。\n\n\n# 3.2 懒汉式单例与双重检查锁定\n\n与饿汉式单例相同的是，懒汉式单例（Lazy Singleton）的构造函数也是私有的；与饿汉式单例类不同的是，懒汉式单例类在第一次被引用时将自己实例化，在懒汉式单例类被加载时不会将自己实例化。懒汉式单例类的结构图如下。\n\n\n\n但如果多个线程同时访问将导致创建多个单例对象！这个时候为了避免多个线程同时调用getInstance()方法，可以使用关键字synchronized，代码如下：\n\npublic class LazySingleton { \n    private static LazySingleton instance = null; \n\n    private LazySingleton() { } \n\n    // 使用synchronized关键字对方法加锁，确保任意时刻只有一个线程可以执行该方法\n    synchronized public static LazySingleton getInstance() { \n        if (instance == null) {\n            instance = new LazySingleton(); \n        }\n        return instance; \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在上述懒汉式单例类中，在getInstance()方法前面增加了关键字synchronized进行线程锁定，已处理多个线程同时访问问题。但我们每次调用getInstance()时都需要进行线程锁定判断，在多线程高并发环境中将会导致性能大大降低。因此可以继续对懒汉式单例进行改进，我们发现无需对getInstance()方法进行锁定，仅需锁定代码段instance = new LazySingleton()即可。故可进行如下改进：\n\npublic static LazySingleton getInstance() { \n    if (instance == null) {\n        synchronized (LazySingleton.class) {\n            instance = new LazySingleton(); \n        }\n    }\n    return instance; \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n问题看似解决，但如果使用上述代码，实际上还是会存在单例对象不唯一的情况。因为线程A和线程B如果同时进入判断，由于锁的原因，一个会先创建，但是另一个并不知道对象已经创建，这样就会导致产生多个实例对象。违背了单例模式的设计思想。我们需要使用双重检查锁定，即在锁内再进行一次instance == null的判断。使用双重检查锁定实现的懒汉式单例类的完整代码如下：\n\npublic class LazySingleton { \n    private volatile static LazySingleton instance = null; \n\n    private LazySingleton() { } \n\n    public static LazySingleton getInstance() { \n        //第一重判断\n        if (instance == null) {\n            //锁定代码块\n            synchronized (LazySingleton.class) {\n                //第二重判断\n                if (instance == null) {\n                    instance = new LazySingleton(); //创建单例实例\n                }\n            }\n        }\n    return instance; \n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n需要注意的时，如果使用双重检查锁定来实现懒汉式单例类，需要在静态成员变量instance之前增加修饰符volatile，被volatile修饰的成员变量可以确保多个线程都能够正确处理。\n\n\n# 3.3 饿汉式单例类与懒汉式单例类的比较\n\n * 饿汉式单例类：无须考虑多个线程同时访问的问题；调用速度和反应时间优于懒汉式单例；资源利用效率不及懒汉式单例；系统加载时间可能会比较长。\n * 懒汉式单例类：实现了延迟加载；必须处理好多个线程同时访问的问题；需通过双重检查锁定等机制进行控制，将导致系统性能受到一定影响。\n\n\n# 4 使用静态内部类实现单例模式\n\n饿汉式单例类不能实现延迟加载，不管将来用不用始终占用内存；懒汉式单例类安全控制烦琐，而且性能受影响。可见它们都存在一些问题，为了克服这些问题，在Java语言中可以通过Initialization on Demand Holder（IoDH）技术来实现单例模式。\n\n在IoDH中，需要在单例类中增加一个静态内部类，在该内部类中创建单例对象，再将该单例对象通过getInstance()方法返回给外部使用，实现代码如下：\n\n//Initialization on Demand Holder\npublic class Singleton {\n    private Singleton() {\n    }\n\n    //静态内部类\n    private static class HolderClass {\n        private final static Singleton instance = new Singleton();\n    }\n\n    public static Singleton getInstance() {\n        return HolderClass.instance;\n    }\n\n    public static void main(String args[]) {\n        Singleton s1, s2; \n        s1 = Singleton.getInstance();\n        s2 = Singleton.getInstance();\n        System.out.println(s1==s2);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n通过使用IoDH既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为一种最好的Java语言单例模式实现方式；其缺点是与编程语言本身的特性相关，很多面向对象语言并不支持IoDH。",normalizedContent:"# 1 单例模式介绍\n\n单例模式（singleton pattern）确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。\n\n例如windows任务管理器，在正常情况下只能打开唯一一个任务管理器。\n\n\n\n单例模式是一种对象创建型模式，其有三个要点：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。\n\n> 主要解决： 一个全局使用的类频繁地创建与销毁。\n> \n> 何时使用： 当您想控制实例数目，节省系统资源的时候。\n> \n> 如何解决： 判断系统是否已经有这个单例，如果有则返回，如果没有则创建。\n> \n> 关键代码： 构造函数是私有的。\n> \n> 应用实例：\n> \n>  * 1、一个班级只有一个班主任。\n>  * 2、windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。\n>  * 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。\n> \n> 优点：\n> \n>  * 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。\n>  * 2、避免对资源的多重占用（比如写文件操作）。\n> \n> 缺点： 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。\n> \n> 使用场景：\n> \n>  * 1、要求生产唯一序列号。\n>  * 2、web 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。\n>  * 3、创建的一个对象需要消耗的资源过多，比如 i/o 与数据库的连接等。\n> \n> 注意事项： getinstance() 方法中需要使用同步锁 synchronized (singleton.class) 防止多线程同时进入造成 instance 被多次实例化。\n\n\n# 2 单例模式详解\n\n\n# 2.1 单例模式结构\n\n单例模式是结构最简单的设计模式，它只包含一个类，即单例类。单例模式的结构图如下。\n\n\n\n由图可知，单例模式只包含一个单例角色，也就是singleton。对于singleton（单例），在单例类的内部创建它的唯一实例，并通过静态方法getinstance()让客户端可以使用它的唯一实例；为了防止在外部对单例类实例化，将其构造函数的可见性设为private；在单例类内部定义了一个singleton类型的静态对象作为可供外部访问的唯一实例。\n\n\n# 2.2 单例模式实现\n\n典型的单例模式的实现代码如下：\n\npublic class singleton {\n    // 静态私有成员变量\n    private static singleton instance = null;  \n    // 私有构造函数\n    private singleton() {   \n    }\n    \n    // 静态公有工厂方法，返回唯一实例\n    public static singleton getinstance() {\n        if(instance == null)\n            instance = new singleton(); \n        return instance;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 2.3 单例模式应用举例\n\n * 题目描述\n   \n   > 某软件公司承接了一个服务器负载均衡(load balance)软件的开发工作，该软件运行在一台负载均衡服务器上，可以将并发访问和数据流量分发到服务器集群中的多台设备上进行并发处理，提高了系统的整体处理能力，缩短了响应时间。由于集群中的服务器需要动态删减，且客户端请求需要统一分发，因此需要确保负载均衡器的唯一性，只能有一个负载均衡器来负责服务器的管理和请求的分发，否则将会带来服务器状态的不一致以及请求分配冲突等问题。如何确保负载均衡器的唯一性是该软件成功的关键，试使用单例模式设计服务器负载均衡器。\n\n * uml类图\n   \n   \n   \n   其中将负载均衡器loadbalance设计为单例类，其中包含一个存储服务器信息的集合serverlist，每次在serverlist中随机选择一台服务器来响应客户端的请求。\n\n * 代码\n   \n   代码地址\n\n\n# 3 饿汉式单例与懒汉式单例\n\n\n# 3.1 饿汉式单例\n\n饿汉式单例（eager singleton）是实现起来最简单的单例类，饿汉式单例类结构图如下。\n\n\n\n有图中我们可以看出，由于在定义静态变量的时候实例化单例类，因此在类加载时单例对象就已创建，代码如下：\n\npublic class eagersingleton { \n    private static final eagersingleton instance = new eagersingleton(); \n    private eagersingleton() { } \n\n    public static eagersingleton getinstance() {\n        return instance; \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n当类被加载时，静态变量instance会被初始化，此时类的私有构造函数就会被调用，单例类的唯一实例将被创建。\n\n\n# 3.2 懒汉式单例与双重检查锁定\n\n与饿汉式单例相同的是，懒汉式单例（lazy singleton）的构造函数也是私有的；与饿汉式单例类不同的是，懒汉式单例类在第一次被引用时将自己实例化，在懒汉式单例类被加载时不会将自己实例化。懒汉式单例类的结构图如下。\n\n\n\n但如果多个线程同时访问将导致创建多个单例对象！这个时候为了避免多个线程同时调用getinstance()方法，可以使用关键字synchronized，代码如下：\n\npublic class lazysingleton { \n    private static lazysingleton instance = null; \n\n    private lazysingleton() { } \n\n    // 使用synchronized关键字对方法加锁，确保任意时刻只有一个线程可以执行该方法\n    synchronized public static lazysingleton getinstance() { \n        if (instance == null) {\n            instance = new lazysingleton(); \n        }\n        return instance; \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在上述懒汉式单例类中，在getinstance()方法前面增加了关键字synchronized进行线程锁定，已处理多个线程同时访问问题。但我们每次调用getinstance()时都需要进行线程锁定判断，在多线程高并发环境中将会导致性能大大降低。因此可以继续对懒汉式单例进行改进，我们发现无需对getinstance()方法进行锁定，仅需锁定代码段instance = new lazysingleton()即可。故可进行如下改进：\n\npublic static lazysingleton getinstance() { \n    if (instance == null) {\n        synchronized (lazysingleton.class) {\n            instance = new lazysingleton(); \n        }\n    }\n    return instance; \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n问题看似解决，但如果使用上述代码，实际上还是会存在单例对象不唯一的情况。因为线程a和线程b如果同时进入判断，由于锁的原因，一个会先创建，但是另一个并不知道对象已经创建，这样就会导致产生多个实例对象。违背了单例模式的设计思想。我们需要使用双重检查锁定，即在锁内再进行一次instance == null的判断。使用双重检查锁定实现的懒汉式单例类的完整代码如下：\n\npublic class lazysingleton { \n    private volatile static lazysingleton instance = null; \n\n    private lazysingleton() { } \n\n    public static lazysingleton getinstance() { \n        //第一重判断\n        if (instance == null) {\n            //锁定代码块\n            synchronized (lazysingleton.class) {\n                //第二重判断\n                if (instance == null) {\n                    instance = new lazysingleton(); //创建单例实例\n                }\n            }\n        }\n    return instance; \n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n需要注意的时，如果使用双重检查锁定来实现懒汉式单例类，需要在静态成员变量instance之前增加修饰符volatile，被volatile修饰的成员变量可以确保多个线程都能够正确处理。\n\n\n# 3.3 饿汉式单例类与懒汉式单例类的比较\n\n * 饿汉式单例类：无须考虑多个线程同时访问的问题；调用速度和反应时间优于懒汉式单例；资源利用效率不及懒汉式单例；系统加载时间可能会比较长。\n * 懒汉式单例类：实现了延迟加载；必须处理好多个线程同时访问的问题；需通过双重检查锁定等机制进行控制，将导致系统性能受到一定影响。\n\n\n# 4 使用静态内部类实现单例模式\n\n饿汉式单例类不能实现延迟加载，不管将来用不用始终占用内存；懒汉式单例类安全控制烦琐，而且性能受影响。可见它们都存在一些问题，为了克服这些问题，在java语言中可以通过initialization on demand holder（iodh）技术来实现单例模式。\n\n在iodh中，需要在单例类中增加一个静态内部类，在该内部类中创建单例对象，再将该单例对象通过getinstance()方法返回给外部使用，实现代码如下：\n\n//initialization on demand holder\npublic class singleton {\n    private singleton() {\n    }\n\n    //静态内部类\n    private static class holderclass {\n        private final static singleton instance = new singleton();\n    }\n\n    public static singleton getinstance() {\n        return holderclass.instance;\n    }\n\n    public static void main(string args[]) {\n        singleton s1, s2; \n        s1 = singleton.getinstance();\n        s2 = singleton.getinstance();\n        system.out.println(s1==s2);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n通过使用iodh既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为一种最好的java语言单例模式实现方式；其缺点是与编程语言本身的特性相关，很多面向对象语言并不支持iodh。",charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"设计模式之适配器模式详解（Java实现）",frontmatter:{title:"设计模式之适配器模式详解（Java实现）",date:"2022-04-24T18:54:37.000Z",tags:["适配器模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/2bc5dd/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89.html",relativePath:"01.开发/02.开发框架/03.设计模式/05.设计模式之适配器模式详解（Java实现）.md",key:"v-79e3d1ae",path:"/pages/2bc5dd/",headers:[{level:2,title:"1 适配器模式介绍",slug:"_1-适配器模式介绍",normalizedTitle:"1 适配器模式介绍",charIndex:2},{level:2,title:"2 适配器模式详解",slug:"_2-适配器模式详解",normalizedTitle:"2 适配器模式详解",charIndex:1166},{level:3,title:"2.1 适配器模式结构",slug:"_2-1-适配器模式结构",normalizedTitle:"2.1 适配器模式结构",charIndex:1180},{level:3,title:"2.2 适配器模式实现",slug:"_2-2-适配器模式实现",normalizedTitle:"2.2 适配器模式实现",charIndex:1600},{level:4,title:"2.2.1 类适配器",slug:"_2-2-1-类适配器",normalizedTitle:"2.2.1 类适配器",charIndex:1615},{level:4,title:"2.2.2 对象适配器",slug:"_2-2-2-对象适配器",normalizedTitle:"2.2.2 对象适配器",charIndex:2049},{level:3,title:"2.3 适配器模式应用举例",slug:"_2-3-适配器模式应用举例",normalizedTitle:"2.3 适配器模式应用举例",charIndex:2642},{level:2,title:"3 缺省适配器模式",slug:"_3-缺省适配器模式",normalizedTitle:"3 缺省适配器模式",charIndex:2981},{level:2,title:"4 双向适配器",slug:"_4-双向适配器",normalizedTitle:"4 双向适配器",charIndex:3755}],headersStr:"1 适配器模式介绍 2 适配器模式详解 2.1 适配器模式结构 2.2 适配器模式实现 2.2.1 类适配器 2.2.2 对象适配器 2.3 适配器模式应用举例 3 缺省适配器模式 4 双向适配器",content:'# 1 适配器模式介绍\n\n\n\n在现实生活中生活用电220V和笔记电脑20V不兼容，我们需要引入 AC Adapter（交流电适配器），在软件开发中我们也会存在不兼容的结构，这个时候就需要引入适配器模式。\n\n适配器模式（Adapter Pattern）可以将一个类的接口和另一个类的接口匹配起来，而无需修改原来的适配者接口和抽象目标接口。\n\n它将一个类的接口转换称客户希望的另一个接口，让那些接口不兼容的类可以一起工作。\n\n适配器模式的别名为包装器模式（Wrapper Pattern），它既可以作为类结构模式，也可以作为对象结构型模式。在适配器模式的定义中所提及的接口是指广义的接口，它可以表示为方法或者方法的集合。\n\n> 主要解决： 主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。\n> \n> 何时使用： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）\n> \n> 如何解决： 继承或依赖（推荐）。\n> \n> 关键代码： 适配器继承或依赖已有的对象，实现想要的目标接口。\n> \n> 应用实例： 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。\n> \n> 优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。\n> \n> 缺点： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。\n> \n> 使用场景： 有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。\n> \n> 注意事项： 适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。\n\n\n# 2 适配器模式详解\n\n\n# 2.1 适配器模式结构\n\n类适配器模式的结构图如下：\n\n\n\n对象适配器模式的结构图如下：\n\n\n\n由上图可知，适配器模式包含以下3个角色。\n\n 1. Target（目标抽象类）：目标抽象类定义客户所需的接口，可以是一个抽象类或者接口，也可以是具体类。在类适配器中，由于Java语言不支持多重继承，它只能是接口。\n 2. Adapter（适配器类）：它可以调用另一个接口 ，作为一个转换器，对Adaptee和Target进行适配。适配器Adapter是适配器模式的核心，在类适配器中，它通过实现Target接口并继承Adaptee类来使二者产生联系，在对象适配器中，它通过继承Target并关联一个Adaptee对象来使二者产生联系。\n 3. Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体的类，包含了客户希望使用的业务方法，在某些情况下甚至没有适配者类的代码。\n\n\n# 2.2 适配器模式实现\n\n# 2.2.1 类适配器\n\n根据上图，在类适配器中适配者类Adaptee没有request方法，而客户端期待这个方法，但在适配者类中实现了specificRequest()方法，该方法提供的实现正式客户端所需要的。为了使客户端能够使用适配者类，提供了一个中间类，即适配器类Adapter，适配器类实现了抽象目标类接口Target，并继承了适配者类，在适配器类的request()方法中调用所继承的适配者类的specificRequest()方法，达到了适配的目的。\n\n因为适配器类与适配者类使继承关系，所以这种适配器模式称为类适配器模式。典型的类适配器代码如下：\n\npublic class Adapter extends Adaptee implements Target {\n    public void request() {\n        super.specificRequest();\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n# 2.2.2 对象适配器\n\n根据上图，在对象适配器中适配者类Adaptee没有request方法，而客户端期待这个方法，但在适配者类中实现了specificRequest()方法，该方法提供的实现正式客户端所需要的。为了使客户端能够使用适配者类，需要提供一个包装类Adapter，即适配器类。\n\n这个包装类包装了一个适配者的实例，从而将客户端与适配者衔接起来，在适配器的request()方法中调用适配者的specificRequest()方法。\n\n因为适配器类与适配者类是关联关系，所以这种适配器模式称为对象适配器模式。典型的对象适配器代码如下：\n\npublic class Adapter extends Target {\n    // 维持一个对适配者对象的引用\n    private Adaptee adaptee;\n    \n    public Adapter(Adaptee adaptee) {\n        this.adaptee = adaptee;\n    }\n    public void request() {\n        // 转发调用\n        adaptee.specificRequest();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2.3 适配器模式应用举例\n\n * 题目描述\n   \n   > 某公司欲开发一款儿童玩具汽车，为了更好地吸引小朋友的注意力，该玩具汽车在移动过程中伴随着灯光闪烁和声音提示。在该公司以往的产品中已经实现了控制灯光闪烁（例如警灯闪烁）和声音提示（例如警笛音效）的程序，为了重用先前的代码并且使得汽车控制软件具有更好的灵活性和扩展性，现使用适配器模式设计该玩具汽车控制软件。\n\n * UML类图\n   \n   使用对象适配器模式来实现，其UML类图如下：\n   \n   \n   \n   其中，CarController类充当抽象目标，PoliceSound和PoliceLamp类充当适配者，PoliceCarAdapter充当适配器。\n\n * 代码\n   \n   代码地址\n\n\n# 3 缺省适配器模式\n\n缺省适配器模式(Default Adapter Pattern)：当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。其结构图如下：\n\n\n\n由上图可知，在缺省适配器模式中包含以下3个角色：\n\n 1. ServiceInterface（适配者接口）：它是一个接口，通常在接口中声明了大量的方法。\n 2. AbstractServiceClass（缺省适配器类）：它是缺省适配器模式的核心类，使用空方法的形式实现了在ServiceInterface接口中声明的方法。通常将它定义为抽象类，因为对它进行实例化没有任何意义。\n 3. ConcreteServiceClass（具体业务类）：它是缺省适配器类的子类，在没有引入适配器之前它需要实现适配者接口，因此需要实现在适配者接口中定义的所有方法，而对于一些无须使用的方法不得不提供空实现。在有了缺省适配器之后可以直接继承该适配者类，根据需要有选择性地覆盖在适配器类中定义的方法。\n\n缺省适配器类的典型代码如下：\n\npublic abstract class AbstractServiceClass implements ServiceInterface {\n    public void serviceMethod1() {  }  //空方法\n    public void serviceMethod2() {  }  //空方法\n    public void serviceMethod3() {  }  //空方法\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 4 双向适配器\n\n在对象适配器的使用过程中，如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类的方法，那么该适配器就是一个双向适配器。其结构图如下：\n\n\n\n其典型代码如下：\n\npublic class Adapter implements Target,Adaptee {\n    // 同时维持对抽象目标类和适配者类的引用\n    private Target target;\n    private Adaptee adaptee;\n  \n    public Adapter(Target target) {\n        this.target = target;\n    }\n  \n    public Adapter(Adaptee adaptee) {\n        this.adaptee = adaptee;\n    }\n  \n    public void request() {\n        adaptee.specificRequest();\n    }\n  \n    public void specificRequest() {\n        target.request();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n',normalizedContent:'# 1 适配器模式介绍\n\n\n\n在现实生活中生活用电220v和笔记电脑20v不兼容，我们需要引入 ac adapter（交流电适配器），在软件开发中我们也会存在不兼容的结构，这个时候就需要引入适配器模式。\n\n适配器模式（adapter pattern）可以将一个类的接口和另一个类的接口匹配起来，而无需修改原来的适配者接口和抽象目标接口。\n\n它将一个类的接口转换称客户希望的另一个接口，让那些接口不兼容的类可以一起工作。\n\n适配器模式的别名为包装器模式（wrapper pattern），它既可以作为类结构模式，也可以作为对象结构型模式。在适配器模式的定义中所提及的接口是指广义的接口，它可以表示为方法或者方法的集合。\n\n> 主要解决： 主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。\n> \n> 何时使用： 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）\n> \n> 如何解决： 继承或依赖（推荐）。\n> \n> 关键代码： 适配器继承或依赖已有的对象，实现想要的目标接口。\n> \n> 应用实例： 1、美国电器 110v，中国 220v，就要有一个适配器将 110v 转化为 220v。 2、java jdk 1.1 提供了 enumeration 接口，而在 1.2 中提供了 iterator 接口，想要使用 1.2 的 jdk，则要将以前系统的 enumeration 接口转化为 iterator 接口，这时就需要适配器模式。 3、在 linux 上运行 windows 程序。 4、java 中的 jdbc。\n> \n> 优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。\n> \n> 缺点： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 a 接口，其实内部被适配成了 b 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 java 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。\n> \n> 使用场景： 有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。\n> \n> 注意事项： 适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。\n\n\n# 2 适配器模式详解\n\n\n# 2.1 适配器模式结构\n\n类适配器模式的结构图如下：\n\n\n\n对象适配器模式的结构图如下：\n\n\n\n由上图可知，适配器模式包含以下3个角色。\n\n 1. target（目标抽象类）：目标抽象类定义客户所需的接口，可以是一个抽象类或者接口，也可以是具体类。在类适配器中，由于java语言不支持多重继承，它只能是接口。\n 2. adapter（适配器类）：它可以调用另一个接口 ，作为一个转换器，对adaptee和target进行适配。适配器adapter是适配器模式的核心，在类适配器中，它通过实现target接口并继承adaptee类来使二者产生联系，在对象适配器中，它通过继承target并关联一个adaptee对象来使二者产生联系。\n 3. adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体的类，包含了客户希望使用的业务方法，在某些情况下甚至没有适配者类的代码。\n\n\n# 2.2 适配器模式实现\n\n# 2.2.1 类适配器\n\n根据上图，在类适配器中适配者类adaptee没有request方法，而客户端期待这个方法，但在适配者类中实现了specificrequest()方法，该方法提供的实现正式客户端所需要的。为了使客户端能够使用适配者类，提供了一个中间类，即适配器类adapter，适配器类实现了抽象目标类接口target，并继承了适配者类，在适配器类的request()方法中调用所继承的适配者类的specificrequest()方法，达到了适配的目的。\n\n因为适配器类与适配者类使继承关系，所以这种适配器模式称为类适配器模式。典型的类适配器代码如下：\n\npublic class adapter extends adaptee implements target {\n    public void request() {\n        super.specificrequest();\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n# 2.2.2 对象适配器\n\n根据上图，在对象适配器中适配者类adaptee没有request方法，而客户端期待这个方法，但在适配者类中实现了specificrequest()方法，该方法提供的实现正式客户端所需要的。为了使客户端能够使用适配者类，需要提供一个包装类adapter，即适配器类。\n\n这个包装类包装了一个适配者的实例，从而将客户端与适配者衔接起来，在适配器的request()方法中调用适配者的specificrequest()方法。\n\n因为适配器类与适配者类是关联关系，所以这种适配器模式称为对象适配器模式。典型的对象适配器代码如下：\n\npublic class adapter extends target {\n    // 维持一个对适配者对象的引用\n    private adaptee adaptee;\n    \n    public adapter(adaptee adaptee) {\n        this.adaptee = adaptee;\n    }\n    public void request() {\n        // 转发调用\n        adaptee.specificrequest();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2.3 适配器模式应用举例\n\n * 题目描述\n   \n   > 某公司欲开发一款儿童玩具汽车，为了更好地吸引小朋友的注意力，该玩具汽车在移动过程中伴随着灯光闪烁和声音提示。在该公司以往的产品中已经实现了控制灯光闪烁（例如警灯闪烁）和声音提示（例如警笛音效）的程序，为了重用先前的代码并且使得汽车控制软件具有更好的灵活性和扩展性，现使用适配器模式设计该玩具汽车控制软件。\n\n * uml类图\n   \n   使用对象适配器模式来实现，其uml类图如下：\n   \n   \n   \n   其中，carcontroller类充当抽象目标，policesound和policelamp类充当适配者，policecaradapter充当适配器。\n\n * 代码\n   \n   代码地址\n\n\n# 3 缺省适配器模式\n\n缺省适配器模式(default adapter pattern)：当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。其结构图如下：\n\n\n\n由上图可知，在缺省适配器模式中包含以下3个角色：\n\n 1. serviceinterface（适配者接口）：它是一个接口，通常在接口中声明了大量的方法。\n 2. abstractserviceclass（缺省适配器类）：它是缺省适配器模式的核心类，使用空方法的形式实现了在serviceinterface接口中声明的方法。通常将它定义为抽象类，因为对它进行实例化没有任何意义。\n 3. concreteserviceclass（具体业务类）：它是缺省适配器类的子类，在没有引入适配器之前它需要实现适配者接口，因此需要实现在适配者接口中定义的所有方法，而对于一些无须使用的方法不得不提供空实现。在有了缺省适配器之后可以直接继承该适配者类，根据需要有选择性地覆盖在适配器类中定义的方法。\n\n缺省适配器类的典型代码如下：\n\npublic abstract class abstractserviceclass implements serviceinterface {\n    public void servicemethod1() {  }  //空方法\n    public void servicemethod2() {  }  //空方法\n    public void servicemethod3() {  }  //空方法\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 4 双向适配器\n\n在对象适配器的使用过程中，如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类的方法，那么该适配器就是一个双向适配器。其结构图如下：\n\n\n\n其典型代码如下：\n\npublic class adapter implements target,adaptee {\n    // 同时维持对抽象目标类和适配者类的引用\n    private target target;\n    private adaptee adaptee;\n  \n    public adapter(target target) {\n        this.target = target;\n    }\n  \n    public adapter(adaptee adaptee) {\n        this.adaptee = adaptee;\n    }\n  \n    public void request() {\n        adaptee.specificrequest();\n    }\n  \n    public void specificrequest() {\n        target.request();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"设计模式之原型模式详解（Java实现）",frontmatter:{title:"设计模式之原型模式详解（Java实现）",date:"2022-04-24T09:19:55.000Z",tags:["原型模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/2d97a5/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89.html",relativePath:"01.开发/02.开发框架/03.设计模式/03.设计模式之原型模式详解（Java实现）.md",key:"v-c3099e10",path:"/pages/2d97a5/",headers:[{level:2,title:"1 原型模式介绍",slug:"_1-原型模式介绍",normalizedTitle:"1 原型模式介绍",charIndex:2},{level:2,title:"2 原型模式详解",slug:"_2-原型模式详解",normalizedTitle:"2 原型模式详解",charIndex:1183},{level:3,title:"2.1 原型模式结构",slug:"_2-1-原型模式结构",normalizedTitle:"2.1 原型模式结构",charIndex:1196},{level:3,title:"2.2 深克隆与浅克隆",slug:"_2-2-深克隆与浅克隆",normalizedTitle:"2.2 深克隆与浅克隆",charIndex:1464},{level:4,title:"2.2.1 浅克隆",slug:"_2-2-1-浅克隆",normalizedTitle:"2.2.1 浅克隆",charIndex:1566},{level:4,title:"2.2.2 深克隆",slug:"_2-2-2-深克隆",normalizedTitle:"2.2.2 深克隆",charIndex:1735},{level:3,title:"2.3 原型模式实现",slug:"_2-3-原型模式实现",normalizedTitle:"2.3 原型模式实现",charIndex:1858},{level:4,title:"2.3.1 通用实现方法",slug:"_2-3-1-通用实现方法",normalizedTitle:"2.3.1 通用实现方法",charIndex:1919},{level:4,title:"2.3.2 Java语言中的clone()方法和Cloneable接口",slug:"_2-3-2-java语言中的clone-方法和cloneable接口",normalizedTitle:"2.3.2 java语言中的clone()方法和cloneable接口",charIndex:2869},{level:3,title:"2.4 原型模式应用举例",slug:"_2-4-原型模式应用举例",normalizedTitle:"2.4 原型模式应用举例",charIndex:3743},{level:2,title:"3 原型管理器",slug:"_3-原型管理器",normalizedTitle:"3 原型管理器",charIndex:4251},{level:3,title:"3.1 原型管理器实现",slug:"_3-1-原型管理器实现",normalizedTitle:"3.1 原型管理器实现",charIndex:4263},{level:3,title:"3.2 原型管理器应用举例",slug:"_3-2-原型管理器应用举例",normalizedTitle:"3.2 原型管理器应用举例",charIndex:5324}],headersStr:"1 原型模式介绍 2 原型模式详解 2.1 原型模式结构 2.2 深克隆与浅克隆 2.2.1 浅克隆 2.2.2 深克隆 2.3 原型模式实现 2.3.1 通用实现方法 2.3.2 Java语言中的clone()方法和Cloneable接口 2.4 原型模式应用举例 3 原型管理器 3.1 原型管理器实现 3.2 原型管理器应用举例",content:'# 1 原型模式介绍\n\n原型模式（Prototype Pattern）是一种对象创建型模式，它是使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。\n\n它的工作原理很简单：将一个原型对象传给要发动创建的对象（即客户端对象），这个要发动创建的对象通过请求原型对象复制自己来实现创建过程。\n\n\n\n> 意图： 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。\n> \n> 主要解决： 在运行期建立和删除原型。\n> \n> 何时使用： 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。\n> \n> 如何解决： 利用已有的一个原型对象，快速地生成和原型对象一样的实例。\n> \n> 关键代码： 1、实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些"易变类"拥有稳定的接口。\n> \n> 应用实例： 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。\n> \n> 优点： 1、性能提高。 2、逃避构造函数的约束。\n> \n> 缺点： 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。\n> \n> 使用场景： 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。\n> \n> 注意事项： 与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。\n\n\n# 2 原型模式详解\n\n\n# 2.1 原型模式结构\n\n原型模式包含以下3个角色。\n\n 1. Prototype（抽象原型类）：它是声明克隆方法的接口，是所有具体原型类的公共父类，它可以是抽象类也可以是接口，甚至还可以是具体实现类。\n 2. ConcretePrototype（具体原型类）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。\n 3. Client（客户类）：在客户类中，让一个原型对象克隆自身从而创建一个新的对象，只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。\n\n\n# 2.2 深克隆与浅克隆\n\n根据在复制原型对象的同时是否复制包含在原型对象中引用类型的成员变量，原型模式的克隆机制可分为两种，即浅克隆（Shallow Clone）和深克隆（Deep Clone）。\n\n# 2.2.1 浅克隆\n\n在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。简单来说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。\n\n\n\n# 2.2.2 深克隆\n\n在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。\n\n\n\n\n# 2.3 原型模式实现\n\n实现原型模式的关键在于如何实现克隆方法。这里介绍两种在Java语言中最常用的克隆实现方法。\n\n# 2.3.1 通用实现方法\n\n通用的克隆实现方法是在具体原型类的克隆方法中实例化一个与自身类型相同的对象并将其返回，同时将相关的参数传入新创建的对象中，保证它们的成员变量相同。\n\n典型的抽象原型类代码如下：\n\npublic abstract class Prototype {\n    public abstract Prototype clone();\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n典型的具体原型类代码如下：\n\npublic class ConcretePrototype extends Prototype {\n    private String name; // 成员变量\n    public void setName(String name) {\n        this.name = name;\n    }\n    public void getName() {\n        return this.name;\n    }\n    // 克隆方法实现\n    public Prototype clone() {\n        Prototype prototype = new ConcretePrototype(); // 创建新对象\n        prototype.setName(this.name);\n        return prototype;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这样我们就只需要在客户类中创建一个ConcretePrototype对象作为原型对象，然后调用其clone()方法即可得到对应的克隆对象。\n\n此方法是原型模式的通用实现，它与编程语言本身的特性无关，其他面向对象编程语言也可以使用这种形式来实现对原型对象的克隆。\n\n在这种通用实现方法中，可通过手工编写clone()方法来实现浅克隆和深克隆。对于引用类型的对象，可以在clone()方法中通过赋值的方式来实现复制，这是一种浅克隆实现方案；如果在clone()方法中通过创建一个全新的成员对象来实现复制，则是一种深克隆实现方案。\n\n# 2.3.2 Java语言中的clone()方法和Cloneable接口\n\n在Java语言中，所有的Java类均继承自java.lang.Object类，Object类提供了一个clone()方法，可以将一个Java对象复制一份。因此在Java中可以直接使用Object提供clone()方法来实现对象的浅克隆。\n\n需要注意的是能够实现克隆的Java类都必须实现一个标识接口Cloneable，表示这个Java类支持被复制。如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将会抛出一个CloneNotSupportedException异常。如下代码所示：\n\npublic class ConcretePrototype implements Cloneable {\n    public Prototype clone() {\n        Object object = null;\n        try {\n            object = super.clone(); // 浅克隆\n        } catch (CloneNotSupportedException exception) {\n            System.err.println("Not support Cloneable");\n        }\n        return (Prototype)object;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n为了获取对象的一个克隆，可以直接利用Object类的clone()方法，其具体步骤如下：\n\n 1. 在派生类中覆盖基类的clone()方法，并声明为public。\n 2. 在派生类的clone()方法中调用super.clone()。\n 3. 派生类需实现Cloneable接口。\n\n此时，Object类相当于抽象原型类，所有实现了Cloneable接口的类相当于具体原型类。\n\n\n# 2.4 原型模式应用举例\n\n * 题目描述\n   \n   某数据处理软件需要增加一个图表复制功能。在图表对象（DataChart）中包含一个数据集对象(DataSet)。数据集对象用于封装要显示的数据，用户可以通过界面上的复制按钮将该图表复制一份，复制后，即可得到新的图表对象，然后可以修改新图表的编号、颜色、数据。试用原型模式设计软件实现深克隆。\n\n * UML类图\n   \n   在该设计方案中，DataChart 类包含一个 DataSet 对象，在复制 DataChart 对象的同时将 复制 DataSet 对象，因此需要使用深克隆技术，可使用流来实现深克隆。其中Serializable是java.io包中定义的、用于实现Java类的序列化操作而提供的一个语义级别的接口。Serializable序列化接口没有任何方法或者字段，只是用于标识可序列化的语义。实现了Serializable接口的类可以被ObjectOutputStream转换为字节流，同时也可以通过ObjectInputStream再将其解析为对象。故我们实现这个接口即可使用流来实现深克隆\n\n * 代码\n   \n   代码地址\n\n\n# 3 原型管理器\n\n\n# 3.1 原型管理器实现\n\n原型管理器(Prototype Manager)是将多个原型对象存储在一个集合中供客户端使用，它是一个专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象， 如果需要某个原型对象的一个克隆，可以通过复制集合中对应的原型对象来获得。 在原型管理器中针对抽象原型类进行编程，以便扩展。 其结构如图所示：\n\n\n\n其中典型的原型管理器PrototypeManager类的实现代码片段如下：\n\npackage prototype_pattern;\n\nimport java.util.Hashtable;\n\n/**\n * @author Cnc_hzf\n * @date 2022/4/22 15:00\n */\npublic class PrototypeManager {\n    private Hashtable prototypeTable = new Hashtable(); // 使用Hashtable存储原型对象\n    public PrototypeManager() {\n        prototypeTable.put("A", new ConcretePrototypeA());\n        prototypeTable.put("B", new ConcretePrototypeB());\n    }\n    public void add(String key, Prototype prototype) {\n        prototypeTable.put(key, prototype);\n    }\n    public Prototype get(String key) {\n        Prototype clone = ((Prototype) prototypeTable.get(key)).clone(); // 通过克隆方法创建新对象\n        return clone;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n在实际开发中可以将PrototypeManger设计为单例类，确保系统中有且仅有一个PrototypeManager对象，这样既有利于节省系统资源，还可以更好地对原型管理器对象进行控制。\n\n\n# 3.2 原型管理器应用举例\n\n * 题目描述\n   \n   > 某公司需要创建一个公文管理器，公文管理器中需要提供一个集合对象来存储一些公文模板，用户可以通过复制这些模板快速的创建新的公文，试使用带有原型管理器的原型模式来设计该公文管理器并使用Java代码编程模拟。\n\n * UML类图\n   \n   \n   \n   其中，OfficialDocument （抽象公文类）充当抽象原型类，其子类 FAR（Feasibility Analysis Report，可行性分析报告）和 SRS（Software Requirements Specification，软件需求规格说明书）充当具体原型类，PrototypeManager 充当原型管理器。\n\n * 代码\n   \n   代码地址',normalizedContent:'# 1 原型模式介绍\n\n原型模式（prototype pattern）是一种对象创建型模式，它是使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。\n\n它的工作原理很简单：将一个原型对象传给要发动创建的对象（即客户端对象），这个要发动创建的对象通过请求原型对象复制自己来实现创建过程。\n\n\n\n> 意图： 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。\n> \n> 主要解决： 在运行期建立和删除原型。\n> \n> 何时使用： 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。\n> \n> 如何解决： 利用已有的一个原型对象，快速地生成和原型对象一样的实例。\n> \n> 关键代码： 1、实现克隆操作，在 java 继承 cloneable，重写 clone()，在 .net 中可以使用 object 类的 memberwiseclone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些"易变类"拥有稳定的接口。\n> \n> 应用实例： 1、细胞分裂。 2、java 中的 object clone() 方法。\n> \n> 优点： 1、性能提高。 2、逃避构造函数的约束。\n> \n> 缺点： 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 cloneable 接口。\n> \n> 使用场景： 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 java 融为浑然一体，大家可以随手拿来使用。\n> \n> 注意事项： 与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 cloneable，重写，深拷贝是通过实现 serializable 读取二进制流。\n\n\n# 2 原型模式详解\n\n\n# 2.1 原型模式结构\n\n原型模式包含以下3个角色。\n\n 1. prototype（抽象原型类）：它是声明克隆方法的接口，是所有具体原型类的公共父类，它可以是抽象类也可以是接口，甚至还可以是具体实现类。\n 2. concreteprototype（具体原型类）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。\n 3. client（客户类）：在客户类中，让一个原型对象克隆自身从而创建一个新的对象，只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。\n\n\n# 2.2 深克隆与浅克隆\n\n根据在复制原型对象的同时是否复制包含在原型对象中引用类型的成员变量，原型模式的克隆机制可分为两种，即浅克隆（shallow clone）和深克隆（deep clone）。\n\n# 2.2.1 浅克隆\n\n在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。简单来说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。\n\n\n\n# 2.2.2 深克隆\n\n在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。\n\n\n\n\n# 2.3 原型模式实现\n\n实现原型模式的关键在于如何实现克隆方法。这里介绍两种在java语言中最常用的克隆实现方法。\n\n# 2.3.1 通用实现方法\n\n通用的克隆实现方法是在具体原型类的克隆方法中实例化一个与自身类型相同的对象并将其返回，同时将相关的参数传入新创建的对象中，保证它们的成员变量相同。\n\n典型的抽象原型类代码如下：\n\npublic abstract class prototype {\n    public abstract prototype clone();\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n典型的具体原型类代码如下：\n\npublic class concreteprototype extends prototype {\n    private string name; // 成员变量\n    public void setname(string name) {\n        this.name = name;\n    }\n    public void getname() {\n        return this.name;\n    }\n    // 克隆方法实现\n    public prototype clone() {\n        prototype prototype = new concreteprototype(); // 创建新对象\n        prototype.setname(this.name);\n        return prototype;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这样我们就只需要在客户类中创建一个concreteprototype对象作为原型对象，然后调用其clone()方法即可得到对应的克隆对象。\n\n此方法是原型模式的通用实现，它与编程语言本身的特性无关，其他面向对象编程语言也可以使用这种形式来实现对原型对象的克隆。\n\n在这种通用实现方法中，可通过手工编写clone()方法来实现浅克隆和深克隆。对于引用类型的对象，可以在clone()方法中通过赋值的方式来实现复制，这是一种浅克隆实现方案；如果在clone()方法中通过创建一个全新的成员对象来实现复制，则是一种深克隆实现方案。\n\n# 2.3.2 java语言中的clone()方法和cloneable接口\n\n在java语言中，所有的java类均继承自java.lang.object类，object类提供了一个clone()方法，可以将一个java对象复制一份。因此在java中可以直接使用object提供clone()方法来实现对象的浅克隆。\n\n需要注意的是能够实现克隆的java类都必须实现一个标识接口cloneable，表示这个java类支持被复制。如果一个类没有实现这个接口但是调用了clone()方法，java编译器将会抛出一个clonenotsupportedexception异常。如下代码所示：\n\npublic class concreteprototype implements cloneable {\n    public prototype clone() {\n        object object = null;\n        try {\n            object = super.clone(); // 浅克隆\n        } catch (clonenotsupportedexception exception) {\n            system.err.println("not support cloneable");\n        }\n        return (prototype)object;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n为了获取对象的一个克隆，可以直接利用object类的clone()方法，其具体步骤如下：\n\n 1. 在派生类中覆盖基类的clone()方法，并声明为public。\n 2. 在派生类的clone()方法中调用super.clone()。\n 3. 派生类需实现cloneable接口。\n\n此时，object类相当于抽象原型类，所有实现了cloneable接口的类相当于具体原型类。\n\n\n# 2.4 原型模式应用举例\n\n * 题目描述\n   \n   某数据处理软件需要增加一个图表复制功能。在图表对象（datachart）中包含一个数据集对象(dataset)。数据集对象用于封装要显示的数据，用户可以通过界面上的复制按钮将该图表复制一份，复制后，即可得到新的图表对象，然后可以修改新图表的编号、颜色、数据。试用原型模式设计软件实现深克隆。\n\n * uml类图\n   \n   在该设计方案中，datachart 类包含一个 dataset 对象，在复制 datachart 对象的同时将 复制 dataset 对象，因此需要使用深克隆技术，可使用流来实现深克隆。其中serializable是java.io包中定义的、用于实现java类的序列化操作而提供的一个语义级别的接口。serializable序列化接口没有任何方法或者字段，只是用于标识可序列化的语义。实现了serializable接口的类可以被objectoutputstream转换为字节流，同时也可以通过objectinputstream再将其解析为对象。故我们实现这个接口即可使用流来实现深克隆\n\n * 代码\n   \n   代码地址\n\n\n# 3 原型管理器\n\n\n# 3.1 原型管理器实现\n\n原型管理器(prototype manager)是将多个原型对象存储在一个集合中供客户端使用，它是一个专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象， 如果需要某个原型对象的一个克隆，可以通过复制集合中对应的原型对象来获得。 在原型管理器中针对抽象原型类进行编程，以便扩展。 其结构如图所示：\n\n\n\n其中典型的原型管理器prototypemanager类的实现代码片段如下：\n\npackage prototype_pattern;\n\nimport java.util.hashtable;\n\n/**\n * @author cnc_hzf\n * @date 2022/4/22 15:00\n */\npublic class prototypemanager {\n    private hashtable prototypetable = new hashtable(); // 使用hashtable存储原型对象\n    public prototypemanager() {\n        prototypetable.put("a", new concreteprototypea());\n        prototypetable.put("b", new concreteprototypeb());\n    }\n    public void add(string key, prototype prototype) {\n        prototypetable.put(key, prototype);\n    }\n    public prototype get(string key) {\n        prototype clone = ((prototype) prototypetable.get(key)).clone(); // 通过克隆方法创建新对象\n        return clone;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n在实际开发中可以将prototypemanger设计为单例类，确保系统中有且仅有一个prototypemanager对象，这样既有利于节省系统资源，还可以更好地对原型管理器对象进行控制。\n\n\n# 3.2 原型管理器应用举例\n\n * 题目描述\n   \n   > 某公司需要创建一个公文管理器，公文管理器中需要提供一个集合对象来存储一些公文模板，用户可以通过复制这些模板快速的创建新的公文，试使用带有原型管理器的原型模式来设计该公文管理器并使用java代码编程模拟。\n\n * uml类图\n   \n   \n   \n   其中，officialdocument （抽象公文类）充当抽象原型类，其子类 far（feasibility analysis report，可行性分析报告）和 srs（software requirements specification，软件需求规格说明书）充当具体原型类，prototypemanager 充当原型管理器。\n\n * 代码\n   \n   代码地址',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"设计模式之桥接模式详解（Java实现）",frontmatter:{title:"设计模式之桥接模式详解（Java实现）",date:"2022-04-24T21:25:59.000Z",tags:["桥接模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/aab372/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/06.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89.html",relativePath:"01.开发/02.开发框架/03.设计模式/06.设计模式之桥接模式详解（Java实现）.md",key:"v-0373c099",path:"/pages/aab372/",headers:[{level:2,title:"1 桥接模式介绍",slug:"_1-桥接模式介绍",normalizedTitle:"1 桥接模式介绍",charIndex:2},{level:2,title:"2 桥接模式详解",slug:"_2-桥接模式详解",normalizedTitle:"2 桥接模式详解",charIndex:975},{level:3,title:"2.1 桥接模式结构",slug:"_2-1-桥接模式结构",normalizedTitle:"2.1 桥接模式结构",charIndex:988},{level:3,title:"2.2 桥接模式实现",slug:"_2-2-桥接模式实现",normalizedTitle:"2.2 桥接模式实现",charIndex:1692},{level:3,title:"2.3 桥接模式应用实例",slug:"_2-3-桥接模式应用实例",normalizedTitle:"2.3 桥接模式应用实例",charIndex:2867}],headersStr:"1 桥接模式介绍 2 桥接模式详解 2.1 桥接模式结构 2.2 桥接模式实现 2.3 桥接模式应用实例",content:"# 1 桥接模式介绍\n\n毛笔和蜡笔是两种很常见的文具，它们都归属于画笔。假设我们需要大、中、小3种型号的画笔，能够绘制12种不同的颜色。那么我们的解决方案如下：\n\n\n\n显然，在毛笔中，我们将颜色和型号进行了分离，增加新的颜色或者型号对另一方没有影响，即用软件工程中的术语，可以认为在蜡笔中颜色和型号之间存在较强的耦合性，而毛笔很好地将二者解耦，使用起来非常灵活，扩展也较为方便。\n\n在软件开发中也有一种设计模式可以用来处理上述类似的具有多变化维度的情况，它就是桥接模式（Bridge Pattern）。它将抽象部分与它的实现部分解耦，使得两者都能独立变化。\n\n桥接模式又被称为柄体(Handle and Body)模式或接口(Interface)模式，用抽象关联取代了传统的多层继承，将类之间的静态继承关系转换为动态的对象组合关系。\n\n> 主要解决： 在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。\n> \n> 何时使用： 实现系统可能有多个角度分类，每一种角度都可能变化。\n> \n> **如何解决：**把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。\n> \n> 关键代码： 抽象类依赖实现类。\n> \n> 应用实例： 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。\n> \n> 优点： 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。\n> \n> **缺点：**桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。\n> \n> 使用场景： 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。\n> \n> 注意事项： 对于两个独立变化的维度，使用桥接模式再适合不过了。\n\n\n# 2 桥接模式详解\n\n\n# 2.1 桥接模式结构\n\n桥接模式的结构图如下：\n\n\n\n由上图可知，桥接模式包括以下4个角色。\n\n 1. Abstraction（抽象类）：它是用于定义抽象类的接口，通常是抽象类而不是接口，其中定义了一个Implementor（实现类接口）类型的对象并可以维护该对象，它与Implementor之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。\n 2. RefinedAbstraction（扩充抽象类）：它扩充由Abstraction定义的接口，通常情况下它不再是抽象类而是具体类，实现了在Abstraction中声明的抽象业务方法，在RefinedAbstraction中可以调用在Implementor中定义的业务方法。\n 3. Implementor（实现类接口）：它是定义实现类的接口，这个接口不一定要与Abstraction的接口完全一致，事实上这两个接口可以完全不同。一般而言，Implementor接口仅提供基本操作，而Abstraction定义的接口可能会做更多更复杂的操作。Implementor接口对这些基本操作进行了声明，而具体实现交给其子类。通过关联关系，在Abstraction中不仅拥有自己的方法，还可以调用到Implementor中定义的方法，使用关联关系代替继承关系。\n 4. ConcreteImplementor（具体实现类）：它具体实现了Implementor接口，在不同的ConcreteImplementor中提供基本操作的不同实现，在程序运行时ConcreteImplementor对象将替换其父类对象，提供给抽象类具体的业务操作方法。\n\n\n# 2.2 桥接模式实现\n\n在具体编码实现时，由于在桥接模式中存在两个独立变化的维度，为了降低两者之间的耦合度，首先需要针对两个不同的维度提取抽象类和实现类接口，并建立一个抽象关联关系。对于“实现部分维度”，典型的接口代码如下：\n\npublic interface Implementor {\n    public void operationImpl();\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n在实现Implementor接口的子类ConcreteImplementor中实现了在该接口中声明的方法，用于定义与该维度相对应的一些具体方法，代码如下：\n\npublic class ConcreteImplementor implements Implementor {\n    public void operationImpl() {\n        //具体业务方法的实现\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n对于另一“抽象部分”维度而言，其典型的抽象类代码如下：\n\npublic abstract class Abstraction {\n    protected Implementor impl; //定义实现类接口对象\n\n    public void setImpl(Implementor impl) {\n        this.impl = impl;\n    }\n\n    public abstract void operation(); //声明抽象业务方法\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n在抽象类Abstraction中定义了一个实现类接口类型的成员对象impl，再通过Setter方法或者构造方法以注入的方式给该对象赋值。一般将该对象的可见性定义为protected，以便在其子类中访问Implementor的方法，其子类一般称为扩充对象类或细化抽象类（RefinedAbstraction），典型的RefinedAbstraction类代码如下：\n\npublic class RefinedAbstraction extends Abstraction {\n    public void operation() {\n        //业务代码\n        impl.operationImpl(); //调用实现类的方法\n        //业务代码\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n对于客户端而言，可以针对两个维度的抽象层编程，在程序运行时再动态确定两个维度的子类，动态组合对象，将两个独立变化的维度完全解耦，以便能够灵活地扩充任一维度而对另一维度不造成任何影响。\n\n\n# 2.3 桥接模式应用实例\n\n * 题目描述\n   \n   > 某软件公司欲开发一个数据转换工具，可以将数据库中的数据转换成多种文件格式，例如TXT、XML、PDF等格式，同时该工具需要支持多种不同的数据库。试用桥接模式对其进行设计。\n\n * UML类图\n   \n   \n   \n   其中，FileConvertor 充当抽象类角色，TXTConvertor、XMLConvertor 和 PDFConvertor 充当扩充抽象类角色，DataHandler 充当实现类接口角色，OracleHandler 和SQLServerHandler充当具体实现类角色。\n\n * 代码\n   \n   代码地址",normalizedContent:"# 1 桥接模式介绍\n\n毛笔和蜡笔是两种很常见的文具，它们都归属于画笔。假设我们需要大、中、小3种型号的画笔，能够绘制12种不同的颜色。那么我们的解决方案如下：\n\n\n\n显然，在毛笔中，我们将颜色和型号进行了分离，增加新的颜色或者型号对另一方没有影响，即用软件工程中的术语，可以认为在蜡笔中颜色和型号之间存在较强的耦合性，而毛笔很好地将二者解耦，使用起来非常灵活，扩展也较为方便。\n\n在软件开发中也有一种设计模式可以用来处理上述类似的具有多变化维度的情况，它就是桥接模式（bridge pattern）。它将抽象部分与它的实现部分解耦，使得两者都能独立变化。\n\n桥接模式又被称为柄体(handle and body)模式或接口(interface)模式，用抽象关联取代了传统的多层继承，将类之间的静态继承关系转换为动态的对象组合关系。\n\n> 主要解决： 在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。\n> \n> 何时使用： 实现系统可能有多个角度分类，每一种角度都可能变化。\n> \n> **如何解决：**把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。\n> \n> 关键代码： 抽象类依赖实现类。\n> \n> 应用实例： 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。\n> \n> 优点： 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。\n> \n> **缺点：**桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。\n> \n> 使用场景： 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。\n> \n> 注意事项： 对于两个独立变化的维度，使用桥接模式再适合不过了。\n\n\n# 2 桥接模式详解\n\n\n# 2.1 桥接模式结构\n\n桥接模式的结构图如下：\n\n\n\n由上图可知，桥接模式包括以下4个角色。\n\n 1. abstraction（抽象类）：它是用于定义抽象类的接口，通常是抽象类而不是接口，其中定义了一个implementor（实现类接口）类型的对象并可以维护该对象，它与implementor之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。\n 2. refinedabstraction（扩充抽象类）：它扩充由abstraction定义的接口，通常情况下它不再是抽象类而是具体类，实现了在abstraction中声明的抽象业务方法，在refinedabstraction中可以调用在implementor中定义的业务方法。\n 3. implementor（实现类接口）：它是定义实现类的接口，这个接口不一定要与abstraction的接口完全一致，事实上这两个接口可以完全不同。一般而言，implementor接口仅提供基本操作，而abstraction定义的接口可能会做更多更复杂的操作。implementor接口对这些基本操作进行了声明，而具体实现交给其子类。通过关联关系，在abstraction中不仅拥有自己的方法，还可以调用到implementor中定义的方法，使用关联关系代替继承关系。\n 4. concreteimplementor（具体实现类）：它具体实现了implementor接口，在不同的concreteimplementor中提供基本操作的不同实现，在程序运行时concreteimplementor对象将替换其父类对象，提供给抽象类具体的业务操作方法。\n\n\n# 2.2 桥接模式实现\n\n在具体编码实现时，由于在桥接模式中存在两个独立变化的维度，为了降低两者之间的耦合度，首先需要针对两个不同的维度提取抽象类和实现类接口，并建立一个抽象关联关系。对于“实现部分维度”，典型的接口代码如下：\n\npublic interface implementor {\n    public void operationimpl();\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n在实现implementor接口的子类concreteimplementor中实现了在该接口中声明的方法，用于定义与该维度相对应的一些具体方法，代码如下：\n\npublic class concreteimplementor implements implementor {\n    public void operationimpl() {\n        //具体业务方法的实现\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n对于另一“抽象部分”维度而言，其典型的抽象类代码如下：\n\npublic abstract class abstraction {\n    protected implementor impl; //定义实现类接口对象\n\n    public void setimpl(implementor impl) {\n        this.impl = impl;\n    }\n\n    public abstract void operation(); //声明抽象业务方法\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n在抽象类abstraction中定义了一个实现类接口类型的成员对象impl，再通过setter方法或者构造方法以注入的方式给该对象赋值。一般将该对象的可见性定义为protected，以便在其子类中访问implementor的方法，其子类一般称为扩充对象类或细化抽象类（refinedabstraction），典型的refinedabstraction类代码如下：\n\npublic class refinedabstraction extends abstraction {\n    public void operation() {\n        //业务代码\n        impl.operationimpl(); //调用实现类的方法\n        //业务代码\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n对于客户端而言，可以针对两个维度的抽象层编程，在程序运行时再动态确定两个维度的子类，动态组合对象，将两个独立变化的维度完全解耦，以便能够灵活地扩充任一维度而对另一维度不造成任何影响。\n\n\n# 2.3 桥接模式应用实例\n\n * 题目描述\n   \n   > 某软件公司欲开发一个数据转换工具，可以将数据库中的数据转换成多种文件格式，例如txt、xml、pdf等格式，同时该工具需要支持多种不同的数据库。试用桥接模式对其进行设计。\n\n * uml类图\n   \n   \n   \n   其中，fileconvertor 充当抽象类角色，txtconvertor、xmlconvertor 和 pdfconvertor 充当扩充抽象类角色，datahandler 充当实现类接口角色，oraclehandler 和sqlserverhandler充当具体实现类角色。\n\n * 代码\n   \n   代码地址",charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"设计模式之装饰模式详解（Java实现）",frontmatter:{title:"设计模式之装饰模式详解（Java实现）",date:"2022-04-28T15:31:32.000Z",tags:["装饰模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/c49acf/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/08.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89.html",relativePath:"01.开发/02.开发框架/03.设计模式/08.设计模式之装饰模式详解（Java实现）.md",key:"v-4dbea03d",path:"/pages/c49acf/",headers:[{level:2,title:"1 装饰模式介绍",slug:"_1-装饰模式介绍",normalizedTitle:"1 装饰模式介绍",charIndex:2},{level:2,title:"2 装饰模式详解",slug:"_2-装饰模式详解",normalizedTitle:"2 装饰模式详解",charIndex:776},{level:3,title:"2.1 装饰模式结构",slug:"_2-1-装饰模式结构",normalizedTitle:"2.1 装饰模式结构",charIndex:789},{level:3,title:"2.2 装饰模式实现",slug:"_2-2-装饰模式实现",normalizedTitle:"2.2 装饰模式实现",charIndex:1257},{level:3,title:"2.3 装饰模式应用举例",slug:"_2-3-装饰模式应用举例",normalizedTitle:"2.3 装饰模式应用举例",charIndex:2277},{level:2,title:"3 透明装饰模式和半透明装饰模式",slug:"_3-透明装饰模式和半透明装饰模式",normalizedTitle:"3 透明装饰模式和半透明装饰模式",charIndex:2667}],headersStr:"1 装饰模式介绍 2 装饰模式详解 2.1 装饰模式结构 2.2 装饰模式实现 2.3 装饰模式应用举例 3 透明装饰模式和半透明装饰模式",content:'# 1 装饰模式介绍\n\n在生活中，我们往往会给图片增加一些边框等来装饰图片，可以让图片变得更漂亮，如下图，就是对小狗图片的装饰。\n\n\n\n在软件设计中，我们也有一种类似图片的技术可以对已有对象（图片）的功能进行扩展（装修），以获得更加符合用户需求的对象，使得对象具有更加强大的功能。这种技术对应于一种被称之为装饰模式（Decorator Pattern）的设计模式。装饰模式能动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案。引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩展原有类的功能\n\n> 主要解决： 一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。\n> \n> 何时使用： 在不想增加很多子类的情况下扩展类。\n> \n> 如何解决： 将具体功能职责划分，同时继承装饰者模式。\n> \n> 关键代码： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。\n> \n> 应用实例： 1、孙悟空有 72 变，当他变成"庙宇"后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。\n> \n> 优点： 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。\n> \n> 缺点： 多层装饰比较复杂。\n> \n> 使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。\n> \n> 注意事项： 可代替继承。\n\n\n# 2 装饰模式详解\n\n\n# 2.1 装饰模式结构\n\n装饰模式的结构如图所示：\n\n\n\n由结构图可知，装饰模式包含以下4个角色。\n\n 1. Component（抽象构件）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。\n 2. ConcreteComponent（具体构件）：它是抽象构件的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰类可以给它增加额外的职责（方法）。\n 3. Decorator（抽象装饰类）：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。\n 4. ConcreteDecorator（具体装饰类）：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用于扩充该对象的行为。\n\n\n# 2.2 装饰模式实现\n\n抽象构件类典型代码：\n\npublic abstract class Component {\n    public abstract void operation();\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n具体构件类典型代码：\n\npublic class ConcreteComponent extends Component {\n    public void operation() {\n        //实现基本功能    \n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n抽象装饰类典型代码：\n\npublic class Decorator extends Component {\n    private Component component; //维持一个对抽象构件对象的引用\n\n    //注入一个抽象构件类型的对象\n    public Decorator(Component component) {\n        this.component=component;\n    }\n\n    public void operation() {\n        component.operation();  //调用原有业务方法\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n具体装饰类典型代码：\n\npublic class ConcreteDecorator extends Decorator {\n    public ConcreteDecorator(Component component) {\n        super(component); \n    }\n\n    public void operation() {\n        super.operation(); //调用原有业务方法\n        addedBehavior(); //调用新增业务方法\n    }\n\n    //新增业务方法\n    public void addedBehavior() { \n        ……\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2.3 装饰模式应用举例\n\n * 题目描述\n   \n   > 简单的手机（SimplePhone）再接收到来电的时候，会发出声音提醒主人；而现在我们需要为该手机添加一项功能，在接收来电的时候，除了声音还能产生振动（JarPhone）；还可以得到更高级的手机（ComplexPhone），来电的时候，它不仅能够发声，产生振动，而且还有灯光在闪烁提示。现在用装饰模式来模拟一下手机的升级过程，要求绘制类图并编程实现。\n\n * UML类图\n\n\n\n其中，Cellphone 为抽象类，声明了来电方法 receiveCall()，SimplePhone 为简单手机类， 提供了声音提示，JarPhone 和 ComplexPhone 分别提供了振动提示和灯光闪烁提示。 PhoneDecorator 是抽象装饰者，它维持一个对父类对象的引用。\n\n * 代码\n   \n   代码地址\n\n\n# 3 透明装饰模式和半透明装饰模式\n\n 1. 透明装饰模式\n    \n    要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型。对于客户端而言，具体构件对象和具体装饰对象没有任何区别。可以让客户端透明地使用装饰之前的对象和装饰之后的对象，无须关心它们的区别。可以对一个已装饰过的对象进行多次装实例：\n    \n    ……\n    Component component_o,component_d1,component_d2; //全部使用抽象构件定义\n    component_o = new ConcreteComponent();\n    component_d1 = new ConcreteDecorator1(component_o);\n    component_d2 = new ConcreteDecorator2(component_d1);\n    component_d2.operation();\n    //无法单独调用component_d2的addedBehavior()方法\n    ……\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 2. 半透明装饰模式\n    \n    用具体装饰类型来定义装饰之后的对象，而具体构件使用抽象构件类型来定义。对于客户端而言，具体构件类型无须关心，是透明的；但是具体装饰类型必须指定，这是不透明的。可以给系统带来更多的灵活性，设计相对简单，使用起来也非常方便，客户端使用具体装饰类型来定义装饰后的对象，因此可以单独调用addedBehavior()方法。最大的缺点在于不能实现对同一个对象的多次装饰，而且客户端需要有区别地对待装饰之前的对象和装饰之后的对象。实例：\n    \n    ……\n    Component component_o; //使用抽象构件类型定义\n    component_o = new ConcreteComponent();\n    component_o.operation();\n    ConcreteDecorator component_d; //使用具体装饰类型定义\n    component_d = new ConcreteDecorator(component_o);\n    component_d.operation();\n    component_d.addedBehavior(); //单独调用新增业务方法\n    ……\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    ',normalizedContent:'# 1 装饰模式介绍\n\n在生活中，我们往往会给图片增加一些边框等来装饰图片，可以让图片变得更漂亮，如下图，就是对小狗图片的装饰。\n\n\n\n在软件设计中，我们也有一种类似图片的技术可以对已有对象（图片）的功能进行扩展（装修），以获得更加符合用户需求的对象，使得对象具有更加强大的功能。这种技术对应于一种被称之为装饰模式（decorator pattern）的设计模式。装饰模式能动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案。引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩展原有类的功能\n\n> 主要解决： 一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。\n> \n> 何时使用： 在不想增加很多子类的情况下扩展类。\n> \n> 如何解决： 将具体功能职责划分，同时继承装饰者模式。\n> \n> 关键代码： 1、component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 component 类，具体扩展类重写父类方法。\n> \n> 应用实例： 1、孙悟空有 72 变，当他变成"庙宇"后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。\n> \n> 优点： 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。\n> \n> 缺点： 多层装饰比较复杂。\n> \n> 使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。\n> \n> 注意事项： 可代替继承。\n\n\n# 2 装饰模式详解\n\n\n# 2.1 装饰模式结构\n\n装饰模式的结构如图所示：\n\n\n\n由结构图可知，装饰模式包含以下4个角色。\n\n 1. component（抽象构件）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。\n 2. concretecomponent（具体构件）：它是抽象构件的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰类可以给它增加额外的职责（方法）。\n 3. decorator（抽象装饰类）：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。\n 4. concretedecorator（具体装饰类）：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用于扩充该对象的行为。\n\n\n# 2.2 装饰模式实现\n\n抽象构件类典型代码：\n\npublic abstract class component {\n    public abstract void operation();\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n具体构件类典型代码：\n\npublic class concretecomponent extends component {\n    public void operation() {\n        //实现基本功能    \n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n抽象装饰类典型代码：\n\npublic class decorator extends component {\n    private component component; //维持一个对抽象构件对象的引用\n\n    //注入一个抽象构件类型的对象\n    public decorator(component component) {\n        this.component=component;\n    }\n\n    public void operation() {\n        component.operation();  //调用原有业务方法\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n具体装饰类典型代码：\n\npublic class concretedecorator extends decorator {\n    public concretedecorator(component component) {\n        super(component); \n    }\n\n    public void operation() {\n        super.operation(); //调用原有业务方法\n        addedbehavior(); //调用新增业务方法\n    }\n\n    //新增业务方法\n    public void addedbehavior() { \n        ……\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2.3 装饰模式应用举例\n\n * 题目描述\n   \n   > 简单的手机（simplephone）再接收到来电的时候，会发出声音提醒主人；而现在我们需要为该手机添加一项功能，在接收来电的时候，除了声音还能产生振动（jarphone）；还可以得到更高级的手机（complexphone），来电的时候，它不仅能够发声，产生振动，而且还有灯光在闪烁提示。现在用装饰模式来模拟一下手机的升级过程，要求绘制类图并编程实现。\n\n * uml类图\n\n\n\n其中，cellphone 为抽象类，声明了来电方法 receivecall()，simplephone 为简单手机类， 提供了声音提示，jarphone 和 complexphone 分别提供了振动提示和灯光闪烁提示。 phonedecorator 是抽象装饰者，它维持一个对父类对象的引用。\n\n * 代码\n   \n   代码地址\n\n\n# 3 透明装饰模式和半透明装饰模式\n\n 1. 透明装饰模式\n    \n    要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型。对于客户端而言，具体构件对象和具体装饰对象没有任何区别。可以让客户端透明地使用装饰之前的对象和装饰之后的对象，无须关心它们的区别。可以对一个已装饰过的对象进行多次装实例：\n    \n    ……\n    component component_o,component_d1,component_d2; //全部使用抽象构件定义\n    component_o = new concretecomponent();\n    component_d1 = new concretedecorator1(component_o);\n    component_d2 = new concretedecorator2(component_d1);\n    component_d2.operation();\n    //无法单独调用component_d2的addedbehavior()方法\n    ……\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 2. 半透明装饰模式\n    \n    用具体装饰类型来定义装饰之后的对象，而具体构件使用抽象构件类型来定义。对于客户端而言，具体构件类型无须关心，是透明的；但是具体装饰类型必须指定，这是不透明的。可以给系统带来更多的灵活性，设计相对简单，使用起来也非常方便，客户端使用具体装饰类型来定义装饰后的对象，因此可以单独调用addedbehavior()方法。最大的缺点在于不能实现对同一个对象的多次装饰，而且客户端需要有区别地对待装饰之前的对象和装饰之后的对象。实例：\n    \n    ……\n    component component_o; //使用抽象构件类型定义\n    component_o = new concretecomponent();\n    component_o.operation();\n    concretedecorator component_d; //使用具体装饰类型定义\n    component_d = new concretedecorator(component_o);\n    component_d.operation();\n    component_d.addedbehavior(); //单独调用新增业务方法\n    ……\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    ',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"设计模式之组合模式详解（Java实现）",frontmatter:{title:"设计模式之组合模式详解（Java实现）",date:"2022-04-25T19:58:27.000Z",tags:["组合模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/eac75e/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/07.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89.html",relativePath:"01.开发/02.开发框架/03.设计模式/07.设计模式之组合模式详解（Java实现）.md",key:"v-a521f62a",path:"/pages/eac75e/",headers:[{level:2,title:"1 组合模式介绍",slug:"_1-组合模式介绍",normalizedTitle:"1 组合模式介绍",charIndex:2},{level:2,title:"2 组合模式详解",slug:"_2-组合模式详解",normalizedTitle:"2 组合模式详解",charIndex:750},{level:3,title:"2.1 组合模式结构",slug:"_2-1-组合模式结构",normalizedTitle:"2.1 组合模式结构",charIndex:763},{level:3,title:"2.2 组合模式实现",slug:"_2-2-组合模式实现",normalizedTitle:"2.2 组合模式实现",charIndex:1163},{level:3,title:"2.3 组合模式应用举例",slug:"_2-3-组合模式应用举例",normalizedTitle:"2.3 组合模式应用举例",charIndex:2521},{level:2,title:"3 透明组合模式和安全组合模式",slug:"_3-透明组合模式和安全组合模式",normalizedTitle:"3 透明组合模式和安全组合模式",charIndex:2838}],headersStr:"1 组合模式介绍 2 组合模式详解 2.1 组合模式结构 2.2 组合模式实现 2.3 组合模式应用举例 3 透明组合模式和安全组合模式",content:"# 1 组合模式介绍\n\n在我们的树形目录结构中，包含文件和文件夹两类不同的元素，如下图。\n\n\n\n其中文件夹中可以包含文件，也可以继续包含文件夹；而在文件中不能再包含子文件或者子文件夹。\n\n那么我们可以将文件夹看作是容器（Container），将文件看作是叶子（Leaf）。那如何一致的对待容器对象和叶子对象呢？\n\n组合模式（Composite Pattern）让客户端可以统一对待单个对象和组合对象。这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。\n\n> 主要解决： 它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。\n> \n> 何时使用： 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。\n> \n> 如何解决： 树枝和叶子实现统一接口，树枝内部组合该接口。\n> \n> 关键代码： 树枝内部组合该接口，并且含有内部属性 List，里面放 Component。\n> \n> 应用实例： 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。\n> \n> 优点： 1、高层模块调用简单。 2、节点自由增加。\n> \n> 缺点： 在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。\n> \n> 使用场景： 部分、整体场景，如树形菜单，文件、文件夹的管理。\n> \n> 注意事项： 定义时为具体类。\n\n\n# 2 组合模式详解\n\n\n# 2.1 组合模式结构\n\n组合模式的结构如图所示：\n\n\n\n由图可知，组合模式包含以下3个角色。\n\n 1. Component（抽象构件）：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。\n 2. Leaf（叶子构件）：它在组合结构中表示叶子结点对象，叶子结点没有子结点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过抛出异常、提示错误等方式进行处理。\n 3. Composite（容器构件）：它在组合结构中表示容器结点对象，容器结点包含子结点，其子结点可以是叶子结点，也可以是容器结点，它提供一个集合用于存储子结点，实现类在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子结点的业务方法。\n\n\n# 2.2 组合模式实现\n\n对于组合模式中的抽象构件角色，其典型代码如下：\n\npublic abstract class Component {\n    public abstract void addComponent(Component c); // 增加成员\n    public abstract void remove(Component c); // 删除成员\n    public abstract Component getChild(int i); // 获取成员\n    public abstract void operation(); // 业务方法\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n对于组合模式中的叶子构件角色，其典型代码如下：\n\npublic class Leaf extends Component {\n    public void add(Component c) {\n        // 异常处理或错误提示\n    }\n    public void remove(Component c) {\n        // 异常处理或错误提示\n    }\n    public void getChild(int i) {\n        // 异常处理或错误提示\n    }\n    public void operation() {\n        // 叶子构件具体业务方法的实现\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n对于组合模式中的容器构件角色，其典型代码如下：\n\nimport java.util.*;\n\npublic class Composite extends Component {\n    private ArrayList<Component> list = new ArrayList<Component>();\n    \n    public void add(Component c) {\n        list.add(c);\n    }\n    public void remove(Component c) {\n        list.remove(c);\n    }\n    public void getChild(int i) {\n        return (Componnent) list.get(i);\n    }\n    public void operation() {\n        // 容器构件具体业务方法的实现，将递归调用成员构件的业务方法\n        for (Object object : list) {\n            ((Component)obj).operation();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 2.3 组合模式应用举例\n\n * 题目描述\n   \n   > 某软件公司欲开发一个杀毒(Antivirus)软件，该软件既可以对某个文件夹(Folder)杀毒，也可以对某个指定的文件(File)进行杀毒。该杀毒软件还可以根据各类文件的特点，为不同类型的文件提供不同的杀毒方式，例如图像文件(ImageFile)和文本文件(TextFile)的杀毒方式就有所差异。现使用组合模式来设计该杀毒软件的整体框架。\n\n * UML类图\n   \n   其中，AbstractFile充当抽象构件类，Folder充当容器构件类，ImageFile、TextFile和VideoFile充当叶子构件类。\n\n * 代码\n   \n   代码地址\n\n\n# 3 透明组合模式和安全组合模式\n\n组合模式根据抽象构件的定义形式又可以分为透明组合模式和安全组合模式。\n\n * 透明组合模式\n   \n   \n   \n   根据结构图我们可以看出抽象构件Component中声明了所有用于管理成员对象的方法，包括add()、remove()，以及getChild()等方法，在客户端看来，叶子对象与容器对象所提供的方法是一致的，客户端可以一致地对待所有的对象，缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的。\n\n * 安全组合模式\n   \n   \n   \n   根据结构图可以看出抽象构件Component中没有声明任何用于管理成员对象的方法，而是在Composite类中声明并实现这些方法，对于叶子对象，客户端不可能调用到这些方法。缺点是不够透明，客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。但在实际应用中，安全组合模式的使用频率也非常高。",normalizedContent:"# 1 组合模式介绍\n\n在我们的树形目录结构中，包含文件和文件夹两类不同的元素，如下图。\n\n\n\n其中文件夹中可以包含文件，也可以继续包含文件夹；而在文件中不能再包含子文件或者子文件夹。\n\n那么我们可以将文件夹看作是容器（container），将文件看作是叶子（leaf）。那如何一致的对待容器对象和叶子对象呢？\n\n组合模式（composite pattern）让客户端可以统一对待单个对象和组合对象。这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。\n\n> 主要解决： 它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。\n> \n> 何时使用： 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。\n> \n> 如何解决： 树枝和叶子实现统一接口，树枝内部组合该接口。\n> \n> 关键代码： 树枝内部组合该接口，并且含有内部属性 list，里面放 component。\n> \n> 应用实例： 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。 2、在 java awt 和 swing 中，对于 button 和 checkbox 是树叶，container 是树枝。\n> \n> 优点： 1、高层模块调用简单。 2、节点自由增加。\n> \n> 缺点： 在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。\n> \n> 使用场景： 部分、整体场景，如树形菜单，文件、文件夹的管理。\n> \n> 注意事项： 定义时为具体类。\n\n\n# 2 组合模式详解\n\n\n# 2.1 组合模式结构\n\n组合模式的结构如图所示：\n\n\n\n由图可知，组合模式包含以下3个角色。\n\n 1. component（抽象构件）：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。\n 2. leaf（叶子构件）：它在组合结构中表示叶子结点对象，叶子结点没有子结点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过抛出异常、提示错误等方式进行处理。\n 3. composite（容器构件）：它在组合结构中表示容器结点对象，容器结点包含子结点，其子结点可以是叶子结点，也可以是容器结点，它提供一个集合用于存储子结点，实现类在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子结点的业务方法。\n\n\n# 2.2 组合模式实现\n\n对于组合模式中的抽象构件角色，其典型代码如下：\n\npublic abstract class component {\n    public abstract void addcomponent(component c); // 增加成员\n    public abstract void remove(component c); // 删除成员\n    public abstract component getchild(int i); // 获取成员\n    public abstract void operation(); // 业务方法\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n对于组合模式中的叶子构件角色，其典型代码如下：\n\npublic class leaf extends component {\n    public void add(component c) {\n        // 异常处理或错误提示\n    }\n    public void remove(component c) {\n        // 异常处理或错误提示\n    }\n    public void getchild(int i) {\n        // 异常处理或错误提示\n    }\n    public void operation() {\n        // 叶子构件具体业务方法的实现\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n对于组合模式中的容器构件角色，其典型代码如下：\n\nimport java.util.*;\n\npublic class composite extends component {\n    private arraylist<component> list = new arraylist<component>();\n    \n    public void add(component c) {\n        list.add(c);\n    }\n    public void remove(component c) {\n        list.remove(c);\n    }\n    public void getchild(int i) {\n        return (componnent) list.get(i);\n    }\n    public void operation() {\n        // 容器构件具体业务方法的实现，将递归调用成员构件的业务方法\n        for (object object : list) {\n            ((component)obj).operation();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 2.3 组合模式应用举例\n\n * 题目描述\n   \n   > 某软件公司欲开发一个杀毒(antivirus)软件，该软件既可以对某个文件夹(folder)杀毒，也可以对某个指定的文件(file)进行杀毒。该杀毒软件还可以根据各类文件的特点，为不同类型的文件提供不同的杀毒方式，例如图像文件(imagefile)和文本文件(textfile)的杀毒方式就有所差异。现使用组合模式来设计该杀毒软件的整体框架。\n\n * uml类图\n   \n   其中，abstractfile充当抽象构件类，folder充当容器构件类，imagefile、textfile和videofile充当叶子构件类。\n\n * 代码\n   \n   代码地址\n\n\n# 3 透明组合模式和安全组合模式\n\n组合模式根据抽象构件的定义形式又可以分为透明组合模式和安全组合模式。\n\n * 透明组合模式\n   \n   \n   \n   根据结构图我们可以看出抽象构件component中声明了所有用于管理成员对象的方法，包括add()、remove()，以及getchild()等方法，在客户端看来，叶子对象与容器对象所提供的方法是一致的，客户端可以一致地对待所有的对象，缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的。\n\n * 安全组合模式\n   \n   \n   \n   根据结构图可以看出抽象构件component中没有声明任何用于管理成员对象的方法，而是在composite类中声明并实现这些方法，对于叶子对象，客户端不可能调用到这些方法。缺点是不够透明，客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。但在实际应用中，安全组合模式的使用频率也非常高。",charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"设计模式之外观模式详解（Java实现）",frontmatter:{title:"设计模式之外观模式详解（Java实现）",date:"2022-04-30T09:18:49.000Z",tags:["外观模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/e40609/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/09.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89.html",relativePath:"01.开发/02.开发框架/03.设计模式/09.设计模式之外观模式详解（Java实现）.md",key:"v-f177b3e6",path:"/pages/e40609/",headers:[{level:2,title:"1 外观模式概述",slug:"_1-外观模式概述",normalizedTitle:"1 外观模式概述",charIndex:2},{level:2,title:"2 外观模式详解",slug:"_2-外观模式详解",normalizedTitle:"2 外观模式详解",charIndex:789},{level:3,title:"2.1 外观模式结构",slug:"_2-1-外观模式结构",normalizedTitle:"2.1 外观模式结构",charIndex:802},{level:3,title:"2.2 外观模式实现",slug:"_2-2-外观模式实现",normalizedTitle:"2.2 外观模式实现",charIndex:1142},{level:3,title:"2.3 外观模式应用举例",slug:"_2-3-外观模式应用举例",normalizedTitle:"2.3 外观模式应用举例",charIndex:2105},{level:2,title:"3 抽象外观类",slug:"_3-抽象外观类",normalizedTitle:"3 抽象外观类",charIndex:2451}],headersStr:"1 外观模式概述 2 外观模式详解 2.1 外观模式结构 2.2 外观模式实现 2.3 外观模式应用举例 3 抽象外观类",content:'# 1 外观模式概述\n\n在软件开发中，有时候为了完成一项较为复杂的功能，一个客户类需要和多个业务类交互，而这些需要交互的业务类经常会作为一个整体出现，由于设计的类比较多，导致使用代码较为复杂，此时特别需要一个类似服务员的角色，由它来负责和多个业务类进行交互，而客户类只需要与该类进行交互。外观模式（Facade Pattern）通过引入一个新的外观类(Facade)来负责和多个业务类【子系统(Subsystem)，所指的子系统是一个广义的概念，它可以是一个类、一个功能模块、系统的一个组成部分或者一个完整的系统】进行交互，而客户类只需与外观类交互。\n\n\n\n它为子系统中的一组接口提供了一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n\n> 主要解决： 降低访问复杂系统的内部子系统时的复杂度，简化客户端之间的接口。\n> \n> 何时使用： 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个"接待员"即可。 2、定义系统的入口。\n> \n> 如何解决： 客户端不与系统耦合，外观类与系统耦合。\n> \n> 关键代码： 在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。\n> \n> 应用实例： 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 2、JAVA 的三层开发模式。\n> \n> 优点： 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。\n> \n> **缺点：**不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。\n> \n> 使用场景： 1、为复杂的模块或子系统提供外界访问的模块。 2、子系统相对独立。 3、预防低水平人员带来的风险。\n> \n> 注意事项： 在层次化结构中，可以使用外观模式定义系统中每一层的入口。\n\n\n# 2 外观模式详解\n\n\n# 2.1 外观模式结构\n\n外观模式没有一个一般化的类图描述，下图可以用来描述外观模式的结构图。\n\n\n\n由上图可知，外观模式包含以下两个角色。\n\n 1. Facade（外观角色）：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统，传递给相应的子系统对象处理。\n 2. SubSystem（子系统角色）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。\n\n\n# 2.2 外观模式实现\n\n子系统类通常是一些业务类，实现了一些具体的、独立的业务功能，其典型代码如下：\n\npublic class SubSystemA {\n    public void methodA() {\n        //业务实现代码\n    }\n}\npublic class SubSystemB {\n    public void methodB() {\n        //业务实现代码\n    }\n}\npublic class SubSystemC {\n    public void methodC() {\n        //业务实现代码\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n外观类的典型代码如下：\n\npublic class Facade {\n    private SubSystemA obj1 = new SubSystemA();\n    private SubSystemB obj2 = new SubSystemB();\n    private SubSystemC obj3 = new SubSystemC();\n\n    public void method() {\n        obj1.method();\n        obj2.method();\n        obj3.method();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n由于在外观类中维持了对子系统对象的引用，客户端可以通过外观类来间接调用子系统对象的业务方法，而无须与子系统对象直接交互。在引入外观类后，客户端代码变得非常简单，其典型代码如下：\n\npublic class Client {\n    public static void main(String args[]) {\n        Facade facade = new Facade();\n        facade.method();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2.3 外观模式应用举例\n\n * 题目描述\n   \n   > 某软件公司要开发一个可应用于多个软件的文件加密模块，该模块可以对文件中的数据进行加密并将加密之后的数据存储在一个新文件中，具体的流程包括3个部分，分别是读取源文件、加密、保存加密之后的文件，其中，读取文件和保存文件使用流来实现，加密操作通过求模运算实现。这3个操作相对独立，为了实现代码的独立重用，让设计更符合单一职责原则，这3个操作的业务代码封装在3个不同的类中。 现使用外观模式设计该文件加密模块。\n\n * UML类图\n   \n   \n   \n   其中，EncryptFacade充当外观类，FileReader、CipherMachine和FileWriter充当子系统类。\n\n * 代码\n   \n   代码地址\n\n\n# 3 抽象外观类\n\n在标准的外观模式的结构图中，如果需要增加、删除或更换与外观类交互的子系统类，必须修改外观类或客户端的源代码，这将违背开闭原则，因此可以通过引入抽象外观类对系统进行改进，在一定程度上解决该问题。\n\n如2.3中的题目我们需要更换一个加密类，如果我们需要增加一个新的外观类NewEncryptFacade与FileReader类、FileWriter类以及新增加的NewClipherMachine类交互，虽然原有系统类库无须作修改，但是因为客户端代码中原来针对EncryptFacade类进行编程，现在需要修改为NewEncryptFacade类，所以需要修改客户端源代码。如何在不修改客户端代码的前提下使用新的外观类呢？那么我们可以引入一个抽象外观类，客户端针对抽象外观类编程即可。结构图如下：\n\n\n\n修改后的代码如下：\n\n代码地址',normalizedContent:'# 1 外观模式概述\n\n在软件开发中，有时候为了完成一项较为复杂的功能，一个客户类需要和多个业务类交互，而这些需要交互的业务类经常会作为一个整体出现，由于设计的类比较多，导致使用代码较为复杂，此时特别需要一个类似服务员的角色，由它来负责和多个业务类进行交互，而客户类只需要与该类进行交互。外观模式（facade pattern）通过引入一个新的外观类(facade)来负责和多个业务类【子系统(subsystem)，所指的子系统是一个广义的概念，它可以是一个类、一个功能模块、系统的一个组成部分或者一个完整的系统】进行交互，而客户类只需与外观类交互。\n\n\n\n它为子系统中的一组接口提供了一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n\n> 主要解决： 降低访问复杂系统的内部子系统时的复杂度，简化客户端之间的接口。\n> \n> 何时使用： 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个"接待员"即可。 2、定义系统的入口。\n> \n> 如何解决： 客户端不与系统耦合，外观类与系统耦合。\n> \n> 关键代码： 在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。\n> \n> 应用实例： 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 2、java 的三层开发模式。\n> \n> 优点： 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。\n> \n> **缺点：**不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。\n> \n> 使用场景： 1、为复杂的模块或子系统提供外界访问的模块。 2、子系统相对独立。 3、预防低水平人员带来的风险。\n> \n> 注意事项： 在层次化结构中，可以使用外观模式定义系统中每一层的入口。\n\n\n# 2 外观模式详解\n\n\n# 2.1 外观模式结构\n\n外观模式没有一个一般化的类图描述，下图可以用来描述外观模式的结构图。\n\n\n\n由上图可知，外观模式包含以下两个角色。\n\n 1. facade（外观角色）：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统，传递给相应的子系统对象处理。\n 2. subsystem（子系统角色）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。\n\n\n# 2.2 外观模式实现\n\n子系统类通常是一些业务类，实现了一些具体的、独立的业务功能，其典型代码如下：\n\npublic class subsystema {\n    public void methoda() {\n        //业务实现代码\n    }\n}\npublic class subsystemb {\n    public void methodb() {\n        //业务实现代码\n    }\n}\npublic class subsystemc {\n    public void methodc() {\n        //业务实现代码\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n外观类的典型代码如下：\n\npublic class facade {\n    private subsystema obj1 = new subsystema();\n    private subsystemb obj2 = new subsystemb();\n    private subsystemc obj3 = new subsystemc();\n\n    public void method() {\n        obj1.method();\n        obj2.method();\n        obj3.method();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n由于在外观类中维持了对子系统对象的引用，客户端可以通过外观类来间接调用子系统对象的业务方法，而无须与子系统对象直接交互。在引入外观类后，客户端代码变得非常简单，其典型代码如下：\n\npublic class client {\n    public static void main(string args[]) {\n        facade facade = new facade();\n        facade.method();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2.3 外观模式应用举例\n\n * 题目描述\n   \n   > 某软件公司要开发一个可应用于多个软件的文件加密模块，该模块可以对文件中的数据进行加密并将加密之后的数据存储在一个新文件中，具体的流程包括3个部分，分别是读取源文件、加密、保存加密之后的文件，其中，读取文件和保存文件使用流来实现，加密操作通过求模运算实现。这3个操作相对独立，为了实现代码的独立重用，让设计更符合单一职责原则，这3个操作的业务代码封装在3个不同的类中。 现使用外观模式设计该文件加密模块。\n\n * uml类图\n   \n   \n   \n   其中，encryptfacade充当外观类，filereader、ciphermachine和filewriter充当子系统类。\n\n * 代码\n   \n   代码地址\n\n\n# 3 抽象外观类\n\n在标准的外观模式的结构图中，如果需要增加、删除或更换与外观类交互的子系统类，必须修改外观类或客户端的源代码，这将违背开闭原则，因此可以通过引入抽象外观类对系统进行改进，在一定程度上解决该问题。\n\n如2.3中的题目我们需要更换一个加密类，如果我们需要增加一个新的外观类newencryptfacade与filereader类、filewriter类以及新增加的newcliphermachine类交互，虽然原有系统类库无须作修改，但是因为客户端代码中原来针对encryptfacade类进行编程，现在需要修改为newencryptfacade类，所以需要修改客户端源代码。如何在不修改客户端代码的前提下使用新的外观类呢？那么我们可以引入一个抽象外观类，客户端针对抽象外观类编程即可。结构图如下：\n\n\n\n修改后的代码如下：\n\n代码地址',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"设计模式之命令模式详解（Java实现）",frontmatter:{title:"设计模式之命令模式详解（Java实现）",date:"2022-04-30T15:21:42.000Z",tags:["命令模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/31f81b/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89.html",relativePath:"01.开发/02.开发框架/03.设计模式/11.设计模式之命令模式详解（Java实现）.md",key:"v-527901ce",path:"/pages/31f81b/",headers:[{level:2,title:"1 命令模式介绍",slug:"_1-命令模式介绍",normalizedTitle:"1 命令模式介绍",charIndex:2},{level:2,title:"2 命令模式详解",slug:"_2-命令模式详解",normalizedTitle:"2 命令模式详解",charIndex:1113},{level:3,title:"2.1 命令模式结构",slug:"_2-1-命令模式结构",normalizedTitle:"2.1 命令模式结构",charIndex:1126},{level:3,title:"2.2 命令模式实现",slug:"_2-2-命令模式实现",normalizedTitle:"2.2 命令模式实现",charIndex:1653},{level:3,title:"2.3 命令模式应用举例",slug:"_2-3-命令模式应用举例",normalizedTitle:"2.3 命令模式应用举例",charIndex:2757},{level:2,title:"3 实现命令队列",slug:"_3-实现命令队列",normalizedTitle:"3 实现命令队列",charIndex:3136}],headersStr:"1 命令模式介绍 2 命令模式详解 2.1 命令模式结构 2.2 命令模式实现 2.3 命令模式应用举例 3 实现命令队列",content:'# 1 命令模式介绍\n\n在现实生活中人们通过使用开关来控制一些电器的打开和关闭，例如电灯或者排气扇，如下图。\n\n\n\n我们可以将开关看成一个请求发送者，电灯或者排气扇则是请求的最终接收者和处理者。开关和电灯之间并不存在直接耦合关系，它们通过电线连接在一起，使用不同的电线可以连接不同的请求接收者，只需要更换一根电线，相同的发送者（开关）即可对应不同的接收者（电器）。\n\n在软件开发中也存在很多与开关和电器类似的请求发送者和接收者对象，例如按钮和事件处理类。为了降低系统的耦合度，将请求的发送者和接收者解耦，我们可以使用命令模式（Command Pattern）来设计系统。\n\n在命令模式中发送者与接收者之间引入了新的命令对象（类似电线），将发送者的请求封装在命令对象中，再通过命令对象来调用接收者的方法。它可以使请求发送者和接收者完全解耦，发送者和接收者之间没有直接引用的关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。\n\n> 定义： 将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。\n> \n> 主要解决： 在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。\n> \n> 何时使用： 在某些场合，比如要对行为进行"记录、撤销/重做、事务"等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将"行为请求者"与"行为实现者"解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。\n> \n> 如何解决： 通过调用者调用接受者执行命令，顺序：调用者→命令→接受者。\n> \n> 关键代码： 定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口\n> \n> 应用实例： struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。\n> \n> 优点： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。\n> \n> 缺点： 使用命令模式可能会导致某些系统有过多的具体命令类。\n> \n> 使用场景： 认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。\n> \n> 注意事项： 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。\n\n\n# 2 命令模式详解\n\n\n# 2.1 命令模式结构\n\n命令模式的核心在于引入了抽象命令类和具体命令类，通过命令类来降低发送者和接收者的耦合度，请求发送者只需指定一个命令对象，再通过命令对象来调用请求接收者的处理方法，结构图如下：\n\n\n\n由图可知，命令模式包含以下4个角色。\n\n 1. Command（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作。\n 2. ConcreteCommand（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。具体命令类在实现execute()方法时将调用接收者对象的相关操作(Action)。\n 3. Invoker（调用者）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求接收者的相关操作。\n 4. Receiver（接收者）：接收者执行与请求相关的操作，具体实现对请求的业务处理。\n\n\n# 2.2 命令模式实现\n\n典型的抽象命令类代码如下：\n\npublic abstract class Command {\n    public abstract void execute();\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n对于请求发送者（即调用者）而言，将针对抽象命令类进行编程，可以通过构造函数或者Setter方法在运行时注入具体命令类对象，并在业务方法中调用命令对象的execute()方法，其典型代码如下：\n\npublic class Invoker {\n    private Command command;\n    \n    // 构造注入\n    public Invoker(Command command) {\n        this.command = command;\n    }\n    \n    // 设值注入\n    public setCommand(Command command) {\n        this.command = command;\n    }\n    \n    // 业务方法，用于调用命令类中的execute()方法\n    public void call() {\n        command.execute();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n具体命令类继承了抽象命令类，它与请求接收者关联，实现了在抽象命令类中声明的execute()方法，并在实现时调用接收者的请求响应方法。其典型代码如下：\n\npublic class ConcreteCommand extends Command {\n    private Receiver receiver; //维持一个对请求接收者对象的引用\n\n    public void execute() {\n        receiver.action(); //调用请求接收者的业务处理方法action()\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n请求接收者Receiver具体实现对请求的业务处理，它拥有action()方法，用于执行与请求相关操作，其典型代码如下：\n\npublic class Receiver {\n    public void action() {\n        //具体操作\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 2.3 命令模式应用举例\n\n * 题目描述\n   \n   > 为了用户使用方便，某系统提供了一系列功能键，用户可以自定义功能键的功能，例如功能键FunctionButton可以用于退出系统（由SystemExitClass类来实现），也可以用于显示帮助文档（由DisplayHelpClass类来实现）。\n   > \n   > 用户可以通过修改配置文件来改变功能键的用途，现使用命令模式来设计该系统，使得功能键类与功能类之间解耦，可为同一个功能键设置不同的功能。\n\n * UML类图\n\n\n\n其中，FunctionButton充当请求调用者，SystemExitClass和DisplayHelpClass充当请求接收者，Command是抽象命令类，ExitCommand和HelpCommand充当具体命令类。\n\n * 代码\n   \n   代码地址\n\n\n# 3 实现命令队列\n\n有时候，当一个请求发送者发送一个请求时有不止一个请求接收者产生响应，这些请求接收者将逐个执行业务方法，完成对请求的处理，此时可以通过命令队列来实现。\n\n命令队列的实现方法有多种形式，其中最常用、灵活性最好的一种方式就是增加一个CommandQueue类，由该类负责存储多个命令对象，而不同的命令对象可以对应不同的请求接收者。CommandQueue类的典型代码如下：\n\npackage homework;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class CommandQueue {\n    private List<Command> commandList = new ArrayList();\n    public void addCommand(Command command) {\n        commandList.add(command);\n    }\n    public void removeCommand(Command command) {\n        commandList.remove(command);\n    }\n\n    /**\n     * 循环调用每一个命令对象的execute()方法\n     */\n    public void execute() {\n        for (Command command : commandList) {\n            command.execute();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n在增加命令队列类CommandQueue以后，请求发送者Invoker将针对CommandQueue编程。即将Command修改为CommandQueue即可。',normalizedContent:'# 1 命令模式介绍\n\n在现实生活中人们通过使用开关来控制一些电器的打开和关闭，例如电灯或者排气扇，如下图。\n\n\n\n我们可以将开关看成一个请求发送者，电灯或者排气扇则是请求的最终接收者和处理者。开关和电灯之间并不存在直接耦合关系，它们通过电线连接在一起，使用不同的电线可以连接不同的请求接收者，只需要更换一根电线，相同的发送者（开关）即可对应不同的接收者（电器）。\n\n在软件开发中也存在很多与开关和电器类似的请求发送者和接收者对象，例如按钮和事件处理类。为了降低系统的耦合度，将请求的发送者和接收者解耦，我们可以使用命令模式（command pattern）来设计系统。\n\n在命令模式中发送者与接收者之间引入了新的命令对象（类似电线），将发送者的请求封装在命令对象中，再通过命令对象来调用接收者的方法。它可以使请求发送者和接收者完全解耦，发送者和接收者之间没有直接引用的关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。\n\n> 定义： 将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。\n> \n> 主要解决： 在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。\n> \n> 何时使用： 在某些场合，比如要对行为进行"记录、撤销/重做、事务"等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将"行为请求者"与"行为实现者"解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。\n> \n> 如何解决： 通过调用者调用接受者执行命令，顺序：调用者→命令→接受者。\n> \n> 关键代码： 定义三个角色：1、received 真正的命令执行对象 2、command 3、invoker 使用命令对象的入口\n> \n> 应用实例： struts 1 中的 action 核心控制器 actionservlet 只有一个，相当于 invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 command。\n> \n> 优点： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。\n> \n> 缺点： 使用命令模式可能会导致某些系统有过多的具体命令类。\n> \n> 使用场景： 认为是命令的地方都可以使用命令模式，比如： 1、gui 中每一个按钮都是一条命令。 2、模拟 cmd。\n> \n> 注意事项： 系统需要支持命令的撤销(undo)操作和恢复(redo)操作，也可以考虑使用命令模式，见命令模式的扩展。\n\n\n# 2 命令模式详解\n\n\n# 2.1 命令模式结构\n\n命令模式的核心在于引入了抽象命令类和具体命令类，通过命令类来降低发送者和接收者的耦合度，请求发送者只需指定一个命令对象，再通过命令对象来调用请求接收者的处理方法，结构图如下：\n\n\n\n由图可知，命令模式包含以下4个角色。\n\n 1. command（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作。\n 2. concretecommand（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。具体命令类在实现execute()方法时将调用接收者对象的相关操作(action)。\n 3. invoker（调用者）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求接收者的相关操作。\n 4. receiver（接收者）：接收者执行与请求相关的操作，具体实现对请求的业务处理。\n\n\n# 2.2 命令模式实现\n\n典型的抽象命令类代码如下：\n\npublic abstract class command {\n    public abstract void execute();\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n对于请求发送者（即调用者）而言，将针对抽象命令类进行编程，可以通过构造函数或者setter方法在运行时注入具体命令类对象，并在业务方法中调用命令对象的execute()方法，其典型代码如下：\n\npublic class invoker {\n    private command command;\n    \n    // 构造注入\n    public invoker(command command) {\n        this.command = command;\n    }\n    \n    // 设值注入\n    public setcommand(command command) {\n        this.command = command;\n    }\n    \n    // 业务方法，用于调用命令类中的execute()方法\n    public void call() {\n        command.execute();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n具体命令类继承了抽象命令类，它与请求接收者关联，实现了在抽象命令类中声明的execute()方法，并在实现时调用接收者的请求响应方法。其典型代码如下：\n\npublic class concretecommand extends command {\n    private receiver receiver; //维持一个对请求接收者对象的引用\n\n    public void execute() {\n        receiver.action(); //调用请求接收者的业务处理方法action()\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n请求接收者receiver具体实现对请求的业务处理，它拥有action()方法，用于执行与请求相关操作，其典型代码如下：\n\npublic class receiver {\n    public void action() {\n        //具体操作\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 2.3 命令模式应用举例\n\n * 题目描述\n   \n   > 为了用户使用方便，某系统提供了一系列功能键，用户可以自定义功能键的功能，例如功能键functionbutton可以用于退出系统（由systemexitclass类来实现），也可以用于显示帮助文档（由displayhelpclass类来实现）。\n   > \n   > 用户可以通过修改配置文件来改变功能键的用途，现使用命令模式来设计该系统，使得功能键类与功能类之间解耦，可为同一个功能键设置不同的功能。\n\n * uml类图\n\n\n\n其中，functionbutton充当请求调用者，systemexitclass和displayhelpclass充当请求接收者，command是抽象命令类，exitcommand和helpcommand充当具体命令类。\n\n * 代码\n   \n   代码地址\n\n\n# 3 实现命令队列\n\n有时候，当一个请求发送者发送一个请求时有不止一个请求接收者产生响应，这些请求接收者将逐个执行业务方法，完成对请求的处理，此时可以通过命令队列来实现。\n\n命令队列的实现方法有多种形式，其中最常用、灵活性最好的一种方式就是增加一个commandqueue类，由该类负责存储多个命令对象，而不同的命令对象可以对应不同的请求接收者。commandqueue类的典型代码如下：\n\npackage homework;\n\nimport java.util.arraylist;\nimport java.util.list;\n\npublic class commandqueue {\n    private list<command> commandlist = new arraylist();\n    public void addcommand(command command) {\n        commandlist.add(command);\n    }\n    public void removecommand(command command) {\n        commandlist.remove(command);\n    }\n\n    /**\n     * 循环调用每一个命令对象的execute()方法\n     */\n    public void execute() {\n        for (command command : commandlist) {\n            command.execute();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n在增加命令队列类commandqueue以后，请求发送者invoker将针对commandqueue编程。即将command修改为commandqueue即可。',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"设计模式之代理模式详解（Java实现）",frontmatter:{title:"设计模式之代理模式详解（Java实现）",date:"2022-04-30T09:21:54.000Z",tags:["代理模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/933a7d/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89.html",relativePath:"01.开发/02.开发框架/03.设计模式/10.设计模式之代理模式详解（Java实现）.md",key:"v-4a7c7cef",path:"/pages/933a7d/",headers:[{level:2,title:"1 代理模式介绍",slug:"_1-代理模式介绍",normalizedTitle:"1 代理模式介绍",charIndex:2},{level:2,title:"2 代理模式详解",slug:"_2-代理模式详解",normalizedTitle:"2 代理模式详解",charIndex:1014},{level:3,title:"2.1 代理模式结构",slug:"_2-1-代理模式结构",normalizedTitle:"2.1 代理模式结构",charIndex:1027},{level:3,title:"2.2 代理模式实现",slug:"_2-2-代理模式实现",normalizedTitle:"2.2 代理模式实现",charIndex:1527},{level:3,title:"2.3 代理模式应用举例",slug:"_2-3-代理模式应用举例",normalizedTitle:"2.3 代理模式应用举例",charIndex:2350}],headersStr:"1 代理模式介绍 2 代理模式详解 2.1 代理模式结构 2.2 代理模式实现 2.3 代理模式应用举例",content:"# 1 代理模式介绍\n\n代理模式（Proxy Pattern）是常用的结构型设计模式之一，当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，代理对象在客户端对象和目标对象之间起到中介的作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。\n\n代理模式的变化形式非常多，常见的代理形式有远程代理、保护代理、虚拟代理、缓冲代理、智能引用代理等。\n\n> 主要解决： 在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。\n> \n> 何时使用： 想在访问一个类时做一些控制。\n> \n> 如何解决： 增加中间层。\n> \n> 关键代码： 实现与被代理类组合。\n> \n> 应用实例： 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。\n> \n> 优点： 1、职责清晰。 2、高扩展性。 3、智能化。\n> \n> 缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。\n> \n> 使用场景： 按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。\n> \n> 注意事项： 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。\n\n\n# 2 代理模式详解\n\n\n# 2.1 代理模式结构\n\n代理模式的结构比较简单，其核心是代理类，为了让客户端能够一致地对待真实对象和代理对象，在代理模式中引入了抽象层，其结构图如下：\n\n\n\n由图可知，代理模式包含以下3个角色。\n\n 1. Subject（抽象主题角色）：它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。\n\n 2. Proxy（代理主题角色）：它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供了一个与真实主题角色相同的接口，以便任何时候都可以代替真实主题；代理主题角色还可以控制真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。\n    \n    通常，在代理主题角色中客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅单纯调用真实主题对象中的操作。\n\n 3. RealSubject（真实主题角色）：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接使用真实主题角色中定义的操作。\n\n\n# 2.2 代理模式实现\n\n典型的抽象主题类代码如下：\n\npublic abstract class Subject {\n    public abstract void request();\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n真实主题类继承了抽象主题类，提供了业务方法的具体实现，其典型代码如下：\n\npublic class RealSubject extends Subject {\n    public void request() {\n        // 业务方法的具体实现代码\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n代理类也是抽象主题类的子类，它维持一个对真实主题对象的引用，调用在真实主题中实现的业务方法，在调用时可以在原有业务方法的基础上附加一些新的方法对功能进行扩充或约束。最简单的代理类实现代码如下：\n\npublic class Proxy extends Subject {\n    // 维持一个对真实主题对象的引用\n    private RealSubject realSubject = new RealSubject();\n    \n    public void preRequest() {\n        ...\n    }\n    public void request() {\n        preRequest();\n        // 调用真实主题对象的方法\n        realSubject.request();\n        postRequest();\n    }\n    public void postRequest() {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 2.3 代理模式应用举例\n\n * 题目描述\n   \n   > 在一个论坛中已注册用户和游客的权限不同，已注册的用户拥有发帖、修改自己的注册信息、修改自己的帖子等功能；而游客只能看到别人发的帖子，没有其他权限。使用保护代理来设计该权限管理模块。\n\n * UML类图\n   \n   \n   \n   其中，AbstractPermission 为抽象主题角色，PermissionProxy 为代理主题角色， RealPermission 为真实主题角色。\n\n * 代码\n   \n   代码地址",normalizedContent:"# 1 代理模式介绍\n\n代理模式（proxy pattern）是常用的结构型设计模式之一，当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，代理对象在客户端对象和目标对象之间起到中介的作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。\n\n代理模式的变化形式非常多，常见的代理形式有远程代理、保护代理、虚拟代理、缓冲代理、智能引用代理等。\n\n> 主要解决： 在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。\n> \n> 何时使用： 想在访问一个类时做一些控制。\n> \n> 如何解决： 增加中间层。\n> \n> 关键代码： 实现与被代理类组合。\n> \n> 应用实例： 1、windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。\n> \n> 优点： 1、职责清晰。 2、高扩展性。 3、智能化。\n> \n> 缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。\n> \n> 使用场景： 按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、copy-on-write 代理。 4、保护（protect or access）代理。 5、cache代理。 6、防火墙（firewall）代理。 7、同步化（synchronization）代理。 8、智能引用（smart reference）代理。\n> \n> 注意事项： 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。\n\n\n# 2 代理模式详解\n\n\n# 2.1 代理模式结构\n\n代理模式的结构比较简单，其核心是代理类，为了让客户端能够一致地对待真实对象和代理对象，在代理模式中引入了抽象层，其结构图如下：\n\n\n\n由图可知，代理模式包含以下3个角色。\n\n 1. subject（抽象主题角色）：它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。\n\n 2. proxy（代理主题角色）：它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供了一个与真实主题角色相同的接口，以便任何时候都可以代替真实主题；代理主题角色还可以控制真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。\n    \n    通常，在代理主题角色中客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅单纯调用真实主题对象中的操作。\n\n 3. realsubject（真实主题角色）：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接使用真实主题角色中定义的操作。\n\n\n# 2.2 代理模式实现\n\n典型的抽象主题类代码如下：\n\npublic abstract class subject {\n    public abstract void request();\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n真实主题类继承了抽象主题类，提供了业务方法的具体实现，其典型代码如下：\n\npublic class realsubject extends subject {\n    public void request() {\n        // 业务方法的具体实现代码\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n代理类也是抽象主题类的子类，它维持一个对真实主题对象的引用，调用在真实主题中实现的业务方法，在调用时可以在原有业务方法的基础上附加一些新的方法对功能进行扩充或约束。最简单的代理类实现代码如下：\n\npublic class proxy extends subject {\n    // 维持一个对真实主题对象的引用\n    private realsubject realsubject = new realsubject();\n    \n    public void prerequest() {\n        ...\n    }\n    public void request() {\n        prerequest();\n        // 调用真实主题对象的方法\n        realsubject.request();\n        postrequest();\n    }\n    public void postrequest() {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 2.3 代理模式应用举例\n\n * 题目描述\n   \n   > 在一个论坛中已注册用户和游客的权限不同，已注册的用户拥有发帖、修改自己的注册信息、修改自己的帖子等功能；而游客只能看到别人发的帖子，没有其他权限。使用保护代理来设计该权限管理模块。\n\n * uml类图\n   \n   \n   \n   其中，abstractpermission 为抽象主题角色，permissionproxy 为代理主题角色， realpermission 为真实主题角色。\n\n * 代码\n   \n   代码地址",charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"实用网站",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"05.资源收藏/01.实用网站",description:"实用网站收集"}},title:"实用网站",permalink:"/resource/website/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-23T11:18:33.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/05.sub01%E5%AE%9E%E7%94%A8%E7%BD%91%E7%AB%99.html",relativePath:"00.目录页/05.sub01实用网站.md",key:"v-49e30f62",path:"/resource/website/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 19:47:19",lastUpdatedTimestamp:1700826439e3},{title:"设计模式之策略模式详解（Java实现）",frontmatter:{title:"设计模式之策略模式详解（Java实现）",date:"2022-05-01T09:44:58.000Z",tags:["策略模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/b22ffc/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%EF%BC%89%E5%AE%9E%E7%8E%B0.html",relativePath:"01.开发/02.开发框架/03.设计模式/13.设计模式之策略模式详解（Java）实现.md",key:"v-cecf59c6",path:"/pages/b22ffc/",headers:[{level:2,title:"1 策略模式介绍",slug:"_1-策略模式介绍",normalizedTitle:"1 策略模式介绍",charIndex:2},{level:2,title:"2 策略模式详解",slug:"_2-策略模式详解",normalizedTitle:"2 策略模式详解",charIndex:483},{level:3,title:"2.1 策略模式结构",slug:"_2-1-策略模式结构",normalizedTitle:"2.1 策略模式结构",charIndex:496},{level:3,title:"2.2 策略模式实现",slug:"_2-2-策略模式实现",normalizedTitle:"2.2 策略模式实现",charIndex:823},{level:3,title:"2.3 策略模式应用举例",slug:"_2-3-策略模式应用举例",normalizedTitle:"2.3 策略模式应用举例",charIndex:1457}],headersStr:"1 策略模式介绍 2 策略模式详解 2.1 策略模式结构 2.2 策略模式实现 2.3 策略模式应用举例",content:"# 1 策略模式介绍\n\n在很多情况下，实现某个目标的途径不止一条，例如在外出旅游时游客可以选择多种不同的出行方式，可根据实际情况来确定最适合的出行方式。\n\n\n\n在软件开发中，也常常会遇到类似的情况，实现某个功能有多种算法，一种常用的方法是通过硬编码将所有的算法集中在一个类中，在该类中提供多个方法，每个方法对应一个算法；当然也可以将这些算法封装在一个统一的方法中，通过if...else...等条件判断选择。这两种实现方法都可以称为硬编码。但这样的方式封装了大量的算法，代码非常复杂，维护也很困难。\n\n策略模式（Strategy Pattern）定义一些独立的类来封装不同的算法，每一个类封装一种具体的算法，在这里每一个封装算法的类都可以称为一种策略（Strategy），为了保证这些策略在使用时具有一致性，一般会提供一个抽象的策略类来做算法的声明，而每种算法对应于一个具体策略类。\n\n策略模式定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法可以独立于使用它们的客户而变化。它又称为政策（Policy）模式，是一种对象行为型模式。\n\n\n# 2 策略模式详解\n\n\n# 2.1 策略模式结构\n\n其结构图如下：\n\n\n\n由图可知，策略模式包含以下3个角色。\n\n 1. Context（环境类）：环境类是使用算法的角色，它在解决某个问题时可以采用多种策略。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略。\n 2. Strategy（抽象策略类）：抽象策略类为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法。\n 3. ConcreteStrategy（具体策略类）：具体策略类实现了在抽象策略类中声明的算法，在运行时具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务功能。\n\n\n# 2.2 策略模式实现\n\n抽象策略类典型代码如下：\n\npublic abstract class AbstractStrategy {\n    // 声明抽象算法\n    public abstract void algorithm();\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n具体策略类典型代码如下：\n\npublic class ConcreteStrategyA extends AbstractStrategy {\n    // 算法的具体实现\n    public void algorithm() {\n        // 算法A\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n环境类典型代码如下：\n\npublic class Context {\n    private AbstractStrategy strategy; // 维持一个对抽象策略类的引用\n    public void setStrategy(AbstractStrategy strategy) {\n        this.strategy = strategy;\n    }\n    // 调用策略类中的算法\n    public void algorithm() {\n        strategy.algorithm();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 2.3 策略模式应用举例\n\n * 题目描述\n   \n   > 某软件公司为某电影院开发了一套影院售票系统，在该系统中需要为不同类型的用户提供不同的电影票打折方式，具体打折方案如下：* (1) 学生凭学生证可享受票价8折优惠。 (2) 年龄在10周岁及以下的儿童可享受每张票减免10元的优惠（原始票价需大于等于20元）。 (3) 影院VIP用户除享受票价半价优惠外还可进行积分，积分累计到一定额度可换取电影院赠送的奖品。 该系统在将来可能还要根据需要引入新的打折方式。现使用策略模式设计该影院售票系统的打折方案。\n\n * UML类图\n   \n   其中，MovieTicket充当环境类角色，Discount充当抽象策略角色，StudentDiscount、ChildrenDiscount和VIPDiscount充当具体策略角色。\n\n * 代码\n   \n   代码地址",normalizedContent:"# 1 策略模式介绍\n\n在很多情况下，实现某个目标的途径不止一条，例如在外出旅游时游客可以选择多种不同的出行方式，可根据实际情况来确定最适合的出行方式。\n\n\n\n在软件开发中，也常常会遇到类似的情况，实现某个功能有多种算法，一种常用的方法是通过硬编码将所有的算法集中在一个类中，在该类中提供多个方法，每个方法对应一个算法；当然也可以将这些算法封装在一个统一的方法中，通过if...else...等条件判断选择。这两种实现方法都可以称为硬编码。但这样的方式封装了大量的算法，代码非常复杂，维护也很困难。\n\n策略模式（strategy pattern）定义一些独立的类来封装不同的算法，每一个类封装一种具体的算法，在这里每一个封装算法的类都可以称为一种策略（strategy），为了保证这些策略在使用时具有一致性，一般会提供一个抽象的策略类来做算法的声明，而每种算法对应于一个具体策略类。\n\n策略模式定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法可以独立于使用它们的客户而变化。它又称为政策（policy）模式，是一种对象行为型模式。\n\n\n# 2 策略模式详解\n\n\n# 2.1 策略模式结构\n\n其结构图如下：\n\n\n\n由图可知，策略模式包含以下3个角色。\n\n 1. context（环境类）：环境类是使用算法的角色，它在解决某个问题时可以采用多种策略。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略。\n 2. strategy（抽象策略类）：抽象策略类为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法。\n 3. concretestrategy（具体策略类）：具体策略类实现了在抽象策略类中声明的算法，在运行时具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务功能。\n\n\n# 2.2 策略模式实现\n\n抽象策略类典型代码如下：\n\npublic abstract class abstractstrategy {\n    // 声明抽象算法\n    public abstract void algorithm();\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n具体策略类典型代码如下：\n\npublic class concretestrategya extends abstractstrategy {\n    // 算法的具体实现\n    public void algorithm() {\n        // 算法a\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n环境类典型代码如下：\n\npublic class context {\n    private abstractstrategy strategy; // 维持一个对抽象策略类的引用\n    public void setstrategy(abstractstrategy strategy) {\n        this.strategy = strategy;\n    }\n    // 调用策略类中的算法\n    public void algorithm() {\n        strategy.algorithm();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 2.3 策略模式应用举例\n\n * 题目描述\n   \n   > 某软件公司为某电影院开发了一套影院售票系统，在该系统中需要为不同类型的用户提供不同的电影票打折方式，具体打折方案如下：* (1) 学生凭学生证可享受票价8折优惠。 (2) 年龄在10周岁及以下的儿童可享受每张票减免10元的优惠（原始票价需大于等于20元）。 (3) 影院vip用户除享受票价半价优惠外还可进行积分，积分累计到一定额度可换取电影院赠送的奖品。 该系统在将来可能还要根据需要引入新的打折方式。现使用策略模式设计该影院售票系统的打折方案。\n\n * uml类图\n   \n   其中，movieticket充当环境类角色，discount充当抽象策略角色，studentdiscount、childrendiscount和vipdiscount充当具体策略角色。\n\n * 代码\n   \n   代码地址",charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"二分查找的奇技淫巧",frontmatter:{title:"二分查找的奇技淫巧",date:"2020-01-21T16:15:34.000Z",tags:["二分查找"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/71fd4b/",categories:["开发","数据结构与算法","查找算法"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/03.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/03.%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/01.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html",relativePath:"01.开发/03.数据结构与算法/03.查找算法/01.二分查找.md",key:"v-1f62b379",path:"/pages/71fd4b/",headers:[{level:2,title:"1 二分搜索升天词",slug:"_1-二分搜索升天词",normalizedTitle:"1 二分搜索升天词",charIndex:2},{level:2,title:"2 手写二分查找模板",slug:"_2-手写二分查找模板",normalizedTitle:"2 手写二分查找模板",charIndex:33},{level:3,title:"2.1 版本1",slug:"_2-1-版本1",normalizedTitle:"2.1 版本1",charIndex:140},{level:3,title:"2.2 版本2",slug:"_2-2-版本2",normalizedTitle:"2.2 版本2",charIndex:630},{level:2,title:"3 利用C++自带的lowerbound和upperbound函数",slug:"_3-利用c-自带的lower-bound和upper-bound函数",normalizedTitle:"3 利用c++自带的lowerbound和upperbound函数",charIndex:null},{level:3,title:"3.1 自带函数源码",slug:"_3-1-自带函数源码",normalizedTitle:"3.1 自带函数源码",charIndex:1195},{level:3,title:"3.2 进阶—自定义比较规则",slug:"_3-2-进阶-自定义比较规则",normalizedTitle:"3.2 进阶—自定义比较规则",charIndex:2584}],headersStr:"1 二分搜索升天词 2 手写二分查找模板 2.1 版本1 2.2 版本2 3 利用C++自带的lowerbound和upperbound函数 3.1 自带函数源码 3.2 进阶—自定义比较规则",content:'# 1 二分搜索升天词\n\n转自：labuladong\n\n\n\n\n# 2 手写二分查找模板\n\n二分模板一共有两个，分别适用于不同情况。 算法思路：假设目标值在闭区间[l,r][l, r][l,r]中， 每次将区间长度缩小一半，当l=rl = rl=r时，我们就找到了目标值。\n\n\n# 2.1 版本1\n\n当我们将区间[l,r][l, r][l,r]划分成[l,mid][l, mid][l,mid]和[mid+1,r][mid + 1, r][mid+1,r]时，其更新操作是r=midr = midr=mid或者l=mid+1l = mid + 1l=mid+1;，计算midmidmid时不需要加111。\n\nbool check(int x) {\n    ...\n    ...\n}\nint binary_search_1(int l, int r) {\n    while (l < r) {\n        int mid = (l + r) >> 1;\n        if (check(mid)) {\n            r = mid;\n        } else {\n            l = mid + 1;\n        }\n    }\n    return l;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2.2 版本2\n\n当我们将区间[l,r][l, r][l,r]划分成[l,mid−1][l, mid-1][l,mid−1]和[mid,r][mid, r][mid,r]时，其更新操作是r=mid−1r = mid - 1r=mid−1或者l=midl = midl=mid;，此时为了防止死循环，计算midmidmid时需要加111。\n\nbool check(int x) {\n    ...\n    ...\n}\nint binary_search_2(int l, int r) {\n    while (l < r) {\n        int mid = (l + r + 1) >> 1;\n        if (check(mid)) { // check为判断函数，我们自己手写的规则\n            l = mid;\n        } else {\n            r = mid - 1;\n        }\n    }\n    return l;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 3 利用C++自带的lower_bound和upper_bound函数\n\n\n# 3.1 自带函数源码\n\nlower_bound：返回一个迭代器，迭代器指向[first, last)不小于val的第一个元素。如果范围内的所有元素比较小于val，则函数返回last。\n\ntemplate <class ForwardIterator, class T>\nForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T& val)\n{\n  ForwardIterator it;\n  iterator_traits<ForwardIterator>::difference_type count, step;\n  count = distance(first,last);\n  while (count>0)\n  {\n    it = first; step=count/2; advance (it,step);\n    if (*it<val) {                 // or: if (comp(*it,val)), for version (2)\n      first=++it;\n      count-=step+1;\n    }\n    else count=step;\n  }\n  return first;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nupper_bound：返回一个迭代器，迭代器指向[first, last)大于val的第一个元素。如果范围内的所有元素比较都不大于val，则函数返回last。\n\ntemplate <class ForwardIterator, class T>\nForwardIterator upper_bound (ForwardIterator first, ForwardIterator last, const T& val)\n{\n  ForwardIterator it;\n  iterator_traits<ForwardIterator>::difference_type count, step;\n  count = std::distance(first,last);\n  while (count>0)\n  {\n    it = first; step=count/2; std::advance (it,step);\n    if (!(val<*it))                 // or: if (!comp(val,*it)), for version (2)\n      { first=++it; count-=step+1;  }\n    else count=step;\n  }\n  return first;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n根据源码，我们很容易就可以使用它们，不用自己手写了，但如果需要自定义比较规则，实际上就是需要我们实现一个check函数即可。\n\n\n# 3.2 进阶—自定义比较规则\n\n在 C++ 中有很多情况下，我们需要自定义比较器，无非就是三种情况：\n\n 1. 对一个自定义的 struct 重写它的 operator < 方法\n 2. 定义一个``Comparator`函数\n 3. 定义一个Comparator结构体对象\n\n * 自定义结构体\n   \n   如果我们自定义了一个struct，然后想要对其排序又不想额外写一个比较器，那么最好实现它的 operaotr < 方法。\n   \n   struct node{\n       string s;\n       node(string s) {\n           this->s = s;\n       }\n       bool operator < (const node &a) const { // 注意这两个const，必须要加上，否则会报错，前者const是能接收非const和const的实参，后者const是表明该函数不会修改类成员变量。\n           return this->s.size() < a.s.size();\n       }\n   };\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   这样，我们就可以使用了。如下：\n   \n   vector<node> v(10, node("111"));\n   int pos = lower_bound(v.begin(), v.end(), node("111")) - v.begin();\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n * 函数比较器\n   \n   可以通过编写一个外部的比较器函数，实现 < 功能。\n   \n   struct node{\n       string s;\n       node(string s) {\n           this->s = s;\n       }\n   };\n   bool cmp(const string &s1, const string &s2) {\n       return s1.size() < s2.size();\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   这个通常用于自定义排序，其他的会报错，应该是不支持函数比较器，读者可自行尝试。\n   \n   vector<string> v(10, "111");\n   sort(v.begin(), v.end(), cmp);\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n * 函数对象比较器\n   \n   所谓函数对象是指实现了 operator () 的类或者结构体。可以用这样的一个对象来代替函数作为比较器。\n   \n   struct cmper {\n       bool operator() (const string &s1, const string &s2) const {\n           return s1.size() < s2.size();\n       }\n   };\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   这个通常用于自定义排序，其他的会报错，应该是不支持函数比较器，读者可自行尝试。\n   \n   vector<string> v(10, "111");\n   sort(v.begin(), v.end(), cmper());\n   \n   \n   1\n   2\n   \n   1\n   2\n   ',normalizedContent:'# 1 二分搜索升天词\n\n转自：labuladong\n\n\n\n\n# 2 手写二分查找模板\n\n二分模板一共有两个，分别适用于不同情况。 算法思路：假设目标值在闭区间[l,r][l, r][l,r]中， 每次将区间长度缩小一半，当l=rl = rl=r时，我们就找到了目标值。\n\n\n# 2.1 版本1\n\n当我们将区间[l,r][l, r][l,r]划分成[l,mid][l, mid][l,mid]和[mid+1,r][mid + 1, r][mid+1,r]时，其更新操作是r=midr = midr=mid或者l=mid+1l = mid + 1l=mid+1;，计算midmidmid时不需要加111。\n\nbool check(int x) {\n    ...\n    ...\n}\nint binary_search_1(int l, int r) {\n    while (l < r) {\n        int mid = (l + r) >> 1;\n        if (check(mid)) {\n            r = mid;\n        } else {\n            l = mid + 1;\n        }\n    }\n    return l;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2.2 版本2\n\n当我们将区间[l,r][l, r][l,r]划分成[l,mid−1][l, mid-1][l,mid−1]和[mid,r][mid, r][mid,r]时，其更新操作是r=mid−1r = mid - 1r=mid−1或者l=midl = midl=mid;，此时为了防止死循环，计算midmidmid时需要加111。\n\nbool check(int x) {\n    ...\n    ...\n}\nint binary_search_2(int l, int r) {\n    while (l < r) {\n        int mid = (l + r + 1) >> 1;\n        if (check(mid)) { // check为判断函数，我们自己手写的规则\n            l = mid;\n        } else {\n            r = mid - 1;\n        }\n    }\n    return l;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 3 利用c++自带的lower_bound和upper_bound函数\n\n\n# 3.1 自带函数源码\n\nlower_bound：返回一个迭代器，迭代器指向[first, last)不小于val的第一个元素。如果范围内的所有元素比较小于val，则函数返回last。\n\ntemplate <class forwarditerator, class t>\nforwarditerator lower_bound (forwarditerator first, forwarditerator last, const t& val)\n{\n  forwarditerator it;\n  iterator_traits<forwarditerator>::difference_type count, step;\n  count = distance(first,last);\n  while (count>0)\n  {\n    it = first; step=count/2; advance (it,step);\n    if (*it<val) {                 // or: if (comp(*it,val)), for version (2)\n      first=++it;\n      count-=step+1;\n    }\n    else count=step;\n  }\n  return first;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nupper_bound：返回一个迭代器，迭代器指向[first, last)大于val的第一个元素。如果范围内的所有元素比较都不大于val，则函数返回last。\n\ntemplate <class forwarditerator, class t>\nforwarditerator upper_bound (forwarditerator first, forwarditerator last, const t& val)\n{\n  forwarditerator it;\n  iterator_traits<forwarditerator>::difference_type count, step;\n  count = std::distance(first,last);\n  while (count>0)\n  {\n    it = first; step=count/2; std::advance (it,step);\n    if (!(val<*it))                 // or: if (!comp(val,*it)), for version (2)\n      { first=++it; count-=step+1;  }\n    else count=step;\n  }\n  return first;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n根据源码，我们很容易就可以使用它们，不用自己手写了，但如果需要自定义比较规则，实际上就是需要我们实现一个check函数即可。\n\n\n# 3.2 进阶—自定义比较规则\n\n在 c++ 中有很多情况下，我们需要自定义比较器，无非就是三种情况：\n\n 1. 对一个自定义的 struct 重写它的 operator < 方法\n 2. 定义一个``comparator`函数\n 3. 定义一个comparator结构体对象\n\n * 自定义结构体\n   \n   如果我们自定义了一个struct，然后想要对其排序又不想额外写一个比较器，那么最好实现它的 operaotr < 方法。\n   \n   struct node{\n       string s;\n       node(string s) {\n           this->s = s;\n       }\n       bool operator < (const node &a) const { // 注意这两个const，必须要加上，否则会报错，前者const是能接收非const和const的实参，后者const是表明该函数不会修改类成员变量。\n           return this->s.size() < a.s.size();\n       }\n   };\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   这样，我们就可以使用了。如下：\n   \n   vector<node> v(10, node("111"));\n   int pos = lower_bound(v.begin(), v.end(), node("111")) - v.begin();\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n * 函数比较器\n   \n   可以通过编写一个外部的比较器函数，实现 < 功能。\n   \n   struct node{\n       string s;\n       node(string s) {\n           this->s = s;\n       }\n   };\n   bool cmp(const string &s1, const string &s2) {\n       return s1.size() < s2.size();\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   这个通常用于自定义排序，其他的会报错，应该是不支持函数比较器，读者可自行尝试。\n   \n   vector<string> v(10, "111");\n   sort(v.begin(), v.end(), cmp);\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n * 函数对象比较器\n   \n   所谓函数对象是指实现了 operator () 的类或者结构体。可以用这样的一个对象来代替函数作为比较器。\n   \n   struct cmper {\n       bool operator() (const string &s1, const string &s2) const {\n           return s1.size() < s2.size();\n       }\n   };\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   这个通常用于自定义排序，其他的会报错，应该是不支持函数比较器，读者可自行尝试。\n   \n   vector<string> v(10, "111");\n   sort(v.begin(), v.end(), cmper());\n   \n   \n   1\n   2\n   \n   1\n   2\n   ',charsets:{cjk:!0},lastUpdated:"2023/11/25, 16:14:12",lastUpdatedTimestamp:1700900052e3},{title:"设计模式之模板方法模式详解（Java实现）",frontmatter:{title:"设计模式之模板方法模式详解（Java实现）",date:"2022-05-01T09:44:58.000Z",tags:["模板方法模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/2aa461/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89.html",relativePath:"01.开发/02.开发框架/03.设计模式/14.设计模式之模板方法模式详解（Java实现）.md",key:"v-ab6c5552",path:"/pages/2aa461/",headers:[{level:2,title:"1 模板方法模式介绍",slug:"_1-模板方法模式介绍",normalizedTitle:"1 模板方法模式介绍",charIndex:2},{level:2,title:"2 模板方法模式详解",slug:"_2-模板方法模式详解",normalizedTitle:"2 模板方法模式详解",charIndex:912},{level:3,title:"2.1 模板方法模式结构",slug:"_2-1-模板方法模式结构",normalizedTitle:"2.1 模板方法模式结构",charIndex:927},{level:3,title:"2.2 模板方法模式实现",slug:"_2-2-模板方法模式实现",normalizedTitle:"2.2 模板方法模式实现",charIndex:1319},{level:3,title:"2.3 模板方法模式应用举例",slug:"_2-3-模板方法模式应用举例",normalizedTitle:"2.3 模板方法模式应用举例",charIndex:2870}],headersStr:"1 模板方法模式介绍 2 模板方法模式详解 2.1 模板方法模式结构 2.2 模板方法模式实现 2.3 模板方法模式应用举例",content:"# 1 模板方法模式介绍\n\n在软件开发中，某个方法的实现需要多个步骤，其中有些步骤是固定的，而有些步骤并不固定，存在可变性。为了提高代码的复用性和系统的灵活性，可以使用一种称为模板方法模式（Template Method Pattern）的设计模式来对这类情况进行设计。在模板方法模式中将实现功能的每一个步骤所对应的方法称为基本方法，而将调用这些基本方法同时定义基本方法的执行次序的方法称为模板方法。\n\n模板方法模式定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。它是结构最简单的行为型设计模式，在其结构中只存在父类与子类的继承关系。\n\n模板方法模式将一些复杂流程的实现步骤封装在一系列基本方法中，在抽象父类中提供一个称之为模板方法的方法来定义这些基本方法的执行次序，而通过其子类来覆盖某些步骤，从而使得相同的算法框架可以有不同的执行结果。\n\n> 主要解决： 一些方法通用，却在每一个子类都重新写了这一方法。\n> \n> 何时使用： 有一些通用的方法。\n> \n> 如何解决： 将这些通用算法抽象出来。\n> \n> 关键代码： 在抽象类实现，其他步骤在子类实现。\n> \n> 应用实例： 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。\n> \n> 优点： 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。\n> \n> 缺点： 每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。\n> \n> 使用场景： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。\n> \n> 注意事项： 为防止恶意操作，一般模板方法都加上 final 关键词。\n\n\n# 2 模板方法模式详解\n\n\n# 2.1 模板方法模式结构\n\n模板方法模式的结构比较简单，其核心是抽象类和其中的模板方法设计，其结构图如下：\n\n\n\n由上图可知，模板方法模式包含以下两个角色。\n\n 1. AbstractClass（抽象类）：在抽象类中定义了一系列基本操作（Primitive Operations），这些基本操作可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤。同时在抽象类中实现了一个模板方法（Template Method），用于定义一个算法的框架，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法。\n 2. ConcreteClass（具体子类）：它是抽象类的子类，用于实现在父类中声明的抽象基本操作以及完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体基本操作。\n\n\n# 2.2 模板方法模式实现\n\n在实现模板方法模式时，开发抽象类的软件设计师和开发具体子类的软件设计师之间可以进行协作。\n\n * 模板方法\n   \n   一个模板方法就是将定义在抽象类中的把基本操作方法组合在一起形成一个总算法或一个总行为的方法。这个模板方法定义在抽象类中，并由子类不加修改地完全继承下来。由于模板方法是具体方法，因此模板方法模式中的抽象层只能是抽象类，而不是接口。\n\n * 基本方法\n   \n   基本方法是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为3种，即抽象方法（Abstract Method）、具体方法（Concrete Method）和钩子方法（Hook Method）。\n   \n   * 抽象方法：一个抽象方法由抽象类声明、由其具体子类实现。\n   * 具体方法：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。\n   * 钩子方法：一个钩子方法由一个抽象类或具体类声明并实现，而其子类可能会加以扩展。通常在父类中给出的实现是一个空实现，并以该空实现作为方法的默认实现。当然，钩子方法也可以提供一个非空的默认实现。\n   \n   抽象类的典型代码如下：\n   \n   public abstract class AbstractClass {\n       //模板方法\n       public void templateMethod() {\n           primitiveOperation1();\n           primitiveOperation2();\n           primitiveOperation3();\n   }\n   \n       //基本方法—具体方法\n       public void primitiveOperation1() {\n           //实现代码\n       }\n   \n       //基本方法—抽象方法\n       public abstract void primitiveOperation2();    \n   \n       //基本方法—钩子方法\n       public void primitiveOperation3()   \n       {  }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n   \n   具体子类的典型代码如下：\n   \n   public class ConcreteClass extends AbstractClass {\n       public void primitiveOperation2() {\n           //实现代码\n       }\n   \n       public void primitiveOperation3() {\n           //实现代码\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n\n# 2.3 模板方法模式应用举例\n\n * 题目描述\n   \n   > 某软件公司要为某银行的业务支撑系统开发一个利息计算模块，利息的计算流程如下： (1) 系统根据账号和密码验证用户信息，如果用户信息错误，则系统显示出错提示。 (2) 如果用户信息正确，则根据用户类型的不同使用不同的利息计算公式计算利息（如活期账户和定期账户具有不同的利息计算公式）。 (3) 系统显示利息。 现使用模板方法模式设计该利息计算模块。\n\n * UML类图\n   \n   \n   \n   其中，Account充当抽象类角色，CurrentAccount和SavingAccount充当具体子类角色。\n\n * 代码\n   \n   代码地址",normalizedContent:"# 1 模板方法模式介绍\n\n在软件开发中，某个方法的实现需要多个步骤，其中有些步骤是固定的，而有些步骤并不固定，存在可变性。为了提高代码的复用性和系统的灵活性，可以使用一种称为模板方法模式（template method pattern）的设计模式来对这类情况进行设计。在模板方法模式中将实现功能的每一个步骤所对应的方法称为基本方法，而将调用这些基本方法同时定义基本方法的执行次序的方法称为模板方法。\n\n模板方法模式定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。它是结构最简单的行为型设计模式，在其结构中只存在父类与子类的继承关系。\n\n模板方法模式将一些复杂流程的实现步骤封装在一系列基本方法中，在抽象父类中提供一个称之为模板方法的方法来定义这些基本方法的执行次序，而通过其子类来覆盖某些步骤，从而使得相同的算法框架可以有不同的执行结果。\n\n> 主要解决： 一些方法通用，却在每一个子类都重新写了这一方法。\n> \n> 何时使用： 有一些通用的方法。\n> \n> 如何解决： 将这些通用算法抽象出来。\n> \n> 关键代码： 在抽象类实现，其他步骤在子类实现。\n> \n> 应用实例： 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 session、关闭 session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。\n> \n> 优点： 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。\n> \n> 缺点： 每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。\n> \n> 使用场景： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。\n> \n> 注意事项： 为防止恶意操作，一般模板方法都加上 final 关键词。\n\n\n# 2 模板方法模式详解\n\n\n# 2.1 模板方法模式结构\n\n模板方法模式的结构比较简单，其核心是抽象类和其中的模板方法设计，其结构图如下：\n\n\n\n由上图可知，模板方法模式包含以下两个角色。\n\n 1. abstractclass（抽象类）：在抽象类中定义了一系列基本操作（primitive operations），这些基本操作可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤。同时在抽象类中实现了一个模板方法（template method），用于定义一个算法的框架，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法。\n 2. concreteclass（具体子类）：它是抽象类的子类，用于实现在父类中声明的抽象基本操作以及完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体基本操作。\n\n\n# 2.2 模板方法模式实现\n\n在实现模板方法模式时，开发抽象类的软件设计师和开发具体子类的软件设计师之间可以进行协作。\n\n * 模板方法\n   \n   一个模板方法就是将定义在抽象类中的把基本操作方法组合在一起形成一个总算法或一个总行为的方法。这个模板方法定义在抽象类中，并由子类不加修改地完全继承下来。由于模板方法是具体方法，因此模板方法模式中的抽象层只能是抽象类，而不是接口。\n\n * 基本方法\n   \n   基本方法是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为3种，即抽象方法（abstract method）、具体方法（concrete method）和钩子方法（hook method）。\n   \n   * 抽象方法：一个抽象方法由抽象类声明、由其具体子类实现。\n   * 具体方法：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。\n   * 钩子方法：一个钩子方法由一个抽象类或具体类声明并实现，而其子类可能会加以扩展。通常在父类中给出的实现是一个空实现，并以该空实现作为方法的默认实现。当然，钩子方法也可以提供一个非空的默认实现。\n   \n   抽象类的典型代码如下：\n   \n   public abstract class abstractclass {\n       //模板方法\n       public void templatemethod() {\n           primitiveoperation1();\n           primitiveoperation2();\n           primitiveoperation3();\n   }\n   \n       //基本方法—具体方法\n       public void primitiveoperation1() {\n           //实现代码\n       }\n   \n       //基本方法—抽象方法\n       public abstract void primitiveoperation2();    \n   \n       //基本方法—钩子方法\n       public void primitiveoperation3()   \n       {  }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n   \n   具体子类的典型代码如下：\n   \n   public class concreteclass extends abstractclass {\n       public void primitiveoperation2() {\n           //实现代码\n       }\n   \n       public void primitiveoperation3() {\n           //实现代码\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n\n# 2.3 模板方法模式应用举例\n\n * 题目描述\n   \n   > 某软件公司要为某银行的业务支撑系统开发一个利息计算模块，利息的计算流程如下： (1) 系统根据账号和密码验证用户信息，如果用户信息错误，则系统显示出错提示。 (2) 如果用户信息正确，则根据用户类型的不同使用不同的利息计算公式计算利息（如活期账户和定期账户具有不同的利息计算公式）。 (3) 系统显示利息。 现使用模板方法模式设计该利息计算模块。\n\n * uml类图\n   \n   \n   \n   其中，account充当抽象类角色，currentaccount和savingaccount充当具体子类角色。\n\n * 代码\n   \n   代码地址",charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"位运算全面总结",frontmatter:{title:"位运算全面总结",date:"2021-05-28T13:12:04.000Z",tags:["位运算"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/41f1cd/",categories:["开发","数据结构与算法","位运算"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/03.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/05.%E4%BD%8D%E8%BF%90%E7%AE%97/01.%E4%BD%8D%E8%BF%90%E7%AE%97%E5%85%A8%E9%9D%A2%E6%80%BB%E7%BB%93.html",relativePath:"01.开发/03.数据结构与算法/05.位运算/01.位运算全面总结.md",key:"v-66f80783",path:"/pages/41f1cd/",headers:[{level:2,title:"1 位运算概述",slug:"_1-位运算概述",normalizedTitle:"1 位运算概述",charIndex:2},{level:2,title:"2 位运算的性质",slug:"_2-位运算的性质",normalizedTitle:"2 位运算的性质",charIndex:1187},{level:3,title:"2.1 运算符的优先级",slug:"_2-1-运算符的优先级",normalizedTitle:"2.1 运算符的优先级",charIndex:1200},{level:3,title:"2.2 位运算符的运算律",slug:"_2-2-位运算符的运算律",normalizedTitle:"2.2 位运算符的运算律",charIndex:2340},{level:2,title:"3 位运算高级操作",slug:"_3-位运算高级操作",normalizedTitle:"3 位运算高级操作",charIndex:2846},{level:2,title:"4 负数的位运算",slug:"_4-负数的位运算",normalizedTitle:"4 负数的位运算",charIndex:5898},{level:2,title:"5 位运算的一些应用",slug:"_5-位运算的一些应用",normalizedTitle:"5 位运算的一些应用",charIndex:6782},{level:2,title:"6 位运算例题",slug:"_6-位运算例题",normalizedTitle:"6 位运算例题",charIndex:8640},{level:3,title:"6.1 更新二进制位",slug:"_6-1-更新二进制位",normalizedTitle:"6.1 更新二进制位",charIndex:8652},{level:3,title:"6.2 A+B问题",slug:"_6-2-a-b问题",normalizedTitle:"6.2 a+b问题",charIndex:9616},{level:3,title:"6.3 O(1)时间检测2的幂次",slug:"_6-3-o-1-时间检测2的幂次",normalizedTitle:"6.3 o(1)时间检测2的幂次",charIndex:10825}],headersStr:"1 位运算概述 2 位运算的性质 2.1 运算符的优先级 2.2 位运算符的运算律 3 位运算高级操作 4 负数的位运算 5 位运算的一些应用 6 位运算例题 6.1 更新二进制位 6.2 A+B问题 6.3 O(1)时间检测2的幂次",content:"# 1 位运算概述\n\n我们知道，计算机中的数在内存中都是以二进制形式进行存储的 ，而位运算就是直接对整数在内存中的二进制位进行操作，因此其执行效率非常高，在程序中尽量使用位运算进行操作，这会大大提高程序的性能。\n\n那么，涉及位运算的运算符如下表所示：\n\n符号   描述   运算规则                                  实例（以四位二进制数为例）\n&    与    两个位都为1时，结果才为1。                        0001&0001=1,0001&0000=0,0000&0000=00000001\\&0001=1,0001\\&0000=0,0000\\&0000=00000001&0001=1,0001&0000=0,0000&0000=0000\n|    或    两个位都为0时，结果才为0。                        0001∥0001=0001,0001∥0000=0001,0000∥0000=00000001\\|0001=0001,0001\\|0000=0001,0000\\|0000=00000001∥0001=0001,0001∥0000=0001,0000∥0000=0000\n^    异或   两个位相同为0，相异为1。                         0001∧0001=0000,0001∧0000=1,0000∧0000=00001\n                                                \\wedge0001=0000,0001\\wedge0000=1,0000\\wedge\n                                                0000=00001∧0001=0000,0001∧0000=1,0000∧0000=0\n~    取反   0变1，1变0。                              ∼0=1,∼1=0\\sim0=1,\\sim 1 = 0∼0=1,∼1=0\n<<   左移   各二进位全部左移若干位，高位丢弃，低位补0。                0001<<k=0100，k=20001<<k=0100，k=20001<<k=0100，k=2，kkk是左移的位数，这里k=2k=2k=2\n>>   右移   各二进位全部右移若干位，对无符号数，高位补0，有符号数，右移补111。   0100>>k=0001，k=20100>>k=0001，k=20100>>k=0001，k=2，kkk是右移的位数，这里k=2k=2k=2\n\n看完，你可能会觉得挺简单的，但位运算的难点并不在这，而在于其性质、高级操作和它的应用。\n\n\n# 2 位运算的性质\n\n\n# 2.1 运算符的优先级\n\n优先级需要弄清楚，如果不太清楚可以加小括号确保是想要的运算顺序，这里只是相对优先级，即只是和一些常用的算术运算符做比较。\n\n优先级   运算符                                                                                       结合方向\n1     −（符号运算符）,∼（取反运算符），++（自增），−−（自减）-（符号运算符）,\\sim（取反运算符），                                      从右到左\n      ++（自增），--（自减）−（符号运算符）,∼（取反运算符），++（自增），−−（自减）\n2     ∗（乘）,/（除）,%（取余）*（乘）,/（除）,\\%（取余）∗（乘）,/（除）,%（取余）                                            从左到右\n3     +（加）,−（减）+（加）,-（减）+（加）,−（减）                                                               从左到右\n4     <<（左移），>>（右移）<<（左移），>>（右移）<<（左移），>>（右移）                                                   从左到右\n5     >（大于）,<(小于),>=(大于等于),<=(小于等于)>（大于）,<(小于),>=(大于等于),<=(小于等于)>（大于）,<(小于),>=(大于等于),<=(小于等于)   从左到右\n6     ==(等于),!=（不等于）==(等于),!=（不等于）==(等于),!=（不等于）                                                从左到右\n7     &（按位与）\\&（按位与）&（按位与）                                                                       从左到右\n8     ∧(按位异或)\\wedge (按位异或)∧(按位异或)                                                               从左到右\n9     ∥(按位或)\\|(按位或)∥(按位或)                                                                       从左到右\n\n\n# 2.2 位运算符的运算律\n\n公式名称                  运算规则\n交换律                   A&B=B&A,A∧B=B∧AA\\&B=B\\&A ,A\\wedge B=B\\wedge AA&B=B&A,A∧B=B∧A\n结合律（注意结合律只能在同符号下进行）   (A&B)&C=A&(B&C)(A\\&B)\\&C=A\\&(B\\&C)(A&B)&C=A&(B&C)\n等幂律                   A&A=A，A∥A=AA\\&A=A，A\\|A=AA&A=A，A∥A=A\n零律                    A&0=0A\\&0=0A&0=0\n互补律（注意，这不同于逻辑运算）      A&∼A=0,A∥∼A=−1A\\&\\sim A=0,A\\|\\sim A=-1A&∼A=0,A∥∼A=−1\n同一律                   A∥0=A，A∧0=AA\\|0=A，A\\wedge 0 =AA∥0=A，A∧0=A\n\n以上仅为已证明的运算律（可能存在遗漏），其余的博主均认为是不符合不成立的，注意：千万不要将逻辑运算的运算律或者其他的运算律与这混为一谈。\n\n\n# 3 位运算高级操作\n\n如下表，请读者认真阅读理解，在阅读的过程中可以对示例进行运算。\n\n功能               示例                                                                                                                位运算\n去掉最后一位           0100−>00100100->00100100−>0010                                                                                    x>>1x>>1x>>1\n在最后加一个000        0100−>10000100->10000100−>1000                                                                                    x<<1x<<1x<<1\n在最后加一个1          0100−>10010100->10010100−>1001                                                                                    (x<<1)+1(x<<1)+1(x<<1)+1\n将最后一位变为111       0100−>01010100->01010100−>0101                                                                                    x∥1x\\|1x∥1\n将最后一位变为000       0101−>01000101->01000101−>0100，这里实际上就是先确保最低位变为111，再减去111。                                                         (x∥1)−1(x\\|1)-1(x∥1)−1\n最后一位取反           0100−>01010100->01010100−>0101 ，利用异或性质，其中除最后一位其余不变。                                                               x∧1x\\wedge1x∧1\n把右数的第kkk位变为111   0001−>1001,k=40001->1001,k=40001−>1001,k=4                                                                        x∥(1<<(k−1))x\\|(1<<(k-1))x∥(1<<(k−1))\n把右数的第kkk位变为000   1001−>0001,k=41001->0001,k=41001−>0001,k=4，这个操作实际上就是先得到了100010001000，然后取反得到011101110111，最后利用按位与的性质其余位不变，最高位为000   x&(∼(1<<(k−1)))x\\&(\\sim(1<<(k-1)))x&(∼(1<<(k−1)))\n把右数的第kkk位取反      1000−>0000,k=41000->0000,k=41000−>0000,k=4，利用异或性质                                                                 x∧(1<<(k−1))x\\wedge (1<<(k-1))x∧(1<<(k−1))\n\n由于表长限制，这里接下表继续：\n\n功能                示例                                                                                          位运算\n取末kkk位            1011−>0011,k=21011->0011,k=21011−>0011,k=2                                                  x&((1<<k)−1)x\\&((1<<k)-1)x&((1<<k)−1)\n取右数的第kkk位         1011−>0001,k=41011->0001,k=41011−>0001,k=4，右移k−1k-1k−1位则是去掉了最后的k−1k-1k−1位，我们利用按位与即可将其提取出来   x>>(k−1)&1x>>(k-1)\\&1x>>(k−1)&1\n把末kkk位全变为111      1000−>1111,k=31000->1111,k=31000−>1111,k=3                                                  x∥((1<<k)−1)x\\|((1<<k)-1)x∥((1<<k)−1)\n把末kkk位取反          0101−>1010,k=40101->1010,k=40101−>1010,k=4                                                  x∧((1<<k)−1)x\\wedge ((1<<k)-1)x∧((1<<k)−1)\n把右边连续的111变为000    0111−>00000111->00000111−>0000 ，注意是右起连续的111                                                 x&(x+1)x\\&(x+1)x&(x+1)\n把右起的第一个000变为111   0011−>01110011->01110011−>0111                                                              x∥(x+1)x\\|(x+1)x∥(x+1)\n把右起连续的000变为111    1000−>11111000->11111000−>1111，注意是右起连续的000                                                  x∥(x−1)x\\|(x-1)x∥(x−1)\n取右边连续的111         1011−>00111011->00111011−>0011                                                              (x∧(x+1))>>1(x\\wedge (x+1))>>1(x∧(x+1))>>1\n去掉右起的第一个111的左边    1101−>00011101->00011101−>0001                                                              x&(x∧(x−1))x\\&(x\\wedge (x-1))x&(x∧(x−1))\n\n当然，这里只是一些常用的，并不是全部，位运算的神奇远不止于此。\n\n\n# 4 负数的位运算\n\n首先，我们要知道，在计算机中，运算是使用的二进制补码，而正数的补码是它本身，负数的补码则是符号位不变，其余按位取反，最后再+1+1+1得到的， 例如：\n\n151515,原码:00001111 00001111\\space00001111 补码:000011110000111100001111\n\n−15-15−15,原码:10001111 10001111\\space10001111 补码:111100011111000111110001\n\n那么对于负数的位运算而言，它们的操作都是建立在补码上的，得到的运算结果是补码，最后将补码结果转化成一个普通的十进制数结果。但需要注意的是，符号位是需要参与运算的，而在左移右移操作中，负数右移补111，左移右边补000。例如对于−15-15−15，其补码为11110001,11110001,11110001,右移一位(−15>>1)(-15>>1)(−15>>1)得到的是111110001111100011111000，即−8-8−8，其他的同理。\n\n这里我们介绍几个特殊的性质：\n\n * 快速判断是否为−1-1−1\n   \n   在链式前向星中，我们初始化headheadhead数组为−1-1−1，最后判断是否遍历完uuu的所有边时，即判断iii是否为−1-1−1，我们直接用∼i\\sim i∼i即可。原因就在于−1-1−1的补码是111111111111111111111111，按位取反就变为000000000000000000000000，这实际上就是000。\n\n * 取最低位的111，lowbit函数\n   \n   也就是x&(−x)x\\&(-x)x&(−x)，这在树状数组中起着巨大作用，这里指路一篇树状数组讲解blogblogblog:点这里，我们来证明一下，这里取x=15x=15x=15，对于15&(−15)15\\&(-15)15&(−15)，我们知道，在补码上进行运算得到的是000000010000000100000001，需要注意二元运算的符号位我们需要进行运算。\n\n\n# 5 位运算的一些应用\n\n * 位运算实现乘除法\n   \n   > 将xxx左移一位实现×2\\times 2×2，将xxx右移一位实现÷2\\div2÷2。\n   > \n   > a<<1≡a∗2a<<1 \\equiv a*2a<<1≡a∗2\n   > \n   > a>>1≡a/2a >>1 \\equiv a/2a>>1≡a/2\n\n * 位运算交换两整数\n\n void swap(int &a,int &b){\n      a ^= b;\n      b ^= a;\n      a ^= b;\n  }\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n这效率非常高，我们来剖析其原理，对于a=a∧ba=a\\wedge ba=a∧b，则b=b∧(a∧b)b = b\\wedge(a\\wedge b)b=b∧(a∧b)，根据交换律以及异或性质，得b=b∧b∧a=0∧a=ab=b\\wedge b\\wedge a=0\\wedge a=ab=b∧b∧a=0∧a=a，同理a=(a∧b)∧a=0∧b=ba=(a\\wedge b)\\wedge a=0\\wedge b=ba=(a∧b)∧a=0∧b=b。这样就实现了交换操作。\n\n * 位运算判断奇偶数\n   \n   > 我们知道，在二进制中，最低位决定了是奇数还是偶数，所以我们可以提取出最低位的值，即与111相与即可实现目的，为000则是偶数，为111则是奇数。\n\n * 位运算改变正负性和求绝对值\n\nint change(int a){\n    return ~ a + 1;\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n对于正数而言，补码就是原码，所以按位取反再+1+1+1则得到对应真值负数的补码，而对于负数，其补码进行按位取反再+1+1+1则得到对应真值正数的补码，变为原码。那么知道这个我们就可以特判是否为负数 （这里通过右移313131位，若为正数，则得到的是000，若为负数，则得到的是−1-1−1，而000的补码为000000000000,−1-1−1的补码为111111111111，根据异或性质即可判断感谢读者 （恢。）指出错误，这里应该是要进行按位取反操作，这样如果为负数判断结果才为0 。） ，利用条件表达式就可以根据判断结果求绝对值了。如下：\n\nint abs(int a){\n    return ~(a >> 31) ? a : ~a + 1;\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n * 位运算实现对ppp取余（p为2k2^k2k）\n\nint mod(int a,int p){\n    return a & (p - 1);\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n取余实际上就是舍去大于等于ppp的位数，所以我们只需要保留在ppp范围内的数。由于我们限定了ppp为2k2^k2k，所以(p−1)(p - 1)(p−1)一定是将小于ppp的最高位全部变为了111，这样再进行与操作即可得到余数。\n\n * 位运算统计二进制数111的个数\n\nint count(int x){\n    int cnt = 0;\n    while(x){\n        x = x & (x - 1);\n        cnt ++;\n    }\n    return cnt;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n对于任意的xxx，转换成二进制后，是形如这样的数字：aa...aa10...00aa...aa10...00aa...aa10...00，从右向左数有任意多个000，直到遇见第一个111，字母aaa用来占位，代表111左边的任意数字。x−1x-1x−1转换成二进制后，是形如这样的数字：aa...aa01...11aa...aa01...11aa...aa01...11，从右向左数，原来的任意多个000都变成111，原来的第一个111，变成000，字母aaa部分不变。对xxx 和 x−1x-1x−1 进行 按位与 计算，会得到：aa...aa00...00aa...aa00...00aa...aa00...00，从右向左数，原来的第一个111变成了000，字母a部分不变。所以 x&(x−1)x \\& (x-1)x&(x−1)相当于消除了 xxx 从右向左数遇到的第一个111。那么，xxx转换成二进制后包含多少个111，count函数里的循环就会进行多少次，直到xxx所有的111都被“消除”。\n\n\n# 6 位运算例题\n\n\n# 6.1 更新二进制位\n\n * 题面\n   \n   > 给出两个32位的整数N和M，以及两个二进制位的位置i和j。写一个方法来使得N中的第i到j位等于M（M会是N中从第i为开始到第j位的子串）\n   > \n   > 样例：\n   > \n   > 输入: N=(10000000000)2 M=(10101)2 i=2 j=6\n   > 输出: N=(10001010100)2\n   > 输入: N=(10000000000)2 M=(11111)2 i=2 j=6\n   > 输出: N=(10001111100)2\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n\n * 解题思路\n   \n   结合所学，我们的思路应该就是先将第iii位到第jjj位全部变为000，再将与左移iii位的MMM进行或操作。\n\n * AC代码\n\nclass Solution {\npublic:\n    int updateBits(int n, int m, int i, int j) {\n    \t// 循环遍历从第 i 位到第 j 位\n        for(int pos = i; pos <= j; pos ++ ){\n        \t// 将 n 的第 pos 位设为 0\n            // ~(1 << pos) 创建一个在第 pos 位为 0 其他位为 1 的掩码\n            // 然后使用按位与运算符（&）来将 n 的第 pos 位设置为 0\n        \tn &= ~(1 << pos);\n        }\n        // 将 m 左移 i 位，使 m 的低位对齐到 n 的第 i 位\n        // 然后使用按位或运算符（|）合并 n 和 m\n        // 这样 n 的第 i 到第 j 位就被 m 的相应位所替换\n        return n | (m << i);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 6.2 A+B问题\n\n * 题面\n   \n   > 给出两个整数 a 和 b , 求他们的和并以整数（int）的形式返回。不能使用 + 等数学运算符。\n   > \n   > 样例：\n   > \n   > 输入：\n   > \n   > a = 1\n   > b = 2\n   > \n   > \n   > 1\n   > 2\n   > \n   > 1\n   > 2\n   > \n   > \n   > 输出：\n   > \n   > 3\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 输入：\n   > \n   > a = -1\n   > b = 1\n   > \n   > \n   > 1\n   > 2\n   > \n   > 1\n   > 2\n   > \n   > \n   > 输出：\n   > \n   > 0\n   > \n   > \n   > 1\n   > \n   > 1\n\n * 解题思路\n   \n   这题我们可以利用异或操作来实现，因为异或操作有一个别名叫不进位加法。那么进位操作我们实际上就可以通过a&ba\\&ba&b来实现，因为a&ba\\&ba&b得到的都是aaa和bbb上都有的111，我们再左移即得到的是进位之后的结果，所以a+b=(a∧b)+(a&b<<1)a+b=(a\\wedge b)+(a\\&b<<1)a+b=(a∧b)+(a&b<<1)。通过这样模拟竖式加法操作即可。\n\n * AC代码\n\nclass Solution {\npublic:\n    int aplusb(int a, int b) {\n    \t// 当没有进位需要处理时循环结束\n        while(b != 0){\n        \t// temp_a 存储 a 和 b 的按位异或结果，这相当于不带进位的加法\n            int temp_a = a ^ b;\n            // temp_b 存储 a 和 b 的按位与结果并左移一位，这相当于计算进位\n            // 因为只有两个位都是1时才会产生进位\n            int temp_b = (a & b) << 1;\n\n\t\t\t// 更新 a 为不带进位的加法结果\n            a = temp_a;\n\t\n\t\t\t// 更新 b 为进位\n            b = temp_b;\n        }\n        // 当没有进位时，a 中存储了最终结果，返回 a\n        return a;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 6.3 O(1)时间检测2的幂次\n\n * 题面\n   \n   > 用 O(1) 时间检测整数 n 是否是 2 的幂次。\n   > \n   > 样例\n   > \n   > n=4，返回 true;\n   > \n   > n=5，返回 false.\n   > \n   > 挑战\n   > \n   > O(1) 时间复杂度\n\n * 解题思路\n   \n   首先我们知道2k2^k2k是大于000的，这里我们需要特判，同理，2k2^k2k的二进制表示中只有111个111，故我们可以利用x&(x−1)x\\&(x-1)x&(x−1)来消除唯一的111判断是否等于000即可。\n\n * AC代码\n\nclass Solution {\npublic:\n    bool checkPowerOf2(int n) {\n        // 检查 n 是否大于 0\n        // 2 的幂必须是正数，因为 0 和负数都不是 2 的幂\n        // 检查 n 和 n - 1 的按位与操作是否为 0\n        // 如果 n 是 2 的幂，则其二进制表示中只有一个 1\n        // 例如 2 (10), 4 (100), 8 (1000)\n        // 当 n 是 2 的幂时，n - 1 的二进制表示是 n 的最高位 1 变为 0，\n        // 其余位从 0 变为 1，例如 2 (10) - 1 = 1 (01), 4 (100) - 1 = 3 (011)\n        // 因此 n & (n - 1) 将得到 0\n        return n > 0 && (n & (n - 1)) == 0;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n",normalizedContent:"# 1 位运算概述\n\n我们知道，计算机中的数在内存中都是以二进制形式进行存储的 ，而位运算就是直接对整数在内存中的二进制位进行操作，因此其执行效率非常高，在程序中尽量使用位运算进行操作，这会大大提高程序的性能。\n\n那么，涉及位运算的运算符如下表所示：\n\n符号   描述   运算规则                                  实例（以四位二进制数为例）\n&    与    两个位都为1时，结果才为1。                        0001&0001=1,0001&0000=0,0000&0000=00000001\\&0001=1,0001\\&0000=0,0000\\&0000=00000001&0001=1,0001&0000=0,0000&0000=0000\n|    或    两个位都为0时，结果才为0。                        0001∥0001=0001,0001∥0000=0001,0000∥0000=00000001\\|0001=0001,0001\\|0000=0001,0000\\|0000=00000001∥0001=0001,0001∥0000=0001,0000∥0000=0000\n^    异或   两个位相同为0，相异为1。                         0001∧0001=0000,0001∧0000=1,0000∧0000=00001\n                                                \\wedge0001=0000,0001\\wedge0000=1,0000\\wedge\n                                                0000=00001∧0001=0000,0001∧0000=1,0000∧0000=0\n~    取反   0变1，1变0。                              ∼0=1,∼1=0\\sim0=1,\\sim 1 = 0∼0=1,∼1=0\n<<   左移   各二进位全部左移若干位，高位丢弃，低位补0。                0001<<k=0100，k=20001<<k=0100，k=20001<<k=0100，k=2，kkk是左移的位数，这里k=2k=2k=2\n>>   右移   各二进位全部右移若干位，对无符号数，高位补0，有符号数，右移补111。   0100>>k=0001，k=20100>>k=0001，k=20100>>k=0001，k=2，kkk是右移的位数，这里k=2k=2k=2\n\n看完，你可能会觉得挺简单的，但位运算的难点并不在这，而在于其性质、高级操作和它的应用。\n\n\n# 2 位运算的性质\n\n\n# 2.1 运算符的优先级\n\n优先级需要弄清楚，如果不太清楚可以加小括号确保是想要的运算顺序，这里只是相对优先级，即只是和一些常用的算术运算符做比较。\n\n优先级   运算符                                                                                       结合方向\n1     −（符号运算符）,∼（取反运算符），++（自增），−−（自减）-（符号运算符）,\\sim（取反运算符），                                      从右到左\n      ++（自增），--（自减）−（符号运算符）,∼（取反运算符），++（自增），−−（自减）\n2     ∗（乘）,/（除）,%（取余）*（乘）,/（除）,\\%（取余）∗（乘）,/（除）,%（取余）                                            从左到右\n3     +（加）,−（减）+（加）,-（减）+（加）,−（减）                                                               从左到右\n4     <<（左移），>>（右移）<<（左移），>>（右移）<<（左移），>>（右移）                                                   从左到右\n5     >（大于）,<(小于),>=(大于等于),<=(小于等于)>（大于）,<(小于),>=(大于等于),<=(小于等于)>（大于）,<(小于),>=(大于等于),<=(小于等于)   从左到右\n6     ==(等于),!=（不等于）==(等于),!=（不等于）==(等于),!=（不等于）                                                从左到右\n7     &（按位与）\\&（按位与）&（按位与）                                                                       从左到右\n8     ∧(按位异或)\\wedge (按位异或)∧(按位异或)                                                               从左到右\n9     ∥(按位或)\\|(按位或)∥(按位或)                                                                       从左到右\n\n\n# 2.2 位运算符的运算律\n\n公式名称                  运算规则\n交换律                   a&b=b&a,a∧b=b∧aa\\&b=b\\&a ,a\\wedge b=b\\wedge aa&b=b&a,a∧b=b∧a\n结合律（注意结合律只能在同符号下进行）   (a&b)&c=a&(b&c)(a\\&b)\\&c=a\\&(b\\&c)(a&b)&c=a&(b&c)\n等幂律                   a&a=a，a∥a=aa\\&a=a，a\\|a=aa&a=a，a∥a=a\n零律                    a&0=0a\\&0=0a&0=0\n互补律（注意，这不同于逻辑运算）      a&∼a=0,a∥∼a=−1a\\&\\sim a=0,a\\|\\sim a=-1a&∼a=0,a∥∼a=−1\n同一律                   a∥0=a，a∧0=aa\\|0=a，a\\wedge 0 =aa∥0=a，a∧0=a\n\n以上仅为已证明的运算律（可能存在遗漏），其余的博主均认为是不符合不成立的，注意：千万不要将逻辑运算的运算律或者其他的运算律与这混为一谈。\n\n\n# 3 位运算高级操作\n\n如下表，请读者认真阅读理解，在阅读的过程中可以对示例进行运算。\n\n功能               示例                                                                                                                位运算\n去掉最后一位           0100−>00100100->00100100−>0010                                                                                    x>>1x>>1x>>1\n在最后加一个000        0100−>10000100->10000100−>1000                                                                                    x<<1x<<1x<<1\n在最后加一个1          0100−>10010100->10010100−>1001                                                                                    (x<<1)+1(x<<1)+1(x<<1)+1\n将最后一位变为111       0100−>01010100->01010100−>0101                                                                                    x∥1x\\|1x∥1\n将最后一位变为000       0101−>01000101->01000101−>0100，这里实际上就是先确保最低位变为111，再减去111。                                                         (x∥1)−1(x\\|1)-1(x∥1)−1\n最后一位取反           0100−>01010100->01010100−>0101 ，利用异或性质，其中除最后一位其余不变。                                                               x∧1x\\wedge1x∧1\n把右数的第kkk位变为111   0001−>1001,k=40001->1001,k=40001−>1001,k=4                                                                        x∥(1<<(k−1))x\\|(1<<(k-1))x∥(1<<(k−1))\n把右数的第kkk位变为000   1001−>0001,k=41001->0001,k=41001−>0001,k=4，这个操作实际上就是先得到了100010001000，然后取反得到011101110111，最后利用按位与的性质其余位不变，最高位为000   x&(∼(1<<(k−1)))x\\&(\\sim(1<<(k-1)))x&(∼(1<<(k−1)))\n把右数的第kkk位取反      1000−>0000,k=41000->0000,k=41000−>0000,k=4，利用异或性质                                                                 x∧(1<<(k−1))x\\wedge (1<<(k-1))x∧(1<<(k−1))\n\n由于表长限制，这里接下表继续：\n\n功能                示例                                                                                          位运算\n取末kkk位            1011−>0011,k=21011->0011,k=21011−>0011,k=2                                                  x&((1<<k)−1)x\\&((1<<k)-1)x&((1<<k)−1)\n取右数的第kkk位         1011−>0001,k=41011->0001,k=41011−>0001,k=4，右移k−1k-1k−1位则是去掉了最后的k−1k-1k−1位，我们利用按位与即可将其提取出来   x>>(k−1)&1x>>(k-1)\\&1x>>(k−1)&1\n把末kkk位全变为111      1000−>1111,k=31000->1111,k=31000−>1111,k=3                                                  x∥((1<<k)−1)x\\|((1<<k)-1)x∥((1<<k)−1)\n把末kkk位取反          0101−>1010,k=40101->1010,k=40101−>1010,k=4                                                  x∧((1<<k)−1)x\\wedge ((1<<k)-1)x∧((1<<k)−1)\n把右边连续的111变为000    0111−>00000111->00000111−>0000 ，注意是右起连续的111                                                 x&(x+1)x\\&(x+1)x&(x+1)\n把右起的第一个000变为111   0011−>01110011->01110011−>0111                                                              x∥(x+1)x\\|(x+1)x∥(x+1)\n把右起连续的000变为111    1000−>11111000->11111000−>1111，注意是右起连续的000                                                  x∥(x−1)x\\|(x-1)x∥(x−1)\n取右边连续的111         1011−>00111011->00111011−>0011                                                              (x∧(x+1))>>1(x\\wedge (x+1))>>1(x∧(x+1))>>1\n去掉右起的第一个111的左边    1101−>00011101->00011101−>0001                                                              x&(x∧(x−1))x\\&(x\\wedge (x-1))x&(x∧(x−1))\n\n当然，这里只是一些常用的，并不是全部，位运算的神奇远不止于此。\n\n\n# 4 负数的位运算\n\n首先，我们要知道，在计算机中，运算是使用的二进制补码，而正数的补码是它本身，负数的补码则是符号位不变，其余按位取反，最后再+1+1+1得到的， 例如：\n\n151515,原码:00001111 00001111\\space00001111 补码:000011110000111100001111\n\n−15-15−15,原码:10001111 10001111\\space10001111 补码:111100011111000111110001\n\n那么对于负数的位运算而言，它们的操作都是建立在补码上的，得到的运算结果是补码，最后将补码结果转化成一个普通的十进制数结果。但需要注意的是，符号位是需要参与运算的，而在左移右移操作中，负数右移补111，左移右边补000。例如对于−15-15−15，其补码为11110001,11110001,11110001,右移一位(−15>>1)(-15>>1)(−15>>1)得到的是111110001111100011111000，即−8-8−8，其他的同理。\n\n这里我们介绍几个特殊的性质：\n\n * 快速判断是否为−1-1−1\n   \n   在链式前向星中，我们初始化headheadhead数组为−1-1−1，最后判断是否遍历完uuu的所有边时，即判断iii是否为−1-1−1，我们直接用∼i\\sim i∼i即可。原因就在于−1-1−1的补码是111111111111111111111111，按位取反就变为000000000000000000000000，这实际上就是000。\n\n * 取最低位的111，lowbit函数\n   \n   也就是x&(−x)x\\&(-x)x&(−x)，这在树状数组中起着巨大作用，这里指路一篇树状数组讲解blogblogblog:点这里，我们来证明一下，这里取x=15x=15x=15，对于15&(−15)15\\&(-15)15&(−15)，我们知道，在补码上进行运算得到的是000000010000000100000001，需要注意二元运算的符号位我们需要进行运算。\n\n\n# 5 位运算的一些应用\n\n * 位运算实现乘除法\n   \n   > 将xxx左移一位实现×2\\times 2×2，将xxx右移一位实现÷2\\div2÷2。\n   > \n   > a<<1≡a∗2a<<1 \\equiv a*2a<<1≡a∗2\n   > \n   > a>>1≡a/2a >>1 \\equiv a/2a>>1≡a/2\n\n * 位运算交换两整数\n\n void swap(int &a,int &b){\n      a ^= b;\n      b ^= a;\n      a ^= b;\n  }\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n这效率非常高，我们来剖析其原理，对于a=a∧ba=a\\wedge ba=a∧b，则b=b∧(a∧b)b = b\\wedge(a\\wedge b)b=b∧(a∧b)，根据交换律以及异或性质，得b=b∧b∧a=0∧a=ab=b\\wedge b\\wedge a=0\\wedge a=ab=b∧b∧a=0∧a=a，同理a=(a∧b)∧a=0∧b=ba=(a\\wedge b)\\wedge a=0\\wedge b=ba=(a∧b)∧a=0∧b=b。这样就实现了交换操作。\n\n * 位运算判断奇偶数\n   \n   > 我们知道，在二进制中，最低位决定了是奇数还是偶数，所以我们可以提取出最低位的值，即与111相与即可实现目的，为000则是偶数，为111则是奇数。\n\n * 位运算改变正负性和求绝对值\n\nint change(int a){\n    return ~ a + 1;\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n对于正数而言，补码就是原码，所以按位取反再+1+1+1则得到对应真值负数的补码，而对于负数，其补码进行按位取反再+1+1+1则得到对应真值正数的补码，变为原码。那么知道这个我们就可以特判是否为负数 （这里通过右移313131位，若为正数，则得到的是000，若为负数，则得到的是−1-1−1，而000的补码为000000000000,−1-1−1的补码为111111111111，根据异或性质即可判断感谢读者 （恢。）指出错误，这里应该是要进行按位取反操作，这样如果为负数判断结果才为0 。） ，利用条件表达式就可以根据判断结果求绝对值了。如下：\n\nint abs(int a){\n    return ~(a >> 31) ? a : ~a + 1;\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n * 位运算实现对ppp取余（p为2k2^k2k）\n\nint mod(int a,int p){\n    return a & (p - 1);\n}\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n取余实际上就是舍去大于等于ppp的位数，所以我们只需要保留在ppp范围内的数。由于我们限定了ppp为2k2^k2k，所以(p−1)(p - 1)(p−1)一定是将小于ppp的最高位全部变为了111，这样再进行与操作即可得到余数。\n\n * 位运算统计二进制数111的个数\n\nint count(int x){\n    int cnt = 0;\n    while(x){\n        x = x & (x - 1);\n        cnt ++;\n    }\n    return cnt;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n对于任意的xxx，转换成二进制后，是形如这样的数字：aa...aa10...00aa...aa10...00aa...aa10...00，从右向左数有任意多个000，直到遇见第一个111，字母aaa用来占位，代表111左边的任意数字。x−1x-1x−1转换成二进制后，是形如这样的数字：aa...aa01...11aa...aa01...11aa...aa01...11，从右向左数，原来的任意多个000都变成111，原来的第一个111，变成000，字母aaa部分不变。对xxx 和 x−1x-1x−1 进行 按位与 计算，会得到：aa...aa00...00aa...aa00...00aa...aa00...00，从右向左数，原来的第一个111变成了000，字母a部分不变。所以 x&(x−1)x \\& (x-1)x&(x−1)相当于消除了 xxx 从右向左数遇到的第一个111。那么，xxx转换成二进制后包含多少个111，count函数里的循环就会进行多少次，直到xxx所有的111都被“消除”。\n\n\n# 6 位运算例题\n\n\n# 6.1 更新二进制位\n\n * 题面\n   \n   > 给出两个32位的整数n和m，以及两个二进制位的位置i和j。写一个方法来使得n中的第i到j位等于m（m会是n中从第i为开始到第j位的子串）\n   > \n   > 样例：\n   > \n   > 输入: n=(10000000000)2 m=(10101)2 i=2 j=6\n   > 输出: n=(10001010100)2\n   > 输入: n=(10000000000)2 m=(11111)2 i=2 j=6\n   > 输出: n=(10001111100)2\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n\n * 解题思路\n   \n   结合所学，我们的思路应该就是先将第iii位到第jjj位全部变为000，再将与左移iii位的mmm进行或操作。\n\n * ac代码\n\nclass solution {\npublic:\n    int updatebits(int n, int m, int i, int j) {\n    \t// 循环遍历从第 i 位到第 j 位\n        for(int pos = i; pos <= j; pos ++ ){\n        \t// 将 n 的第 pos 位设为 0\n            // ~(1 << pos) 创建一个在第 pos 位为 0 其他位为 1 的掩码\n            // 然后使用按位与运算符（&）来将 n 的第 pos 位设置为 0\n        \tn &= ~(1 << pos);\n        }\n        // 将 m 左移 i 位，使 m 的低位对齐到 n 的第 i 位\n        // 然后使用按位或运算符（|）合并 n 和 m\n        // 这样 n 的第 i 到第 j 位就被 m 的相应位所替换\n        return n | (m << i);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 6.2 a+b问题\n\n * 题面\n   \n   > 给出两个整数 a 和 b , 求他们的和并以整数（int）的形式返回。不能使用 + 等数学运算符。\n   > \n   > 样例：\n   > \n   > 输入：\n   > \n   > a = 1\n   > b = 2\n   > \n   > \n   > 1\n   > 2\n   > \n   > 1\n   > 2\n   > \n   > \n   > 输出：\n   > \n   > 3\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 输入：\n   > \n   > a = -1\n   > b = 1\n   > \n   > \n   > 1\n   > 2\n   > \n   > 1\n   > 2\n   > \n   > \n   > 输出：\n   > \n   > 0\n   > \n   > \n   > 1\n   > \n   > 1\n\n * 解题思路\n   \n   这题我们可以利用异或操作来实现，因为异或操作有一个别名叫不进位加法。那么进位操作我们实际上就可以通过a&ba\\&ba&b来实现，因为a&ba\\&ba&b得到的都是aaa和bbb上都有的111，我们再左移即得到的是进位之后的结果，所以a+b=(a∧b)+(a&b<<1)a+b=(a\\wedge b)+(a\\&b<<1)a+b=(a∧b)+(a&b<<1)。通过这样模拟竖式加法操作即可。\n\n * ac代码\n\nclass solution {\npublic:\n    int aplusb(int a, int b) {\n    \t// 当没有进位需要处理时循环结束\n        while(b != 0){\n        \t// temp_a 存储 a 和 b 的按位异或结果，这相当于不带进位的加法\n            int temp_a = a ^ b;\n            // temp_b 存储 a 和 b 的按位与结果并左移一位，这相当于计算进位\n            // 因为只有两个位都是1时才会产生进位\n            int temp_b = (a & b) << 1;\n\n\t\t\t// 更新 a 为不带进位的加法结果\n            a = temp_a;\n\t\n\t\t\t// 更新 b 为进位\n            b = temp_b;\n        }\n        // 当没有进位时，a 中存储了最终结果，返回 a\n        return a;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 6.3 o(1)时间检测2的幂次\n\n * 题面\n   \n   > 用 o(1) 时间检测整数 n 是否是 2 的幂次。\n   > \n   > 样例\n   > \n   > n=4，返回 true;\n   > \n   > n=5，返回 false.\n   > \n   > 挑战\n   > \n   > o(1) 时间复杂度\n\n * 解题思路\n   \n   首先我们知道2k2^k2k是大于000的，这里我们需要特判，同理，2k2^k2k的二进制表示中只有111个111，故我们可以利用x&(x−1)x\\&(x-1)x&(x−1)来消除唯一的111判断是否等于000即可。\n\n * ac代码\n\nclass solution {\npublic:\n    bool checkpowerof2(int n) {\n        // 检查 n 是否大于 0\n        // 2 的幂必须是正数，因为 0 和负数都不是 2 的幂\n        // 检查 n 和 n - 1 的按位与操作是否为 0\n        // 如果 n 是 2 的幂，则其二进制表示中只有一个 1\n        // 例如 2 (10), 4 (100), 8 (1000)\n        // 当 n 是 2 的幂时，n - 1 的二进制表示是 n 的最高位 1 变为 0，\n        // 其余位从 0 变为 1，例如 2 (10) - 1 = 1 (01), 4 (100) - 1 = 3 (011)\n        // 因此 n & (n - 1) 将得到 0\n        return n > 0 && (n & (n - 1)) == 0;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n",charsets:{cjk:!0},lastUpdated:"2023/11/25, 16:14:12",lastUpdatedTimestamp:1700900052e3},{title:"数位DP学习整理",frontmatter:{title:"数位DP学习整理",date:"2021-05-12T18:20:58.000Z",tags:["数位DP"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/243023/",categories:["开发","数据结构与算法","动态规划"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/03.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/07.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/01.%E6%95%B0%E4%BD%8DDP.html",relativePath:"01.开发/03.数据结构与算法/07.动态规划/01.数位DP.md",key:"v-66f28a6e",path:"/pages/243023/",headers:[{level:2,title:"1 数位DP介绍",slug:"_1-数位dp介绍",normalizedTitle:"1 数位dp介绍",charIndex:2},{level:2,title:"2 数位DP解法",slug:"_2-数位dp解法",normalizedTitle:"2 数位dp解法",charIndex:256},{level:2,title:"3 数位DP经典例题",slug:"_3-数位dp经典例题",normalizedTitle:"3 数位dp经典例题",charIndex:725},{level:3,title:"3.1 度的数量",slug:"_3-1-度的数量",normalizedTitle:"3.1 度的数量",charIndex:740},{level:3,title:"3.2 计数问题",slug:"_3-2-计数问题",normalizedTitle:"3.2 计数问题",charIndex:3886},{level:3,title:"3.3 数字游戏",slug:"_3-3-数字游戏",normalizedTitle:"3.3 数字游戏",charIndex:8248},{level:3,title:"3.4 windy数",slug:"_3-4-windy数",normalizedTitle:"3.4 windy数",charIndex:10401},{level:3,title:"3.5 数字游戏Ⅱ",slug:"_3-5-数字游戏ii",normalizedTitle:"3.5 数字游戏ⅱ",charIndex:13174},{level:3,title:"3.6 不要62",slug:"_3-6-不要62",normalizedTitle:"3.6 不要62",charIndex:15419},{level:3,title:"3.7 恨7不成妻",slug:"_3-7-恨7不成妻",normalizedTitle:"3.7 恨7不成妻",charIndex:17758},{level:2,title:"4 数位DP总结",slug:"_4-数位dp总结",normalizedTitle:"4 数位dp总结",charIndex:17800}],headersStr:"1 数位DP介绍 2 数位DP解法 3 数位DP经典例题 3.1 度的数量 3.2 计数问题 3.3 数字游戏 3.4 windy数 3.5 数字游戏Ⅱ 3.6 不要62 3.7 恨7不成妻 4 数位DP总结",content:'# 1 数位DP介绍\n\n数位DP往往都是这样的题型，给定一个闭区间[l,r][l,r][l,r]，让你求这个区间中满足某种条件的数的总数。而这个区间可能很大，简单的暴力代码如下：\n\nint ans=0;\nfor(int i=l;i<=r;i++){\n    if(check(i))ans++;\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n我们发现，若区间长度超过1e81e81e8，我们暴力枚举就会超时了，而数位DPDPDP则可以解决这样的题型。数位DPDPDP实际上就是在数位上进行DPDPDP。\n\n\n# 2 数位DP解法\n\n数位DPDPDP就是换一种暴力枚举的方式，使得新的枚举方式符合DPDPDP的性质，然后预处理好即可。我们来看：我们可以用f(n)f(n)f(n)表示[0,n][0,n][0,n]的所有满足条件的个数，那么对于[l,r][l,r][l,r]我们就可以用[l,r]  ⟺  f(r)−f(l−1)[l,r]\\iff f(r)-f(l-1)[l,r]⟺f(r)−f(l−1)，相当于前缀和思想。那么也就是说我们只要求出f(n)f(n)f(n)即可。那么数位DPDPDP关键的思想就是从树的角度来考虑。将数拆分成位，从高位到低位开始枚举。我们可以视NNN为nnn位数，那么我们拆分N:an、an−1...a1N:a_{n}、a_{n-1}...a_1N:an 、an−1 ...a1 。那么我们就可以开始分解建树，如下。之后我们就可以预处理再求解f(n)f(n)f(n)了，个人认为求解f(n)f(n)f(n)是最难的一步。\n\n\n\n听完是不是有点绕，我们可以来点题目练习一下，做完就会发现了数位DPDPDP的套路了。\n\n\n# 3 数位DP经典例题\n\n\n# 3.1 度的数量\n\n * 题面\n   \n   > 求给定区间$ [X,Y]$ 中满足下列条件的整数个数：这个数恰好等于 KKK 个互不相等的 BBB 的整数次幂之和。例如，设 X=15,Y=20,K=2,B=2X=15,Y=20,K=2,B=2X=15,Y=20,K=2,B=2，则有且仅有下列三个数满足题意： 17=24+2017=2^4+2^017=24+20 18=24+2118=2^4+2^118=24+21 20=24+2220=2^4+2^220=24+22 输入格式 第一行包含两个整数 X 和 Y，接下来两行包含整数 KKK 和 BBB。 输出格式 只包含一个整数，表示满足条件的数的个数。 数据范围 1≤X≤Y≤231−1,1≤X≤Y≤2^{31}−1,1≤X≤Y≤231−1, 1≤K≤20,1≤K≤20,1≤K≤20, 2≤B≤102≤B≤102≤B≤10 输入样例： 15 20 2 2 输出样例： 3\n\n * 解题思路\n   \n   此题实际上就是将十进制数转化为BBB进制数，判断位数上的值是否为111。那么我们可以视NNN为nnn位数，那么我们拆分N:an、an−1...a1N:a_{n}、a_{n-1}...a_1N:an 、an−1 ...a1 。从树的角度考虑：我们设N=76543210,B=10N=76543210,B=10N=76543210,B=10，那么我们从高位往最低位开始枚举如下；枚举ana_nan 时，我们有两种选择：\n   \n   1. 走右边分支，那么我们填7(an)7(a_n)7(an )，而题目要求每一位只能填111或者000,而an>1a_n>1an >1，所以不是合法方案，我们直接剔除。\n   2. 走左边分支，那么我们可以填000~666，即0−an−10-{a_n}-10−an −1，那么由于每一位只能填111或者000，所以我们累加这两种选择的方案。\n   \n   记住，走到了左边分支是可以直接累加的。\n   \n   所以我们实际上还是要做一个预处理的，我们用f[i][j]f[i][j]f[i][j]表示还剩下iii位没有填，且需要填写jjj个111的方案数。那么在(i,j)(i,j)(i,j)这个状态，我们可以选择填111，那么接下来的状态就是f[i−1][j−1]f[i-1][j-1]f[i−1][j−1]，而如果填000，那么接下来的状态就是f[i−1][j]f[i-1][j]f[i−1][j]，那么状态转移方程就是f[i][j]=f[i−1][j]+f[i][j−1]f[i][j]=f[i-1][j]+f[i][j-1]f[i][j]=f[i−1][j]+f[i][j−1]。而初始状态即是当j=0j=0j=0时，f[i][0]=1f[i][0]=1f[i][0]=1。这样我们就可以预处理fff数组了。\n   \n   处理完之后我们就可以直接模拟做了。\n\n * 代码\n\n/**\n  *@filename:度的数量\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 11:23\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 100000 + 5;\nconst int mod = 1e9+7;\n\nint l,r,k,b;\nint f[35][35];\n//首先我们先预处理f数组。其中f[i][j]表示剩下还有i个没填，需要填写j个1的方案数。\nvoid init(){\n    for(int i=0;i<35;i++){\n        for(int j=0;j<=i;j++){\n            if(!j)f[i][j]=1;\n            else{\n                f[i][j]=f[i-1][j]+f[i-1][j-1];\n            }\n        }\n    }\n}\nint dp(int n){\n    //求解f(n)。我们需要避免n为0的情况，这里需要特判。\n    if(!n)return 0;\n    vector<int> nums;//将n分割，存储位数。\n    while(n){\n        nums.push_back(n%b);\n        n/=b;\n    }\n    int ans=0;//答案。\n    int last=0;//前面的信息，这里代表的是前面分支选取了多少个1.\n    for(int i=nums.size()-1;i>=0;i--){\n        int x=nums[i];\n        if(x){\n            //说明x>0，我们可以选择左边分支填0.\n            ans+=f[i][k-last];\n            if(x>1){\n                //当x>1我们才可以枚举左边分支填1.\n                if(k-last-1>=0){\n                    //如果还可以填1的话。\n                    ans+=f[i][k-last-1];\n                }\n                break;//因为右边分支只能为0或1，所以不符合条件。break。\n            }\n            else{\n                //当x=1就可以进入右边的分支继续讨论。\n                last++;\n                if(last>k)break;\n            }\n        }\n        //考虑到最后一位，如果符合条件那么末位填0也算一种方案。\n        if(!i&&last==k)ans++;\n    }\n    return ans;\n}\nvoid solve(){\n}\nint main(){\n    cin>>l>>r>>k>>b;\n    init();\n    cout<<dp(r)-dp(l-1)<<endl;\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n\n# 3.2 计数问题\n\n * 题面\n   \n   > 给定两个整数 a 和 b，求 a 和 b 之间的所有数字中 0∼90∼9 的出现次数。\n   > \n   > 例如，a=1024，b=1032a=1024，b=1032a=1024，b=1032，则 a 和 b 之间共有 99 个数如下：\n   > \n   > 1024 1025 1026 1027 1028 1029 1030 1031 1032\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 其中 0 出现 10次，1 出现 10 次，2 出现 7 次，3 出现 3 次等等…\n   > \n   > 输入格式\n   > \n   > 输入包含多组测试数据。\n   > \n   > 每组测试数据占一行，包含两个整数 a 和 b。\n   > \n   > 当读入一行为 0 0 时，表示输入终止，且该行不作处理。\n   > \n   > 输出格式\n   > \n   > 每组数据输出一个结果，每个结果占一行。\n   > \n   > 每个结果包含十个用空格隔开的数字，第一个数字表示 0 出现的次数，第二个数字表示 1 出现的次数，以此类推。\n   > \n   > 数据范围\n   > \n   > 0<a,b<1000000000<a,b<1000000000<a,b<1000000000<a,b<1000000000<a,b<1000000000<a,b<100000000\n   > \n   > 输入样例：\n   > \n   > 1 10\n   > 44 497\n   > 346 542\n   > 1199 1748\n   > 1496 1403\n   > 1004 503\n   > 1714 190\n   > 1317 854\n   > 1976 494\n   > 1001 1960\n   > 0 0\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > \n   > \n   > 输出样例：\n   > \n   > 1 2 1 1 1 1 1 1 1 1\n   > 85 185 185 185 190 96 96 96 95 93\n   > 40 40 40 93 136 82 40 40 40 40\n   > 115 666 215 215 214 205 205 154 105 106\n   > 16 113 19 20 114 20 20 19 19 16\n   > 107 105 100 101 101 197 200 200 200 200\n   > 413 1133 503 503 503 502 502 417 402 412\n   > 196 512 186 104 87 93 97 97 142 196\n   > 398 1375 398 398 405 499 499 495 488 471\n   > 294 1256 296 296 296 296 287 286 286 247\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n\n * 解题思路\n   \n   \n   \n   我们需要预处理fff数组，那么我们可以用f[i,j,u]f[i,j,u]f[i,j,u]表示iii位，最高位为jjj的数拥有uuu的个数。那么如果jjj不等于uuu时，则f[i][j][u]+=f[i−1][k][u],0≤k≤9f[i][j][u]+=f[i-1][k][u],0\\leq k \\leq 9f[i][j][u]+=f[i−1][k][u],0≤k≤9。这个应该不难理解，因为这个状态就是由之前的状态得到的。 而当jjj等于uuu时，那么同样也可以由之前的999个状态得到。为f[i][j][u]+=f[i−1][k][u],0≤k≤9f[i][j][u]+=f[i-1][k][u],0\\leq k \\leq 9f[i][j][u]+=f[i−1][k][u],0≤k≤9。记住，我们是还没有计算最高位的uuu个数的，因为最高位本身就为uuu，也是一种可能，所以我们需要加上。那么总共有10i−110^{i-1}10i−1多的数，所以增加的u的数量为10i−110^{i-1}10i−1。初始状态就是f[1][i][i]=1f[1][i][i]=1f[1][i][i]=1，到这，我们的fff数组就初始化完了，那么接下来。就是拆位分支的数位DPDPDP套路讨论了，这里不在叙述，代码附详细注释。\n\n * 代码\n\n/**\n  *@filename:计数问题\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 13:12\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 100000 + 5;\nconst int mod = 1e9+7;\n\nint l,r;\nint f[11][10][10];//预处理f数组。其中f[i][j][u]表示i位最高位为j的数拥有u的个数。\nvoid init(){\n    for(int i=0;i<10;i++)f[1][i][i]=1;\n    for(int i=2;i<11;i++){\n        for(int j=0;j<10;j++){\n            for(int u=0;u<10;u++){\n                //判断j是否等于u。\n                if(j==u)f[i][j][u]+=pow(10,i-1);\n                for(int k=0;k<10;k++){\n                    f[i][j][u]+=f[i-1][k][u];\n                }\n            }\n        }\n    }\n}\nll dp(int n,int u){\n    //1~n,求x的出现次数。\n    if(!n)return u?0:1;//特判n是否为0.根据u的值确定返回值。\n    vector<int> nums;//存储分割后的位数。\n    while(n)nums.push_back(n%10),n/=10;\n    int last=0;//last记录前面u出现的次数。\n    ll ans=0;//答案。\n    for(int i=nums.size()-1;i>=0;i--){\n        int x=nums[i];\n        //左边分支，0~x。\n        for(int j=(i==nums.size()-1);j<x;j++){\n            //由于此题不能有前导0.\n            ans+=f[i+1][j][u];//注意这里i需要+1，因为我们i下标从0开始。而位数从1开始。\n        }\n        //走左边分支，那么我们需要加上前面的个数。注意这里需要乘上x，因为左边分支有x中选择。\n        ans+=x*last*pow(10,i);\n        if(x==u)last++;//记录last。\n        if(!i)ans+=last;//加上这个数本身含有的。\n    }\n    //由于我们前面都是枚举n位数的，我们还需要统计所有0~n-1位数的方案数量。\n    //例如000011是不合法的，但11是合法的。\n    //这一步确实很容易忽略，没办法，数位DP就是这么难。\n    for(int i=1;i<nums.size();i++){\n        for(int j=(i!=1);j<=9;j++){\n            ans+=f[i][j][u];\n        }\n    }\n    return ans;\n}\nvoid solve(){\n}\nint main(){\n    init();\n    while(cin>>l>>r&&(l||r)){\n        if(l>r)swap(l,r);\n        for(int i=0;i<=9;i++){\n            cout<<dp(r,i)-dp(l-1,i);\n            i==9?cout<<endl:cout<<" ";\n        }\n    }\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n\n# 3.3 数字游戏\n\n * 题面\n   \n   > 科协里最近很流行数字游戏。\n   > \n   > 某人命名了一种不降数，这种数字必须满足从左到右各位数字呈非下降关系，如 123，446。\n   > \n   > 现在大家决定玩一个游戏，指定一个整数闭区间 [a,b]，问这个区间内有多少个不降数。\n   > \n   > 输入格式 输入包含多组测试数据。\n   > \n   > 每组数据占一行，包含两个整数 a 和 b。\n   > \n   > 输出格式 每行给出一组测试数据的答案，即 [a,b] 之间有多少不降数。\n   > \n   > 数据范围 1≤a≤b≤231−11≤ a ≤ b ≤2^{31}−11≤a≤b≤231−1\n   > \n   > 样例输入 1 9 1 19 样例输出 9 18\n\n * 解题思路\n   \n   同样的套路， 先预处理fff数组，我们用f[i][j]f[i][j]f[i][j]表示iii位数，且最高位为jjj的不降数方案数。那么我们来列写一下状态转移方程，对于f[i][j]f[i][j]f[i][j]，要满足不降数的要求，则f[i−1][k]f[i-1][k]f[i−1][k]，kkk需满足j≤k≤9j \\leq k \\leq 9j≤k≤9，那么自然f[i][j]=∑k=j9f[i−1][k]f[i][j]=\\sum_{k=j}^9 f[i-1][k]f[i][j]=∑k=j9 f[i−1][k]。而初始状态自然是f[1][j]=1f[1][j]=1f[1][j]=1。预处理完之后，我们就好做了，直接按数位DPDPDP的思想处理即可。代码附详细注释。\n\n * 代码\n\n/**\n  *@filename:数字游戏\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 14:57\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 100000 + 5;\nconst int mod = 1e9+7;\n\nint l,r;\nint f[11][11];//预处理f数组。其中f[i][j]表示i位数，且最高位为j的不降数方案数。\nvoid init(){\n    for(int i=1;i<10;i++)f[1][i]=1;\n    for(int i=2;i<11;i++){\n        for(int j=0;j<10;j++){\n            for(int k=j;k<10;k++){\n                f[i][j]+=f[i-1][k];\n            }\n        }\n    }\n}\nint dp(int n){\n    //1~n，这里我们需要特判n=0。\n    if(!n)return 0;\n    vector<int> nums;//存储分割位数。\n    while(n)nums.push_back(n%10),n/=10;\n    int last=0;//last存储上一位的最大值。\n    int ans=0;//答案。\n    for(int i=nums.size()-1;i>=0;i--){\n        int x=nums[i];\n        //走左边的分支。因为要保持不降序，所以我们j>=last。\n        for(int j=last;j<x;j++){\n            ans+=f[i+1][j];//注意是i+1位。\n        }\n        if(last>x)break;//说明上一位比x大，不能构成降序了，直接退出。\n        last=x;//走右分支了，更新last。\n        if(!i)ans++;//全部枚举完了，自身也同样构成了一种方案。\n    }\n    return ans;\n}\nint main(){\n    init();\n    while(cin>>l>>r){\n        cout<<dp(r)-dp(l-1)<<endl;\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n# 3.4 windy数\n\n * 题面\n   \n   > windy 定义了一种 windy 数。\n   > \n   > 不含前导零且相邻两个数字之差至少为 2 的正整数被称为 windy 数。windy 想知道，在 a 和 b 之间，包括 a 和 b ，总共有多少个 windy 数？\n   > \n   > 输入格式\n   > \n   > 输入只有一行两个整数，分别表示 a 和 b。\n   > \n   > 输出格式\n   > \n   > 输出一行一个整数表示答案。\n   > \n   > 输入输出样例\n   > \n   > 输入 #1\n   > \n   > 1 10\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 输出 #1\n   > \n   > 9\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 输入 #2\n   > \n   > 25 50\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 输出 #2\n   > \n   > 20\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 说明/提示\n   > \n   > 数据规模与约定\n   > \n   > 对于全部的测试点，保证 1≤a≤b≤2×1091 \\leq a \\leq b \\leq 2 \\times 10^91≤a≤b≤2×109。\n\n * 解题思路\n   \n   同样，我们先进行预处理fff数组，其中f[i][j]f[i][j]f[i][j]表示iii位，其中最高位为jjj的方案数。那么根据题意，状态转移方程即为f[i][j]=∑f[i−1][k]f[i][j]=\\sum_{}f[i-1][k]f[i][j]=∑ f[i−1][k]，其中0≤k≤9 and abs(k−j)>=20 \\leq k \\leq 9 \\space and \\space abs(k-j)>=20≤k≤9 and abs(k−j)>=2。而初始状态即为dp[1][i]=1dp[1][i]=1dp[1][i]=1。预处理完之后就好处理了，这里不再提供思路，请大家自己画出树结构并完成此题。\n\n * 代码\n\n/**\n  *@filename:windy数\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 15:43\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 100000 + 5;\nconst int mod = 1e9+7;\n\nint l,r;\nint f[11][10];//f数组。其中f[i][j]表示i位，其中最高位为j的方案数。\nvoid init(){\n    for(int i=0;i<10;i++)f[1][i]=1;\n    for(int i=2;i<11;i++){\n        for(int j=0;j<10;j++){\n            for(int k=0;k<10;k++){\n                if(abs(k-j)>=2){\n                    f[i][j]+=f[i-1][k];\n                }\n            }\n        }\n    }\n}\nint dp(int n){\n    if(!n){\n        //特判n为0的情况，避免对之后操作造成影响。\n        return 0;\n    }\n    vector<int> nums;//存储分割位数。\n    int last=-2;//存储上一位的值。这里初值为-2,是因为我们需要确定1可以。\n    int ans=0;//答案。\n    while(n)nums.push_back(n%10),n/=10;\n    for(int i=nums.size()-1;i>=0;i--){\n        int x=nums[i];\n        //左分支。\n        for(int j=(i==nums.size()-1);j<x;j++){\n            if(abs(j-last)>=2){\n                //说明符合要求。\n                ans+=f[i+1][j];\n            }\n        }\n        if(abs(x-last)<2)break;//不满足要去。\n        last=x;\n        if(!i)ans++;//枚举到最后一位，自身也形成了一种方案。\n    }\n    //特殊枚举有前导0的数。\n    for(int i=1;i<nums.size();i++){\n        for(int j=1;j<=9;j++){\n            ans+=f[i][j];\n        }\n    }\n    return ans;\n}\nvoid solve(){\n}\nint main(){\n    init();\n    cin>>l>>r;\n    cout<<dp(r)-dp(l-1)<<endl;\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n\n# 3.5 数字游戏Ⅱ\n\n * 题面\n   \n   > 由于科协里最近真的很流行数字游戏。\n   > \n   > 某人又命名了一种取模数，这种数字必须满足各位数字之和modNmodNmodN为 0。\n   > \n   > 现在大家又要玩游戏了，指定一个整数闭区间 [a.b]，问这个区间内有多少个取模数。\n   > \n   > 数据范围 1≤a,b≤231−11≤a,b≤2^{31}−11≤a,b≤231−1, 1≤N<1001≤N<1001≤N<100 样例 输入 1 19 9\n   > \n   > 输出 2\n\n * 解题思路\n   \n   虽然这道题看起来很复杂，但是本质还是还是数位DP的套路，只不过现在性质是满足各位数字之和modNmod NmodN为0。那么此题实际上困难点在于预处理，我们发现预处理这其实就是一个dpdpdp，我们用闫式DPDPDP分析法分析如下：\n   \n   我们得到这个fff数组有什么用呢？我们发现，如果我现在已知前面的位数相加为lastlastlast，在左分支处，由于后面的数可以随便枚举，所以我们利用这个性质直接累加f[i+1][j][mod(−last,p)]f[i+1][j][mod(-last,p)]f[i+1][j][mod(−last,p)]即可得到种类数。故此按照数位DPDPDP步骤易解。\n\n * 代码\n\n/**\n  *@filename:数字游戏Ⅱ\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 18:23\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 100000 + 5;\n\nint l,r,p;\nint f[12][12][110];//f[i][j][k]表示i位数，最高位是j，其模n的余数是k的方案数。\n//预处理也是一个dp过程。\nint mod(int x,int y){\n    //由于c++中的%负数会得到负数，所以我们需要做一个偏移。\n    return (x%y+y)%y;\n}\nvoid init(){\n    memset(f,0,sizeof(f));\n    //预处理f数组。\n    for(int i=0;i<10;i++)f[1][i][i%p]++;\n    for(int i=2;i<12;i++){\n        for(int j=0;j<10;j++){\n            for(int k=0;k<p;k++){\n                for(int x=0;x<10;x++){\n                    f[i][j][k]+=f[i-1][x][mod(k-j,p)];\n                }\n            }\n        }\n    }\n}\nint dp(int n){\n    if(!n)return 1;\n    vector<int> a;//存储切出来的位数。\n    while(n)a.push_back(n%10),n/=10;\n    int last=0;//last存储前面数字之和。\n    int ans=0;\n    for(int i=a.size()-1;i>=0;i--){\n        int x=a[i];\n        for(int j=0;j<x;j++){\n            //走左边分支。为了凑成模n余0，则接下来的所有位数相加+last模n为0，所以我们来个-last即可。\n            ans+=f[i+1][j][mod(-last,p)];\n        }\n        last+=x;\n        if(!i&&last%p==0)ans++;//判断本身是否符合条件。\n    }\n    return ans;\n}\nvoid solve(){\n}\nint main(){\n    while(cin>>l>>r>>p){\n        init();\n        cout<<dp(r)-dp(l-1)<<endl;\n    }\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# 3.6 不要62\n\n * 题面\n   \n   > 杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。 杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。 不吉利的数字为所有含有4或62的号码。例如： 62315 73418 88914 都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。 你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。\n   > \n   > Input\n   > \n   > 输入的都是整数对n、m（0<n≤m<1000000），如果遇到都是0的整数对，则输入结束。\n   > \n   > Output\n   > \n   > 对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。\n   > \n   > Sample Input\n   > \n   > 1 100\n   > 0 0\n   > \n   > \n   > 1\n   > 2\n   > \n   > 1\n   > 2\n   > \n   > \n   > Sample Output\n   > \n   > 80\n   > \n   > \n   > 1\n   > \n   > 1\n\n * 解题思路\n   \n   这道题相对来说比较简单，因为预处理这一部分我们很容易想到。用f[i][j]f[i][j]f[i][j]表示iii位数字且最高位为jjj的方案数。那么我们排除掉特殊情况进行状态转移即可。代码附详细注释。\n\n * 代码\n\n/**\n  *@filename:不要62\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 19:56\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 100000 + 5;\nconst int mod = 1e9+7;\n\nint l,r;\nint f[11][11];//f[i][j]表示i位数且最高位为j的方案数。\n//那么我们来对这个进行分析，对于f[i][j]这个状态，我们根据题意我们转移的f[i-1][k]必须满足k!=4,j!=4.\n//并且jk!=62.\nvoid init(){\n    for(int i=0;i<10;i++)f[1][i]=1;\n    //排除4的情况。\n    f[1][4]=0;\n    for(int i=2;i<11;i++){\n        for(int j=0;j<10;j++){\n            if(j==4)continue;\n            for(int k=0;k<10;k++){\n                if((j==6&&k==2)||k==4)continue;\n                f[i][j]+=f[i-1][k];\n            }\n        }\n    }\n}\nint dp(int n){\n    if(!n)return 1;\n    vector<int> a;//存储分割位数。\n    int ans=0,last=0;//last保存上一位的值。\n    while(n)a.push_back(n%10),n/=10;\n    for(int i=a.size()-1;i>=0;i--){\n        int x=a[i];\n        for(int j=0;j<x;j++){\n            //走左边分支，我们需要判断。\n            if(j==4||(j==2&&last==6))continue;\n            ans+=f[i+1][j];\n        }\n        if(x==4||(last==6&&x==2))break;\n        last=x;\n        if(!i)ans++;\n    }\n    return ans;\n}\nvoid solve(){\n}\nint main(){\n    init();\n    while(cin>>l>>r&&(l||r)){\n        cout<<dp(r)-dp(l-1)<<endl;\n        solve();\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n# 3.7 恨7不成妻\n\n由于此题太过变态，已单开一篇blog讲解： 点这里。\n\n\n# 4 数位DP总结\n\n做了这么多的题，我们发现数位DPDPDP确实是有套路的，难点就在于预处理，通常就是要用DPDPDP来预处理，这里推荐大家学一下闫式DPDPDP分析法。预处理完之后，就可以套路做题了。当然，学DPDPDP一定要多刷题，所以请各位一定要多多刷题哦！',normalizedContent:'# 1 数位dp介绍\n\n数位dp往往都是这样的题型，给定一个闭区间[l,r][l,r][l,r]，让你求这个区间中满足某种条件的数的总数。而这个区间可能很大，简单的暴力代码如下：\n\nint ans=0;\nfor(int i=l;i<=r;i++){\n    if(check(i))ans++;\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n我们发现，若区间长度超过1e81e81e8，我们暴力枚举就会超时了，而数位dpdpdp则可以解决这样的题型。数位dpdpdp实际上就是在数位上进行dpdpdp。\n\n\n# 2 数位dp解法\n\n数位dpdpdp就是换一种暴力枚举的方式，使得新的枚举方式符合dpdpdp的性质，然后预处理好即可。我们来看：我们可以用f(n)f(n)f(n)表示[0,n][0,n][0,n]的所有满足条件的个数，那么对于[l,r][l,r][l,r]我们就可以用[l,r]  ⟺  f(r)−f(l−1)[l,r]\\iff f(r)-f(l-1)[l,r]⟺f(r)−f(l−1)，相当于前缀和思想。那么也就是说我们只要求出f(n)f(n)f(n)即可。那么数位dpdpdp关键的思想就是从树的角度来考虑。将数拆分成位，从高位到低位开始枚举。我们可以视nnn为nnn位数，那么我们拆分n:an、an−1...a1n:a_{n}、a_{n-1}...a_1n:an 、an−1 ...a1 。那么我们就可以开始分解建树，如下。之后我们就可以预处理再求解f(n)f(n)f(n)了，个人认为求解f(n)f(n)f(n)是最难的一步。\n\n\n\n听完是不是有点绕，我们可以来点题目练习一下，做完就会发现了数位dpdpdp的套路了。\n\n\n# 3 数位dp经典例题\n\n\n# 3.1 度的数量\n\n * 题面\n   \n   > 求给定区间$ [x,y]$ 中满足下列条件的整数个数：这个数恰好等于 kkk 个互不相等的 bbb 的整数次幂之和。例如，设 x=15,y=20,k=2,b=2x=15,y=20,k=2,b=2x=15,y=20,k=2,b=2，则有且仅有下列三个数满足题意： 17=24+2017=2^4+2^017=24+20 18=24+2118=2^4+2^118=24+21 20=24+2220=2^4+2^220=24+22 输入格式 第一行包含两个整数 x 和 y，接下来两行包含整数 kkk 和 bbb。 输出格式 只包含一个整数，表示满足条件的数的个数。 数据范围 1≤x≤y≤231−1,1≤x≤y≤2^{31}−1,1≤x≤y≤231−1, 1≤k≤20,1≤k≤20,1≤k≤20, 2≤b≤102≤b≤102≤b≤10 输入样例： 15 20 2 2 输出样例： 3\n\n * 解题思路\n   \n   此题实际上就是将十进制数转化为bbb进制数，判断位数上的值是否为111。那么我们可以视nnn为nnn位数，那么我们拆分n:an、an−1...a1n:a_{n}、a_{n-1}...a_1n:an 、an−1 ...a1 。从树的角度考虑：我们设n=76543210,b=10n=76543210,b=10n=76543210,b=10，那么我们从高位往最低位开始枚举如下；枚举ana_nan 时，我们有两种选择：\n   \n   1. 走右边分支，那么我们填7(an)7(a_n)7(an )，而题目要求每一位只能填111或者000,而an>1a_n>1an >1，所以不是合法方案，我们直接剔除。\n   2. 走左边分支，那么我们可以填000~666，即0−an−10-{a_n}-10−an −1，那么由于每一位只能填111或者000，所以我们累加这两种选择的方案。\n   \n   记住，走到了左边分支是可以直接累加的。\n   \n   所以我们实际上还是要做一个预处理的，我们用f[i][j]f[i][j]f[i][j]表示还剩下iii位没有填，且需要填写jjj个111的方案数。那么在(i,j)(i,j)(i,j)这个状态，我们可以选择填111，那么接下来的状态就是f[i−1][j−1]f[i-1][j-1]f[i−1][j−1]，而如果填000，那么接下来的状态就是f[i−1][j]f[i-1][j]f[i−1][j]，那么状态转移方程就是f[i][j]=f[i−1][j]+f[i][j−1]f[i][j]=f[i-1][j]+f[i][j-1]f[i][j]=f[i−1][j]+f[i][j−1]。而初始状态即是当j=0j=0j=0时，f[i][0]=1f[i][0]=1f[i][0]=1。这样我们就可以预处理fff数组了。\n   \n   处理完之后我们就可以直接模拟做了。\n\n * 代码\n\n/**\n  *@filename:度的数量\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 11:23\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 100000 + 5;\nconst int mod = 1e9+7;\n\nint l,r,k,b;\nint f[35][35];\n//首先我们先预处理f数组。其中f[i][j]表示剩下还有i个没填，需要填写j个1的方案数。\nvoid init(){\n    for(int i=0;i<35;i++){\n        for(int j=0;j<=i;j++){\n            if(!j)f[i][j]=1;\n            else{\n                f[i][j]=f[i-1][j]+f[i-1][j-1];\n            }\n        }\n    }\n}\nint dp(int n){\n    //求解f(n)。我们需要避免n为0的情况，这里需要特判。\n    if(!n)return 0;\n    vector<int> nums;//将n分割，存储位数。\n    while(n){\n        nums.push_back(n%b);\n        n/=b;\n    }\n    int ans=0;//答案。\n    int last=0;//前面的信息，这里代表的是前面分支选取了多少个1.\n    for(int i=nums.size()-1;i>=0;i--){\n        int x=nums[i];\n        if(x){\n            //说明x>0，我们可以选择左边分支填0.\n            ans+=f[i][k-last];\n            if(x>1){\n                //当x>1我们才可以枚举左边分支填1.\n                if(k-last-1>=0){\n                    //如果还可以填1的话。\n                    ans+=f[i][k-last-1];\n                }\n                break;//因为右边分支只能为0或1，所以不符合条件。break。\n            }\n            else{\n                //当x=1就可以进入右边的分支继续讨论。\n                last++;\n                if(last>k)break;\n            }\n        }\n        //考虑到最后一位，如果符合条件那么末位填0也算一种方案。\n        if(!i&&last==k)ans++;\n    }\n    return ans;\n}\nvoid solve(){\n}\nint main(){\n    cin>>l>>r>>k>>b;\n    init();\n    cout<<dp(r)-dp(l-1)<<endl;\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n\n# 3.2 计数问题\n\n * 题面\n   \n   > 给定两个整数 a 和 b，求 a 和 b 之间的所有数字中 0∼90∼9 的出现次数。\n   > \n   > 例如，a=1024，b=1032a=1024，b=1032a=1024，b=1032，则 a 和 b 之间共有 99 个数如下：\n   > \n   > 1024 1025 1026 1027 1028 1029 1030 1031 1032\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 其中 0 出现 10次，1 出现 10 次，2 出现 7 次，3 出现 3 次等等…\n   > \n   > 输入格式\n   > \n   > 输入包含多组测试数据。\n   > \n   > 每组测试数据占一行，包含两个整数 a 和 b。\n   > \n   > 当读入一行为 0 0 时，表示输入终止，且该行不作处理。\n   > \n   > 输出格式\n   > \n   > 每组数据输出一个结果，每个结果占一行。\n   > \n   > 每个结果包含十个用空格隔开的数字，第一个数字表示 0 出现的次数，第二个数字表示 1 出现的次数，以此类推。\n   > \n   > 数据范围\n   > \n   > 0<a,b<1000000000<a,b<1000000000<a,b<1000000000<a,b<1000000000<a,b<1000000000<a,b<100000000\n   > \n   > 输入样例：\n   > \n   > 1 10\n   > 44 497\n   > 346 542\n   > 1199 1748\n   > 1496 1403\n   > 1004 503\n   > 1714 190\n   > 1317 854\n   > 1976 494\n   > 1001 1960\n   > 0 0\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > \n   > \n   > 输出样例：\n   > \n   > 1 2 1 1 1 1 1 1 1 1\n   > 85 185 185 185 190 96 96 96 95 93\n   > 40 40 40 93 136 82 40 40 40 40\n   > 115 666 215 215 214 205 205 154 105 106\n   > 16 113 19 20 114 20 20 19 19 16\n   > 107 105 100 101 101 197 200 200 200 200\n   > 413 1133 503 503 503 502 502 417 402 412\n   > 196 512 186 104 87 93 97 97 142 196\n   > 398 1375 398 398 405 499 499 495 488 471\n   > 294 1256 296 296 296 296 287 286 286 247\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n\n * 解题思路\n   \n   \n   \n   我们需要预处理fff数组，那么我们可以用f[i,j,u]f[i,j,u]f[i,j,u]表示iii位，最高位为jjj的数拥有uuu的个数。那么如果jjj不等于uuu时，则f[i][j][u]+=f[i−1][k][u],0≤k≤9f[i][j][u]+=f[i-1][k][u],0\\leq k \\leq 9f[i][j][u]+=f[i−1][k][u],0≤k≤9。这个应该不难理解，因为这个状态就是由之前的状态得到的。 而当jjj等于uuu时，那么同样也可以由之前的999个状态得到。为f[i][j][u]+=f[i−1][k][u],0≤k≤9f[i][j][u]+=f[i-1][k][u],0\\leq k \\leq 9f[i][j][u]+=f[i−1][k][u],0≤k≤9。记住，我们是还没有计算最高位的uuu个数的，因为最高位本身就为uuu，也是一种可能，所以我们需要加上。那么总共有10i−110^{i-1}10i−1多的数，所以增加的u的数量为10i−110^{i-1}10i−1。初始状态就是f[1][i][i]=1f[1][i][i]=1f[1][i][i]=1，到这，我们的fff数组就初始化完了，那么接下来。就是拆位分支的数位dpdpdp套路讨论了，这里不在叙述，代码附详细注释。\n\n * 代码\n\n/**\n  *@filename:计数问题\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 13:12\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 100000 + 5;\nconst int mod = 1e9+7;\n\nint l,r;\nint f[11][10][10];//预处理f数组。其中f[i][j][u]表示i位最高位为j的数拥有u的个数。\nvoid init(){\n    for(int i=0;i<10;i++)f[1][i][i]=1;\n    for(int i=2;i<11;i++){\n        for(int j=0;j<10;j++){\n            for(int u=0;u<10;u++){\n                //判断j是否等于u。\n                if(j==u)f[i][j][u]+=pow(10,i-1);\n                for(int k=0;k<10;k++){\n                    f[i][j][u]+=f[i-1][k][u];\n                }\n            }\n        }\n    }\n}\nll dp(int n,int u){\n    //1~n,求x的出现次数。\n    if(!n)return u?0:1;//特判n是否为0.根据u的值确定返回值。\n    vector<int> nums;//存储分割后的位数。\n    while(n)nums.push_back(n%10),n/=10;\n    int last=0;//last记录前面u出现的次数。\n    ll ans=0;//答案。\n    for(int i=nums.size()-1;i>=0;i--){\n        int x=nums[i];\n        //左边分支，0~x。\n        for(int j=(i==nums.size()-1);j<x;j++){\n            //由于此题不能有前导0.\n            ans+=f[i+1][j][u];//注意这里i需要+1，因为我们i下标从0开始。而位数从1开始。\n        }\n        //走左边分支，那么我们需要加上前面的个数。注意这里需要乘上x，因为左边分支有x中选择。\n        ans+=x*last*pow(10,i);\n        if(x==u)last++;//记录last。\n        if(!i)ans+=last;//加上这个数本身含有的。\n    }\n    //由于我们前面都是枚举n位数的，我们还需要统计所有0~n-1位数的方案数量。\n    //例如000011是不合法的，但11是合法的。\n    //这一步确实很容易忽略，没办法，数位dp就是这么难。\n    for(int i=1;i<nums.size();i++){\n        for(int j=(i!=1);j<=9;j++){\n            ans+=f[i][j][u];\n        }\n    }\n    return ans;\n}\nvoid solve(){\n}\nint main(){\n    init();\n    while(cin>>l>>r&&(l||r)){\n        if(l>r)swap(l,r);\n        for(int i=0;i<=9;i++){\n            cout<<dp(r,i)-dp(l-1,i);\n            i==9?cout<<endl:cout<<" ";\n        }\n    }\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n\n# 3.3 数字游戏\n\n * 题面\n   \n   > 科协里最近很流行数字游戏。\n   > \n   > 某人命名了一种不降数，这种数字必须满足从左到右各位数字呈非下降关系，如 123，446。\n   > \n   > 现在大家决定玩一个游戏，指定一个整数闭区间 [a,b]，问这个区间内有多少个不降数。\n   > \n   > 输入格式 输入包含多组测试数据。\n   > \n   > 每组数据占一行，包含两个整数 a 和 b。\n   > \n   > 输出格式 每行给出一组测试数据的答案，即 [a,b] 之间有多少不降数。\n   > \n   > 数据范围 1≤a≤b≤231−11≤ a ≤ b ≤2^{31}−11≤a≤b≤231−1\n   > \n   > 样例输入 1 9 1 19 样例输出 9 18\n\n * 解题思路\n   \n   同样的套路， 先预处理fff数组，我们用f[i][j]f[i][j]f[i][j]表示iii位数，且最高位为jjj的不降数方案数。那么我们来列写一下状态转移方程，对于f[i][j]f[i][j]f[i][j]，要满足不降数的要求，则f[i−1][k]f[i-1][k]f[i−1][k]，kkk需满足j≤k≤9j \\leq k \\leq 9j≤k≤9，那么自然f[i][j]=∑k=j9f[i−1][k]f[i][j]=\\sum_{k=j}^9 f[i-1][k]f[i][j]=∑k=j9 f[i−1][k]。而初始状态自然是f[1][j]=1f[1][j]=1f[1][j]=1。预处理完之后，我们就好做了，直接按数位dpdpdp的思想处理即可。代码附详细注释。\n\n * 代码\n\n/**\n  *@filename:数字游戏\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 14:57\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 100000 + 5;\nconst int mod = 1e9+7;\n\nint l,r;\nint f[11][11];//预处理f数组。其中f[i][j]表示i位数，且最高位为j的不降数方案数。\nvoid init(){\n    for(int i=1;i<10;i++)f[1][i]=1;\n    for(int i=2;i<11;i++){\n        for(int j=0;j<10;j++){\n            for(int k=j;k<10;k++){\n                f[i][j]+=f[i-1][k];\n            }\n        }\n    }\n}\nint dp(int n){\n    //1~n，这里我们需要特判n=0。\n    if(!n)return 0;\n    vector<int> nums;//存储分割位数。\n    while(n)nums.push_back(n%10),n/=10;\n    int last=0;//last存储上一位的最大值。\n    int ans=0;//答案。\n    for(int i=nums.size()-1;i>=0;i--){\n        int x=nums[i];\n        //走左边的分支。因为要保持不降序，所以我们j>=last。\n        for(int j=last;j<x;j++){\n            ans+=f[i+1][j];//注意是i+1位。\n        }\n        if(last>x)break;//说明上一位比x大，不能构成降序了，直接退出。\n        last=x;//走右分支了，更新last。\n        if(!i)ans++;//全部枚举完了，自身也同样构成了一种方案。\n    }\n    return ans;\n}\nint main(){\n    init();\n    while(cin>>l>>r){\n        cout<<dp(r)-dp(l-1)<<endl;\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n# 3.4 windy数\n\n * 题面\n   \n   > windy 定义了一种 windy 数。\n   > \n   > 不含前导零且相邻两个数字之差至少为 2 的正整数被称为 windy 数。windy 想知道，在 a 和 b 之间，包括 a 和 b ，总共有多少个 windy 数？\n   > \n   > 输入格式\n   > \n   > 输入只有一行两个整数，分别表示 a 和 b。\n   > \n   > 输出格式\n   > \n   > 输出一行一个整数表示答案。\n   > \n   > 输入输出样例\n   > \n   > 输入 #1\n   > \n   > 1 10\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 输出 #1\n   > \n   > 9\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 输入 #2\n   > \n   > 25 50\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 输出 #2\n   > \n   > 20\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 说明/提示\n   > \n   > 数据规模与约定\n   > \n   > 对于全部的测试点，保证 1≤a≤b≤2×1091 \\leq a \\leq b \\leq 2 \\times 10^91≤a≤b≤2×109。\n\n * 解题思路\n   \n   同样，我们先进行预处理fff数组，其中f[i][j]f[i][j]f[i][j]表示iii位，其中最高位为jjj的方案数。那么根据题意，状态转移方程即为f[i][j]=∑f[i−1][k]f[i][j]=\\sum_{}f[i-1][k]f[i][j]=∑ f[i−1][k]，其中0≤k≤9 and abs(k−j)>=20 \\leq k \\leq 9 \\space and \\space abs(k-j)>=20≤k≤9 and abs(k−j)>=2。而初始状态即为dp[1][i]=1dp[1][i]=1dp[1][i]=1。预处理完之后就好处理了，这里不再提供思路，请大家自己画出树结构并完成此题。\n\n * 代码\n\n/**\n  *@filename:windy数\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 15:43\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 100000 + 5;\nconst int mod = 1e9+7;\n\nint l,r;\nint f[11][10];//f数组。其中f[i][j]表示i位，其中最高位为j的方案数。\nvoid init(){\n    for(int i=0;i<10;i++)f[1][i]=1;\n    for(int i=2;i<11;i++){\n        for(int j=0;j<10;j++){\n            for(int k=0;k<10;k++){\n                if(abs(k-j)>=2){\n                    f[i][j]+=f[i-1][k];\n                }\n            }\n        }\n    }\n}\nint dp(int n){\n    if(!n){\n        //特判n为0的情况，避免对之后操作造成影响。\n        return 0;\n    }\n    vector<int> nums;//存储分割位数。\n    int last=-2;//存储上一位的值。这里初值为-2,是因为我们需要确定1可以。\n    int ans=0;//答案。\n    while(n)nums.push_back(n%10),n/=10;\n    for(int i=nums.size()-1;i>=0;i--){\n        int x=nums[i];\n        //左分支。\n        for(int j=(i==nums.size()-1);j<x;j++){\n            if(abs(j-last)>=2){\n                //说明符合要求。\n                ans+=f[i+1][j];\n            }\n        }\n        if(abs(x-last)<2)break;//不满足要去。\n        last=x;\n        if(!i)ans++;//枚举到最后一位，自身也形成了一种方案。\n    }\n    //特殊枚举有前导0的数。\n    for(int i=1;i<nums.size();i++){\n        for(int j=1;j<=9;j++){\n            ans+=f[i][j];\n        }\n    }\n    return ans;\n}\nvoid solve(){\n}\nint main(){\n    init();\n    cin>>l>>r;\n    cout<<dp(r)-dp(l-1)<<endl;\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n\n# 3.5 数字游戏ⅱ\n\n * 题面\n   \n   > 由于科协里最近真的很流行数字游戏。\n   > \n   > 某人又命名了一种取模数，这种数字必须满足各位数字之和modnmodnmodn为 0。\n   > \n   > 现在大家又要玩游戏了，指定一个整数闭区间 [a.b]，问这个区间内有多少个取模数。\n   > \n   > 数据范围 1≤a,b≤231−11≤a,b≤2^{31}−11≤a,b≤231−1, 1≤n<1001≤n<1001≤n<100 样例 输入 1 19 9\n   > \n   > 输出 2\n\n * 解题思路\n   \n   虽然这道题看起来很复杂，但是本质还是还是数位dp的套路，只不过现在性质是满足各位数字之和modnmod nmodn为0。那么此题实际上困难点在于预处理，我们发现预处理这其实就是一个dpdpdp，我们用闫式dpdpdp分析法分析如下：\n   \n   我们得到这个fff数组有什么用呢？我们发现，如果我现在已知前面的位数相加为lastlastlast，在左分支处，由于后面的数可以随便枚举，所以我们利用这个性质直接累加f[i+1][j][mod(−last,p)]f[i+1][j][mod(-last,p)]f[i+1][j][mod(−last,p)]即可得到种类数。故此按照数位dpdpdp步骤易解。\n\n * 代码\n\n/**\n  *@filename:数字游戏ⅱ\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 18:23\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 100000 + 5;\n\nint l,r,p;\nint f[12][12][110];//f[i][j][k]表示i位数，最高位是j，其模n的余数是k的方案数。\n//预处理也是一个dp过程。\nint mod(int x,int y){\n    //由于c++中的%负数会得到负数，所以我们需要做一个偏移。\n    return (x%y+y)%y;\n}\nvoid init(){\n    memset(f,0,sizeof(f));\n    //预处理f数组。\n    for(int i=0;i<10;i++)f[1][i][i%p]++;\n    for(int i=2;i<12;i++){\n        for(int j=0;j<10;j++){\n            for(int k=0;k<p;k++){\n                for(int x=0;x<10;x++){\n                    f[i][j][k]+=f[i-1][x][mod(k-j,p)];\n                }\n            }\n        }\n    }\n}\nint dp(int n){\n    if(!n)return 1;\n    vector<int> a;//存储切出来的位数。\n    while(n)a.push_back(n%10),n/=10;\n    int last=0;//last存储前面数字之和。\n    int ans=0;\n    for(int i=a.size()-1;i>=0;i--){\n        int x=a[i];\n        for(int j=0;j<x;j++){\n            //走左边分支。为了凑成模n余0，则接下来的所有位数相加+last模n为0，所以我们来个-last即可。\n            ans+=f[i+1][j][mod(-last,p)];\n        }\n        last+=x;\n        if(!i&&last%p==0)ans++;//判断本身是否符合条件。\n    }\n    return ans;\n}\nvoid solve(){\n}\nint main(){\n    while(cin>>l>>r>>p){\n        init();\n        cout<<dp(r)-dp(l-1)<<endl;\n    }\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# 3.6 不要62\n\n * 题面\n   \n   > 杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。 杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。 不吉利的数字为所有含有4或62的号码。例如： 62315 73418 88914 都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。 你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。\n   > \n   > input\n   > \n   > 输入的都是整数对n、m（0<n≤m<1000000），如果遇到都是0的整数对，则输入结束。\n   > \n   > output\n   > \n   > 对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。\n   > \n   > sample input\n   > \n   > 1 100\n   > 0 0\n   > \n   > \n   > 1\n   > 2\n   > \n   > 1\n   > 2\n   > \n   > \n   > sample output\n   > \n   > 80\n   > \n   > \n   > 1\n   > \n   > 1\n\n * 解题思路\n   \n   这道题相对来说比较简单，因为预处理这一部分我们很容易想到。用f[i][j]f[i][j]f[i][j]表示iii位数字且最高位为jjj的方案数。那么我们排除掉特殊情况进行状态转移即可。代码附详细注释。\n\n * 代码\n\n/**\n  *@filename:不要62\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 19:56\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 100000 + 5;\nconst int mod = 1e9+7;\n\nint l,r;\nint f[11][11];//f[i][j]表示i位数且最高位为j的方案数。\n//那么我们来对这个进行分析，对于f[i][j]这个状态，我们根据题意我们转移的f[i-1][k]必须满足k!=4,j!=4.\n//并且jk!=62.\nvoid init(){\n    for(int i=0;i<10;i++)f[1][i]=1;\n    //排除4的情况。\n    f[1][4]=0;\n    for(int i=2;i<11;i++){\n        for(int j=0;j<10;j++){\n            if(j==4)continue;\n            for(int k=0;k<10;k++){\n                if((j==6&&k==2)||k==4)continue;\n                f[i][j]+=f[i-1][k];\n            }\n        }\n    }\n}\nint dp(int n){\n    if(!n)return 1;\n    vector<int> a;//存储分割位数。\n    int ans=0,last=0;//last保存上一位的值。\n    while(n)a.push_back(n%10),n/=10;\n    for(int i=a.size()-1;i>=0;i--){\n        int x=a[i];\n        for(int j=0;j<x;j++){\n            //走左边分支，我们需要判断。\n            if(j==4||(j==2&&last==6))continue;\n            ans+=f[i+1][j];\n        }\n        if(x==4||(last==6&&x==2))break;\n        last=x;\n        if(!i)ans++;\n    }\n    return ans;\n}\nvoid solve(){\n}\nint main(){\n    init();\n    while(cin>>l>>r&&(l||r)){\n        cout<<dp(r)-dp(l-1)<<endl;\n        solve();\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n# 3.7 恨7不成妻\n\n由于此题太过变态，已单开一篇blog讲解： 点这里。\n\n\n# 4 数位dp总结\n\n做了这么多的题，我们发现数位dpdpdp确实是有套路的，难点就在于预处理，通常就是要用dpdpdp来预处理，这里推荐大家学一下闫式dpdpdp分析法。预处理完之后，就可以套路做题了。当然，学dpdpdp一定要多刷题，所以请各位一定要多多刷题哦！',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"线段树入门",frontmatter:{title:"线段树入门",date:"2020-08-07T12:17:56.000Z",tags:["线段树"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/088910/",categories:["开发","数据结构与算法","数据结构"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/03.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/06.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8.html",relativePath:"01.开发/03.数据结构与算法/06.数据结构/01.线段树入门.md",key:"v-39ec134c",path:"/pages/088910/",headers:[{level:2,title:"1 什么是线段树？",slug:"_1-什么是线段树",normalizedTitle:"1 什么是线段树？",charIndex:244},{level:2,title:"2 线段树的基本内容",slug:"_2-线段树的基本内容",normalizedTitle:"2 线段树的基本内容",charIndex:1927},{level:2,title:"3 线段树的基本操作",slug:"_3-线段树的基本操作",normalizedTitle:"3 线段树的基本操作",charIndex:3400},{level:3,title:"3.1 点更新",slug:"_3-1-点更新",normalizedTitle:"3.1 点更新",charIndex:3440},{level:3,title:"3.2 区间查询",slug:"_3-2-区间查询",normalizedTitle:"3.2 区间查询",charIndex:3931}],headersStr:"1 什么是线段树？ 2 线段树的基本内容 3 线段树的基本操作 3.1 点更新 3.2 区间查询",content:'前言：理解线段树着实花了我很多时间，主要之前一直有个误区，就是对线段树中存储的信息，我认为只能是区间和，可万万没想到呀，它还可以是别的东西：区间最小值、区间最大值等等呀，我表示👤(已黑化)，好了，言归正传，博主是完全理解了线段树之后才有勇气写这篇文章的，所以我是根据一个完全初学者到理解线段树的过程来写下这篇文章的，不会像其他文章一下难以理解，当然，本文也只是我学习整理的，如果有错误的话，还请评论区留言或私信我，共同进步。\n\n线段树讲解共有两篇，这一篇为入门，另一篇为进阶。\n\n\n# 1 什么是线段树？\n\n * 线段树的基本概念\n   \n   在深入学习线段树之前，我们首先要了解线段树是什么？线段树本质也是一颗二叉搜索树，也被认为是区间树（即每个结点都有一段区间，我们也认为是线段）。那有小伙伴可能就要问了，什么是二叉搜索树？二叉搜索树顾名思义：前提是一颗二叉树，它的每个结点度都小于等于2，即每个结点最多有两个子树。其次就是搜索，这是关键，我们这个线段树在其中都有一个区间，那么搜索即是可以在这个区间上搜索你想要的值，这就是搜索，其中，每个结点存储的信息是由你来定的，如果你想求区间和，那么就可以存储区间和，如果你想求区间最大值，那么你可以存储区间最大值，只要可行，你都可以进行你想要的操作。\n   \n   ----------------------------------------\n\n * 线段树的注意事项\n   \n   1. 在给定了大小给定了叶子结点数目的时候这个线段树就已经确定了，我们不能进行添加和删除元素，不是说不能对已有叶子结点赋值，是不能对其进行扩大或者减小。因为在大多数情况中，对于线段树来说，区间本身都是固定的，不考虑新增和删除元素。所以用数组存储的话，直接用静态数组就好了，不用动态数组。\n   \n   2. 线段树的大小一定要开叶子结点数目（即原有点对点的数据数组大小）的四倍。例如叶子结点数目是maxn，那么我们通常会开线段树的大小为maxn<<2。因为线段树也是一颗完全二叉树，当最大的时候可能是满二叉树。我们来证明一下，我们这样想：最深一层的数目是n，则此线段树的高度为⌈\\lceil⌈log⁡2n⌉\\log_2n\\rceillog2 n⌉,我们可知⌈\\lceil⌈log⁡2n⌉\\log_2n\\rceillog2 n⌉ ≤\\leq≤ log2n+1log_2n+1log2 n+1。那么我们通过然后通过等比数列求和公式（a1(1−qx)1−q\\frac{a_1(1-q^x)}{1-q}1−qa1 (1−qx) ）求得二叉树的节点个数，具体公式为1∗(1−2x)1−2\\frac{1*(1-2^x)}{1-2}1−21∗(1−2x) ，（xxx为树的层数，为树的高度+1+1+1），化简可得2log2n+1+1−12^{log_2n+1+1}-12log2 n+1+1−1,整理之后即为4n4n4n（近似计算忽略掉-1)\n   \n   3. 我们进行乘除法运算的时候要使用位运算（<< >>一定要仔细理解这两个运算符），而避免使用基本的数学运算，因为我们会频繁使用结点坐标更新，用位运算会更快一点，而且还可以防WR。\n   \n   4. 在表示坐标的时候，若一个结点下标为i，那么它的父节点就是i>>1。如果这个结点是这个父节点的左孩子，那么右孩子下标就是i+1。如果这个结点是父节点的右孩子，那么左孩子的下标就是i-1。那个这个结点的左孩子下标就是i<<1，右孩子下标就是(i<<1)=1（==这里一定要使用括号改变运算符优先级，因为位运算的优先级属实低。==）\n   \n   5. 要根据你想解决的问题来设置结点的数据信息。区间求和和区间最值所进行的是不太一样的，所更改的信息也都要注意，但都是一个本质，就是从下往上更新，到达根节点就退出。\n   \n   6. 线段树不一定是满二叉树，也就是说线段树的叶子结点不一定是在最后一层。线段树也不一定是完全二叉树（切记！）。但我们可以把线段树看成是满二叉树，对于不存在的结点我们视为空就行。\n\n * 线段树能解决的问题\n   \n   线段树的适用范围很广，可以在线维护修改以及查询区间上的最值，求和。==使用一维线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN)==。线段树更可以扩充到二维线段树（矩阵树）和三维线段树（空间树），这里我们不作讲解。（其实博主也暂时不会😄）\n\n你问我线段树算什么东西？今天我就告诉你，单点、区间朴素查询处理做的我线段树能做！单点、区间朴素查询没有的速度我有！这就是线段树。（战术后仰）\n\n\n# 2 线段树的基本内容\n\n我们先看一颗线段树：\n\n\n\n不然发现线段树的特点，每个结点都有一个值和区间，每个结点的左右孩子都存储了父结点的一半的区间，且它们的序号是按照层次顺序编号的。在日常处理中，我们通常是使用结构体数组来作为线段树的存储结构，因为这样我们就可以利用下标的关系来找到父节点和孩子结点了。例如我们已知一个结点的下标为i，那么：\n\n * 对于父结点：i>>1（这个进行的操作其实就是i/2，前面提到，这样会快很多）\n   \n   具体证明也很简单，把线段树看成一个完全二叉树（空结点也当作使用）对于任意一个结点i来说，它所在此二叉树的log2ilog_2ilog2 i 层，则此层共有2log2(i)2^{log2(i)}2log2(i)个结点，同样对于k的左子树那层来说有2log2k+12^{log_2{k}+1}2log2 k+1个结点，则结点k和左子树间隔了2∗2log2(i)−i+2∗(i−2log2(k))2*2^{log_2(i)}-i + 2*(i-2^{log_2(k)})2∗2log2 (i)−i+2∗(i−2log2 (k))个结点，然后这就很简单就得到k+2∗2log2(k)−k+2∗(k−2log2(k))=2∗kk+2*2^{log_2(k)}-k + 2*(k-2^{log2(k)}) = 2*kk+2∗2log2 (k)−k+2∗(k−2log2(k))=2∗k的关系了吧，右子树也就等于左子树结点+1。\n\n * 对于左孩子结点：左孩子下标：i<<1（这些是同理的，即是由父结点推孩子结点。）\n\n * 对于右孩子结点：右孩子下标：i<<1|1\n\n了解了这些关系，我们是有能力去建立一颗线段树的，因为线段树也是树，所以我们自然可以利用递归的思想去建树，不会很难，我也写全了注释。\n\nconst int maxn = 1e5;//最大值。\nstruct Node{\n    int left;  //左端点\n    int right; //右端点\n    int value;//代表区间[left,right]的信息，可以是区间和，也可以是区间最值。\n}node[maxn<<2];//这里我们要开4倍大小，防止数据溢出\nint father[maxn];//存储原来数据在线段树中的下标，易于从下向上更新区间数据。例如father[i]表示原来的第i个数据在线段树中的下标，这些在线段树中都是叶子结点。\nvoid BuildTree(int i,int l,int r){\n    node[i].left=l;node[i].right=r;//存储各自结点的区间\n    node[i].value=0;                     //初始化为0.\n    if(l==r){                    //说明已经到了叶子结点。\n        father[l]=i;//存储下标。\n        return;\n    }\n    BuildTree(i<<1,l,(l+r)/2); //递归初始化左子树\n    BuildTree((i<<1)+1,(l+r)/2+1,r);//递归初始化右子树。\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n这样，我们的线段树就建好了。我们来看线段树有哪些基本操作吧。\n\n\n# 3 线段树的基本操作\n\n我们这里以结点的值value代表区间和来处理。\n\n\n# 3.1 点更新\n\n这很好办，有没有注意我们是使用了一个father数组，如果我在原数组中修改第i个元素的值，我们是直接可以node[father[i]].value=w，这就是我们使用father数组的好处，那你可能会问了，我们这样是不是要使用三个数组？大可不必，我们没必要给原有数据开一个数组存放，因为我们本身就已经把数据放在线段树中了，不管线段树中存放的是区间和还是区间最值，对于叶子结点来说，它就是本身。那么我们加入了点，自然也要更新整棵树，那有关这个叶子结点到根节点的路径自然全部都是要更新的，我们则是从下往上利用递归思想来更新的。\n\nvoid UpdateTree(int ri){\n    if(ri==1){\n        return;\n    }\n    int fi=ri>>1;//获得父结点下标。\n    node[fi].value=node[fi<<1].value+node[fi<<1|1].value;//两段区间总和。\n    UpdateTree(fi);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 3.2 区间查询\n\n我们有了线段树，可却不对它进行相关查询，那这颗线段树也只是精致的花瓶而已。我们最重要的就是进行区间查询，现在如果我想知道某个区间和的话，我们应该怎样来处理呢？我们知道根节点是存放了整个区间的信息，然后它的孩子结点则存放了它一半区间的信息，这样则显而易见，我们从根节点开始自上往下查询即可。我们本着下面的思想就一目了然了。\n\n1、如果这个区间被完全包括在目标区间里面，直接返回这个区间的值\n\n2、如果这个区间的左儿子和目标区间有交集，那么搜索左儿子\n\n3、如果这个区间的右儿子和目标区间有交集，那么搜索右儿子\n\nOK，整活。\n\n//区间查询，调用函数时为QueryTree(1,l,r)，即从根节点自上往下查询。\nint QueryTree(int i,int l,int r){\n    int sum=0;\n    if(l==node[i].left&&r==node[i].right){\n        //如果刚好就是这个区间，我们直接返回。\n        sum+=node[i].value;\n        return sum;\n    }\n    i=i<<1;\n    if(l<=node[i].right){\n        //说明部分包含左子树\n        if(r<=node[i].right){\n            //说明全包含在左子树。\n            sum+=QueryTree(i,l,r);\n        }\n        else{\n            sum+=QueryTree(i,l,node[i].right);\n        }\n    }\n    i+=1;\n    if(r>=node[i].left){\n        //说明部分包含右子树\n        if(l>=node[i].left){\n            //说明全包含在右子树。\n            sum+=QueryTree(i,l,r);\n        }\n        else{\n            sum+=QueryTree(i,node[i].left,r);\n        }\n    }\n    return sum; //返回求得的区间和。\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n区间查询不断二分，易知时间复杂度为O(log2nlog_2nlog2 n)。\n\n线段树的基本操作就是这些，当然，这只是入门，灵活使用线段树以及更深层次的利用线段树的道路还很长，我们一起加油！\n\n----------------------------------------\n\n主函数部分测试：\n\nint main(){\n    freopen("in.txt", "r", stdin);//提交的时候要注释掉\n    ios::sync_with_stdio(false);//打消iostream中输入输出缓存，节省时间。\n    cin.tie(0); cout.tie(0);//可以通过tie(0)（0表示NULL）来解除cin与cout的绑定，进一步加快执行效率。\n    int n,m,g;\n    while(cin>>n>>m){\n        BuildTree(1,1,n);\n        rep(i,1,n){\n            cin>>g;\n            node[father[i]].value=g;\n            UpdateTree(father[i]);\n        }\n        char ch;\n        int a,b;\n        while(m--){\n            cin>>ch>>a>>b;\n            if(ch==\'Q\'){\n                cout<<QueryTree(1,a,b)<<endl;;\n            }\n            else{\n                node[father[a]].value=b;\n                UpdateTree(father[a]);\n            }\n        }\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n测试数据：\n\n6 5 \n2 3 8 23 1 9\nQ 1 6\nS 2 3\nQ 1 6\nS 3 4\nQ 1 6\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n测试结果：',normalizedContent:'前言：理解线段树着实花了我很多时间，主要之前一直有个误区，就是对线段树中存储的信息，我认为只能是区间和，可万万没想到呀，它还可以是别的东西：区间最小值、区间最大值等等呀，我表示👤(已黑化)，好了，言归正传，博主是完全理解了线段树之后才有勇气写这篇文章的，所以我是根据一个完全初学者到理解线段树的过程来写下这篇文章的，不会像其他文章一下难以理解，当然，本文也只是我学习整理的，如果有错误的话，还请评论区留言或私信我，共同进步。\n\n线段树讲解共有两篇，这一篇为入门，另一篇为进阶。\n\n\n# 1 什么是线段树？\n\n * 线段树的基本概念\n   \n   在深入学习线段树之前，我们首先要了解线段树是什么？线段树本质也是一颗二叉搜索树，也被认为是区间树（即每个结点都有一段区间，我们也认为是线段）。那有小伙伴可能就要问了，什么是二叉搜索树？二叉搜索树顾名思义：前提是一颗二叉树，它的每个结点度都小于等于2，即每个结点最多有两个子树。其次就是搜索，这是关键，我们这个线段树在其中都有一个区间，那么搜索即是可以在这个区间上搜索你想要的值，这就是搜索，其中，每个结点存储的信息是由你来定的，如果你想求区间和，那么就可以存储区间和，如果你想求区间最大值，那么你可以存储区间最大值，只要可行，你都可以进行你想要的操作。\n   \n   ----------------------------------------\n\n * 线段树的注意事项\n   \n   1. 在给定了大小给定了叶子结点数目的时候这个线段树就已经确定了，我们不能进行添加和删除元素，不是说不能对已有叶子结点赋值，是不能对其进行扩大或者减小。因为在大多数情况中，对于线段树来说，区间本身都是固定的，不考虑新增和删除元素。所以用数组存储的话，直接用静态数组就好了，不用动态数组。\n   \n   2. 线段树的大小一定要开叶子结点数目（即原有点对点的数据数组大小）的四倍。例如叶子结点数目是maxn，那么我们通常会开线段树的大小为maxn<<2。因为线段树也是一颗完全二叉树，当最大的时候可能是满二叉树。我们来证明一下，我们这样想：最深一层的数目是n，则此线段树的高度为⌈\\lceil⌈log⁡2n⌉\\log_2n\\rceillog2 n⌉,我们可知⌈\\lceil⌈log⁡2n⌉\\log_2n\\rceillog2 n⌉ ≤\\leq≤ log2n+1log_2n+1log2 n+1。那么我们通过然后通过等比数列求和公式（a1(1−qx)1−q\\frac{a_1(1-q^x)}{1-q}1−qa1 (1−qx) ）求得二叉树的节点个数，具体公式为1∗(1−2x)1−2\\frac{1*(1-2^x)}{1-2}1−21∗(1−2x) ，（xxx为树的层数，为树的高度+1+1+1），化简可得2log2n+1+1−12^{log_2n+1+1}-12log2 n+1+1−1,整理之后即为4n4n4n（近似计算忽略掉-1)\n   \n   3. 我们进行乘除法运算的时候要使用位运算（<< >>一定要仔细理解这两个运算符），而避免使用基本的数学运算，因为我们会频繁使用结点坐标更新，用位运算会更快一点，而且还可以防wr。\n   \n   4. 在表示坐标的时候，若一个结点下标为i，那么它的父节点就是i>>1。如果这个结点是这个父节点的左孩子，那么右孩子下标就是i+1。如果这个结点是父节点的右孩子，那么左孩子的下标就是i-1。那个这个结点的左孩子下标就是i<<1，右孩子下标就是(i<<1)=1（==这里一定要使用括号改变运算符优先级，因为位运算的优先级属实低。==）\n   \n   5. 要根据你想解决的问题来设置结点的数据信息。区间求和和区间最值所进行的是不太一样的，所更改的信息也都要注意，但都是一个本质，就是从下往上更新，到达根节点就退出。\n   \n   6. 线段树不一定是满二叉树，也就是说线段树的叶子结点不一定是在最后一层。线段树也不一定是完全二叉树（切记！）。但我们可以把线段树看成是满二叉树，对于不存在的结点我们视为空就行。\n\n * 线段树能解决的问题\n   \n   线段树的适用范围很广，可以在线维护修改以及查询区间上的最值，求和。==使用一维线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为o(logn)==。线段树更可以扩充到二维线段树（矩阵树）和三维线段树（空间树），这里我们不作讲解。（其实博主也暂时不会😄）\n\n你问我线段树算什么东西？今天我就告诉你，单点、区间朴素查询处理做的我线段树能做！单点、区间朴素查询没有的速度我有！这就是线段树。（战术后仰）\n\n\n# 2 线段树的基本内容\n\n我们先看一颗线段树：\n\n\n\n不然发现线段树的特点，每个结点都有一个值和区间，每个结点的左右孩子都存储了父结点的一半的区间，且它们的序号是按照层次顺序编号的。在日常处理中，我们通常是使用结构体数组来作为线段树的存储结构，因为这样我们就可以利用下标的关系来找到父节点和孩子结点了。例如我们已知一个结点的下标为i，那么：\n\n * 对于父结点：i>>1（这个进行的操作其实就是i/2，前面提到，这样会快很多）\n   \n   具体证明也很简单，把线段树看成一个完全二叉树（空结点也当作使用）对于任意一个结点i来说，它所在此二叉树的log2ilog_2ilog2 i 层，则此层共有2log2(i)2^{log2(i)}2log2(i)个结点，同样对于k的左子树那层来说有2log2k+12^{log_2{k}+1}2log2 k+1个结点，则结点k和左子树间隔了2∗2log2(i)−i+2∗(i−2log2(k))2*2^{log_2(i)}-i + 2*(i-2^{log_2(k)})2∗2log2 (i)−i+2∗(i−2log2 (k))个结点，然后这就很简单就得到k+2∗2log2(k)−k+2∗(k−2log2(k))=2∗kk+2*2^{log_2(k)}-k + 2*(k-2^{log2(k)}) = 2*kk+2∗2log2 (k)−k+2∗(k−2log2(k))=2∗k的关系了吧，右子树也就等于左子树结点+1。\n\n * 对于左孩子结点：左孩子下标：i<<1（这些是同理的，即是由父结点推孩子结点。）\n\n * 对于右孩子结点：右孩子下标：i<<1|1\n\n了解了这些关系，我们是有能力去建立一颗线段树的，因为线段树也是树，所以我们自然可以利用递归的思想去建树，不会很难，我也写全了注释。\n\nconst int maxn = 1e5;//最大值。\nstruct node{\n    int left;  //左端点\n    int right; //右端点\n    int value;//代表区间[left,right]的信息，可以是区间和，也可以是区间最值。\n}node[maxn<<2];//这里我们要开4倍大小，防止数据溢出\nint father[maxn];//存储原来数据在线段树中的下标，易于从下向上更新区间数据。例如father[i]表示原来的第i个数据在线段树中的下标，这些在线段树中都是叶子结点。\nvoid buildtree(int i,int l,int r){\n    node[i].left=l;node[i].right=r;//存储各自结点的区间\n    node[i].value=0;                     //初始化为0.\n    if(l==r){                    //说明已经到了叶子结点。\n        father[l]=i;//存储下标。\n        return;\n    }\n    buildtree(i<<1,l,(l+r)/2); //递归初始化左子树\n    buildtree((i<<1)+1,(l+r)/2+1,r);//递归初始化右子树。\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n这样，我们的线段树就建好了。我们来看线段树有哪些基本操作吧。\n\n\n# 3 线段树的基本操作\n\n我们这里以结点的值value代表区间和来处理。\n\n\n# 3.1 点更新\n\n这很好办，有没有注意我们是使用了一个father数组，如果我在原数组中修改第i个元素的值，我们是直接可以node[father[i]].value=w，这就是我们使用father数组的好处，那你可能会问了，我们这样是不是要使用三个数组？大可不必，我们没必要给原有数据开一个数组存放，因为我们本身就已经把数据放在线段树中了，不管线段树中存放的是区间和还是区间最值，对于叶子结点来说，它就是本身。那么我们加入了点，自然也要更新整棵树，那有关这个叶子结点到根节点的路径自然全部都是要更新的，我们则是从下往上利用递归思想来更新的。\n\nvoid updatetree(int ri){\n    if(ri==1){\n        return;\n    }\n    int fi=ri>>1;//获得父结点下标。\n    node[fi].value=node[fi<<1].value+node[fi<<1|1].value;//两段区间总和。\n    updatetree(fi);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 3.2 区间查询\n\n我们有了线段树，可却不对它进行相关查询，那这颗线段树也只是精致的花瓶而已。我们最重要的就是进行区间查询，现在如果我想知道某个区间和的话，我们应该怎样来处理呢？我们知道根节点是存放了整个区间的信息，然后它的孩子结点则存放了它一半区间的信息，这样则显而易见，我们从根节点开始自上往下查询即可。我们本着下面的思想就一目了然了。\n\n1、如果这个区间被完全包括在目标区间里面，直接返回这个区间的值\n\n2、如果这个区间的左儿子和目标区间有交集，那么搜索左儿子\n\n3、如果这个区间的右儿子和目标区间有交集，那么搜索右儿子\n\nok，整活。\n\n//区间查询，调用函数时为querytree(1,l,r)，即从根节点自上往下查询。\nint querytree(int i,int l,int r){\n    int sum=0;\n    if(l==node[i].left&&r==node[i].right){\n        //如果刚好就是这个区间，我们直接返回。\n        sum+=node[i].value;\n        return sum;\n    }\n    i=i<<1;\n    if(l<=node[i].right){\n        //说明部分包含左子树\n        if(r<=node[i].right){\n            //说明全包含在左子树。\n            sum+=querytree(i,l,r);\n        }\n        else{\n            sum+=querytree(i,l,node[i].right);\n        }\n    }\n    i+=1;\n    if(r>=node[i].left){\n        //说明部分包含右子树\n        if(l>=node[i].left){\n            //说明全包含在右子树。\n            sum+=querytree(i,l,r);\n        }\n        else{\n            sum+=querytree(i,node[i].left,r);\n        }\n    }\n    return sum; //返回求得的区间和。\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n区间查询不断二分，易知时间复杂度为o(log2nlog_2nlog2 n)。\n\n线段树的基本操作就是这些，当然，这只是入门，灵活使用线段树以及更深层次的利用线段树的道路还很长，我们一起加油！\n\n----------------------------------------\n\n主函数部分测试：\n\nint main(){\n    freopen("in.txt", "r", stdin);//提交的时候要注释掉\n    ios::sync_with_stdio(false);//打消iostream中输入输出缓存，节省时间。\n    cin.tie(0); cout.tie(0);//可以通过tie(0)（0表示null）来解除cin与cout的绑定，进一步加快执行效率。\n    int n,m,g;\n    while(cin>>n>>m){\n        buildtree(1,1,n);\n        rep(i,1,n){\n            cin>>g;\n            node[father[i]].value=g;\n            updatetree(father[i]);\n        }\n        char ch;\n        int a,b;\n        while(m--){\n            cin>>ch>>a>>b;\n            if(ch==\'q\'){\n                cout<<querytree(1,a,b)<<endl;;\n            }\n            else{\n                node[father[a]].value=b;\n                updatetree(father[a]);\n            }\n        }\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n测试数据：\n\n6 5 \n2 3 8 23 1 9\nq 1 6\ns 2 3\nq 1 6\ns 3 4\nq 1 6\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n测试结果：',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"状压DP学习总结+经典例题精解",frontmatter:{title:"状压DP学习总结+经典例题精解",date:"2021-05-31T21:34:31.000Z",tags:["状压DP"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},categories:["开发","数据结构与算法","动态规划"],permalink:"/pages/671a5d/",readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/03.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/07.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/02.%E7%8A%B6%E5%8E%8BDP.html",relativePath:"01.开发/03.数据结构与算法/07.动态规划/02.状压DP.md",key:"v-1081ce44",path:"/pages/671a5d/",headers:[{level:2,title:"1 前言",slug:"_1-前言",normalizedTitle:"1 前言",charIndex:2},{level:2,title:"2 状态压缩",slug:"_2-状态压缩",normalizedTitle:"2 状态压缩",charIndex:197},{level:2,title:"3 使用场景",slug:"_3-使用场景",normalizedTitle:"3 使用场景",charIndex:595},{level:2,title:"4 常用模板",slug:"_4-常用模板",normalizedTitle:"4 常用模板",charIndex:985},{level:2,title:"5 经典例题",slug:"_5-经典例题",normalizedTitle:"5 经典例题",charIndex:1626},{level:3,title:"5.1 USACO06NOV Corn Fields G",slug:"_5-1-usaco06nov-corn-fields-g",normalizedTitle:"5.1 usaco06nov corn fields g",charIndex:1637},{level:3,title:"5.2 吃奶酪",slug:"_5-2-吃奶酪",normalizedTitle:"5.2 吃奶酪",charIndex:4998},{level:3,title:"5.3  USACO13NOV No Change G",slug:"_5-3-usaco13nov-no-change-g",normalizedTitle:"5.3  usaco13nov no change g",charIndex:null},{level:3,title:"5.4 SCOI2005互不侵犯",slug:"_5-4-scoi2005互不侵犯",normalizedTitle:"5.4 scoi2005互不侵犯",charIndex:12391}],headersStr:"1 前言 2 状态压缩 3 使用场景 4 常用模板 5 经典例题 5.1 USACO06NOV Corn Fields G 5.2 吃奶酪 5.3  USACO13NOV No Change G 5.4 SCOI2005互不侵犯",content:'# 1 前言\n\n> 学了这么久，说真的，动态规划是一个特别难的领域，而状压DPDPDP我感觉是其中一个比较难的分支，其中的状态定义、状态转移、状态计算都是难点。如果要完全搞懂状压DPDPDP是需要花很多时间去吸收去实践的，所以建议读者多刷DPDPDP题。同时，学习本文的先修知识为二进制位运算操作、基础动态规划和动态规划的分析。这里指路一篇二进制讲解blogblogblog:点这里。\n\n\n# 2 状态压缩\n\n我们知道状态压缩，顾名思义，就是需要考虑的状态非常多，我们如果用平常的思想去表示状态，那是非常不现实的，在时间和空间上都不允许，我们使用某种方法，以最小的代价表示某种状态。 那么，这通常是用进制来表示状态的，而选择几进制则根据要求使用的对象的点的状态有几种。一般来说，只有000和111，我们则是用二进制来表示，当然也有其他进制的题，在例题中会列举，需要我们灵活变通，主要谈二进制。\n\n那么如何用二进制表示状态呢？我们发现，二进制上是按位分的，那么我们每一位可以看成一个点，而点上的取值则为该点的状态或者选择。例如000010010000100100001001这个状态则表示第一个点和第四个点状态为111，其余的点状态为000。所以按照这种思想，我们能抽象的表示出一个很复杂的状态，实现了时间和空间的优化。\n\n知道了这个，我们就按照正常动态规划的思想去写这类题目即可。\n\n\n# 3 使用场景\n\n由上我们知道，状态压缩其实是有适用环境的：\n\n 1. 状态需要有一定的状态单元。 即一个状态应该是保存一个集合，其中的元素值对应着000或111，例如我们常见的棋盘，我们可以用000或111来表示棋子的放置状态。而整个集合即是一个010101串，即二进制数，我们通常用十进制表示。那么我们再进行状态转移或者判断的时候，需要先将十进制转化为二进制，再将二进制转化为十进制。\n 2. 题目中限制的集合大小不会超过202020。 这是最显著的特征，为什么呢？我们知道如果用二进制表示状态，那么集合大小为202020的二进制状态有220−12^{20} - 1220−1，已经达到1e71e71e7的数量级了。\n 3. 具有动态规划的特性。 对于动态规划，一般都是要求最优化某个值，具有最优子结构的性质。同时也需要满足状态转移的特性，而不是前一个状态毫无关系的。\n\n\n# 4 常用模板\n\n下面的模板适用于大多数题目，特殊题目需要灵活变动，总之，多刷题自然就都会了。\n\nint n;\nint maxn = 1 << n;//总状态数。\n    //枚举已有的集合数。按照状态转移的顺序，一般从小编号到大编号。\n    for(int i = 1; i <= m; ++ i){\n        //枚举当前集合中的状态。\n        for(int j = 0; j < maxn; ++ j){\n            //判断当前集合是否处于合法状态，通常我们需用一个数组提前处理好。如g数组;\n            if(当前状态是否合格){\n                for(int k = 0; k < maxn; ++ k){\n                    //枚举上一个集合的状态。\n                    if(上一个集合的状态是否合格 + 上一个集合的状态和当前状态的集合是否产生了冲突){\n                        列写状态转移方程。\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 5 经典例题\n\n\n# 5.1 USACO06NOV Corn Fields G\n\n * 题面\n   \n   > 农场主John新买了一块长方形的新牧场，这块牧场被划分成M行N列(1 ≤ M ≤ 12; 1 ≤ N ≤ 12)，每一格都是一块正方形的土地。John打算在牧场上的某几格里种上美味的草，供他的奶牛们享用。\n   > \n   > 遗憾的是，有些土地相当贫瘠，不能用来种草。并且，奶牛们喜欢独占一块草地的感觉，于是John不会选择两块相邻的土地，也就是说，没有哪两块草地有公共边。\n   > \n   > John想知道，如果不考虑草地的总块数，那么，一共有多少种种植方案可供他选择？（当然，把新牧场完全荒废也是一种方案）\n   > \n   > 输入格式\n   > \n   > 第一行：两个整数M和N，用空格隔开。\n   > \n   > 第2到第M+1行：每行包含N个用空格隔开的整数，描述了每块土地的状态。第i+1行描述了第i行的土地，所有整数均为0或1，是1的话，表示这块土地足够肥沃，0则表示这块土地不适合种草。\n   > \n   > 输出格式\n   > \n   > 一个整数，即牧场分配总方案数除以100,000,000的余数。\n   > \n   > 输入\n   > \n   > 2 3\n   > 1 1 1\n   > 0 1 0\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > \n   > 1\n   > 2\n   > 3\n   > \n   > \n   > 输出\n   > \n   > 9\n   > \n   > \n   > 1\n   > \n   > 1\n\n * 解题思路\n   \n   我们先作出规定，定义nnn代表的是行，mmm代表的是列。那么牧场大小就是n×mn\\times mn×m。我们看到数据范围,n,mn,mn,m都特别小，同时所求为方案数，这很符合状压DP的适用条件。那么对于每一行，我们就可以看成一个未知集合，而集合的大小自然就是列mmm。对于每一个单元，其取值范围为0,10,10,1，而111代表放置奶牛，000代表不放置奶牛，所以我们自然可以用二进制表示，那么状态总数就是(1<<m)−1(1 << m) - 1(1<<m)−1。 对于每一个状态，我们需要判断是否合格，而其中明确不能选择两块相邻的土地，在集合内，即相邻位不能全为111，所以我们可以预处理ggg数组，处理方式即为:g[i] = !(i & (i << 1))；同样，我们还应该知晓土地的状况，因为毕竟只有土地肥沃才可以放置奶牛，则我们可以通过一个ststst数组判断，集合与集合之间，我们也需要考虑相邻位不能全为111，所以在枚举上一个集合的状态也需要严格判断。对于状态定义，我们可以用f[i][j]f[i][j]f[i][j]表示第iii行且状态为jjj的方案数。对于状态转移，假设上一行状态为kkk，则状态转移方程为：\n   \n   f[i][j]+=f[i−1][k]f[i][j] += f[i - 1][k]f[i][j]+=f[i−1][k]\n   \n   具体见ACACAC代码。\n\n * AC代码\n\n/**\n  *@filename:Corn Field G\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-28 16:50\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 10 + 5,M = 10 + 5;\nconst int P = 1e8;\n\nint n,m;//n行m列的土地。\nint a[N][M],st[N];//a代表土地，st代表每一行的土地状况。\nbool g[1 << N];//g得到所有状态中的合法状态。\nint f[N][1 << N];//f[i][j]表示的则是第i行且状态为j的方案数，是由上一行转移过来的，所以我们定义上一行的状态为k。\n//则状态转移方程为f[i][j] += f[i - 1][k];//其中j和k必须满足条件。\nvoid solve(){\n}\nint main(){\n    scanf("%d%d", &n, &m);\n    for(int i = 1; i <= n; ++ i){\n        for(int j = 1; j <= m; ++ j){\n            scanf("%d", &a[i][j]);\n        }\n    }\n    //得到每一行的土地状况。\n    for(int i = 1; i <= n; ++ i){\n        for(int j = 1; j <= m; ++ j){\n            st[i] = (st[i] << 1) + a[i][j];\n        }\n    }\n    //得到所有状态中的合法状态。\n    int maxn = 1 << m;//总状态。\n    f[0][0] = 1;//初始化，这种也算一种。\n    for(int i = 0; i < maxn; ++ i){\n        g[i] = !( i & (i << 1));//由于不能相邻，所以我们左移判断是否符合条件。 \n    }\n    for(int i = 1; i <= n; ++ i){\n        //枚举每一行。\n        for(int j = 0; j < maxn; ++ j){\n            //枚举每一行的状态，判断此状态是否符合条件。1.不能相邻。2.是全部状态的子集。\n            if(g[j] && (j & st[i]) == j){\n                //如果符合条件。则我们去判断上一行是否符合。\n                for(int k = 0; k < maxn; ++ k){\n                    //枚举上一行状态。注意，这里我们无需判断上一行状态是否存在，因为不存在即为0.\n                    //只需要判断j和k是否存在相邻草地。\n                    if(!(j & k)){\n                        f[i][j] = (f[i][j] + f[i - 1][k]) % P;\n                    }\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for(int j = 0; j < maxn; ++ j){\n        ans = (ans + f[n][j]) % P;\n    }\n    printf("%d\\n", ans);\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n\n# 5.2 吃奶酪\n\n * 题面\n   \n   > 房间里放着nnn块奶酪。一只小老鼠要把它们都吃掉，问至少要跑多少距离？老鼠一开始在 (0,0)(0,0)(0,0)点处。\n   > \n   > 输入格式\n   > \n   > 第一行有一个整数，表示奶酪的数量 n。\n   > \n   > 第 22 到第 (n + 1)行，每行两个实数，第 (i+1)(i + 1)(i+1)行的实数分别表示第 iii 块奶酪的横纵坐标 xi,yix_i, y_ixi ,yi 。\n   > \n   > 输出格式\n   > \n   > 输出一行一个实数，表示要跑的最少距离，保留 2位小数。\n   > \n   > 输入 #1\n   > \n   > 4\n   > 1 1\n   > 1 -1\n   > -1 1\n   > -1 -1\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > \n   > \n   > 输出 #1\n   > \n   > 7.41\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 数据规模与约定\n   > \n   > 对于全部的测试点，保证 1≤n≤15，∣xi∣,∣yi∣≤2001\\leq n\\leq 15，|x_i|, |y_i| \\leq 2001≤n≤15，∣xi ∣,∣yi ∣≤200，小数点后最多有 3位数字。\n   > \n   > 提示\n   > \n   > 对于两个点$$ (x_1,y_1)，(x_2, y_2)$$，两点之间的距离公式为(x1−x2)2+(y1−y2)2\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}(x1 −x2 )2+(y1 −y2 )2 。\n\n * 解题思路\n   \n   同样，根据数据量等信息我们很容易发现这是一个状压DPDPDP。奶酪的状态无非两种0,10,10,1，而根据题意我们的集合数量只有111个，集合大小自然是奶酪的数量，而奶酪有nnn个，所以我们的集合情况也有(1<<n)−1(1 << n)-1(1<<n)−1种，同样在此题我们需要先初始化好奶酪的合法状态，用ggg数组表示，更严格的说，g[i]g[i]g[i]表示第iii个奶酪所在的二进制中的位置，用十进制数表示 。由于我们还需要计算距离，所以我们需要将每个点之间的距离也求出来，用distdistdist数组预处理奶酪之间的距离以及起点与各个奶酪的距离。 那么在状态定义上，我们可以用f[i][j]f[i][j]f[i][j]表示当前为iii状态，且处于第jjj个奶酪的最小距离，故状态转移方程易知为：\n   \n   f[i][j]=min(f[i][j],f[i−g[j]][k]+dist[k][j])f[i][j]=min(f[i][j],f[i-g[j]][k]+dist[k][j])f[i][j]=min(f[i][j],f[i−g[j]][k]+dist[k][j])\n   \n   据此，题目可解，具体看代码。\n\n * AC代码\n\n/**\n  *@filename:吃奶酪\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-30 14:20\n**/\n#include <bits/stdc++.h>\n#define x first \n#define y second\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<double,double> pdd;\nconst int N = 16;\nconst int P = 1e9+7;\n\nint n;\npdd a[N];\ndouble dist[N][N];//dist[i][j]表示第i个奶酪到第j个奶酪的距离。\nint g[1 << N];//奶酪的状态。\ndouble f[1 << N][N];//f[i][j]表示当前为i状态，且处于第j个奶酪的最小距离。\npdd st;\ndouble get(pdd a,pdd b){\n    return sqrt(pow(a.x - b.x,2) + pow(a.y - b.y,2));\n}\nvoid solve(){\n    //先计算距离。\n    st.x = 0,st.y = 0;\n    for(int i = 1; i <= n; ++ i){\n        dist[0][i] = get(st,a[i]);\n    }\n    for(int i = 1; i <= n; ++ i){\n        for(int j = 1; j <= n; ++ j){\n            dist[i][j] = get(a[i],a[j]);\n        }\n    }\n     int maxn = 1 << n;\n    //初始化奶酪的状态。\n    g[1] = 1;\n    for(int i = 2; i <= n; ++ i){\n        g[i] = g[i - 1] << 1;\n    }\n    //初始化最大值。\n    fill(f[0],f[0] + (1 << N) * N,0x3f3f3f3f);\n    //确定只吃了一个奶酪的距离。\n    for(int i = 1; i <= n; ++ i){\n        f[g[i]][i] = dist[0][i];\n    }\n    f[0][0] = 0;//最开始自然为0，0.\n    for(int i = 0; i < maxn ; ++ i){\n        //枚举所有状态。\n        for(int j = 1; j <= n; ++ j){\n            if(i & g[j]){\n                //该状态如果包含此奶酪就跳过。\n                for(int k = 1; k <= n; ++ k){\n                    if(k != j && i & g[k]){\n                        //说明符合条件。\n                        f[i][j] = min(f[i][j],f[i - g[j]][k] + dist[k][j]);//进行状态转移。\n                    }\n                }\n            }\n        }\n    }\n    double maxx = 0x3f3f3f3f;\n    for(int i = 1; i <= n; ++ i){\n        maxx = min(maxx,f[maxn - 1][i]);\n    }\n    printf("%.2lf\\n",maxx);\n}\nint main(){\n    scanf("%d", &n);\n    for(int i = 1; i <= n; ++ i){\n        scanf("%lf%lf", &a[i].x, &a[i].y);\n    }\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\n\n# 5.3 USACO13NOV No Change G\n\n * 题面\n   \n   > 约翰到商场购物，他的钱包里有K(1 <= K <= 16)个硬币，面值的范围是1..100,000,000。\n   > \n   > 约翰想按顺序买 N个物品(1 <= N <= 100,000)，第i个物品需要花费c(i)块钱，(1 <= c(i) <= 10,000)。\n   > \n   > 在依次进行的购买N个物品的过程中，约翰可以随时停下来付款，每次付款只用一个硬币，支付购买的内容是从上一次支付后开始到现在的这些所有物品（前提是该硬币足以支付这些物品的费用）。不幸的是，商场的收银机坏了，如果约翰支付的硬币面值大于所需的费用，他不会得到任何找零。\n   > \n   > 请计算出在购买完N个物品后，约翰最多剩下多少钱。如果无法完成购买，输出-1\n   > \n   > 输入格式\n   > \n   > *Line 1: Two integers, K and N.\n   > \n   > * Lines 2..1+K: Each line contains the amount of money of one of FJ\'s coins.\n   > \n   > * Lines 2+K..1+N+K: These N lines contain the costs of FJ\'s intended purchases.\n   > \n   > 输出格式\n   > \n   > * Line 1: The maximum amount of money FJ can end up with, or -1 if FJ cannot complete all of his purchases.\n   > \n   > 输入 #1\n   > \n   > 3 6 \n   > 12 \n   > 15 \n   > 10 \n   > 6 \n   > 3 \n   > 3 \n   > 2 \n   > 3 \n   > 7 \n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > \n   > \n   > 输出 #1\n   > \n   > 12 \n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 说明/提示\n   > \n   > FJ has 3 coins of values 12, 15, and 10. He must make purchases in sequence of value 6, 3, 3, 2, 3, and 7.\n   > \n   > FJ spends his 10-unit coin on the first two purchases, then the 15-unit coin on the remaining purchases. This leaves him with the 12-unit coin.\n\n * 解题思路\n   \n   此题状态定义比较简单，因为实际上我们只在乎了硬币的花费，这已经是一个集合了，花费为111不花费为000，而其他并不用在乎。所以我们完全可以用f[i]f[i]f[i]表示在iii状态下能够购买的最大物品数。此题难点在于状态转移。同样在此题我们需要先初始化好硬币的合法状态，用ggg数组表示，更严格的说，g[i]g[i]g[i]表示第iii个硬币所在的二进制中的位置。用十进制数表示。为了方便处理，我们需要用前缀和来优化本题，因为在处理过程中我们随时都要计算当前已有的总价值能够换取多少物品。 同样，在状态转移方面，我们需要根据前面的状态得到后者的状态，而由于我们是从小到大枚举状态的，故一定可以利用前面的状态而不会出现前面状态不是最优解，我们对于每一种状态，我们可以排除一个硬币获取前面的最优解，即枚举该状态已有的硬币，通过异或排除，最后利用二分查找所能购买的最大值得到最优解。 说起来有点乱，详情可见ACACAC代码。\n\n * AC代码\n\n/**\n  *@filename:No_Change_G\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-28 17:14\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 1000000 + 5,K = 20;\nconst int P = 1e9+7;\n\nint n,k;\nint g[K];//每个硬币的状态。\nint w[K];//硬币的价值\nint sum[N];//物品价值的前缀和。\nint ans;\nint f[1 << K];//f[i]表示在i状态下能够购买的最大物品数。\nvoid solve(){\n    //初始化硬币状态。\n    g[1] = 1;\n    for(int i = 2; i <= k; ++ i){\n        g[i] = g[i -1] << 1;\n    }\n    int maxn = 1 << k;//得到\n    for(int i = 0; i < maxn; ++ i){\n        //枚举每一种状态。\n        for(int j = 1; j <= k; ++ j){\n            //枚举所有的硬币。\n            if(i & g[j]){\n                //说明该硬币在当前状态使用过。\n                int te = f[i ^ g[j]];//获取该状态不使用j能获得的物品数。\n                te = upper_bound(sum + 1,sum + n + 1,sum[te] + w[j]) - sum;//这里需要减1.\n                f[i] = max(f[i],te - 1);\n            }\n        }\n    }\n    ll maxx = -2,temp;\n    for(int i = 0; i < maxn; ++ i){\n        if(f[i] == n){\n            //说明该状态能够将所有物品都买完。\n            temp = 0;\n            for(int j = 1; j <= k; ++ j){\n                if(i & g[j]){\n                    temp += w[j];\n                }\n            }\n            maxx = max(maxx,ans - temp);\n        }\n    }\n    if(maxx < 0)printf("%d\\n", -1);\n    else printf("%d\\n",maxx);\n}\nint main(){\n    scanf("%d%d", &k , &n);\n    for(int i = 1; i <= k; ++ i){\n        scanf("%d", &w[i]);\n        ans += w[i];//求硬币总价值。\n    }\n    for(int i = 1; i <= n; ++ i){\n        scanf("%d", &sum[i]);\n        sum[i] += sum[i - 1];\n    }\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n\n# 5.4 SCOI2005互不侵犯\n\n * 题面\n   \n   > 在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。\n   > \n   > 输入格式\n   > \n   > 只有一行，包含两个数N，K （ 1 <=N <=9, 0 <= K <= N * N）\n   > \n   > 输出格式\n   > \n   > 所得的方案数\n   > \n   > 输入 #1\n   > \n   > 3 2\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 输出 #1\n   > \n   > 16\n   > \n   > \n   > 1\n   > \n   > 1\n\n * 解题思路\n   \n   这道题跟5.15.15.1例题有点相似，只不过这里多了左上左下右上右下这几个点，处理方法一样，我们需要知道每个状态的放置国王数，所以这我们需要预处理。定义状态f[i][j][k]f[i][j][k]f[i][j][k]表示在第iii行且处于jjj状态时已经放置了kkk个国王。其他的处理方式和5.15.15.1相同，这里不作叙述，可见ACACAC代码。\n\n * AC代码\n\n/**\n  *@filename:互不侵犯\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-31 16:32\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 10;\nconst int P = 1e9+7;\n\nint n,m;\nint tot,num[1 << N];//num[i]表示第i种可行状态的国王所放数量。\nll f[N][1 << N][N * N];//f[i][j][k]表示前i行，当前处于j状态且已经放置了k个国王。\nint get(int x){\n    //获取该状态有多少国王。\n    int sum = 0;\n    for(int i = 0; i < n; ++ i){\n        sum += (x & 1);\n        x >>= 1;\n    }\n    return sum;\n}\nvoid init(){\n    int maxn = 1 << n;\n    for(int i = 0; i < maxn; ++ i){\n        if(i & (i << 1))continue;//说明存在相邻的。\n        num[i] = get(i);\n        f[1][i][num[i]] = 1;\n    }\n}\nvoid solve(){\n    init();\n    int maxn = 1 << n;\n    for(int i = 2; i <= n; ++ i){\n        for(int j = 0; j < maxn; ++ j){\n            //枚举所有状态。\n            if(j & (j << 1))continue;\n            for(int k = 0; k < maxn; ++ k){\n                //枚举上一行的所有状态。\n                if(((k & (k << 1)) || j & k || ((j << 1) & k) || (j & (k << 1)))){\n                    continue;\n                }\n                for(int cnt = num[j]; cnt <= m; ++ cnt){\n                    f[i][j][cnt] += f[i - 1][k][cnt - num[j]];\n                }\n            }\n        }\n    }\n    ll ans = 0;\n    for(int  i= 0; i < maxn; ++ i){\n        ans += f[n][i][m];\n    }\n    printf("%lld\\n",ans);\n}\nint main(){\n    scanf("%d %d", &n, &m);\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n',normalizedContent:'# 1 前言\n\n> 学了这么久，说真的，动态规划是一个特别难的领域，而状压dpdpdp我感觉是其中一个比较难的分支，其中的状态定义、状态转移、状态计算都是难点。如果要完全搞懂状压dpdpdp是需要花很多时间去吸收去实践的，所以建议读者多刷dpdpdp题。同时，学习本文的先修知识为二进制位运算操作、基础动态规划和动态规划的分析。这里指路一篇二进制讲解blogblogblog:点这里。\n\n\n# 2 状态压缩\n\n我们知道状态压缩，顾名思义，就是需要考虑的状态非常多，我们如果用平常的思想去表示状态，那是非常不现实的，在时间和空间上都不允许，我们使用某种方法，以最小的代价表示某种状态。 那么，这通常是用进制来表示状态的，而选择几进制则根据要求使用的对象的点的状态有几种。一般来说，只有000和111，我们则是用二进制来表示，当然也有其他进制的题，在例题中会列举，需要我们灵活变通，主要谈二进制。\n\n那么如何用二进制表示状态呢？我们发现，二进制上是按位分的，那么我们每一位可以看成一个点，而点上的取值则为该点的状态或者选择。例如000010010000100100001001这个状态则表示第一个点和第四个点状态为111，其余的点状态为000。所以按照这种思想，我们能抽象的表示出一个很复杂的状态，实现了时间和空间的优化。\n\n知道了这个，我们就按照正常动态规划的思想去写这类题目即可。\n\n\n# 3 使用场景\n\n由上我们知道，状态压缩其实是有适用环境的：\n\n 1. 状态需要有一定的状态单元。 即一个状态应该是保存一个集合，其中的元素值对应着000或111，例如我们常见的棋盘，我们可以用000或111来表示棋子的放置状态。而整个集合即是一个010101串，即二进制数，我们通常用十进制表示。那么我们再进行状态转移或者判断的时候，需要先将十进制转化为二进制，再将二进制转化为十进制。\n 2. 题目中限制的集合大小不会超过202020。 这是最显著的特征，为什么呢？我们知道如果用二进制表示状态，那么集合大小为202020的二进制状态有220−12^{20} - 1220−1，已经达到1e71e71e7的数量级了。\n 3. 具有动态规划的特性。 对于动态规划，一般都是要求最优化某个值，具有最优子结构的性质。同时也需要满足状态转移的特性，而不是前一个状态毫无关系的。\n\n\n# 4 常用模板\n\n下面的模板适用于大多数题目，特殊题目需要灵活变动，总之，多刷题自然就都会了。\n\nint n;\nint maxn = 1 << n;//总状态数。\n    //枚举已有的集合数。按照状态转移的顺序，一般从小编号到大编号。\n    for(int i = 1; i <= m; ++ i){\n        //枚举当前集合中的状态。\n        for(int j = 0; j < maxn; ++ j){\n            //判断当前集合是否处于合法状态，通常我们需用一个数组提前处理好。如g数组;\n            if(当前状态是否合格){\n                for(int k = 0; k < maxn; ++ k){\n                    //枚举上一个集合的状态。\n                    if(上一个集合的状态是否合格 + 上一个集合的状态和当前状态的集合是否产生了冲突){\n                        列写状态转移方程。\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 5 经典例题\n\n\n# 5.1 usaco06nov corn fields g\n\n * 题面\n   \n   > 农场主john新买了一块长方形的新牧场，这块牧场被划分成m行n列(1 ≤ m ≤ 12; 1 ≤ n ≤ 12)，每一格都是一块正方形的土地。john打算在牧场上的某几格里种上美味的草，供他的奶牛们享用。\n   > \n   > 遗憾的是，有些土地相当贫瘠，不能用来种草。并且，奶牛们喜欢独占一块草地的感觉，于是john不会选择两块相邻的土地，也就是说，没有哪两块草地有公共边。\n   > \n   > john想知道，如果不考虑草地的总块数，那么，一共有多少种种植方案可供他选择？（当然，把新牧场完全荒废也是一种方案）\n   > \n   > 输入格式\n   > \n   > 第一行：两个整数m和n，用空格隔开。\n   > \n   > 第2到第m+1行：每行包含n个用空格隔开的整数，描述了每块土地的状态。第i+1行描述了第i行的土地，所有整数均为0或1，是1的话，表示这块土地足够肥沃，0则表示这块土地不适合种草。\n   > \n   > 输出格式\n   > \n   > 一个整数，即牧场分配总方案数除以100,000,000的余数。\n   > \n   > 输入\n   > \n   > 2 3\n   > 1 1 1\n   > 0 1 0\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > \n   > 1\n   > 2\n   > 3\n   > \n   > \n   > 输出\n   > \n   > 9\n   > \n   > \n   > 1\n   > \n   > 1\n\n * 解题思路\n   \n   我们先作出规定，定义nnn代表的是行，mmm代表的是列。那么牧场大小就是n×mn\\times mn×m。我们看到数据范围,n,mn,mn,m都特别小，同时所求为方案数，这很符合状压dp的适用条件。那么对于每一行，我们就可以看成一个未知集合，而集合的大小自然就是列mmm。对于每一个单元，其取值范围为0,10,10,1，而111代表放置奶牛，000代表不放置奶牛，所以我们自然可以用二进制表示，那么状态总数就是(1<<m)−1(1 << m) - 1(1<<m)−1。 对于每一个状态，我们需要判断是否合格，而其中明确不能选择两块相邻的土地，在集合内，即相邻位不能全为111，所以我们可以预处理ggg数组，处理方式即为:g[i] = !(i & (i << 1))；同样，我们还应该知晓土地的状况，因为毕竟只有土地肥沃才可以放置奶牛，则我们可以通过一个ststst数组判断，集合与集合之间，我们也需要考虑相邻位不能全为111，所以在枚举上一个集合的状态也需要严格判断。对于状态定义，我们可以用f[i][j]f[i][j]f[i][j]表示第iii行且状态为jjj的方案数。对于状态转移，假设上一行状态为kkk，则状态转移方程为：\n   \n   f[i][j]+=f[i−1][k]f[i][j] += f[i - 1][k]f[i][j]+=f[i−1][k]\n   \n   具体见acacac代码。\n\n * ac代码\n\n/**\n  *@filename:corn field g\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-28 16:50\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int n = 10 + 5,m = 10 + 5;\nconst int p = 1e8;\n\nint n,m;//n行m列的土地。\nint a[n][m],st[n];//a代表土地，st代表每一行的土地状况。\nbool g[1 << n];//g得到所有状态中的合法状态。\nint f[n][1 << n];//f[i][j]表示的则是第i行且状态为j的方案数，是由上一行转移过来的，所以我们定义上一行的状态为k。\n//则状态转移方程为f[i][j] += f[i - 1][k];//其中j和k必须满足条件。\nvoid solve(){\n}\nint main(){\n    scanf("%d%d", &n, &m);\n    for(int i = 1; i <= n; ++ i){\n        for(int j = 1; j <= m; ++ j){\n            scanf("%d", &a[i][j]);\n        }\n    }\n    //得到每一行的土地状况。\n    for(int i = 1; i <= n; ++ i){\n        for(int j = 1; j <= m; ++ j){\n            st[i] = (st[i] << 1) + a[i][j];\n        }\n    }\n    //得到所有状态中的合法状态。\n    int maxn = 1 << m;//总状态。\n    f[0][0] = 1;//初始化，这种也算一种。\n    for(int i = 0; i < maxn; ++ i){\n        g[i] = !( i & (i << 1));//由于不能相邻，所以我们左移判断是否符合条件。 \n    }\n    for(int i = 1; i <= n; ++ i){\n        //枚举每一行。\n        for(int j = 0; j < maxn; ++ j){\n            //枚举每一行的状态，判断此状态是否符合条件。1.不能相邻。2.是全部状态的子集。\n            if(g[j] && (j & st[i]) == j){\n                //如果符合条件。则我们去判断上一行是否符合。\n                for(int k = 0; k < maxn; ++ k){\n                    //枚举上一行状态。注意，这里我们无需判断上一行状态是否存在，因为不存在即为0.\n                    //只需要判断j和k是否存在相邻草地。\n                    if(!(j & k)){\n                        f[i][j] = (f[i][j] + f[i - 1][k]) % p;\n                    }\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for(int j = 0; j < maxn; ++ j){\n        ans = (ans + f[n][j]) % p;\n    }\n    printf("%d\\n", ans);\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n\n# 5.2 吃奶酪\n\n * 题面\n   \n   > 房间里放着nnn块奶酪。一只小老鼠要把它们都吃掉，问至少要跑多少距离？老鼠一开始在 (0,0)(0,0)(0,0)点处。\n   > \n   > 输入格式\n   > \n   > 第一行有一个整数，表示奶酪的数量 n。\n   > \n   > 第 22 到第 (n + 1)行，每行两个实数，第 (i+1)(i + 1)(i+1)行的实数分别表示第 iii 块奶酪的横纵坐标 xi,yix_i, y_ixi ,yi 。\n   > \n   > 输出格式\n   > \n   > 输出一行一个实数，表示要跑的最少距离，保留 2位小数。\n   > \n   > 输入 #1\n   > \n   > 4\n   > 1 1\n   > 1 -1\n   > -1 1\n   > -1 -1\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > \n   > \n   > 输出 #1\n   > \n   > 7.41\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 数据规模与约定\n   > \n   > 对于全部的测试点，保证 1≤n≤15，∣xi∣,∣yi∣≤2001\\leq n\\leq 15，|x_i|, |y_i| \\leq 2001≤n≤15，∣xi ∣,∣yi ∣≤200，小数点后最多有 3位数字。\n   > \n   > 提示\n   > \n   > 对于两个点$$ (x_1,y_1)，(x_2, y_2)$$，两点之间的距离公式为(x1−x2)2+(y1−y2)2\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}(x1 −x2 )2+(y1 −y2 )2 。\n\n * 解题思路\n   \n   同样，根据数据量等信息我们很容易发现这是一个状压dpdpdp。奶酪的状态无非两种0,10,10,1，而根据题意我们的集合数量只有111个，集合大小自然是奶酪的数量，而奶酪有nnn个，所以我们的集合情况也有(1<<n)−1(1 << n)-1(1<<n)−1种，同样在此题我们需要先初始化好奶酪的合法状态，用ggg数组表示，更严格的说，g[i]g[i]g[i]表示第iii个奶酪所在的二进制中的位置，用十进制数表示 。由于我们还需要计算距离，所以我们需要将每个点之间的距离也求出来，用distdistdist数组预处理奶酪之间的距离以及起点与各个奶酪的距离。 那么在状态定义上，我们可以用f[i][j]f[i][j]f[i][j]表示当前为iii状态，且处于第jjj个奶酪的最小距离，故状态转移方程易知为：\n   \n   f[i][j]=min(f[i][j],f[i−g[j]][k]+dist[k][j])f[i][j]=min(f[i][j],f[i-g[j]][k]+dist[k][j])f[i][j]=min(f[i][j],f[i−g[j]][k]+dist[k][j])\n   \n   据此，题目可解，具体看代码。\n\n * ac代码\n\n/**\n  *@filename:吃奶酪\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-30 14:20\n**/\n#include <bits/stdc++.h>\n#define x first \n#define y second\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<double,double> pdd;\nconst int n = 16;\nconst int p = 1e9+7;\n\nint n;\npdd a[n];\ndouble dist[n][n];//dist[i][j]表示第i个奶酪到第j个奶酪的距离。\nint g[1 << n];//奶酪的状态。\ndouble f[1 << n][n];//f[i][j]表示当前为i状态，且处于第j个奶酪的最小距离。\npdd st;\ndouble get(pdd a,pdd b){\n    return sqrt(pow(a.x - b.x,2) + pow(a.y - b.y,2));\n}\nvoid solve(){\n    //先计算距离。\n    st.x = 0,st.y = 0;\n    for(int i = 1; i <= n; ++ i){\n        dist[0][i] = get(st,a[i]);\n    }\n    for(int i = 1; i <= n; ++ i){\n        for(int j = 1; j <= n; ++ j){\n            dist[i][j] = get(a[i],a[j]);\n        }\n    }\n     int maxn = 1 << n;\n    //初始化奶酪的状态。\n    g[1] = 1;\n    for(int i = 2; i <= n; ++ i){\n        g[i] = g[i - 1] << 1;\n    }\n    //初始化最大值。\n    fill(f[0],f[0] + (1 << n) * n,0x3f3f3f3f);\n    //确定只吃了一个奶酪的距离。\n    for(int i = 1; i <= n; ++ i){\n        f[g[i]][i] = dist[0][i];\n    }\n    f[0][0] = 0;//最开始自然为0，0.\n    for(int i = 0; i < maxn ; ++ i){\n        //枚举所有状态。\n        for(int j = 1; j <= n; ++ j){\n            if(i & g[j]){\n                //该状态如果包含此奶酪就跳过。\n                for(int k = 1; k <= n; ++ k){\n                    if(k != j && i & g[k]){\n                        //说明符合条件。\n                        f[i][j] = min(f[i][j],f[i - g[j]][k] + dist[k][j]);//进行状态转移。\n                    }\n                }\n            }\n        }\n    }\n    double maxx = 0x3f3f3f3f;\n    for(int i = 1; i <= n; ++ i){\n        maxx = min(maxx,f[maxn - 1][i]);\n    }\n    printf("%.2lf\\n",maxx);\n}\nint main(){\n    scanf("%d", &n);\n    for(int i = 1; i <= n; ++ i){\n        scanf("%lf%lf", &a[i].x, &a[i].y);\n    }\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\n\n# 5.3 usaco13nov no change g\n\n * 题面\n   \n   > 约翰到商场购物，他的钱包里有k(1 <= k <= 16)个硬币，面值的范围是1..100,000,000。\n   > \n   > 约翰想按顺序买 n个物品(1 <= n <= 100,000)，第i个物品需要花费c(i)块钱，(1 <= c(i) <= 10,000)。\n   > \n   > 在依次进行的购买n个物品的过程中，约翰可以随时停下来付款，每次付款只用一个硬币，支付购买的内容是从上一次支付后开始到现在的这些所有物品（前提是该硬币足以支付这些物品的费用）。不幸的是，商场的收银机坏了，如果约翰支付的硬币面值大于所需的费用，他不会得到任何找零。\n   > \n   > 请计算出在购买完n个物品后，约翰最多剩下多少钱。如果无法完成购买，输出-1\n   > \n   > 输入格式\n   > \n   > *line 1: two integers, k and n.\n   > \n   > * lines 2..1+k: each line contains the amount of money of one of fj\'s coins.\n   > \n   > * lines 2+k..1+n+k: these n lines contain the costs of fj\'s intended purchases.\n   > \n   > 输出格式\n   > \n   > * line 1: the maximum amount of money fj can end up with, or -1 if fj cannot complete all of his purchases.\n   > \n   > 输入 #1\n   > \n   > 3 6 \n   > 12 \n   > 15 \n   > 10 \n   > 6 \n   > 3 \n   > 3 \n   > 2 \n   > 3 \n   > 7 \n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > \n   > \n   > 输出 #1\n   > \n   > 12 \n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 说明/提示\n   > \n   > fj has 3 coins of values 12, 15, and 10. he must make purchases in sequence of value 6, 3, 3, 2, 3, and 7.\n   > \n   > fj spends his 10-unit coin on the first two purchases, then the 15-unit coin on the remaining purchases. this leaves him with the 12-unit coin.\n\n * 解题思路\n   \n   此题状态定义比较简单，因为实际上我们只在乎了硬币的花费，这已经是一个集合了，花费为111不花费为000，而其他并不用在乎。所以我们完全可以用f[i]f[i]f[i]表示在iii状态下能够购买的最大物品数。此题难点在于状态转移。同样在此题我们需要先初始化好硬币的合法状态，用ggg数组表示，更严格的说，g[i]g[i]g[i]表示第iii个硬币所在的二进制中的位置。用十进制数表示。为了方便处理，我们需要用前缀和来优化本题，因为在处理过程中我们随时都要计算当前已有的总价值能够换取多少物品。 同样，在状态转移方面，我们需要根据前面的状态得到后者的状态，而由于我们是从小到大枚举状态的，故一定可以利用前面的状态而不会出现前面状态不是最优解，我们对于每一种状态，我们可以排除一个硬币获取前面的最优解，即枚举该状态已有的硬币，通过异或排除，最后利用二分查找所能购买的最大值得到最优解。 说起来有点乱，详情可见acacac代码。\n\n * ac代码\n\n/**\n  *@filename:no_change_g\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-28 17:14\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int n = 1000000 + 5,k = 20;\nconst int p = 1e9+7;\n\nint n,k;\nint g[k];//每个硬币的状态。\nint w[k];//硬币的价值\nint sum[n];//物品价值的前缀和。\nint ans;\nint f[1 << k];//f[i]表示在i状态下能够购买的最大物品数。\nvoid solve(){\n    //初始化硬币状态。\n    g[1] = 1;\n    for(int i = 2; i <= k; ++ i){\n        g[i] = g[i -1] << 1;\n    }\n    int maxn = 1 << k;//得到\n    for(int i = 0; i < maxn; ++ i){\n        //枚举每一种状态。\n        for(int j = 1; j <= k; ++ j){\n            //枚举所有的硬币。\n            if(i & g[j]){\n                //说明该硬币在当前状态使用过。\n                int te = f[i ^ g[j]];//获取该状态不使用j能获得的物品数。\n                te = upper_bound(sum + 1,sum + n + 1,sum[te] + w[j]) - sum;//这里需要减1.\n                f[i] = max(f[i],te - 1);\n            }\n        }\n    }\n    ll maxx = -2,temp;\n    for(int i = 0; i < maxn; ++ i){\n        if(f[i] == n){\n            //说明该状态能够将所有物品都买完。\n            temp = 0;\n            for(int j = 1; j <= k; ++ j){\n                if(i & g[j]){\n                    temp += w[j];\n                }\n            }\n            maxx = max(maxx,ans - temp);\n        }\n    }\n    if(maxx < 0)printf("%d\\n", -1);\n    else printf("%d\\n",maxx);\n}\nint main(){\n    scanf("%d%d", &k , &n);\n    for(int i = 1; i <= k; ++ i){\n        scanf("%d", &w[i]);\n        ans += w[i];//求硬币总价值。\n    }\n    for(int i = 1; i <= n; ++ i){\n        scanf("%d", &sum[i]);\n        sum[i] += sum[i - 1];\n    }\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n\n# 5.4 scoi2005互不侵犯\n\n * 题面\n   \n   > 在n×n的棋盘里面放k个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。\n   > \n   > 输入格式\n   > \n   > 只有一行，包含两个数n，k （ 1 <=n <=9, 0 <= k <= n * n）\n   > \n   > 输出格式\n   > \n   > 所得的方案数\n   > \n   > 输入 #1\n   > \n   > 3 2\n   > \n   > \n   > 1\n   > \n   > 1\n   > \n   > \n   > 输出 #1\n   > \n   > 16\n   > \n   > \n   > 1\n   > \n   > 1\n\n * 解题思路\n   \n   这道题跟5.15.15.1例题有点相似，只不过这里多了左上左下右上右下这几个点，处理方法一样，我们需要知道每个状态的放置国王数，所以这我们需要预处理。定义状态f[i][j][k]f[i][j][k]f[i][j][k]表示在第iii行且处于jjj状态时已经放置了kkk个国王。其他的处理方式和5.15.15.1相同，这里不作叙述，可见acacac代码。\n\n * ac代码\n\n/**\n  *@filename:互不侵犯\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-31 16:32\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int n = 10;\nconst int p = 1e9+7;\n\nint n,m;\nint tot,num[1 << n];//num[i]表示第i种可行状态的国王所放数量。\nll f[n][1 << n][n * n];//f[i][j][k]表示前i行，当前处于j状态且已经放置了k个国王。\nint get(int x){\n    //获取该状态有多少国王。\n    int sum = 0;\n    for(int i = 0; i < n; ++ i){\n        sum += (x & 1);\n        x >>= 1;\n    }\n    return sum;\n}\nvoid init(){\n    int maxn = 1 << n;\n    for(int i = 0; i < maxn; ++ i){\n        if(i & (i << 1))continue;//说明存在相邻的。\n        num[i] = get(i);\n        f[1][i][num[i]] = 1;\n    }\n}\nvoid solve(){\n    init();\n    int maxn = 1 << n;\n    for(int i = 2; i <= n; ++ i){\n        for(int j = 0; j < maxn; ++ j){\n            //枚举所有状态。\n            if(j & (j << 1))continue;\n            for(int k = 0; k < maxn; ++ k){\n                //枚举上一行的所有状态。\n                if(((k & (k << 1)) || j & k || ((j << 1) & k) || (j & (k << 1)))){\n                    continue;\n                }\n                for(int cnt = num[j]; cnt <= m; ++ cnt){\n                    f[i][j][cnt] += f[i - 1][k][cnt - num[j]];\n                }\n            }\n        }\n    }\n    ll ans = 0;\n    for(int  i= 0; i < maxn; ++ i){\n        ans += f[n][i][m];\n    }\n    printf("%lld\\n",ans);\n}\nint main(){\n    scanf("%d %d", &n, &m);\n    solve();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"Floyd算法教程",frontmatter:{title:"Floyd算法教程",date:"2020-07-27T16:15:34.000Z",tags:["最短路"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/3610c3/",categories:["开发","数据结构与算法","图算法"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/03.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/08.%E5%9B%BE%E7%AE%97%E6%B3%95/01.Floyd%E7%AE%97%E6%B3%95%E6%95%99%E7%A8%8B.html",relativePath:"01.开发/03.数据结构与算法/08.图算法/01.Floyd算法教程.md",key:"v-857b513e",path:"/pages/3610c3/",headers:[{level:2,title:"1 简介",slug:"_1-简介",normalizedTitle:"1 简介",charIndex:2},{level:2,title:"2 算法原理",slug:"_2-算法原理",normalizedTitle:"2 算法原理",charIndex:161},{level:2,title:"3 邻接矩阵解题模板",slug:"_3-邻接矩阵解题模板",normalizedTitle:"3 邻接矩阵解题模板",charIndex:729},{level:2,title:"4 邻接表解题模板",slug:"_4-邻接表解题模板",normalizedTitle:"4 邻接表解题模板",charIndex:2702}],headersStr:"1 简介 2 算法原理 3 邻接矩阵解题模板 4 邻接表解题模板",content:'# 1 简介\n\nFloyd算法又称为插点法，是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法，可以正确处理有向图或无向图或负权（但不可存在负权回路)的最短路径问题，同时也被用于计算有向图的传递闭包。该算法名称以创始人之一、1978年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名。\n\n\n# 2 算法原理\n\n在给出的一张具有权值图中，我们已知每个顶点v与每个顶点u中的最短距离(即使无法到达，我们也认为是有距离的，但距离为无穷大）。对于最短距离表示，我们用dis[v][u]来表示顶点v到顶点u的最短距离，一开始没进行任何操作时，则表示他们的最短距离，就是顶点v到达顶点u的直接距离。\n\nOK，那么如果我现在有一个中转站（中转顶点temp），我先从顶点v到达顶点temp，再从顶点temp到达顶点u，则这段距离我们可以表示为dis[v][temp]+dis[temp][u]，如果这段距离比我们目前的直接到达方式更小的话，那么我们不就可以更新我们的最短距离dis[v][u]了吗？那么temp这个中转顶点可以是图中的所有顶点，如果我们不断把所有顶点插入作为中转顶点，再不断更新最短距离，最后，得到的dis[n][n]自然是多源点之间的最短路径了。我们由上述推导也可求得我们的状态转移方程dis[v][u]=min(dis[v][u],dis[v][temp]+dis[temp][u])，这就是Floyd算法的思想与原理，不断插入中转顶点，利用动态规划思想来实现。\n\n这里我们还要记录最短路径的方案，针对有些要求最短路径方案的题，我们用path[v][u]的值来记录顶点v到顶点u的中转顶点，若为-1则表示无中转顶点。\n\n\n# 3 邻接矩阵解题模板\n\n存储结构：\n\nconst int maxn=1000;//maxn表示图的最大顶点数\nint graph[maxn][maxn];\nint n;//图的实际顶点数\nint dis[maxn][maxn];//最短距离\nconst int inf=0x3f3f3f3f;//代表无穷大\nint path[maxn][maxn];//记录中转顶点\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n//Floyd算法核心\nvoid floyd(int n){\n    //顶点数目。\n    int i,j,k;//循环变量。\n    memset(dis,inf,sizeof(dis));//调用这个函数需包含memory.h头文件\n    memset(path,-1,sizeof(path));\n    for(i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            //初始化dis。\n            dis[i][j]=graph[i][j];\n        }\n    }\n    for(k=0;k<n;k++){\n    //不断插点\n        for(i=0;i<n;i++){\n            for(j=0;j<n;j++){\n            //对图中所有点之间的最短距离进行更新。\n                if(dis[i][j]>dis[i][k]+dis[k][j]){\n                    path[i][j]=k;//记录中转顶点。\n                    dis[i][j]=dis[i][k]+dis[k][j];//更新。\n                }\n            }\n   \t    }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n我们现在来输出最短路径，由于我们记录了中转顶点，那么我们可以借助我们求得的path数组来实现。如果path[i][j]的值不为-1的话，说明这个值就为中转顶点，可这样最短路径就求出来了吗？显然不是，我们还要继续判断i和k之间以及k和j之间有没有中转顶点。我们可以利用递归思想来实现这个方法输出最短路径。\n\nvoid print_path(int i,int j){\n    int k=path[i][j];\n    if(k==-1)\n        //说明没有中转顶点，直接返回.\n        return;\n    print_path(i,k);//寻找i和k之间\n    cout<<k<<",";\n    print_path(k,j);//寻找k和j之间\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n最后，再设置一个打印我们所求的结果的方法，比较简单，核心就是上面两个函数。\n\nvoid print_result(){\n    int i,j;\n    for(i=0;i<n;i++){\n        for(j=0;j<n;j++){\n              if(dis[i][j]==inf){\n                  //我们先前说过，无法到达我们设置距离为无穷大，则他们之前没有路径\n                  cout<<i<<"和"<<j<<"之间没有路径"<<endl;\n              }\n              else{\n                  cout<<i<<"和"<<j<<"的最短路径为"<<dis[i][j]<<endl;\n                  cout<<"路径方案为："<<i<<",";\n                  print_path(i,j);\n                  cout<<j<<endl;\n              }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n----------------------------------------\n\n\n# 4 邻接表解题模板\n\n存储结构：\n\nconst int maxn=1000;\ntypedef struct arc{\n    //边的信息\n    int adjust;//该边所指向的顶点。\n    int weight;//该边的权值。\n    struct arc *next;//指向一条边。\n}arc,*arclink;\n\ntypedef struct vex{\n    arclink firstarc;//该顶点的第一条边。\n}vex,vexs[maxn];\ntypedef struct graph{\n    vexs adj;\n    int arcnum;//边数\n    int vexnum;//顶点数\n}graph;\ngraph G;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n//初始化操作就不在这写了，最短距离还是用dis[maxn][maxn]表示，中转站顶点用path[maxn][maxn]毕竟我们的核心是解决Floyd算法。\n\nvoid floyd(){\n    int i,j,k;\n    //初始化dis\n    for(i=0;i<G.vexnum;i++){\n        for(j=0;j<G.vexnum;j++){\n            if(i==j)dis[i][j]=0;\n            else dis[i][j]=inf;\n        }\n    }\n    memset(path,-1,sizeof(path));//初始化path数组\n    arclink *p;//辅助作用\n    for(i=0;i<G.vexnum;i++){\n        p=G.adj[i].firstarc;\n        while(p){\n            //此操作是为了记录所有顶点之间的距离\n            dis[i][s->adjust]=s->wight;\n            s=s->next;\n        }\n    }\n    //到了这一步，就跟上面的是一样了，因为我们已经得到了dis数组和path数组的值了。下面利用dp并记录中转顶点，同种套路。\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n',normalizedContent:'# 1 简介\n\nfloyd算法又称为插点法，是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法，可以正确处理有向图或无向图或负权（但不可存在负权回路)的最短路径问题，同时也被用于计算有向图的传递闭包。该算法名称以创始人之一、1978年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名。\n\n\n# 2 算法原理\n\n在给出的一张具有权值图中，我们已知每个顶点v与每个顶点u中的最短距离(即使无法到达，我们也认为是有距离的，但距离为无穷大）。对于最短距离表示，我们用dis[v][u]来表示顶点v到顶点u的最短距离，一开始没进行任何操作时，则表示他们的最短距离，就是顶点v到达顶点u的直接距离。\n\nok，那么如果我现在有一个中转站（中转顶点temp），我先从顶点v到达顶点temp，再从顶点temp到达顶点u，则这段距离我们可以表示为dis[v][temp]+dis[temp][u]，如果这段距离比我们目前的直接到达方式更小的话，那么我们不就可以更新我们的最短距离dis[v][u]了吗？那么temp这个中转顶点可以是图中的所有顶点，如果我们不断把所有顶点插入作为中转顶点，再不断更新最短距离，最后，得到的dis[n][n]自然是多源点之间的最短路径了。我们由上述推导也可求得我们的状态转移方程dis[v][u]=min(dis[v][u],dis[v][temp]+dis[temp][u])，这就是floyd算法的思想与原理，不断插入中转顶点，利用动态规划思想来实现。\n\n这里我们还要记录最短路径的方案，针对有些要求最短路径方案的题，我们用path[v][u]的值来记录顶点v到顶点u的中转顶点，若为-1则表示无中转顶点。\n\n\n# 3 邻接矩阵解题模板\n\n存储结构：\n\nconst int maxn=1000;//maxn表示图的最大顶点数\nint graph[maxn][maxn];\nint n;//图的实际顶点数\nint dis[maxn][maxn];//最短距离\nconst int inf=0x3f3f3f3f;//代表无穷大\nint path[maxn][maxn];//记录中转顶点\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n//floyd算法核心\nvoid floyd(int n){\n    //顶点数目。\n    int i,j,k;//循环变量。\n    memset(dis,inf,sizeof(dis));//调用这个函数需包含memory.h头文件\n    memset(path,-1,sizeof(path));\n    for(i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            //初始化dis。\n            dis[i][j]=graph[i][j];\n        }\n    }\n    for(k=0;k<n;k++){\n    //不断插点\n        for(i=0;i<n;i++){\n            for(j=0;j<n;j++){\n            //对图中所有点之间的最短距离进行更新。\n                if(dis[i][j]>dis[i][k]+dis[k][j]){\n                    path[i][j]=k;//记录中转顶点。\n                    dis[i][j]=dis[i][k]+dis[k][j];//更新。\n                }\n            }\n   \t    }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n我们现在来输出最短路径，由于我们记录了中转顶点，那么我们可以借助我们求得的path数组来实现。如果path[i][j]的值不为-1的话，说明这个值就为中转顶点，可这样最短路径就求出来了吗？显然不是，我们还要继续判断i和k之间以及k和j之间有没有中转顶点。我们可以利用递归思想来实现这个方法输出最短路径。\n\nvoid print_path(int i,int j){\n    int k=path[i][j];\n    if(k==-1)\n        //说明没有中转顶点，直接返回.\n        return;\n    print_path(i,k);//寻找i和k之间\n    cout<<k<<",";\n    print_path(k,j);//寻找k和j之间\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n最后，再设置一个打印我们所求的结果的方法，比较简单，核心就是上面两个函数。\n\nvoid print_result(){\n    int i,j;\n    for(i=0;i<n;i++){\n        for(j=0;j<n;j++){\n              if(dis[i][j]==inf){\n                  //我们先前说过，无法到达我们设置距离为无穷大，则他们之前没有路径\n                  cout<<i<<"和"<<j<<"之间没有路径"<<endl;\n              }\n              else{\n                  cout<<i<<"和"<<j<<"的最短路径为"<<dis[i][j]<<endl;\n                  cout<<"路径方案为："<<i<<",";\n                  print_path(i,j);\n                  cout<<j<<endl;\n              }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n----------------------------------------\n\n\n# 4 邻接表解题模板\n\n存储结构：\n\nconst int maxn=1000;\ntypedef struct arc{\n    //边的信息\n    int adjust;//该边所指向的顶点。\n    int weight;//该边的权值。\n    struct arc *next;//指向一条边。\n}arc,*arclink;\n\ntypedef struct vex{\n    arclink firstarc;//该顶点的第一条边。\n}vex,vexs[maxn];\ntypedef struct graph{\n    vexs adj;\n    int arcnum;//边数\n    int vexnum;//顶点数\n}graph;\ngraph g;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n//初始化操作就不在这写了，最短距离还是用dis[maxn][maxn]表示，中转站顶点用path[maxn][maxn]毕竟我们的核心是解决floyd算法。\n\nvoid floyd(){\n    int i,j,k;\n    //初始化dis\n    for(i=0;i<g.vexnum;i++){\n        for(j=0;j<g.vexnum;j++){\n            if(i==j)dis[i][j]=0;\n            else dis[i][j]=inf;\n        }\n    }\n    memset(path,-1,sizeof(path));//初始化path数组\n    arclink *p;//辅助作用\n    for(i=0;i<g.vexnum;i++){\n        p=g.adj[i].firstarc;\n        while(p){\n            //此操作是为了记录所有顶点之间的距离\n            dis[i][s->adjust]=s->wight;\n            s=s->next;\n        }\n    }\n    //到了这一步，就跟上面的是一样了，因为我们已经得到了dis数组和path数组的值了。下面利用dp并记录中转顶点，同种套路。\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n',charsets:{cjk:!0},lastUpdated:"2023/11/25, 16:14:12",lastUpdatedTimestamp:1700900052e3},{title:"03.HDU 4507 恨7不成妻 （数位DP套路题）",frontmatter:{title:"03.HDU 4507 恨7不成妻 （数位DP套路题）",date:"2021-05-13T22:02:01.000Z",tags:["数位DP"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/243024/",categories:["开发","数据结构与算法","动态规划"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/03.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/07.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/03.HDU%204507%20%E6%81%A87%E4%B8%8D%E6%88%90%E5%A6%BB%20%EF%BC%88%E6%95%B0%E4%BD%8DDP%E5%A5%97%E8%B7%AF%E9%A2%98%EF%BC%8C%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90%EF%BC%89.html",relativePath:"01.开发/03.数据结构与算法/07.动态规划/03.HDU 4507 恨7不成妻 （数位DP套路题，详细解析）.md",key:"v-49401e23",path:"/pages/243024/",headersStr:null,content:'不会数位DPDPDP的这里指路一篇介绍非常详细的数位DPDPDP的blogblogblog:点这里。\n\n * 链接 恨7不成妻\n\n * 题面\n   \n   > 单身! 依然单身！ 吉哥依然单身！ DS级码农吉哥依然单身！ 所以，他生平最恨情人节，不管是214还是77，他都讨厌！ 吉哥观察了214和77这两个数，发现： 2+1+4=72+1+4=72+1+4=7　 7+7=7∗27+7=7*27+7=7∗2 77=7∗1177=7*1177=7∗11 最终，他发现原来这一切归根到底都是因为和7有关！所以，他现在甚至讨厌一切和7有关的数！什么样的数和7有关呢？如果一个整数符合下面3个条件之一，那么我们就说这个整数和7有关—— 　　　1、整数中某一位是7； 　　　2、整数的每一位加起来的和是7的整数倍； 　　　3、这个整数是7的整数倍；\n   > \n   > 现在问题来了：吉哥想知道在一定区间内和7无关的数字的平方和。 　Input 　输入数据的第一行是case数T(1 <= T <= 50)，然后接下来的T行表示T个case;每个case在一行内包含两个正整数L, R(1 <= L <= R <= 10^18)。 　Output 　请计算[L,R]中和7无关的数字的平方和，并将结果对10^9 + 7 求模后输出。 　Sample Input\n   > \n   > 3\n   > 1 9\n   > 10 11\n   > 17 17\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > \n   > \n   > Sample Output\n   > \n   > 236\n   > 221\n   > 0\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > \n   > 1\n   > 2\n   > 3\n\n * 解题思路\n   \n   根据题意我们做出预处理，利用闫式DPDPDP分析法分析如下：\n\n\n\n以上只是简单分析，我们还并没有真正的进行状态转移和计算，那么根据题意，首先是需要知道整数的每一位加起来的和是777的整数倍以及该整数是777的整数倍，这个好处理，在我们的前面的题中有类似的题型，这已经在我们的fff数组的第三维和第四维了。所以难点就在于怎么处理整数的平方和。我们看下面的公式推导：\n\n我们用jAjAjA来表示iii位数，而其中的AAA为i−1i-1i−1位数。设这个状态有ttt个符合要求的数，分别是A1A_1A1 ~AtA_tAt 。 那么，平方和易得为：\n\n(jA1)2+(jA2)2+(jA3)2+...+(jAt−1)2+(jAt)2(jA_1)^2+(jA_2)^2+(jA_3)^2+...+(jA_{t-1})^2+(jA_t)^2(jA1 )2+(jA2 )2+(jA3 )2+...+(jAt−1 )2+(jAt )2\n\n（我们分割表示将AAA提取出来。）\n\n=(j∗10i−1+A1)2+(j∗10i−1+A2)2+(j∗10i−1+A3)2+...+(j∗10i−1+At−1)2+(j∗10i−1+At)2=(j*10^{i-1}+A_1)^2+(j*10^{i-1}+A_2)^2+(j*10^{i-1}+A_3)^2+...+(j*10^{i-1}+A_{t-1})^2+(j*10^{i-1}+A_t)^2=(j∗10i−1+A1 )2+(j∗10i−1+A2 )2+(j∗10i−1+A3 )2+...+(j∗10i−1+At−1 )2+(j∗10i−1+At )2\n\n（平方和公式）\n\n=t∗(j∗10i−1)2+2∗(j∗10i−1)∗(A1+...+At)+(A12+...+A2)=t*(j*10^{i-1})^2+2*(j*10^{i-1})*(A_1+...+A_t)+(A_1^2+...+A^2)=t∗(j∗10i−1)2+2∗(j∗10i−1)∗(A1 +...+At )+(A12 +...+A2)\n\n这样，在这个式子中，由于jjj已知，所以我们发现fff数组需要保存三个值。AAA的000次方之和，也就是符合要求的数，AAA的111次方之和，也就是符合要求的除去jjj的i−1i-1i−1位数相加，AAA的222次方之和，也就是符合要求的除去jjj的i−1i-1i−1位数平方相加。我们分别用s0,s1,s2s_0,s_1,s_2s0 ,s1 ,s2\n\n分别代表上述的三个值。\n\n那么这里我们需要怎么求s1s_1s1 ，如下：\n\n注：这里的s1s_1s1 为i+1i+1i+1位的s1s_1s1 ，而它存储的就是iii位的AAA。\n\njA1+...+jAtjA_1+...+jA_tjA1 +...+jAt\n\n=j∗10i−1+(A1+...+At)=j*10^{i-1}+(A_1+...+A_t)=j∗10i−1+(A1 +...+At )\n\n所以我们的fff应该是一个结构体数组，它需要存取s0,s1,s2s_0,s_1,s_2s0 ,s1 ,s2 。那么预处理根据上述分析其实就简单了。那么就按照数位DPDPDP的套路解决这道题即可。需要注意这道题好多坑点，多取模，足够细心才可以解决。（调BugBugBug调了好久。快绝望了。）\n\n * 代码\n\n/**\n  *@filename:恨7不成妻\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 21:19\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 20;\nconst ll P = 1e9+7;\n\n//需要满足三个性质。\n//1.不含7.\n//2.各位数字之和模7不为0.an-1+...+a0%7!=0. \n//3.该数模7不为0.an-1*pow(10,n-1)+...+a0+pow(10,0)%7!=0\n\nstruct F{\n    ll s0,s1,s2;//s0为符合要求的数。s1为符合要求的数1次方之和，s2为符合要求的数的2次方之和。\n}f[N][10][7][7];//f[i][j][k][u]表示总共有i位数且最高位是j，该数值模7为k，各位数数字之和模7为u的所有数的s0,s1,s2.\n//进行初始化。\nint t;//测试数。\nll l,r;\nll power7[N],power9[N];//power7[i]存储10^i余7的余数，power9[i]存储10^i余P的余数。\nll mod(ll x,ll y){\n    return (x%y+y)%y;\n}\nvoid init(){\n    //确定初始值，位数为1的情况。\n    for(int j=0;j<10;j++){\n        if(j==7)continue;\n        //根据性质排除不符合要求的。\n        F &v=f[1][j][j%7][j%7];//这里用引用减少代码量。\n        v.s0++;\n        v.s1+=j;\n        v.s2+=j*j;\n    }\n    ll power = 10;//辅助作用，表示10的i-1次方。\n    for(int i=2;i<N;i++,power*=10){\n        for(int j=0;j<10;j++){\n            if(j==7)continue;//排除不符合要求的数。\n            for(int k=0;k<7;k++){\n                for(int u=0;u<7;u++){\n                    for(int q=0;q<10;q++){\n                        //枚举i-1的最高位。\n                        if(q==7)continue;\n                        F &x=f[i][j][k][u],y=f[i-1][q][mod(k-j*(power%7),7)][mod(u-j,7)];\n                        //s0,s1,s2都是通过公式就算得到。\n                        x.s0=mod(x.s0+y.s0,P);\n                        x.s1=mod(x.s1+1LL*j%P*(power%P)%P*y.s0%P+y.s1,P);\n                        x.s2=mod(x.s2+\n                            1LL*j%P*y.s0%P*(power%P)%P*j%P*(power%P)%P+\n                            1LL*y.s1%P*2%P*j%P*(power%P)%P+y.s2,P);\n                    }\n                }\n            }\n        }\n    }\n    //这里处理为了方便以及降低时间复杂度。\n    power7[0]=1,power9[0]=1;\n    for(int i=1;i<N;i++){\n        power7[i]=power7[i-1]*10%7;\n        power9[i]=power9[i-1]*10%P;\n    }\n}\nF get(int i,int j,int k,int u){\n    //因为f[i][j][k][u]是本身模7等于k，且各位数之和模7等于u的，所以我们需要找出符合条件的集合。\n    ll s0=0,s1=0,s2=0;\n    for(int x=0;x<7;x++){\n        for(int y=0;y<7;y++){\n            if(x==k||y==u)continue;\n            F v=f[i][j][x][y];\n            s0=mod(s0+v.s0,P);\n            s1=mod(s1+v.s1,P);\n            s2=mod(s2+v.s2,P);\n        }\n    }\n    return {s0,s1,s2};\n}\nll dp(ll n){\n    if(!n)return 0;//0的平方和为0.\n    vector<int> a;\n    ll temp=n%P;//备份一个n，供后面判断n使用。\n    while(n)a.push_back(n%10),n/=10;\n    ll last_a=0,last_b=0;//这里我们需要存储前缀的本身值和前缀的个位数之和。\n    ll ans=0;//答案。\n    for(int i=a.size()-1;i>=0;i--){\n        int x=a[i];\n        for(int j=0;j<x;j++){\n            //走左分支。\n            if(j==7)continue;\n            //我们需要将符合条件的数筛出来，这里要用到一个get函数。\n            //求得本身模7不等于a，并且各位数之和模7不等b的集合，此时就可以使用预处理出来的结构体\n            int k=mod(-last_a*power7[i+1],7),u=mod(-last_b,7);\n            F v=get(i+1,j,k,u);\n            //cout<<v.s0<<" "<<v.s1<<" "<<v.s2<<endl;\n            //根据公式求解s2.\n            //j就是last_a.\n            ans=mod(ans+\n                1LL*(last_a%P)*(last_a%P)%P*(power9[i+1]%P)%P*(power9[i+1]%P)%P*v.s0%P+\n                1LL*2*last_a%P*(power9[i+1]%P)%P*v.s1%P+\n                v.s2,P);\n            //cout<<ans<<endl;\n        }\n        //判断x。\n        if(x==7)break;\n        //走右分支更新。\n        last_a=last_a*10+x;\n        last_b+=x;\n        //判断自己本身是否符合要求。\n        if(!i&&last_a%7&&last_b%7){\n            ans=mod(ans+temp*temp%P,P);\n        }\n    }\n    return ans;\n}\nint main(){\n    init();\n    cin>>t;\n    while(t--){\n        cin>>l>>r;\n        cout<<mod(dp(r)-dp(l-1),P)<<endl;\n    }\n    return 0;\n}\n/*\n1\n1 1000000000000000000\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n',normalizedContent:'不会数位dpdpdp的这里指路一篇介绍非常详细的数位dpdpdp的blogblogblog:点这里。\n\n * 链接 恨7不成妻\n\n * 题面\n   \n   > 单身! 依然单身！ 吉哥依然单身！ ds级码农吉哥依然单身！ 所以，他生平最恨情人节，不管是214还是77，他都讨厌！ 吉哥观察了214和77这两个数，发现： 2+1+4=72+1+4=72+1+4=7　 7+7=7∗27+7=7*27+7=7∗2 77=7∗1177=7*1177=7∗11 最终，他发现原来这一切归根到底都是因为和7有关！所以，他现在甚至讨厌一切和7有关的数！什么样的数和7有关呢？如果一个整数符合下面3个条件之一，那么我们就说这个整数和7有关—— 　　　1、整数中某一位是7； 　　　2、整数的每一位加起来的和是7的整数倍； 　　　3、这个整数是7的整数倍；\n   > \n   > 现在问题来了：吉哥想知道在一定区间内和7无关的数字的平方和。 　input 　输入数据的第一行是case数t(1 <= t <= 50)，然后接下来的t行表示t个case;每个case在一行内包含两个正整数l, r(1 <= l <= r <= 10^18)。 　output 　请计算[l,r]中和7无关的数字的平方和，并将结果对10^9 + 7 求模后输出。 　sample input\n   > \n   > 3\n   > 1 9\n   > 10 11\n   > 17 17\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > \n   > \n   > sample output\n   > \n   > 236\n   > 221\n   > 0\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > \n   > 1\n   > 2\n   > 3\n\n * 解题思路\n   \n   根据题意我们做出预处理，利用闫式dpdpdp分析法分析如下：\n\n\n\n以上只是简单分析，我们还并没有真正的进行状态转移和计算，那么根据题意，首先是需要知道整数的每一位加起来的和是777的整数倍以及该整数是777的整数倍，这个好处理，在我们的前面的题中有类似的题型，这已经在我们的fff数组的第三维和第四维了。所以难点就在于怎么处理整数的平方和。我们看下面的公式推导：\n\n我们用jajaja来表示iii位数，而其中的aaa为i−1i-1i−1位数。设这个状态有ttt个符合要求的数，分别是a1a_1a1 ~ata_tat 。 那么，平方和易得为：\n\n(ja1)2+(ja2)2+(ja3)2+...+(jat−1)2+(jat)2(ja_1)^2+(ja_2)^2+(ja_3)^2+...+(ja_{t-1})^2+(ja_t)^2(ja1 )2+(ja2 )2+(ja3 )2+...+(jat−1 )2+(jat )2\n\n（我们分割表示将aaa提取出来。）\n\n=(j∗10i−1+a1)2+(j∗10i−1+a2)2+(j∗10i−1+a3)2+...+(j∗10i−1+at−1)2+(j∗10i−1+at)2=(j*10^{i-1}+a_1)^2+(j*10^{i-1}+a_2)^2+(j*10^{i-1}+a_3)^2+...+(j*10^{i-1}+a_{t-1})^2+(j*10^{i-1}+a_t)^2=(j∗10i−1+a1 )2+(j∗10i−1+a2 )2+(j∗10i−1+a3 )2+...+(j∗10i−1+at−1 )2+(j∗10i−1+at )2\n\n（平方和公式）\n\n=t∗(j∗10i−1)2+2∗(j∗10i−1)∗(a1+...+at)+(a12+...+a2)=t*(j*10^{i-1})^2+2*(j*10^{i-1})*(a_1+...+a_t)+(a_1^2+...+a^2)=t∗(j∗10i−1)2+2∗(j∗10i−1)∗(a1 +...+at )+(a12 +...+a2)\n\n这样，在这个式子中，由于jjj已知，所以我们发现fff数组需要保存三个值。aaa的000次方之和，也就是符合要求的数，aaa的111次方之和，也就是符合要求的除去jjj的i−1i-1i−1位数相加，aaa的222次方之和，也就是符合要求的除去jjj的i−1i-1i−1位数平方相加。我们分别用s0,s1,s2s_0,s_1,s_2s0 ,s1 ,s2\n\n分别代表上述的三个值。\n\n那么这里我们需要怎么求s1s_1s1 ，如下：\n\n注：这里的s1s_1s1 为i+1i+1i+1位的s1s_1s1 ，而它存储的就是iii位的aaa。\n\nja1+...+jatja_1+...+ja_tja1 +...+jat\n\n=j∗10i−1+(a1+...+at)=j*10^{i-1}+(a_1+...+a_t)=j∗10i−1+(a1 +...+at )\n\n所以我们的fff应该是一个结构体数组，它需要存取s0,s1,s2s_0,s_1,s_2s0 ,s1 ,s2 。那么预处理根据上述分析其实就简单了。那么就按照数位dpdpdp的套路解决这道题即可。需要注意这道题好多坑点，多取模，足够细心才可以解决。（调bugbugbug调了好久。快绝望了。）\n\n * 代码\n\n/**\n  *@filename:恨7不成妻\n  *@author: pursuit\n  *@csdn:unique_pursuit\n  *@email: 2825841950@qq.com\n  *@created: 2021-05-12 21:19\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int n = 20;\nconst ll p = 1e9+7;\n\n//需要满足三个性质。\n//1.不含7.\n//2.各位数字之和模7不为0.an-1+...+a0%7!=0. \n//3.该数模7不为0.an-1*pow(10,n-1)+...+a0+pow(10,0)%7!=0\n\nstruct f{\n    ll s0,s1,s2;//s0为符合要求的数。s1为符合要求的数1次方之和，s2为符合要求的数的2次方之和。\n}f[n][10][7][7];//f[i][j][k][u]表示总共有i位数且最高位是j，该数值模7为k，各位数数字之和模7为u的所有数的s0,s1,s2.\n//进行初始化。\nint t;//测试数。\nll l,r;\nll power7[n],power9[n];//power7[i]存储10^i余7的余数，power9[i]存储10^i余p的余数。\nll mod(ll x,ll y){\n    return (x%y+y)%y;\n}\nvoid init(){\n    //确定初始值，位数为1的情况。\n    for(int j=0;j<10;j++){\n        if(j==7)continue;\n        //根据性质排除不符合要求的。\n        f &v=f[1][j][j%7][j%7];//这里用引用减少代码量。\n        v.s0++;\n        v.s1+=j;\n        v.s2+=j*j;\n    }\n    ll power = 10;//辅助作用，表示10的i-1次方。\n    for(int i=2;i<n;i++,power*=10){\n        for(int j=0;j<10;j++){\n            if(j==7)continue;//排除不符合要求的数。\n            for(int k=0;k<7;k++){\n                for(int u=0;u<7;u++){\n                    for(int q=0;q<10;q++){\n                        //枚举i-1的最高位。\n                        if(q==7)continue;\n                        f &x=f[i][j][k][u],y=f[i-1][q][mod(k-j*(power%7),7)][mod(u-j,7)];\n                        //s0,s1,s2都是通过公式就算得到。\n                        x.s0=mod(x.s0+y.s0,p);\n                        x.s1=mod(x.s1+1ll*j%p*(power%p)%p*y.s0%p+y.s1,p);\n                        x.s2=mod(x.s2+\n                            1ll*j%p*y.s0%p*(power%p)%p*j%p*(power%p)%p+\n                            1ll*y.s1%p*2%p*j%p*(power%p)%p+y.s2,p);\n                    }\n                }\n            }\n        }\n    }\n    //这里处理为了方便以及降低时间复杂度。\n    power7[0]=1,power9[0]=1;\n    for(int i=1;i<n;i++){\n        power7[i]=power7[i-1]*10%7;\n        power9[i]=power9[i-1]*10%p;\n    }\n}\nf get(int i,int j,int k,int u){\n    //因为f[i][j][k][u]是本身模7等于k，且各位数之和模7等于u的，所以我们需要找出符合条件的集合。\n    ll s0=0,s1=0,s2=0;\n    for(int x=0;x<7;x++){\n        for(int y=0;y<7;y++){\n            if(x==k||y==u)continue;\n            f v=f[i][j][x][y];\n            s0=mod(s0+v.s0,p);\n            s1=mod(s1+v.s1,p);\n            s2=mod(s2+v.s2,p);\n        }\n    }\n    return {s0,s1,s2};\n}\nll dp(ll n){\n    if(!n)return 0;//0的平方和为0.\n    vector<int> a;\n    ll temp=n%p;//备份一个n，供后面判断n使用。\n    while(n)a.push_back(n%10),n/=10;\n    ll last_a=0,last_b=0;//这里我们需要存储前缀的本身值和前缀的个位数之和。\n    ll ans=0;//答案。\n    for(int i=a.size()-1;i>=0;i--){\n        int x=a[i];\n        for(int j=0;j<x;j++){\n            //走左分支。\n            if(j==7)continue;\n            //我们需要将符合条件的数筛出来，这里要用到一个get函数。\n            //求得本身模7不等于a，并且各位数之和模7不等b的集合，此时就可以使用预处理出来的结构体\n            int k=mod(-last_a*power7[i+1],7),u=mod(-last_b,7);\n            f v=get(i+1,j,k,u);\n            //cout<<v.s0<<" "<<v.s1<<" "<<v.s2<<endl;\n            //根据公式求解s2.\n            //j就是last_a.\n            ans=mod(ans+\n                1ll*(last_a%p)*(last_a%p)%p*(power9[i+1]%p)%p*(power9[i+1]%p)%p*v.s0%p+\n                1ll*2*last_a%p*(power9[i+1]%p)%p*v.s1%p+\n                v.s2,p);\n            //cout<<ans<<endl;\n        }\n        //判断x。\n        if(x==7)break;\n        //走右分支更新。\n        last_a=last_a*10+x;\n        last_b+=x;\n        //判断自己本身是否符合要求。\n        if(!i&&last_a%7&&last_b%7){\n            ans=mod(ans+temp*temp%p,p);\n        }\n    }\n    return ans;\n}\nint main(){\n    init();\n    cin>>t;\n    while(t--){\n        cin>>l>>r;\n        cout<<mod(dp(r)-dp(l-1),p)<<endl;\n    }\n    return 0;\n}\n/*\n1\n1 1000000000000000000\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"Dijkstra算法教程",frontmatter:{title:"Dijkstra算法教程",date:"2020-07-29T16:15:34.000Z",tags:["最短路"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/180ec0/",categories:["开发","数据结构与算法","图算法"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/03.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/08.%E5%9B%BE%E7%AE%97%E6%B3%95/02.Dijkstra%E7%AE%97%E6%B3%95%E6%95%99%E7%A8%8B.html",relativePath:"01.开发/03.数据结构与算法/08.图算法/02.Dijkstra算法教程.md",key:"v-7f5cbb59",path:"/pages/180ec0/",headers:[{level:2,title:"1 简介（百度百科）",slug:"_1-简介-百度百科",normalizedTitle:"1 简介（百度百科）",charIndex:76},{level:2,title:"2 算法思想与原理",slug:"_2-算法思想与原理",normalizedTitle:"2 算法思想与原理",charIndex:292},{level:2,title:"3 具体步骤",slug:"_3-具体步骤",normalizedTitle:"3 具体步骤",charIndex:920},{level:2,title:"4 动态展示",slug:"_4-动态展示",normalizedTitle:"4 动态展示",charIndex:1479},{level:2,title:"5 一般代码实现（以邻接矩阵为例）",slug:"_5-一般代码实现-以邻接矩阵为例",normalizedTitle:"5 一般代码实现（以邻接矩阵为例）",charIndex:1492},{level:3,title:"5.1 基本数据",slug:"_5-1-基本数据",normalizedTitle:"5.1 基本数据",charIndex:1514},{level:3,title:"5.2 初始化",slug:"_5-2-初始化",normalizedTitle:"5.2 初始化",charIndex:1762},{level:3,title:"5.3 dijkstra算法核心",slug:"_5-3-dijkstra算法核心",normalizedTitle:"5.3 dijkstra算法核心",charIndex:1922},{level:3,title:"5.4 主函数与头文件等",slug:"_5-4-主函数与头文件等",normalizedTitle:"5.4 主函数与头文件等",charIndex:2697},{level:2,title:"6 拓展",slug:"_6-拓展",normalizedTitle:"6 拓展",charIndex:3116}],headersStr:"1 简介（百度百科） 2 算法思想与原理 3 具体步骤 4 动态展示 5 一般代码实现（以邻接矩阵为例） 5.1 基本数据 5.2 初始化 5.3 dijkstra算法核心 5.4 主函数与头文件等 6 拓展",content:"PS：此算法不能用于求负权图，要求所有边的权重都为非负值。\n\n----------------------------------------\n\n\n# 1 简介（百度百科）\n\n> 迪杰斯特拉算法(Dijkstra)是由荷兰计算机科学家狄克斯特拉于1959 年提出的，因此又叫狄克斯特拉算法。这是从一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。迪杰斯特拉算法主要特点是从起始点开始，采用贪心算法的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。\n\n----------------------------------------\n\n\n# 2 算法思想与原理\n\n> dijkstra算法思想是基于贪心算法思想的。所谓贪心算法即始终保持当前迭代解为当前最优解。意思就是在已知的条件下或是当前拥有的全部条件下保证最优解，若在此后的迭代中由于加入了新的条件使得产生了更优解则替代此前的最优解。通过不断的迭代不断保证每次迭代的结果都是当前最优解，那么当迭代到最后一轮时得到的就会是全局最优解。 由于下一轮迭代会参考上一轮的最优解，因此每一轮的迭代的工作量基本一致，降低了整体工作的复杂性。\n\n在最短路径的问题中，局部最优解即当前的最短路径或者说是在当前的已知条件下起点到其余各点的最短距离。关键就在于已知条件，这也是Dijkstra算法最精妙的地方。我们来解释一下。\n\n对于Dijkstra算法，我们假设初始集合（也就是初始条件）不存在任何顶点的，即所有顶点之间是不存在任何路径的，即我们认为所有顶点之间的距离都是无穷大。那么开始加入新的条件，因为我们已知源点距源点距离最小，所以加入进去，并加入它的边，在该条件下，更新该源点到其余顶点的最短距离，选出没有加入到已知集合的距源点距离最小的点，此点最短距离也被确定了（因为其他路径都比这条路径大，无法通过其他路径间接到达这个顶点使得路径更小），然后加入该点与其余还未加入已知条件顶点的边，并以该点迭代刷新最短距离。再重复以上操作，直至所有顶点都加入已知条件集合。\n\n----------------------------------------\n\n\n# 3 具体步骤\n\n 1. 选择起点startstartstart与终点endendend；\n 2. 所有点除起点外加入未知集合，并将起点加入已知集合，即至标志位为真，意为已确定该点到源点的最短路径；\n 3. 初始化计算，更新起点与其他各点的耗费dis(start,n)dis(start,n)dis(start,n);\n 4. 在未知集合中，选择dis(start,n)中值最小的点x，将x加入已知集合。\n 5. 对于剩余顶点中，计算dis(start,n)>dis(start,x)+dis(x,n)dis(start,n)>dis(start,x)+dis(x,n)dis(start,n)>dis(start,x)+dis(x,n) 若真则dis(start,n)=dis(start,x)+dis(x,n)dis(start,n)=dis(start,x)+dis(x,n)dis(start,n)=dis(start,x)+dis(x,n)，此时start与n点路径经过x点。循环直至goal点加入已知列表，取得dis(start,goal)dis(start,goal)dis(start,goal)即为最短距离。\n\n----------------------------------------\n\n\n# 4 动态展示\n\n\n\n\n# 5 一般代码实现（以邻接矩阵为例）\n\n\n# 5.1 基本数据\n\nconst int inf=0x3f3f3f3f; //代表无穷大。\nconst int maxn=100;//最大顶点数\nint n,m;//n个顶点，m条边。\nbool visited[maxn];//判断是否确定到源点的最终最短距离。\nint graph[maxn][maxn];//带权图\nint dis[maxn];//顶点到源点的最短距离。\nint start,goal;//起点与目标点。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 5.2 初始化\n\nvoid init(){\n\tmemset(visited,false,sizeof(visited));\n\tfor(int i=1;i<=n;i++){\n\t\tdis[i]=graph[start][i];//初始化dis数组。\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5.3 dijkstra算法核心\n\nvoid dijkstra(){\n\t//源点为源点start。\n\tint minn;//记录每趟最短路径中最小的路径值。 \n\tint pos;//记录得到的minn所对应的下标。\n\tinit();//调用初始化函数。\n\tvisited[start]=true;\n\tfor(int i=1;i<=n;i++){\n\t\t//将n个顶点依次加入判断。\n\t\tminn=inf;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(!visited[j]&&dis[j]<minn){\n\t\t\t\tminn=dis[j];\n\t\t\t\tpos=j;\n\t\t\t}\n\t\t}\n\t\t//经过这趟for循环后我们找到的就是我们想要的点，可以确定这点到源点的最终最短距离了。\n\t\tvisited[pos]=true;//我们将此点并入已知集合。\n\t\t//接下来就是更新dis数组了，也就是当前最短距离，这都是针对还没有并入已知集合的点。\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(!visited[j]&&dis[j]>dis[pos]+graph[pos][j])\n\t\t\t\tdis[j]=dis[pos]+graph[pos][j];\n\t\t}\n\t}\n\t//退出循环后，所有的点都已并入已知集合中，得到的dis数组也就是最终最短距离了。\n\tcout<<dis[goal]<<endl;//输出目标点到源点的最短路径长度。\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 5.4 主函数与头文件等\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    while(cin>>n>>m){\n\t\tmemset(graph,inf,sizeof(graph));\n\t\tint u,v,w;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>u>>v>>w;\n//\t\t\tgraph[u][v]=w;//有向图\n\t\t\tgraph[u][v]=graph[v][u]=w;//无向图\n\t\t}\n\t\tcin>>start>>goal;//输入起点与终点。\n\t\tdijkstra();\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 6 拓展\n\n如果你学会了dijkstra，那恭喜你成功突破了一关。但是，没有优化的dijkstra算法时间复杂度为O(n2)O(n^2)O(n2)，如果顶点很多边很少呢等等卡邻接矩阵的题，那么建议你还是要学一下dijkstra的优化版了。详情点击：Dijkstra算法优化~~你一定可以看懂的四种进阶优化",normalizedContent:"ps：此算法不能用于求负权图，要求所有边的权重都为非负值。\n\n----------------------------------------\n\n\n# 1 简介（百度百科）\n\n> 迪杰斯特拉算法(dijkstra)是由荷兰计算机科学家狄克斯特拉于1959 年提出的，因此又叫狄克斯特拉算法。这是从一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。迪杰斯特拉算法主要特点是从起始点开始，采用贪心算法的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。\n\n----------------------------------------\n\n\n# 2 算法思想与原理\n\n> dijkstra算法思想是基于贪心算法思想的。所谓贪心算法即始终保持当前迭代解为当前最优解。意思就是在已知的条件下或是当前拥有的全部条件下保证最优解，若在此后的迭代中由于加入了新的条件使得产生了更优解则替代此前的最优解。通过不断的迭代不断保证每次迭代的结果都是当前最优解，那么当迭代到最后一轮时得到的就会是全局最优解。 由于下一轮迭代会参考上一轮的最优解，因此每一轮的迭代的工作量基本一致，降低了整体工作的复杂性。\n\n在最短路径的问题中，局部最优解即当前的最短路径或者说是在当前的已知条件下起点到其余各点的最短距离。关键就在于已知条件，这也是dijkstra算法最精妙的地方。我们来解释一下。\n\n对于dijkstra算法，我们假设初始集合（也就是初始条件）不存在任何顶点的，即所有顶点之间是不存在任何路径的，即我们认为所有顶点之间的距离都是无穷大。那么开始加入新的条件，因为我们已知源点距源点距离最小，所以加入进去，并加入它的边，在该条件下，更新该源点到其余顶点的最短距离，选出没有加入到已知集合的距源点距离最小的点，此点最短距离也被确定了（因为其他路径都比这条路径大，无法通过其他路径间接到达这个顶点使得路径更小），然后加入该点与其余还未加入已知条件顶点的边，并以该点迭代刷新最短距离。再重复以上操作，直至所有顶点都加入已知条件集合。\n\n----------------------------------------\n\n\n# 3 具体步骤\n\n 1. 选择起点startstartstart与终点endendend；\n 2. 所有点除起点外加入未知集合，并将起点加入已知集合，即至标志位为真，意为已确定该点到源点的最短路径；\n 3. 初始化计算，更新起点与其他各点的耗费dis(start,n)dis(start,n)dis(start,n);\n 4. 在未知集合中，选择dis(start,n)中值最小的点x，将x加入已知集合。\n 5. 对于剩余顶点中，计算dis(start,n)>dis(start,x)+dis(x,n)dis(start,n)>dis(start,x)+dis(x,n)dis(start,n)>dis(start,x)+dis(x,n) 若真则dis(start,n)=dis(start,x)+dis(x,n)dis(start,n)=dis(start,x)+dis(x,n)dis(start,n)=dis(start,x)+dis(x,n)，此时start与n点路径经过x点。循环直至goal点加入已知列表，取得dis(start,goal)dis(start,goal)dis(start,goal)即为最短距离。\n\n----------------------------------------\n\n\n# 4 动态展示\n\n\n\n\n# 5 一般代码实现（以邻接矩阵为例）\n\n\n# 5.1 基本数据\n\nconst int inf=0x3f3f3f3f; //代表无穷大。\nconst int maxn=100;//最大顶点数\nint n,m;//n个顶点，m条边。\nbool visited[maxn];//判断是否确定到源点的最终最短距离。\nint graph[maxn][maxn];//带权图\nint dis[maxn];//顶点到源点的最短距离。\nint start,goal;//起点与目标点。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 5.2 初始化\n\nvoid init(){\n\tmemset(visited,false,sizeof(visited));\n\tfor(int i=1;i<=n;i++){\n\t\tdis[i]=graph[start][i];//初始化dis数组。\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5.3 dijkstra算法核心\n\nvoid dijkstra(){\n\t//源点为源点start。\n\tint minn;//记录每趟最短路径中最小的路径值。 \n\tint pos;//记录得到的minn所对应的下标。\n\tinit();//调用初始化函数。\n\tvisited[start]=true;\n\tfor(int i=1;i<=n;i++){\n\t\t//将n个顶点依次加入判断。\n\t\tminn=inf;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(!visited[j]&&dis[j]<minn){\n\t\t\t\tminn=dis[j];\n\t\t\t\tpos=j;\n\t\t\t}\n\t\t}\n\t\t//经过这趟for循环后我们找到的就是我们想要的点，可以确定这点到源点的最终最短距离了。\n\t\tvisited[pos]=true;//我们将此点并入已知集合。\n\t\t//接下来就是更新dis数组了，也就是当前最短距离，这都是针对还没有并入已知集合的点。\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(!visited[j]&&dis[j]>dis[pos]+graph[pos][j])\n\t\t\t\tdis[j]=dis[pos]+graph[pos][j];\n\t\t}\n\t}\n\t//退出循环后，所有的点都已并入已知集合中，得到的dis数组也就是最终最短距离了。\n\tcout<<dis[goal]<<endl;//输出目标点到源点的最短路径长度。\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 5.4 主函数与头文件等\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    while(cin>>n>>m){\n\t\tmemset(graph,inf,sizeof(graph));\n\t\tint u,v,w;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>u>>v>>w;\n//\t\t\tgraph[u][v]=w;//有向图\n\t\t\tgraph[u][v]=graph[v][u]=w;//无向图\n\t\t}\n\t\tcin>>start>>goal;//输入起点与终点。\n\t\tdijkstra();\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 6 拓展\n\n如果你学会了dijkstra，那恭喜你成功突破了一关。但是，没有优化的dijkstra算法时间复杂度为o(n2)o(n^2)o(n2)，如果顶点很多边很少呢等等卡邻接矩阵的题，那么建议你还是要学一下dijkstra的优化版了。详情点击：dijkstra算法优化~~你一定可以看懂的四种进阶优化",charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"Kruskal算法详解",frontmatter:{title:"Kruskal算法详解",date:"2020-08-11T16:15:34.000Z",tags:["最小生成树"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/a97764/",categories:["开发","数据结构与算法","图算法"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/03.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/08.%E5%9B%BE%E7%AE%97%E6%B3%95/03.Kruskal%E7%AE%97%E6%B3%95%E6%95%99%E7%A8%8B.html",relativePath:"01.开发/03.数据结构与算法/08.图算法/03.Kruskal算法教程.md",key:"v-28760263",path:"/pages/a97764/",headers:[{level:2,title:"1、简介",slug:"_1、简介",normalizedTitle:"1、简介",charIndex:2},{level:2,title:"2、构造过程",slug:"_2、构造过程",normalizedTitle:"2、构造过程",charIndex:240},{level:2,title:"3、示例",slug:"_3、示例",normalizedTitle:"3、示例",charIndex:633},{level:2,title:"4、算法实现",slug:"_4、算法实现",normalizedTitle:"4、算法实现",charIndex:644},{level:2,title:"5、算法分析",slug:"_5、算法分析",normalizedTitle:"5、算法分析",charIndex:3325},{level:2,title:"6、测试",slug:"_6、测试",normalizedTitle:"6、测试",charIndex:3513}],headersStr:"1、简介 2、构造过程 3、示例 4、算法实现 5、算法分析 6、测试",content:'# 1、简介\n\nKruskal算法是一种用来查找最小生成树（MSTMSTMST）的算法，由Joseph Kruskal在1956年发表。求最小生成树的算法常用有两种：Kruskal算法和Prim算法。这里指路一篇Prim算法的详解blog：https://blog.csdn.net/hzf0701/article/details/107927858。与Prim算法不同的是，该算法的核心思想是归并边，而Prim算法的核心思想是归并点。这里我们会在后面的实现过程中看到。\n\n\n# 2、构造过程\n\n假设连通网N=(V,E)N=(V,E)N=(V,E)，将NNN中的边按权值从小到大的顺序排列。 ①初始状态为只有nnn个顶点而无边的非连通图T=(V,{})T=(V,\\{\\})T=(V,{})，图中每个顶点自成一个连通分量。 ②在EEE中选择权值最小的边，若该边依附的顶点落在TTT中不同的连通分量上（即不形成回路），则将此边将入到TTT中，否则舍去此边而选择下一条权值最小的边。 ③重复②，直到TTT中所有的顶点都在同一连通分量上为止。\n\n这个算法的构造过程十分简洁明了，那么为什么这样的构造过程能否形成最小生成树呢？我们来看第二个步骤，因为我们选取的边的顶点是不同的连通分量，且边权值是最小的，所以我们保证加入的边都不使得TTT有回路，且权值也最小。这样最后当所有的连通分量都相同时，即所有的顶点都在生成树中被连接成功了，我们构造成的树也就是最小生成树了。\n\n\n# 3、示例\n\n\n\n\n# 4、算法实现\n\n步骤： ①将存储边的数组temp按权值从小到大排序，注意进行运算符重载。 ②初始化连通分量数组verxverxverx。 ③依次查看数组temp的边，循环执行以下操作。\n\n * 依次从排好序的数组temp中选出一条边(u,v)(u,v)(u,v)；\n * 在verxverxverx中分别查找uuu和vvv所在的连通分量v1和v2v_1和v_2v1 和v2 ，进行判断。\n   * 如果v1v_1v1 和v2v_2v2 不等，说明所选的两个顶点分别属于不同的连通分量，则将此边存入最小生成树treetreetree，并合并v1v_1v1 和v2v_2v2 这个两个连通分量。\n   * 如果v1v_1v1 和v2v_2v2 相等，则说明所选的两个顶点属于同一个连通分量，舍去此边而选择下一条权值最小的边。\n\n#include<bits/stdc++.h> //POJ不支持\n\n#define rep(i,a,n) for (int i=a;i<=n;i++)//i为循环变量，a为初始值，n为界限值，递增\n#define per(i,a,n) for (int i=a;i>=n;i--)//i为循环变量， a为初始值，n为界限值，递减。\n#define pb push_back\n#define IOS ios::sync_with_stdio(false);cin.tie(0); cout.tie(0)\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\nconst int inf = 0x3f3f3f3f;//无穷大\nconst int maxn = 1e5;//最大值。\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll>  pll;\ntypedef pair<int, int> pii;\n//*******************************分割线，以上为自定义代码模板***************************************//\n\nstruct edge{\n    int s;//边的起始顶点。\n    int e;//边的终端顶点。\n    int w;//边权值。\n    bool operator < (const edge &a){\n        return w<a.w;\n    }\n};\nedge temp[maxn];//临时数组存储边。\nint verx[maxn];//辅助数组，判断是否连通。\nedge tree[maxn];//最小生成树。\nint n,m;//n*n的图，m条边。\nint cnt;//统计生成结点个数，若不满足n个，则生成失败。\nint sum;//最小生成树权值总和。\nvoid print(){\n    //打印最小生成树函数。\n    cout<<"最小生成树的权值总和为："<<sum<<endl;\n    rep(i,0,cnt-1){\n        cout<<tree[i].s<<" "<<tree[i].e<<"边权值为"<<tree[i].w<<endl;\n    }\n}\nvoid Kruskal(){\n    rep(i,1,n)\n        verx[i]=i;//这里表示各顶点自成一个连通分量。\n    cnt=0;sum=0;\n    sort(temp,temp+m);//将边按权值排列。\n    int v1,v2;\n    rep(i,0,m-1){\n        v1=verx[temp[i].s];\n        v2=verx[temp[i].e];\n        if(v1!=v2){\n            tree[cnt].s=temp[i].s;tree[cnt].e=temp[i].e;tree[cnt].w=temp[i].w;//并入最小生成树。\n            rep(j,1,n){\n                //合并v1和v2的两个分量，即两个集合统一编号。\n                if(verx[j]==v2)verx[j]=v1; //默认集合编号为v2的改为v1.\n            }\n            sum+=tree[cnt].w;\n            cnt++;\n        }\n    }\n    //结束双层for循环之后得到tree即是最小生成树。\n    print();\n}\nint main(){\n    //freopen("in.txt", "r", stdin);//提交的时候要注释掉\n    IOS;\n    while(cin>>n>>m){\n        int u,v,w;\n        rep(i,0,m-1){\n            cin>>u>>v>>w;\n            temp[i].s=u;temp[i].e=v;temp[i].w=w;\n        }\n        Kruskal();\n    }\n    return 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n\n\n\n# 5、算法分析\n\n对于有mmm条边和nnn个顶点的图。在forforfor循环中最耗时的操作就是合并两个不同的连通分量，第一个循环语句的频度为mmm，第二个循环由于存在ififif语句，所以平均频度是log2nlog_2nlog2 n，所以该算法的平均时间复杂度为O(mlog2n)O(mlog_2n)O(mlog2 n)，故和Prim算法相比 此算法适合用于稀疏图。\n\n\n# 6、测试\n\n以示例数据为测试样例：\n\n7 11\n1 2 7\n1 4 5\n2 4 9\n2 3 8\n2 5 7\n4 5 15\n4 6 6\n6 7 11\n5 6 8\n5 7 9\n3 5 5\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n测试结果如图：',normalizedContent:'# 1、简介\n\nkruskal算法是一种用来查找最小生成树（mstmstmst）的算法，由joseph kruskal在1956年发表。求最小生成树的算法常用有两种：kruskal算法和prim算法。这里指路一篇prim算法的详解blog：https://blog.csdn.net/hzf0701/article/details/107927858。与prim算法不同的是，该算法的核心思想是归并边，而prim算法的核心思想是归并点。这里我们会在后面的实现过程中看到。\n\n\n# 2、构造过程\n\n假设连通网n=(v,e)n=(v,e)n=(v,e)，将nnn中的边按权值从小到大的顺序排列。 ①初始状态为只有nnn个顶点而无边的非连通图t=(v,{})t=(v,\\{\\})t=(v,{})，图中每个顶点自成一个连通分量。 ②在eee中选择权值最小的边，若该边依附的顶点落在ttt中不同的连通分量上（即不形成回路），则将此边将入到ttt中，否则舍去此边而选择下一条权值最小的边。 ③重复②，直到ttt中所有的顶点都在同一连通分量上为止。\n\n这个算法的构造过程十分简洁明了，那么为什么这样的构造过程能否形成最小生成树呢？我们来看第二个步骤，因为我们选取的边的顶点是不同的连通分量，且边权值是最小的，所以我们保证加入的边都不使得ttt有回路，且权值也最小。这样最后当所有的连通分量都相同时，即所有的顶点都在生成树中被连接成功了，我们构造成的树也就是最小生成树了。\n\n\n# 3、示例\n\n\n\n\n# 4、算法实现\n\n步骤： ①将存储边的数组temp按权值从小到大排序，注意进行运算符重载。 ②初始化连通分量数组verxverxverx。 ③依次查看数组temp的边，循环执行以下操作。\n\n * 依次从排好序的数组temp中选出一条边(u,v)(u,v)(u,v)；\n * 在verxverxverx中分别查找uuu和vvv所在的连通分量v1和v2v_1和v_2v1 和v2 ，进行判断。\n   * 如果v1v_1v1 和v2v_2v2 不等，说明所选的两个顶点分别属于不同的连通分量，则将此边存入最小生成树treetreetree，并合并v1v_1v1 和v2v_2v2 这个两个连通分量。\n   * 如果v1v_1v1 和v2v_2v2 相等，则说明所选的两个顶点属于同一个连通分量，舍去此边而选择下一条权值最小的边。\n\n#include<bits/stdc++.h> //poj不支持\n\n#define rep(i,a,n) for (int i=a;i<=n;i++)//i为循环变量，a为初始值，n为界限值，递增\n#define per(i,a,n) for (int i=a;i>=n;i--)//i为循环变量， a为初始值，n为界限值，递减。\n#define pb push_back\n#define ios ios::sync_with_stdio(false);cin.tie(0); cout.tie(0)\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\nconst int inf = 0x3f3f3f3f;//无穷大\nconst int maxn = 1e5;//最大值。\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll>  pll;\ntypedef pair<int, int> pii;\n//*******************************分割线，以上为自定义代码模板***************************************//\n\nstruct edge{\n    int s;//边的起始顶点。\n    int e;//边的终端顶点。\n    int w;//边权值。\n    bool operator < (const edge &a){\n        return w<a.w;\n    }\n};\nedge temp[maxn];//临时数组存储边。\nint verx[maxn];//辅助数组，判断是否连通。\nedge tree[maxn];//最小生成树。\nint n,m;//n*n的图，m条边。\nint cnt;//统计生成结点个数，若不满足n个，则生成失败。\nint sum;//最小生成树权值总和。\nvoid print(){\n    //打印最小生成树函数。\n    cout<<"最小生成树的权值总和为："<<sum<<endl;\n    rep(i,0,cnt-1){\n        cout<<tree[i].s<<" "<<tree[i].e<<"边权值为"<<tree[i].w<<endl;\n    }\n}\nvoid kruskal(){\n    rep(i,1,n)\n        verx[i]=i;//这里表示各顶点自成一个连通分量。\n    cnt=0;sum=0;\n    sort(temp,temp+m);//将边按权值排列。\n    int v1,v2;\n    rep(i,0,m-1){\n        v1=verx[temp[i].s];\n        v2=verx[temp[i].e];\n        if(v1!=v2){\n            tree[cnt].s=temp[i].s;tree[cnt].e=temp[i].e;tree[cnt].w=temp[i].w;//并入最小生成树。\n            rep(j,1,n){\n                //合并v1和v2的两个分量，即两个集合统一编号。\n                if(verx[j]==v2)verx[j]=v1; //默认集合编号为v2的改为v1.\n            }\n            sum+=tree[cnt].w;\n            cnt++;\n        }\n    }\n    //结束双层for循环之后得到tree即是最小生成树。\n    print();\n}\nint main(){\n    //freopen("in.txt", "r", stdin);//提交的时候要注释掉\n    ios;\n    while(cin>>n>>m){\n        int u,v,w;\n        rep(i,0,m-1){\n            cin>>u>>v>>w;\n            temp[i].s=u;temp[i].e=v;temp[i].w=w;\n        }\n        kruskal();\n    }\n    return 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n\n\n\n# 5、算法分析\n\n对于有mmm条边和nnn个顶点的图。在forforfor循环中最耗时的操作就是合并两个不同的连通分量，第一个循环语句的频度为mmm，第二个循环由于存在ififif语句，所以平均频度是log2nlog_2nlog2 n，所以该算法的平均时间复杂度为o(mlog2n)o(mlog_2n)o(mlog2 n)，故和prim算法相比 此算法适合用于稀疏图。\n\n\n# 6、测试\n\n以示例数据为测试样例：\n\n7 11\n1 2 7\n1 4 5\n2 4 9\n2 3 8\n2 5 7\n4 5 15\n4 6 6\n6 7 11\n5 6 8\n5 7 9\n3 5 5\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n测试结果如图：',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"Prim算法详解",frontmatter:{title:"Prim算法详解",date:"2020-07-29T11:34:35.000Z",tags:["最小生成树"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/affd0f/",categories:["开发","数据结构与算法","图算法"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/03.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/08.%E5%9B%BE%E7%AE%97%E6%B3%95/04.Prim%E7%AE%97%E6%B3%95%E6%95%99%E7%A8%8B.html",relativePath:"01.开发/03.数据结构与算法/08.图算法/04.Prim算法教程.md",key:"v-4aec2599",path:"/pages/affd0f/",headers:[{level:2,title:"1 最小生成树（Minimum Spanning Tree,MST）",slug:"_1-最小生成树-minimum-spanning-tree-mst",normalizedTitle:"1 最小生成树（minimum spanning tree,mst）",charIndex:2},{level:2,title:"2 Prim算法",slug:"_2-prim算法",normalizedTitle:"2 prim算法",charIndex:659},{level:3,title:"2.1 简介",slug:"_2-1-简介",normalizedTitle:"2.1 简介",charIndex:672},{level:3,title:"2.2 具体步骤",slug:"_2-2-具体步骤",normalizedTitle:"2.2 具体步骤",charIndex:913},{level:3,title:"2.3 算法示例图",slug:"_2-3-算法示例图",normalizedTitle:"2.3 算法示例图",charIndex:1350},{level:3,title:"2.4 算法实现",slug:"_2-4-算法实现",normalizedTitle:"2.4 算法实现",charIndex:1366},{level:3,title:"2.5 算法分析",slug:"_2-5-算法分析",normalizedTitle:"2.5 算法分析",charIndex:4314},{level:3,title:"2.6 测试",slug:"_2-6-测试",normalizedTitle:"2.6 测试",charIndex:4523}],headersStr:"1 最小生成树（Minimum Spanning Tree,MST） 2 Prim算法 2.1 简介 2.2 具体步骤 2.3 算法示例图 2.4 算法实现 2.5 算法分析 2.6 测试",content:'# 1 最小生成树（Minimum Spanning Tree,MST）\n\n在一给定的无向图G=(V,E)G = (V, E)G=(V,E) 中，(u,v)(u, v)(u,v)代表连接顶点uuu 与顶点 vvv 的边，而 w(u,v)w(u, v)w(u,v) 代表此边的权重，若存在 TTT 为 EEE 的子集且为无循环图，使得 w(T)w(T)w(T) 最小，则此 TTT 为 GGG 的最小生成树，因为TTT是由图GGG产生的。\n\n\n\n最小生成树其实是最小权重生成树的简称。我们称求取该生成树的问题成为最小生成树问题。一个连通图可能有多个生成树。当图中的边具有权值时，总会有一个生成树的边的权值之和小于或者等于其它生成树的边的权值之和。广义上而言，对于非连通无向图来说，它的每一连通分量同样有最小生成树，它们的并被称为最小生成森林。以有线电视电缆的架设为例，若只能沿着街道布线，则以街道为边，而路口为顶点，其中必然有一最小生成树能使布线成本最低。\n\n\n\n如图，这个是一个平面图，图中黑色线描述的就是最小生成树，它的权值之和小于其他的生成树。\n\n那么，我们如何来求最小生成树呢，由最小生成树的定义我们可以知道构建最小生成树是可以利用贪心算法去实现的，我们接下来介绍的两种算法也都是利用贪心算法去求得MSTMSTMST的。因为贪心算法的策略就是在每一步尽可能多的选择中选择最优的，在当前看是最好的选择，这种策略虽然一般不能在全局中寻找到最优解，但是对于最小生成树问题来说，它的确可以找到一颗权重最小的树。\n\n\n# 2 Prim算法\n\n\n# 2.1 简介\n\n普里姆算法（Prim\'s algorithm），图论中的一种算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点，且其所有边的权值之和亦为最小。该算法于1930年由捷克数学家沃伊捷赫·亚尔尼克发现；并在1957年由美国计算机科学家罗伯特·普里姆独立发现；1959年，艾兹格·迪科斯彻再次发现了该算法。因此，在某些场合，普里姆算法又被称为DJP算法、亚尔尼克算法或普里姆－亚尔尼克算法。（来源于维基百科）\n\n\n# 2.2 具体步骤\n\nPrim算法是利用贪心算法实现的，我们确定根节点，从这个结点出发。普里姆算法按照以下步骤==逐步扩大树中所含顶点的数目，直到遍及连通图的所有顶点==。下面描述我们==假设N=(V,E)N=(V,E)N=(V,E)是连通网，TETETE是NNN上最小生成树中边的集合==。\n\n① U={u0}(u0∈V),TE={}U=\\{u_0\\}(u_0∈V) ,TE= \\{\\}U={u0 }(u0 ∈V),TE={}。\n\n② 在所有u∈U,v∈(V−U)u∈U,v∈(V-U)u∈U,v∈(V−U)的边(u,v)∈E(u,v)∈E(u,v)∈E找到一条权值最小的边(u0,v0)(u_0,v_0)(u0 ,v0 )并入集合TETETE，同时v0v_0v0 并入集合UUU。\n\n③ 重复②步骤，知道U=VU=VU=V为止。\n\n此时TETETE中必有n−1n-1n−1条边，则T=(V,TE)T=(V,TE)T=(V,TE)即为我们求得的NNN的最小生成树。\n\n\n# 2.3 算法示例图\n\n\n\n\n# 2.4 算法实现\n\n我们如果对Dijkstra算法很熟悉的话，Prim算法也很好实现了，它们都是利用了一样的思路，但却不相同。我们用利用lowcostlowcostlowcost数组来表示到集合中最近的距离，用closestclosestclosest数组来表示最小生成树的边。怎么来表示呢？我们用顶点来形容边，也就是说我们要求的就是closetclosetcloset数组。其中closest[i]closest[i]closest[i]表示的值就是与iii顶点相邻边的顶点序号。具体看代码（附带打印最小生成树代码）。\n\n#include<bits/stdc++.h> //POJ不支持\n\n#define rep(i,a,n) for (int i=a;i<=n;i++)//i为循环变量，a为初始值，n为界限值，递增\n#define per(i,a,n) for (int i=a;i>=n;i--)//i为循环变量， a为初始值，n为界限值，递减。\n#define pb push_back\n#define IOS ios::sync_with_stdio(false);cin.tie(0); cout.tie(0)\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\nconst int inf = 0x3f3f3f3f;//无穷大\nconst int maxn = 1e3;//最大值。\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll>  pll;\ntypedef pair<int, int> pii;\n//*******************************分割线，以上为自定义代码模板***************************************//\n\nint n,m;//图的大小和边数。\nint graph[maxn][maxn];//图\nint lowcost[maxn],closest[maxn];//lowcost[i]表示i到距离集合最近的距离，closest[i]表示i与之相连边的顶点序号。\nint sum;//计算最小生成树的权值总和。\nvoid Prim(int s){\n    //初始化操作，获取基本信息。\n    rep(i,1,n){\n        if(i==s)\n            lowcost[i]=0;\n        else\n            lowcost[i]=graph[s][i];\n        closest[i]=s;\n    }\n    int minn,pos;//距离集合最近的边，pos代表该点的终边下标。\n    sum=0;\n    rep(i,1,n){\n        minn=inf;\n        rep(j,1,n){\n            //找出距离点集合最近的边。\n            if(lowcost[j]!=0&&lowcost[j]<minn){\n                minn=lowcost[j];\n                pos=j;\n            }\n        }\n        if(minn==inf)break;//说明没有找到。\n        sum+=minn;//计算最小生成树的权值之和。\n        lowcost[pos]=0;//加入点集合。\n        rep(j,1,n){\n            //由于点集合中加入了新的点，我们要去更新。\n            if(lowcost[j]!=0&&graph[pos][j]<lowcost[j]){\n                lowcost[j]=graph[pos][j];\n                closest[j]=pos;//改变与顶点j相连的顶点序号。\n            }\n        }\n    }\n    cout<<sum<<endl;//closest数组就是我们要的最小生成树。它代表的就是边。\n}\nvoid print(int s){\n    //打印最小生成树。\n    int temp;\n    rep(i,1,n){\n        //等于s自然不算，故除去这个为n-1条边。\n        if(i!=s){\n            temp=closest[i];\n            cout<<temp<<"->"<<i<<"边权值为："<<graph[temp][i]<<endl;\n        }\n    }\n}\nint main(){\n    //freopen("in.txt", "r", stdin);//提交的时候要注释掉\n    IOS;\n    while(cin>>n>>m){\n        memset(graph,inf,sizeof(graph));//初始化。\n        int u,v,w;//临时变量。\n        rep(i,1,m){\n            cin>>u>>v>>w;\n            //视情况而论，我这里以无向图为例。\n            graph[u][v]=graph[v][u]=w;\n        }\n        //任取根结点，我这里默认取1.\n        Prim(1);\n        print(1);//打印最小生成树。\n    }\n    return 0;\n}\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n\n# 2.5 算法分析\n\n对于此算法，我们图中有nnn个顶点，则第一个进行初始化的循环语句的频度为nnn,第二个循环语句的频度为nnn，==但其中第二个循环中有两个内循环：第一个是在lowcostlowcostlowcost中求最小值，其频度为nnn，第二个是重新选择具有最小权值的边，频度为nnn==，由此我们可知Prim算法的时间复杂度为O(n2)O(n^2)O(n2)，与图中的边数无关，故十分适合于稠密图。\n\n\n# 2.6 测试\n\n我们用示例来测试：\n\n7 11\n1 2 7\n1 4 5\n2 4 9\n2 3 8\n2 5 7\n4 5 15\n4 6 6\n6 7 11\n5 6 8\n5 7 9\n3 5 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n测试结果如图：\n\n',normalizedContent:'# 1 最小生成树（minimum spanning tree,mst）\n\n在一给定的无向图g=(v,e)g = (v, e)g=(v,e) 中，(u,v)(u, v)(u,v)代表连接顶点uuu 与顶点 vvv 的边，而 w(u,v)w(u, v)w(u,v) 代表此边的权重，若存在 ttt 为 eee 的子集且为无循环图，使得 w(t)w(t)w(t) 最小，则此 ttt 为 ggg 的最小生成树，因为ttt是由图ggg产生的。\n\n\n\n最小生成树其实是最小权重生成树的简称。我们称求取该生成树的问题成为最小生成树问题。一个连通图可能有多个生成树。当图中的边具有权值时，总会有一个生成树的边的权值之和小于或者等于其它生成树的边的权值之和。广义上而言，对于非连通无向图来说，它的每一连通分量同样有最小生成树，它们的并被称为最小生成森林。以有线电视电缆的架设为例，若只能沿着街道布线，则以街道为边，而路口为顶点，其中必然有一最小生成树能使布线成本最低。\n\n\n\n如图，这个是一个平面图，图中黑色线描述的就是最小生成树，它的权值之和小于其他的生成树。\n\n那么，我们如何来求最小生成树呢，由最小生成树的定义我们可以知道构建最小生成树是可以利用贪心算法去实现的，我们接下来介绍的两种算法也都是利用贪心算法去求得mstmstmst的。因为贪心算法的策略就是在每一步尽可能多的选择中选择最优的，在当前看是最好的选择，这种策略虽然一般不能在全局中寻找到最优解，但是对于最小生成树问题来说，它的确可以找到一颗权重最小的树。\n\n\n# 2 prim算法\n\n\n# 2.1 简介\n\n普里姆算法（prim\'s algorithm），图论中的一种算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点，且其所有边的权值之和亦为最小。该算法于1930年由捷克数学家沃伊捷赫·亚尔尼克发现；并在1957年由美国计算机科学家罗伯特·普里姆独立发现；1959年，艾兹格·迪科斯彻再次发现了该算法。因此，在某些场合，普里姆算法又被称为djp算法、亚尔尼克算法或普里姆－亚尔尼克算法。（来源于维基百科）\n\n\n# 2.2 具体步骤\n\nprim算法是利用贪心算法实现的，我们确定根节点，从这个结点出发。普里姆算法按照以下步骤==逐步扩大树中所含顶点的数目，直到遍及连通图的所有顶点==。下面描述我们==假设n=(v,e)n=(v,e)n=(v,e)是连通网，tetete是nnn上最小生成树中边的集合==。\n\n① u={u0}(u0∈v),te={}u=\\{u_0\\}(u_0∈v) ,te= \\{\\}u={u0 }(u0 ∈v),te={}。\n\n② 在所有u∈u,v∈(v−u)u∈u,v∈(v-u)u∈u,v∈(v−u)的边(u,v)∈e(u,v)∈e(u,v)∈e找到一条权值最小的边(u0,v0)(u_0,v_0)(u0 ,v0 )并入集合tetete，同时v0v_0v0 并入集合uuu。\n\n③ 重复②步骤，知道u=vu=vu=v为止。\n\n此时tetete中必有n−1n-1n−1条边，则t=(v,te)t=(v,te)t=(v,te)即为我们求得的nnn的最小生成树。\n\n\n# 2.3 算法示例图\n\n\n\n\n# 2.4 算法实现\n\n我们如果对dijkstra算法很熟悉的话，prim算法也很好实现了，它们都是利用了一样的思路，但却不相同。我们用利用lowcostlowcostlowcost数组来表示到集合中最近的距离，用closestclosestclosest数组来表示最小生成树的边。怎么来表示呢？我们用顶点来形容边，也就是说我们要求的就是closetclosetcloset数组。其中closest[i]closest[i]closest[i]表示的值就是与iii顶点相邻边的顶点序号。具体看代码（附带打印最小生成树代码）。\n\n#include<bits/stdc++.h> //poj不支持\n\n#define rep(i,a,n) for (int i=a;i<=n;i++)//i为循环变量，a为初始值，n为界限值，递增\n#define per(i,a,n) for (int i=a;i>=n;i--)//i为循环变量， a为初始值，n为界限值，递减。\n#define pb push_back\n#define ios ios::sync_with_stdio(false);cin.tie(0); cout.tie(0)\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\nconst int inf = 0x3f3f3f3f;//无穷大\nconst int maxn = 1e3;//最大值。\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll>  pll;\ntypedef pair<int, int> pii;\n//*******************************分割线，以上为自定义代码模板***************************************//\n\nint n,m;//图的大小和边数。\nint graph[maxn][maxn];//图\nint lowcost[maxn],closest[maxn];//lowcost[i]表示i到距离集合最近的距离，closest[i]表示i与之相连边的顶点序号。\nint sum;//计算最小生成树的权值总和。\nvoid prim(int s){\n    //初始化操作，获取基本信息。\n    rep(i,1,n){\n        if(i==s)\n            lowcost[i]=0;\n        else\n            lowcost[i]=graph[s][i];\n        closest[i]=s;\n    }\n    int minn,pos;//距离集合最近的边，pos代表该点的终边下标。\n    sum=0;\n    rep(i,1,n){\n        minn=inf;\n        rep(j,1,n){\n            //找出距离点集合最近的边。\n            if(lowcost[j]!=0&&lowcost[j]<minn){\n                minn=lowcost[j];\n                pos=j;\n            }\n        }\n        if(minn==inf)break;//说明没有找到。\n        sum+=minn;//计算最小生成树的权值之和。\n        lowcost[pos]=0;//加入点集合。\n        rep(j,1,n){\n            //由于点集合中加入了新的点，我们要去更新。\n            if(lowcost[j]!=0&&graph[pos][j]<lowcost[j]){\n                lowcost[j]=graph[pos][j];\n                closest[j]=pos;//改变与顶点j相连的顶点序号。\n            }\n        }\n    }\n    cout<<sum<<endl;//closest数组就是我们要的最小生成树。它代表的就是边。\n}\nvoid print(int s){\n    //打印最小生成树。\n    int temp;\n    rep(i,1,n){\n        //等于s自然不算，故除去这个为n-1条边。\n        if(i!=s){\n            temp=closest[i];\n            cout<<temp<<"->"<<i<<"边权值为："<<graph[temp][i]<<endl;\n        }\n    }\n}\nint main(){\n    //freopen("in.txt", "r", stdin);//提交的时候要注释掉\n    ios;\n    while(cin>>n>>m){\n        memset(graph,inf,sizeof(graph));//初始化。\n        int u,v,w;//临时变量。\n        rep(i,1,m){\n            cin>>u>>v>>w;\n            //视情况而论，我这里以无向图为例。\n            graph[u][v]=graph[v][u]=w;\n        }\n        //任取根结点，我这里默认取1.\n        prim(1);\n        print(1);//打印最小生成树。\n    }\n    return 0;\n}\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n\n# 2.5 算法分析\n\n对于此算法，我们图中有nnn个顶点，则第一个进行初始化的循环语句的频度为nnn,第二个循环语句的频度为nnn，==但其中第二个循环中有两个内循环：第一个是在lowcostlowcostlowcost中求最小值，其频度为nnn，第二个是重新选择具有最小权值的边，频度为nnn==，由此我们可知prim算法的时间复杂度为o(n2)o(n^2)o(n2)，与图中的边数无关，故十分适合于稠密图。\n\n\n# 2.6 测试\n\n我们用示例来测试：\n\n7 11\n1 2 7\n1 4 5\n2 4 9\n2 3 8\n2 5 7\n4 5 15\n4 6 6\n6 7 11\n5 6 8\n5 7 9\n3 5 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n测试结果如图：\n\n',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"Linux常用命令、管道、环境变量",frontmatter:{title:"Linux常用命令、管道、环境变量",date:"2022-2-5",tags:["Linux"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/d66bf9/",categories:["开发","系统架构","Linux"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/01.Linux/01.Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E3%80%81%E7%AE%A1%E9%81%93%E3%80%81%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.html",relativePath:"01.开发/05.系统架构/01.Linux/01.Linux常用命令、管道、环境变量.md",key:"v-e792ddf8",path:"/pages/d66bf9/",headers:[{level:2,title:"1 Linux常用命令",slug:"_1-linux常用命令",normalizedTitle:"1 linux常用命令",charIndex:2},{level:3,title:"1.1 系统状况",slug:"_1-1-系统状况",normalizedTitle:"1.1 系统状况",charIndex:18},{level:3,title:"1.2 文件权限",slug:"_1-2-文件权限",normalizedTitle:"1.2 文件权限",charIndex:311},{level:3,title:"1.3 文件检索",slug:"_1-3-文件检索",normalizedTitle:"1.3 文件检索",charIndex:540},{level:3,title:"1.4 查看文件内容",slug:"_1-4-查看文件内容",normalizedTitle:"1.4 查看文件内容",charIndex:1251},{level:3,title:"1.5 用户相关",slug:"_1-5-用户相关",normalizedTitle:"1.5 用户相关",charIndex:1491},{level:3,title:"1.6 工具",slug:"_1-6-工具",normalizedTitle:"1.6 工具",charIndex:1547},{level:3,title:"1.7 安装软件",slug:"_1-7-安装软件",normalizedTitle:"1.7 安装软件",charIndex:1860},{level:2,title:"2 管道",slug:"_2-管道",normalizedTitle:"2 管道",charIndex:1980},{level:3,title:"2.1 管道命令",slug:"_2-1-管道命令",normalizedTitle:"2.1 管道命令",charIndex:1989},{level:3,title:"2.2 实例",slug:"_2-2-实例",normalizedTitle:"2.2 实例",charIndex:2381},{level:2,title:"3 环境变量",slug:"_3-环境变量",normalizedTitle:"3 环境变量",charIndex:2677},{level:3,title:"3.1 概念",slug:"_3-1-概念",normalizedTitle:"3.1 概念",charIndex:2688},{level:3,title:"3.2 查看环境变量",slug:"_3-2-查看环境变量",normalizedTitle:"3.2 查看环境变量",charIndex:2771},{level:3,title:"3.3 修改环境变量",slug:"_3-3-修改环境变量",normalizedTitle:"3.3 修改环境变量",charIndex:2925},{level:3,title:"3.4 常见环境变量",slug:"_3-4-常见环境变量",normalizedTitle:"3.4 常见环境变量",charIndex:3180}],headersStr:"1 Linux常用命令 1.1 系统状况 1.2 文件权限 1.3 文件检索 1.4 查看文件内容 1.5 用户相关 1.6 工具 1.7 安装软件 2 管道 2.1 管道命令 2.2 实例 3 环境变量 3.1 概念 3.2 查看环境变量 3.3 修改环境变量 3.4 常见环境变量",content:"# 1 Linux常用命令\n\n\n# 1.1 系统状况\n\ntop：查看所有进程的信息（Linux的任务管理器）。\n\n * 打开后输入M：按使用内存排序；\n * 打开后输入P：按使用CPU排序；\n * 打开后输入q：退出。\n\ndf -h：查看硬盘使用情况。 free -h：查看内存使用情况。 du -sh：查看当前目录占用的硬盘空间。 ps aux：查看所有进程。 kill -9 pid：杀死编号为pid的进程。 kill -s SIGTERM pid：传递某个具体的信号。 netstat -nt：查看所有网络连接。 w：列出当前登录的用户。 ping www.baidu.com：测试网络连接，检查是否联网。\n\n\n# 1.2 文件权限\n\nchmod：修改文件权限\n\n * chmod +x filename：给filename添加可执行权限；\n * chmod -x filename：去掉filename的可执行权限；\n * chmod abc filename:其中a，b，c各为一个数字，表示User、Group以及Other的权限。r=4，w=2，x=1，为读，写，可执行。 如设置所有人对该文件都可读可写可执行，则设置chmod 777 filename。\n\n\n# 1.3 文件检索\n\nfind <path>(文件路径) -name '*.py'：搜索path路径下的所有py文件。 grep xxx：从stdin中读入若干行数据，如果某行中包含xxx，则输出该行，否则忽略该行。 wc：统计行数、单词数、字节数。\n\n * 既可以从stdin中直接读取内容，也可以在命令行参数中传入文件名列表。\n * wc -l：统计行数。\n * wc -w：统计单词数。\n * wc -c：统计字节数。\n\ntree：展示当前目录的文件结构。\n\n * tree path：展示某个目录的文件结构。\n * tree -a：显示隐藏文件。\n\nag xxx：搜索当前目录下的所有文件，检索xxx字符串。 cut：分割一行内容。\n\n * 从stdin中读入多行数据。\n * echo $PATH | cut -d ':' -f 3, 5：输出PATH用:分割后的第3、5列数据。\n * echo $PATH | cut -d ':' -f 3-5：输出PATH用:分割后的第3-5列数据。\n * echo $PATH | cut -c 3, 5：输出PATH的第3、5个字符。\n * echo $PATH | cut -c 3-5：输出PATH的第3-5个字符。\n\nsort：将每行内容按字典序排序。\n\n * 可以从stdin中读取多行数据。\n * 可以从命令行参数中读取文件名列表。\n\nxargs：将stdin中的数据用空格或回车分割成命令行参数，作为其他命令使用。\n\n * find . -name '*.py' | xargs cat | wc -l：统计当前目录下所有python文件的总行数。\n\n\n# 1.4 查看文件内容\n\nmore：浏览文件内容。\n\n * 回车或空格：下一行。\n * b：上一页。\n * q：退出。\n\nless：和more类似，功能更全。\n\n * 回车：下一行。\n * y：上一行。\n * Page Down：下一页。\n * Page Up：上一页。\n * q：退出。\n\nhead -3 xxx：显示xxx的前3行内容。\n\n * 同时支持从stdin读入内容。\n\ntail -3 xxx：显示xxx末尾3行内容。\n\n * 同时支持从stdin读入内容。\n\n\n# 1.5 用户相关\n\nhistory：展示当前用户的历史操作。内容存放在~/bash_history中。\n\n\n# 1.6 工具\n\nmd5Sum：计算md5的哈希值。\n\n * 也可以从stdin中读入内容，也可以在命令行参数中传入文件名列表。\n\ntime command：统计command命令的执行时间。 ipython3：交互式python环境。可以当作计算器，或者批量管理文件。 i command：!表示执行shell脚本命令。 watch -n 0.1 command：每隔0.1s就执行一次command命令。 tar：压缩文件。\n\n * tar -zcvf xxx.tar.gz /path：压缩。\n * tar -zxvf xxx.tar.gz：解压缩。\n\ndiff xxx yyy：查看文件xxx和yyy的不同点。\n\n\n# 1.7 安装软件\n\nsudo command：以root身份运行command命令。 apt-get install xxx：安装xxx软件。 pip install xxx --user --upgrade：安装python包。\n\n\n# 2 管道\n\n\n# 2.1 管道命令\n\n管道命令操作符是|，,它只能处理经由前面一个指令传出的正确输出信息，对错误信息信息没有直接处理能力。然后传递给下一个命令，作为标准的输入。 下图为管道命令的输出说明： 【指令1】正确输出，作为【指令2】的输入，然后【指令2】的输出作为【指令3】的输入 ，【指令3】输出就会直接显示在屏幕上面了。 通过管道之后，我们发现【指令1】和【指令2】的正确输出不显示在屏幕上面，只显示指令3的输出。\n\n其类似于之前学习的文件重定向，可以将前面一个命令的stdout重定向下一个命令的stdin。但与文件重定向有很大区别：文件重定向左边为命令，右边为文件；管道左右两边均为命令，左边有stdout，右边有stdin。\n\n值得注意的点：\n\n * 管道命令仅能处理stdout，忽略stderr。\n * 管道右边的命令必须能接受stdin。\n * 多个管道命令可以串联。\n\n\n# 2.2 实例\n\n * 统计当前目录下所有python文件的总行数 统计总行数，在前面常用命令学习中，我们已经会了：wc -l，统计当前目录所有的python文件，也易得为：find . -name '*.py'。那么我们需要解决的问题则是将所有python文件选出来得到其内容再统计。我们则可能会这样：find . -name '*.py' | cat | wc -l。但find . -name '*.py'得到的是字符串，我们还需要利用xargs将字符串分割作为命令行参数，这样即可达到效果。 即：find . -name '*.py' | xargs cat | wc -l。\n\n\n# 3 环境变量\n\n\n# 3.1 概念\n\nLinux系统中会用很多环境变量来记录配置信息。环境变量类似于全局变量，可以被各个进程访问到。我们可以通过修改环境变量来方便地修改系统配置。\n\n\n# 3.2 查看环境变量\n\n * 列出当前环境下的所有环境变量：\n\nenv # 显示当前用户的变量；\nset # 显示当前shell的变量，包含当前用户的变量；\nexport # 显示当前导出成用户变量的shell变量。\n\n\n1\n2\n3\n\n1\n2\n3\n\n * 输出某个环境变量的值：echo $PATH\n\n\n# 3.3 修改环境变量\n\n修改环境变量我们可以先将修改命令放到~/.bashrc文件中。修改完之后需执行source ~/.bashrc，来将修改应用到当前的bash环境下。\n\n为何将修改命令放到~/.bashrc，就可以确保修改会影响未来所有的环境呢？\n\n * 每次启动bash，都会先执行~/.bashrc。\n * 每次ssh登录远程服务器，都会启动一个bash命令行给我们。\n * 每次tmux新开一个pane，都会启动一个bash命令行给我们。\n * 未来所有的新开环境都会加载我们修改的内容。\n\n\n# 3.4 常见环境变量\n\nHOME：用户的家目录 PATH：可执行文件（命令）的存储路径。路径与路径之间用:分隔。当某个可执行文件同时出现多个路径中时，会选择从左到右数第一个路径中的执行。下列所有存储路径的环境变量，均采用从左到右的优先顺序。 LD_LIBRARY_PATH：用于指定动态链接库(.so文件)的路径，其内容是以冒号分隔的路径列表。 C_INCLUDE_PATH：C语言的头文件路径，内容是以冒号分隔的路径列表。 CPLUS_INCLUDE_PATH：CPP的头文件路径，内容是以冒号分隔的路径列表。 PYTHONPATH：Python导入包的路径，内容是以冒号分隔的路径列表。 JAVA_HOME：jdk的安装目录。 CLASSPATH：存放Java导入类的路径，内容是以冒号分隔的路径列表。",normalizedContent:"# 1 linux常用命令\n\n\n# 1.1 系统状况\n\ntop：查看所有进程的信息（linux的任务管理器）。\n\n * 打开后输入m：按使用内存排序；\n * 打开后输入p：按使用cpu排序；\n * 打开后输入q：退出。\n\ndf -h：查看硬盘使用情况。 free -h：查看内存使用情况。 du -sh：查看当前目录占用的硬盘空间。 ps aux：查看所有进程。 kill -9 pid：杀死编号为pid的进程。 kill -s sigterm pid：传递某个具体的信号。 netstat -nt：查看所有网络连接。 w：列出当前登录的用户。 ping www.baidu.com：测试网络连接，检查是否联网。\n\n\n# 1.2 文件权限\n\nchmod：修改文件权限\n\n * chmod +x filename：给filename添加可执行权限；\n * chmod -x filename：去掉filename的可执行权限；\n * chmod abc filename:其中a，b，c各为一个数字，表示user、group以及other的权限。r=4，w=2，x=1，为读，写，可执行。 如设置所有人对该文件都可读可写可执行，则设置chmod 777 filename。\n\n\n# 1.3 文件检索\n\nfind <path>(文件路径) -name '*.py'：搜索path路径下的所有py文件。 grep xxx：从stdin中读入若干行数据，如果某行中包含xxx，则输出该行，否则忽略该行。 wc：统计行数、单词数、字节数。\n\n * 既可以从stdin中直接读取内容，也可以在命令行参数中传入文件名列表。\n * wc -l：统计行数。\n * wc -w：统计单词数。\n * wc -c：统计字节数。\n\ntree：展示当前目录的文件结构。\n\n * tree path：展示某个目录的文件结构。\n * tree -a：显示隐藏文件。\n\nag xxx：搜索当前目录下的所有文件，检索xxx字符串。 cut：分割一行内容。\n\n * 从stdin中读入多行数据。\n * echo $path | cut -d ':' -f 3, 5：输出path用:分割后的第3、5列数据。\n * echo $path | cut -d ':' -f 3-5：输出path用:分割后的第3-5列数据。\n * echo $path | cut -c 3, 5：输出path的第3、5个字符。\n * echo $path | cut -c 3-5：输出path的第3-5个字符。\n\nsort：将每行内容按字典序排序。\n\n * 可以从stdin中读取多行数据。\n * 可以从命令行参数中读取文件名列表。\n\nxargs：将stdin中的数据用空格或回车分割成命令行参数，作为其他命令使用。\n\n * find . -name '*.py' | xargs cat | wc -l：统计当前目录下所有python文件的总行数。\n\n\n# 1.4 查看文件内容\n\nmore：浏览文件内容。\n\n * 回车或空格：下一行。\n * b：上一页。\n * q：退出。\n\nless：和more类似，功能更全。\n\n * 回车：下一行。\n * y：上一行。\n * page down：下一页。\n * page up：上一页。\n * q：退出。\n\nhead -3 xxx：显示xxx的前3行内容。\n\n * 同时支持从stdin读入内容。\n\ntail -3 xxx：显示xxx末尾3行内容。\n\n * 同时支持从stdin读入内容。\n\n\n# 1.5 用户相关\n\nhistory：展示当前用户的历史操作。内容存放在~/bash_history中。\n\n\n# 1.6 工具\n\nmd5sum：计算md5的哈希值。\n\n * 也可以从stdin中读入内容，也可以在命令行参数中传入文件名列表。\n\ntime command：统计command命令的执行时间。 ipython3：交互式python环境。可以当作计算器，或者批量管理文件。 i command：!表示执行shell脚本命令。 watch -n 0.1 command：每隔0.1s就执行一次command命令。 tar：压缩文件。\n\n * tar -zcvf xxx.tar.gz /path：压缩。\n * tar -zxvf xxx.tar.gz：解压缩。\n\ndiff xxx yyy：查看文件xxx和yyy的不同点。\n\n\n# 1.7 安装软件\n\nsudo command：以root身份运行command命令。 apt-get install xxx：安装xxx软件。 pip install xxx --user --upgrade：安装python包。\n\n\n# 2 管道\n\n\n# 2.1 管道命令\n\n管道命令操作符是|，,它只能处理经由前面一个指令传出的正确输出信息，对错误信息信息没有直接处理能力。然后传递给下一个命令，作为标准的输入。 下图为管道命令的输出说明： 【指令1】正确输出，作为【指令2】的输入，然后【指令2】的输出作为【指令3】的输入 ，【指令3】输出就会直接显示在屏幕上面了。 通过管道之后，我们发现【指令1】和【指令2】的正确输出不显示在屏幕上面，只显示指令3的输出。\n\n其类似于之前学习的文件重定向，可以将前面一个命令的stdout重定向下一个命令的stdin。但与文件重定向有很大区别：文件重定向左边为命令，右边为文件；管道左右两边均为命令，左边有stdout，右边有stdin。\n\n值得注意的点：\n\n * 管道命令仅能处理stdout，忽略stderr。\n * 管道右边的命令必须能接受stdin。\n * 多个管道命令可以串联。\n\n\n# 2.2 实例\n\n * 统计当前目录下所有python文件的总行数 统计总行数，在前面常用命令学习中，我们已经会了：wc -l，统计当前目录所有的python文件，也易得为：find . -name '*.py'。那么我们需要解决的问题则是将所有python文件选出来得到其内容再统计。我们则可能会这样：find . -name '*.py' | cat | wc -l。但find . -name '*.py'得到的是字符串，我们还需要利用xargs将字符串分割作为命令行参数，这样即可达到效果。 即：find . -name '*.py' | xargs cat | wc -l。\n\n\n# 3 环境变量\n\n\n# 3.1 概念\n\nlinux系统中会用很多环境变量来记录配置信息。环境变量类似于全局变量，可以被各个进程访问到。我们可以通过修改环境变量来方便地修改系统配置。\n\n\n# 3.2 查看环境变量\n\n * 列出当前环境下的所有环境变量：\n\nenv # 显示当前用户的变量；\nset # 显示当前shell的变量，包含当前用户的变量；\nexport # 显示当前导出成用户变量的shell变量。\n\n\n1\n2\n3\n\n1\n2\n3\n\n * 输出某个环境变量的值：echo $path\n\n\n# 3.3 修改环境变量\n\n修改环境变量我们可以先将修改命令放到~/.bashrc文件中。修改完之后需执行source ~/.bashrc，来将修改应用到当前的bash环境下。\n\n为何将修改命令放到~/.bashrc，就可以确保修改会影响未来所有的环境呢？\n\n * 每次启动bash，都会先执行~/.bashrc。\n * 每次ssh登录远程服务器，都会启动一个bash命令行给我们。\n * 每次tmux新开一个pane，都会启动一个bash命令行给我们。\n * 未来所有的新开环境都会加载我们修改的内容。\n\n\n# 3.4 常见环境变量\n\nhome：用户的家目录 path：可执行文件（命令）的存储路径。路径与路径之间用:分隔。当某个可执行文件同时出现多个路径中时，会选择从左到右数第一个路径中的执行。下列所有存储路径的环境变量，均采用从左到右的优先顺序。 ld_library_path：用于指定动态链接库(.so文件)的路径，其内容是以冒号分隔的路径列表。 c_include_path：c语言的头文件路径，内容是以冒号分隔的路径列表。 cplus_include_path：cpp的头文件路径，内容是以冒号分隔的路径列表。 pythonpath：python导入包的路径，内容是以冒号分隔的路径列表。 java_home：jdk的安装目录。 classpath：存放java导入类的路径，内容是以冒号分隔的路径列表。",charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"Linux常用文件管理命令",frontmatter:{title:"Linux常用文件管理命令",date:"2022-01-21T00:00:00.000Z",tags:["Linux"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/b04f81/",categories:["开发","系统架构","Linux"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/01.Linux/02.Linux%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4.html",relativePath:"01.开发/05.系统架构/01.Linux/02.Linux常用文件管理命令.md",key:"v-0b3ccae2",path:"/pages/b04f81/",headers:[{level:2,title:"1. 通用基础知识",slug:"_1-通用基础知识",normalizedTitle:"1. 通用基础知识",charIndex:2},{level:2,title:"2. 文件基础操作",slug:"_2-文件基础操作",normalizedTitle:"2. 文件基础操作",charIndex:197},{level:2,title:"3 编译运行C/C++文件",slug:"_3-编译运行c-c-文件",normalizedTitle:"3 编译运行c/c++文件",charIndex:1975},{level:2,title:"4 参考文献",slug:"_4-参考文献",normalizedTitle:"4 参考文献",charIndex:2152}],headersStr:"1. 通用基础知识 2. 文件基础操作 3 编译运行C/C++文件 4 参考文献",content:'# 1. 通用基础知识\n\n * 查询指令命令help，通过指令名 --help或者man 指令名。\n   \n   例如，我们需要查询ls这个指令的参数用法以及作用，即通过ls --help即可得到如下：\n   \n   \n\n * ctrl c：取消命令，并且换行。\n\n * ctrl u：清空本行命令\n\n * tab：补全命令和文件名，如果补全不了就快速按两下tab键，可以显示备选项。\n\n\n# 2. 文件基础操作\n\n * 注意事项\n   \n   * 如果文件名或者文件夹名存在空格或者一些特殊字符，我们要进行转移表示，即通过转移字符\\来实现。\n   * \n\n * 创建文件夹：mkdir [-p][dirNmae]\n   \n   其中-p确保目录名称一定存在，如果不存在就会创建一个。\n\n * 创建文件：touch [dirName + fileName]\n\n * 显示当前目录下或者指定目录下的所有文件：ls [参数][dirName]\n   \n   其中显示的蓝色是文件夹，白色是普通文件，绿色是可执行文件，如图：\n   \n   \n   \n   参数有：\n   \n   * -a显示所有文件及目录 (. 开头的隐藏文件也会列出)\n   * -l除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出\n   * -r 将文件以相反次序显示(原定依英文字母次序)\n   * -t将文件依建立时间之先后次序列出\n   * -A 同 -a，但不列出 "." (目前目录) 及 ".." (父目录)\n   * -F 在列出的文件名称后加一符号；例如可执行档则加 "*", 目录则加 "/"\n   * -R 若目录下有文件，则以下之文件亦皆依序列出\n\n * 显示目前所在的工作目录的绝对路径名称：pwd\n\n * 切换当前工作目录：cd [dirName]\n   \n   其中dirName可为绝对路径或相对路径，如果没有给出，默认返回家目录。cd -会返回之前的工作目录\n\n * 删除文件或文件夹：rm [dirName] [options]，\n   \n   其中选项包括：\n   \n   ` -i` 删除前逐一询问确认。\n   \n   \n   -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。\n   \n   -r 将目录及以下之档案亦逐一删除,递归所有的子目录,逐一询问。\n   \n   一般删除普通文件直接使用rm [dirName]\n\n * 创建编写文件：vim [dirName]\n   \n   创建好之后会自动进入文件，这个时候我们事写不动东西的，所以我们需要输入小写字母i（为insert的缩写）即可写入，写完之后如何保存？我们先需要按ESC键锁住文件，再输入:wq即可，这个命令就是保存并退出的意思。\n\n * 查看文件：cat [dirName]\n\n * 复制文件：cp [options] source dest\n   \n   其中参数说明：\n   \n   * -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。\n   * -d：复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式。\n   * -f：覆盖已经存在的目标文件而不给出提示。\n   * -i：与 -f 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答 y 时目标文件将被覆盖。\n   * -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。\n   * -r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。复制目录的时候一定要添加的参数\n   * -l：不复制文件，只是生成链接文件。\n   \n   即cp = 复制+粘贴+重命名，我们可以看一个例子cp a/tmp.txt b/tmp2.txt，那么会从a中的\n   \n   tmp.txt复制到b中并重命名为tmp2.txt。\n\n * 为文件或目录改名、或将文件或目录移入其它位置：mv [options] source dest。\n   \n   如果需要重命名，就在后面加上新的文件名。\n   \n   其中参数说明\n   \n   * -b: 当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。\n   * -i: 如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作。\n   * -f: 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。\n   * -n: 不要覆盖任何已存在的文件或目录。\n   * -u：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。\n\n\n# 3 编译运行C/C++文件\n\n * 编译\n   \n   g++ 文件名.cpp -o 文件名 -std=版本\n   \n   例如:g++ main.cpp -o main -std=c++11\n   \n   \n   \n   值得注意的一点就是在AC Terminal里面是用不了万能头文件的。\n\n * 运行\n   \n   ./文件名，即可运行。\n\n\n# 4 参考文献\n\ny总Linux基础课',normalizedContent:'# 1. 通用基础知识\n\n * 查询指令命令help，通过指令名 --help或者man 指令名。\n   \n   例如，我们需要查询ls这个指令的参数用法以及作用，即通过ls --help即可得到如下：\n   \n   \n\n * ctrl c：取消命令，并且换行。\n\n * ctrl u：清空本行命令\n\n * tab：补全命令和文件名，如果补全不了就快速按两下tab键，可以显示备选项。\n\n\n# 2. 文件基础操作\n\n * 注意事项\n   \n   * 如果文件名或者文件夹名存在空格或者一些特殊字符，我们要进行转移表示，即通过转移字符\\来实现。\n   * \n\n * 创建文件夹：mkdir [-p][dirnmae]\n   \n   其中-p确保目录名称一定存在，如果不存在就会创建一个。\n\n * 创建文件：touch [dirname + filename]\n\n * 显示当前目录下或者指定目录下的所有文件：ls [参数][dirname]\n   \n   其中显示的蓝色是文件夹，白色是普通文件，绿色是可执行文件，如图：\n   \n   \n   \n   参数有：\n   \n   * -a显示所有文件及目录 (. 开头的隐藏文件也会列出)\n   * -l除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出\n   * -r 将文件以相反次序显示(原定依英文字母次序)\n   * -t将文件依建立时间之先后次序列出\n   * -a 同 -a，但不列出 "." (目前目录) 及 ".." (父目录)\n   * -f 在列出的文件名称后加一符号；例如可执行档则加 "*", 目录则加 "/"\n   * -r 若目录下有文件，则以下之文件亦皆依序列出\n\n * 显示目前所在的工作目录的绝对路径名称：pwd\n\n * 切换当前工作目录：cd [dirname]\n   \n   其中dirname可为绝对路径或相对路径，如果没有给出，默认返回家目录。cd -会返回之前的工作目录\n\n * 删除文件或文件夹：rm [dirname] [options]，\n   \n   其中选项包括：\n   \n   ` -i` 删除前逐一询问确认。\n   \n   \n   -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。\n   \n   -r 将目录及以下之档案亦逐一删除,递归所有的子目录,逐一询问。\n   \n   一般删除普通文件直接使用rm [dirname]\n\n * 创建编写文件：vim [dirname]\n   \n   创建好之后会自动进入文件，这个时候我们事写不动东西的，所以我们需要输入小写字母i（为insert的缩写）即可写入，写完之后如何保存？我们先需要按esc键锁住文件，再输入:wq即可，这个命令就是保存并退出的意思。\n\n * 查看文件：cat [dirname]\n\n * 复制文件：cp [options] source dest\n   \n   其中参数说明：\n   \n   * -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpr参数组合。\n   * -d：复制时保留链接。这里所说的链接相当于 windows 系统中的快捷方式。\n   * -f：覆盖已经存在的目标文件而不给出提示。\n   * -i：与 -f 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答 y 时目标文件将被覆盖。\n   * -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。\n   * -r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。复制目录的时候一定要添加的参数\n   * -l：不复制文件，只是生成链接文件。\n   \n   即cp = 复制+粘贴+重命名，我们可以看一个例子cp a/tmp.txt b/tmp2.txt，那么会从a中的\n   \n   tmp.txt复制到b中并重命名为tmp2.txt。\n\n * 为文件或目录改名、或将文件或目录移入其它位置：mv [options] source dest。\n   \n   如果需要重命名，就在后面加上新的文件名。\n   \n   其中参数说明\n   \n   * -b: 当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。\n   * -i: 如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作。\n   * -f: 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。\n   * -n: 不要覆盖任何已存在的文件或目录。\n   * -u：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。\n\n\n# 3 编译运行c/c++文件\n\n * 编译\n   \n   g++ 文件名.cpp -o 文件名 -std=版本\n   \n   例如:g++ main.cpp -o main -std=c++11\n   \n   \n   \n   值得注意的一点就是在ac terminal里面是用不了万能头文件的。\n\n * 运行\n   \n   ./文件名，即可运行。\n\n\n# 4 参考文献\n\ny总linux基础课',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"Docker入门教程",frontmatter:{title:"Docker入门教程",date:"2022-02-13T00:00:00.000Z",tags:["Docker"],author:{name:"Pursuit"},link:"https://github.com/unique-pure",permalink:"/pages/12de46/",categories:["开发","云原生","容器化技术"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/07.%E4%BA%91%E5%8E%9F%E7%94%9F/01.%E5%AE%B9%E5%99%A8%E5%8C%96%E6%8A%80%E6%9C%AF/01.Docker%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B.html",relativePath:"01.开发/07.云原生/01.容器化技术/01.Docker入门教程.md",key:"v-7f9d059f",path:"/pages/12de46/",headers:[{level:2,title:"1 初识Docker",slug:"_1-初识docker",normalizedTitle:"1 初识docker",charIndex:2},{level:3,title:"1.1 Docker开源项目",slug:"_1-1-docker开源项目",normalizedTitle:"1.1 docker开源项目",charIndex:17},{level:3,title:"1.2 Linux容器技术",slug:"_1-2-linux容器技术",normalizedTitle:"1.2 linux容器技术",charIndex:252},{level:3,title:"1.3 为什么要使用Docker",slug:"_1-3-为什么要使用docker",normalizedTitle:"1.3 为什么要使用docker",charIndex:700},{level:3,title:"1.4 Docker的核心概念",slug:"_1-4-docker的核心概念",normalizedTitle:"1.4 docker的核心概念",charIndex:1328},{level:3,title:"1.5 Docker安装（Linux）",slug:"_1-5-docker安装-linux",normalizedTitle:"1.5 docker安装（linux）",charIndex:2449},{level:2,title:"2 镜像具体操作",slug:"_2-镜像具体操作",normalizedTitle:"2 镜像具体操作",charIndex:2479},{level:3,title:"2.1 获取镜像",slug:"_2-1-获取镜像",normalizedTitle:"2.1 获取镜像",charIndex:2492},{level:3,title:"2.2 查看镜像信息",slug:"_2-2-查看镜像信息",normalizedTitle:"2.2 查看镜像信息",charIndex:3051},{level:3,title:"2.3 搜寻镜像",slug:"_2-3-搜寻镜像",normalizedTitle:"2.3 搜寻镜像",charIndex:3694},{level:3,title:"2.4 删除镜像",slug:"_2-4-删除镜像",normalizedTitle:"2.4 删除镜像",charIndex:3931},{level:3,title:"2.5 创建镜像",slug:"_2-5-创建镜像",normalizedTitle:"2.5 创建镜像",charIndex:4229},{level:4,title:"2.5.1 基于已有镜像的容器创建",slug:"_2-5-1-基于已有镜像的容器创建",normalizedTitle:"2.5.1 基于已有镜像的容器创建",charIndex:4290},{level:4,title:"2.5.2 基于本地模板导入",slug:"_2-5-2-基于本地模板导入",normalizedTitle:"2.5.2 基于本地模板导入",charIndex:4611},{level:4,title:"2.5.3 基于Dockerfile创建",slug:"_2-5-3-基于dockerfile创建",normalizedTitle:"2.5.3 基于dockerfile创建",charIndex:4887},{level:3,title:"2.6 存出和载入镜像",slug:"_2-6-存出和载入镜像",normalizedTitle:"2.6 存出和载入镜像",charIndex:5668},{level:3,title:"2.7 修改镜像",slug:"_2-7-修改镜像",normalizedTitle:"2.7 修改镜像",charIndex:6096},{level:3,title:"2.8 上传镜像",slug:"_2-8-上传镜像",normalizedTitle:"2.8 上传镜像",charIndex:6270},{level:2,title:"3 容器具体操作",slug:"_3-容器具体操作",normalizedTitle:"3 容器具体操作",charIndex:6514},{level:3,title:"3.1 查看容器",slug:"_3-1-查看容器",normalizedTitle:"3.1 查看容器",charIndex:6527},{level:3,title:"3.2 创建容器",slug:"_3-2-创建容器",normalizedTitle:"3.2 创建容器",charIndex:7025},{level:3,title:"3.3 启动终止容器",slug:"_3-3-启动终止容器",normalizedTitle:"3.3 启动终止容器",charIndex:7800},{level:3,title:"3.4 获取容器的日志",slug:"_3-4-获取容器的日志",normalizedTitle:"3.4 获取容器的日志",charIndex:8016},{level:3,title:"3.5 进入容器",slug:"_3-5-进入容器",normalizedTitle:"3.5 进入容器",charIndex:8193},{level:3,title:"3.6 删除容器",slug:"_3-6-删除容器",normalizedTitle:"3.6 删除容器",charIndex:8627},{level:3,title:"3.7 在本地和容器之间复制文件",slug:"_3-7-在本地和容器之间复制文件",normalizedTitle:"3.7 在本地和容器之间复制文件",charIndex:8875},{level:3,title:"3.8 修改容器",slug:"_3-8-修改容器",normalizedTitle:"3.8 修改容器",charIndex:9049},{level:3,title:"3.9 导入和导出容器",slug:"_3-9-导入和导出容器",normalizedTitle:"3.9 导入和导出容器",charIndex:9278},{level:4,title:"3.9.1 导出容器",slug:"_3-9-1-导出容器",normalizedTitle:"3.9.1 导出容器",charIndex:9293},{level:4,title:"3.9.2 导入容器",slug:"_3-9-2-导入容器",normalizedTitle:"3.9.2 导入容器",charIndex:9591},{level:2,title:"4 仓库",slug:"_4-仓库",normalizedTitle:"4 仓库",charIndex:9981},{level:3,title:"4.1 Docker Hub",slug:"_4-1-docker-hub",normalizedTitle:"4.1 docker hub",charIndex:9990},{level:4,title:"4.1.1 Linux登录登出DockerHub",slug:"_4-1-1-linux登录登出dockerhub",normalizedTitle:"4.1.1 linux登录登出dockerhub",charIndex:10008},{level:4,title:"4.1.2 基本操作",slug:"_4-1-2-基本操作",normalizedTitle:"4.1.2 基本操作",charIndex:10107},{level:4,title:"4.1.3 自动创建",slug:"_4-1-3-自动创建",normalizedTitle:"4.1.3 自动创建",charIndex:10417},{level:2,title:"5 网络基础配置",slug:"_5-网络基础配置",normalizedTitle:"5 网络基础配置",charIndex:10781},{level:3,title:"5.1 端口映射实现访问容器",slug:"_5-1-端口映射实现访问容器",normalizedTitle:"5.1 端口映射实现访问容器",charIndex:10794}],headersStr:"1 初识Docker 1.1 Docker开源项目 1.2 Linux容器技术 1.3 为什么要使用Docker 1.4 Docker的核心概念 1.5 Docker安装（Linux） 2 镜像具体操作 2.1 获取镜像 2.2 查看镜像信息 2.3 搜寻镜像 2.4 删除镜像 2.5 创建镜像 2.5.1 基于已有镜像的容器创建 2.5.2 基于本地模板导入 2.5.3 基于Dockerfile创建 2.6 存出和载入镜像 2.7 修改镜像 2.8 上传镜像 3 容器具体操作 3.1 查看容器 3.2 创建容器 3.3 启动终止容器 3.4 获取容器的日志 3.5 进入容器 3.6 删除容器 3.7 在本地和容器之间复制文件 3.8 修改容器 3.9 导入和导出容器 3.9.1 导出容器 3.9.2 导入容器 4 仓库 4.1 Docker Hub 4.1.1 Linux登录登出DockerHub 4.1.2 基本操作 4.1.3 自动创建 5 网络基础配置 5.1 端口映射实现访问容器",content:'# 1 初识Docker\n\n\n# 1.1 Docker开源项目\n\nDocker是基于Go语言实现的云开源项目，诞生于2013年初，用于支持创建和使用 Linux容器。它的主要目标是“Build, Ship and Run Any App, Anywhere”，即通过对应用封装（Packaging）、分发（Deployment）、运行（Runtime）等生命管理，达到应用组件级别的 “一次封装、到处运行” 。这里的应用组件既可以是一个应用，也可以是一套数据库服务，甚至是一个操作系统或编译器。\n\n\n# 1.2 Linux容器技术\n\nDocker引擎的基础是Linux容器（Linux Containers，LXC）技术。容器则是有效地将由单个操作系统管理的资源划分到孤立的组中，以便更好地在孤立间平衡有冲突的资源使用需求，而LXC项目则是借助容器设计理念，并基于一系列新的内核特性实现了更具有扩展性的虚拟化容器方案。更关键的是，LXC被集成到了主流Linux内核中，进而成为Linux系统轻量级容器技术的事实标准。 那么在LXC的基础上，Docker进一步优化了容器的使用体验。Docker提供了各种容器管理工具（如分发、版本、移植等）让用户无需关注底层的操作，可以简单明了管理和使用容器。用户操作Docker容器就像操作一个轻量级的虚拟机那样简单。\n\n我们可以将Docker容器理解为一种沙盒，每个容器运行一个应用，不同的容器相互隔离，容器之间也可以建立通信机制。容器的创建和停止都十分迅速，容器自身对资源的需求也十分有限，远远低于虚拟机。很多时候，甚至将容器比作是应用本身也没有问题。\n\n\n# 1.3 为什么要使用Docker\n\n * Docker容器虚拟化 举个简单的应用场景的例子，假设用户试图基于最常用的LAMP（Linux+Apache+MySQL+PHP）组合来运维一个网站。按照最传统的做法，首先需要安装Apache、Mysql和PHP以及它们各自运行所依赖的环境；之后分别对它们进行配置。经过大量操作后，然后还需要进行功能测试，看是否工作正常；如果不正常，则意味着更多的时间代价和不可控的风险。可以想象，如果再加上更多的应用，事情会变得更加难以处理。更为可怕的是，如果需要进行服务器迁移，如从腾讯云迁移到阿里云，往往需要重新部署和调试。而Docker提供了一种更为聪明的方式，通过容器来打包应用，意味着迁移只需要再服务器上启动需要的容器就可以了，节约大量的宝贵时间，并降低部署过程中出现问题的风险。\n * Docker在开发和运维的优势 Docker可以在任何环境、任意时间让应用正常运行。在开发和运维中有4大优势：更快速的交付和部署；更高效的资源利用；更轻松的迁移和扩展；更简单的更新管理。\n * Docker与虚拟机的比较\n\n特性      容器          虚拟机\n启动速度    秒级          分钟级\n硬盘使用    一般为MB       一般为GB\n性能      接近原生        弱于\n系统支持量   单机支持上千个容器   一般为几十个\n隔离性     安全隔离        完全隔离\n\n\n# 1.4 Docker的核心概念\n\nDocker有三大核心概念，如果我们理解了这三个核心概念，就能顺利理解Docker的整个生命周期。\n\n * 镜像（Image） Docker镜像（Image）类似于虚拟机镜像，可以理解为一个面向Docker引擎的只读模板，包含了文件系统。例如一个镜像可以只包含一个完整的Ubuntu操作系统环境，可以把它称为一个Ubuntu镜像。镜像也可以安装了Apache应用程序，可以把它称为一个Apache镜像。 镜像是创建Docker容器的基础。通过版本管理和增量的文件系统，Docker提供了一套十分简单的机制来创建和更新现有的镜像，用户甚至可以从网上下载一个已经做好的应用镜像，并通过简单的命令就可以直接使用。\n * 容器（Container） Docker容器（Container）类似于一个轻量级的沙箱，Docker利用容器来运行和隔离应用。容器是从镜像创建的应用运行实例，可以将其启动、开始、停止、删除，而这些容器都是相互隔离、互不可见的。我们实际是可以将容器看作是一个简易版的Linux系统环境（包括root用户权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序打包而成的应用盒子。 镜像自身是只读的。容器从镜像启动的时候，Docker会在镜像的最上层创建一个可写层，镜像本身将保持不变。如果认为虚拟机是模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用，那么Docker容器就是独立运行的一个或一组应用，以及它们的必需运行环境。\n * 仓库（Repository） Docker仓库（Repository）类似于代码仓库，是Docker集中存放镜像文件的场所。而注册服务器（Registry）是存放仓库的地方，其上往往存放着多个仓库。每个仓库集中存放某一类镜像，往往包括多个镜像文件，通过不同的标签（tag）来进行区分。例如存放Ubuntu操作系统镜像的仓库，称为Ubuntu仓库，其中可能包括20.04等不同版本的镜像。根据所存储的镜像公开分享与否，Docker仓库可以分为公开仓库（Public）和私有仓库（Private）两种形式。目前，最大的公开仓库是Docker Hub，存放着数量庞大的镜像供用户下载，国内的公开仓库包括Docker Pool等，可提供稳定的国内访问。 当然，用户如果不希望公开分享自己的镜像文件，Docker也支持用户在本地网络内创建一个只能自己访问的私有仓库。当用户创建了自己的镜像之后就可以使用push命令将它上传到指定的公有或者私有仓库。这样用户下次在另外一台机器上使用该镜像时，只需将其从仓库上pull下来就可以了。\n\n\n# 1.5 Docker安装（Linux）\n\n安装教程\n\n\n# 2 镜像具体操作\n\n\n# 2.1 获取镜像\n\n镜像是Docker运行容器的前提。使用docker pull命令即可从镜像仓库上下载指定镜像到本地。命令格式如下： docker pull [options] NAME[:TAG] options参数说明：\n\n * -a：拉取所有tagged镜像\n\n例如从Docker Hub的Ubuntu仓库下载一个最新版的Ubuntu操作系统的镜像\n\ndocker pull ubuntu:20.04 # 指定版本号，目前最新为20.04\ndocker pull ubuntu #该命令实际上下载的就是ubuntu:latest镜像。\n\n\n1\n2\n\n1\n2\n\n\n\n\n上面这两条命令实际上相当于docker pull registry.hub.docker.com/ubuntu:latest命令，即从默认的注册服务器registry.hub.docker.com中的ubuntu仓库来下载标记为latest的镜像。 我们也可以选择其他注册服务器的仓库下载。那么这个时候我们需要在仓库前指定完整的仓库注册服务器地址。例如从Docker Pool社区的镜像源d1.dockerpool.com下载最新的ubuntu镜像。 docker pull d1.dockerpool.com:5000/ubuntu\n\n\n# 2.2 查看镜像信息\n\n使用docker images命令可以列出本地主机上的所有镜像。命令格式如下： docker images [options] [repository:[tag]] options参数说明：\n\n * -a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；\n * -f :显示满足条件的镜像；\n * -q :只显示镜像ID。\n\n如果没有给出仓库名，那么默认列出本地主机上已有的镜像。我们使用docker images可以查看到如下信息： 可以看到几个字段信息：\n\n * repository：来自于哪个仓库，比如ubuntu仓库。\n * tag：镜像的标签信息，比如20.04或latest。用于标记来自同一个仓库的不同镜像。\n * image id：镜像的ID号，这个特别重要，唯一标识镜像。\n * created：镜像创建时间。\n * size：镜像大小。\n\n我们从图中可以发现，20.04和latest标签的镜像ID是完全一致的，说明它们实际上指向了同一个镜像文件，只是别名不同而已。标签在这里起到了引用或者快捷方式的作用。 我们使用docker inpsect NAME|ID即可查看该镜像的详细信息，为json格式。 我们还可以使用docker history命令查看指定镜像的创建历史，命令格式如下： docker history [options] IMAGE options说明：\n\n * -q :仅列出提交记录ID。\n\n\n# 2.3 搜寻镜像\n\n使用docker search命令可以搜索云端仓库中共享的镜像，默认搜寻Docker Hub官方仓库的镜像。命令格式如下： docker search [options] TERM options说明：\n\n * --automated :只列出 automated build类型的镜像；\n * --no-trunc :显示完整的镜像描述；\n * -f <过滤条件>:例如列出收藏数不小于指定值的镜像。\n\n例如搜寻带mysql关键字的镜像如下：\n\n\n# 2.4 删除镜像\n\n使用docker rmi命令可以删除镜像，命令格式如下： docker rmi IMAGE [IMAGE...] 其中IMAGE可以为镜像标签或者镜像ID，这ID可以为能进行区分的部分前缀串。 需要注意的是，当有该镜像创建的容器存在时，镜像文件时默认无法删除的，若想要强行删除文件则需要加入-f参数来强制删除一个存在容器依赖的镜像，但这样往往会造成一些遗留问题。正确的做法应该是先删除依赖该镜像的所有容器，再来删除镜像。 若要删除所有镜像，可用docker images -q列出所有的ID，正确命令为：docker rmi $(docker images -q)。\n\n\n# 2.5 创建镜像\n\n创建镜像的方法有三种：基于已有镜像的容器创建、基于本地模板导入、基于Dockerfile创建。\n\n# 2.5.1 基于已有镜像的容器创建\n\n使用docker commit命令即可从容器创建一个镜像，命令格式如下： docker commit [options] CONTAINER [REPOSITORY[:TAG]] options说明：\n\n * -a :提交的镜像作者；\n * -c :使用Dockerfile指令来创建镜像；\n * -m :提交时的说明文字；\n * -p :在commit时，将容器暂停。\n\nCONTAINER为容器ID。 顺利的话，命令会返回新创建的镜像的ID信息。 实例如下： docker commit -a "pursuit" -m "my ubuntu" 3c61e963210c myubuntu:v1\n\n# 2.5.2 基于本地模板导入\n\n可以从一个操作系统模板文件导入一个镜像，也可以从网上下载一个模板。一般使用OpenVZ提供的模板来创建。OpenVZ下载地址。 首先下载一个，命令如下： wget https://download.openvz.org/template/precreated/contrib/arch-20161108-x86_64.tar.gz\n\n然后将导入该镜像： cat arch-20161108-x86_64.tar.gz | docker import - arch:x86_64 查看新导入的镜像，已经本地存在了：\n\n# 2.5.3 基于Dockerfile创建\n\n其中Dockerfile是一个文本格式的配置文件，用户可以使用 Dockerfile 快速创建自定义的镜像。 Dockerfile由一行行命令语句组成，并且支持以#开头的注释。Dockerfile分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。例如下面的文件模板：\n\n# This dockerfile user the ubuntu image\n# VERSION 2 - EDITON 1\n# Author: docker_user\n# Command format: Instruction [arguments / command] ..\n\n# 第一行必须指定基于的基础镜像\nFROM ubuntu\n\n# 维护者信息\n# 例如MAINTAINER  docker_user docker_user@email.com\nMAINTAINER pursuit unique.hzf@gmail.com\n\n# 镜像的操作指令\n# RUN <command>，当命令较长，可以用\\来换行。\nRUN echo "Hello, World!"\n\n# 容器启动时执行指令\nCMD /bin/bash\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n创建好Dockerfile后，我们利用docker build命令，命令格式如下： docker build -t PATH|URL repository:tag 如，我们利用Dockerfile生成镜像 sudo docker build . -t arch:x86_64_01 查看本地镜像如下：\n\n\n# 2.6 存出和载入镜像\n\n我们可以使用docker save和docker load命令来存出和载入镜像。 存出即将镜像保存成tar归档文件，载入即将使用docker save命令导出的tar归档文件载入称为镜像文件。 命令格式如下：\n\ndocker save -o filename IMAGE\n或者\ndocker save IMAGE>filename\n\ndocker load --input filename\n或者\ndocker load <filename\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n实例： docker save -o files/ubuntu_20_04.tar ubuntu:20.04 然后我们需要删除ubuntu:20.04镜像，再导入。\n\ndocker rmi ubuntu:20.04\ndocker load <ubuntu_20_04.tar\n\n\n1\n2\n\n1\n2\n\n\n\n\n\n# 2.7 修改镜像\n\n使用docker tag命令可以标记本地镜像，将其归入某一仓库。命令格式如下： docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG] 实例： docker tag ubuntu:20.04 myubuntu/ubuntu:20.04\n\n\n# 2.8 上传镜像\n\n使用docker push命令将本地的镜像上传到镜像仓库，默认上传到DockerHub官方仓库。要先登陆到镜像仓库。命令格式如下： docker push NAME[:TAG] 例如用户user上传自己的本地镜像ubuntu:20.04，需要注意的是我们需要添加新的标签user/ubuntu:20.04（其中user一定要和我们的dockerhub中用户名同名，否则会报错）然后再上传。 之后，我们即可在DockerHub官网看到自己的仓库和上传的镜像了。\n\n\n# 3 容器具体操作\n\n\n# 3.1 查看容器\n\n使用docker ps命令即可列出容器，命令格式如下： docker ps [OPTIONS] 其中options说明：\n\n * -a :显示所有的容器，包括未运行的。\n * -f :根据条件过滤显示的内容。\n * -q :静默模式，只显示容器编号。\n\n我们运行docker ps -a可以得到如图： 其中输出字段说明如下：\n\n * CONTAINER ID: 容器 ID。\n * IMAGE: 使用的镜像。\n * COMMAND: 启动容器时运行的命令。\n * CREATED: 容器的创建时间。\n * STATUS: 容器状态。\n * PORTS: 容器的端口信息和使用的连接类型（tcp\\udp）。\n * NAMES: 自动分配的容器名称。\n\n我们也可以使用docker inspect命令列出容器的元信息，输出格式为json格式，这个命令在查看镜像章节已经说明了，用法相同，这里不再叙述。\n\n使用docker stats可以查看所有容器的统计信息，包括CPU、内存、存储、网络等信息。 使用docker top CONTAINER可查看某个容器内的所有进程。\n\n\n# 3.2 创建容器\n\nDocker的容器十分轻量级，用户可以随时创建或删除容器。\n\n * 新建容器 可以使用docker create命令新建一个容器，例如： docker create -it ubuntu:20.04 即利用镜像ubuntu:20.04创建容器。\n * 新建并启动一个容器 使用docker run命令创建并启动容器。其命令格式如下： docker run [OPTIONS] IMAGE [COMMAND] [ARG...] 其中options说明： 1.--name：为容器指定一个名称； 2.-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； 3.-d: 后台运行容器，并返回容器ID。 4.-i: 以交互模式运行容器，通常与 -t 同时使用。 当使用docker创建并启动容器时，Docker在后台运行的标准操作如下： 1.检查本地是否有指定的镜像，不存在就从公有仓库下载; 2.利用镜像创建并启动一个容器； 3.分配一个文件系统，并在只读的镜像层外面挂载一层可读写层； 4.从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去； 5.从地址池配置一个IP地址给容器； 6.执行用户指定的应用程序； 7.执行完毕后容器被终止。 下面这个实例将启动一个bash终端，允许用户进行交互，可以使用Linux命令。 docker run -it ubuntu:20.04 /bin/bash 其中root为用户名，@后面的为容器ID。我们用ps命令查看进程发现只运行了bash应用，并没有运行其他不需要的进程。可以使用Ctrl+d或输入exit命令来退出容器。当退出容器之后，该容器就自动处于终止状态了。 这是因为对于Docker容器来说，当运行的应用（此例子中为bash）退出后，容器也就没有再运行的必要了。\n\n\n# 3.3 启动终止容器\n\n * 启动容器 使用docker start可以启动一个已存在的容器。命令格式如下： docker start CONTAINER\n * 终止容器 使用docker stop可以启动一个已存在的容器。命令格式如下： docker stop CONTAINER\n * 重启容器 使用docker restart可以启动一个已存在的容器。命令格式如下： docker restart CONTAINER\n\n\n# 3.4 获取容器的日志\n\n使用docker logs即可获取容器的日志。命令格式如下： docker logs [OPTIONS] CONTAINER 其中OPTIONS说明：\n\n * -f : 跟踪日志输出\n * --since :显示某个开始时间的所有日志\n * -t : 显示时间戳\n * --tail :仅列出最新N条容器日志\n\n实例：\n\n\n# 3.5 进入容器\n\n在使用-d参数后，容器启动后会自动进入后台，用户无法看到容器中的信息。我们如果需要进入容器进行操作，有多种方法，这里介绍两种。\n\n * 使用docker attach 命令格式为：docker attach CONTAINER 在容器中，我们可以先按Ctrl-p，再按Ctrl-q可以挂起容器。 但是使用attach命令有时候并不方便。当多个窗口同时attach到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞后，其他窗口也无法执行操作了。\n * 使用docker exec命令 Docker自1.3版本起，提供了一个更方便的工具exec，该命令可以在运行的容器中执行命令，命令格式如下： docker exec [OPTIONS] CONTAINER COMMAND [ARG...] 其中OPTIONS说明： 1.-d :分离模式: 在后台运行 2.-i :即使没有附加也保持STDIN 打开 3.-t :分配一个伪终端\n\n\n# 3.6 删除容器\n\n可以使用docker rm命令来删除==处于终止状态的容器==，命令格式如下： docker rm [OPTIONS] CONTAINER [CONTAINER...] 其中OPTIONS说明：\n\n * -f :通过 SIGKILL 信号强制删除一个运行中的容器。\n * -l:移除容器间的网络连接，而非容器本身。即删除容器的连接，但保留容器。\n * -v :删除与容器关联的卷。\n\n如果需要删除所有容器，可使用docker rm $(docker ps -aq)。\n\n\n# 3.7 在本地和容器之间复制文件\n\n使用docker cp命令用于主机和容器之间的数据拷贝，命令格式如下：\n\ndocker cp xxx CONTAINER:xxx \ndocker cp CONTAINER:xxx xxx\n\n\n1\n2\n\n1\n2\n\n\n实例： docker cp data.txt 3c61e963210c:data.txt\n\n\n# 3.8 修改容器\n\n使用docker rename可以重命名容器，命令格式如下： docker rename CONTAINER1 CONTAINER2 使用docker update可以修改容器配置，命令格式如下： docker update CONTAINER [options] 其中OPTIONS参数过多，使用的时候可以自行百度，例如我们修改容器的内存限制： docker update 3c61e963210 --memory 500MB\n\n\n# 3.9 导入和导出容器\n\n# 3.9.1 导出容器\n\n导出容器是指导出一个已经创建的容器到一个文件，不管此时这个容器是否处于运行状态，可以使用docker export命令导出容器。该命令格式如下：\n\ndocker export [options] xxx.tar CONTAINER \n或者\ndocker export [options] CONTAINER>xxx.tar\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n其中options说明：\n\n * -o :将输入内容写到文件。\n\n例如将id为3c61e963210的容器按日期保存为tar文件： 可以将这些文件传输到其他的机器上，在其他机器上通过导入命令实现容器的迁移。\n\n# 3.9.2 导入容器\n\n导出的文件又可以使用docker import命令导入，成为镜像，命令格式如下： docker import [OPTIONS] xxx.tar image_name:tag 其中OPTIONS说明：\n\n * -c :应用docker 指令创建镜像；\n * -m :提交时的说明文字。\n\n实例： docker import ubuntu-20220212.tar myubunt:latest 我们知道，前面我们学习过docker load命令来导入一个镜像文件。实际上，既可以使用docker load命令来导入镜像存储文件到本地的镜像库，也可以使用docker import命令来导入一个容器快照到本地镜像库。 这两者的区别在于容器快照文件将丢弃所有的历史记录和元信息（仅保存容器当时的快照状态)，，而镜像存储文件将保存完整记录，体积也要大。\n\n\n# 4 仓库\n\n\n# 4.1 Docker Hub\n\n# 4.1.1 Linux登录登出DockerHub\n\n首先在dockerhub官网注册一个账号，然后使用docker login即可登录。登出则直接输入docker logout即可。 实例：\n\n# 4.1.2 基本操作\n\n用户无需登录即可通过docker search命令来查找官网仓库的镜像，并利用docker pull命令来将它下载到本地。 根据是否为官方提供， 可将这些镜像资源分为两类。一种类似ubuntu这样的基础镜像，称为基础或根镜像。这些镜像是由Docker公司创建、验证、支持、提供的。这样的镜像往往使用单个单词作为名字。还有一种类型，比如pursuit/ubuntu镜像，它是由DockerHub用户pursuit创建并维护的，带有用户名称为前缀，表明是某用户的某仓库。可通过用户名称前缀user_name/ 来指定使用某个用户提供的镜像，比如pursuit用户的镜像前缀为pursuit/。\n\n# 4.1.3 自动创建\n\n自动创建（Automated Builds）功能对于需要经常升级镜像内程序来说十分方便。有时候，用户创建了镜像，安装了某个软件，如果软件发布新版本则需要手动更新镜像。 而自动创建功能使得用户通过DockerHub指定追踪一个目标网站（目前支持Github或BitBucket）上的项目，一但发现项目新的提交，则自动执行创建。 要配置自动创建，有如下步骤： 1）创建并登录Docker Hub，以及目标网站； * 在目标网站中连接账户到Docker Hub。 2）在Docker Hub中配置一个自动创建。 3）选取一个目标网站中的项目（需要含Dockerfile）和分支。 4）指定Dockerfile的位置，并提交创建。 之后，就可以在DockerHub的”自动创建“页面跟踪每次创建的状态。\n\n\n# 5 网络基础配置\n\n\n# 5.1 端口映射实现访问容器\n\n大量的互联网应用服务包括多个服务组件，这往往需要多个容器之间通过网络通信进行相互配合。Docker目前提供了映射容器端口到宿主主机和容器互联机制来为容器提供互联网服务。\n\n在启动容器时，如果不指定对应参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。当容器中运行一些应用，要让外部访问这些应用时，可以通过-p参数来指定端口映射，并且，在一个指定的端口上只可以绑定一个容器。支持的格式有ip:hostPort:containerPort、ip::containerPort、hostPort:containerPort。\n\n * 映射所有接口地址 使用hostPort:containerPort格式将本地的4000端口映射到容器的4000端口，可以执行如下命令： docker run -itd -p 4000:4000 --name my_docker_ubuntu ubuntu:20.04 我们可以看到，已经实现了端口映射。多次使用-p标记可以绑定多个端口。例如： docker run -itd -p 4000:4000 -p 3000:3000 --name my_docker_ubuntu ubuntu:20.04\n * 映射到指定地址的指定端口 可以使用ip:hostPort:containerPort格式指定映射使用一个特定地址，比如localhost地址127.0.0.1： docker run -itd -p 127.0.0.1:3000:3000 --name my_docker_ubuntu ubuntu:20.04\n * 映射到指定地址的任意端口 使用ip::containerPort绑定localhost的任意端口到容器的5000端口，本地主机会自动分配一个端口： docker run -itd -p 127.0.0.1::5000 --name my_docker_ubuntu ubuntu:20.04\n * 查看映射端口配置 可以使用docker port container命令来查看当前映射的端口配置，也可以查看到绑定的地址。',normalizedContent:'# 1 初识docker\n\n\n# 1.1 docker开源项目\n\ndocker是基于go语言实现的云开源项目，诞生于2013年初，用于支持创建和使用 linux容器。它的主要目标是“build, ship and run any app, anywhere”，即通过对应用封装（packaging）、分发（deployment）、运行（runtime）等生命管理，达到应用组件级别的 “一次封装、到处运行” 。这里的应用组件既可以是一个应用，也可以是一套数据库服务，甚至是一个操作系统或编译器。\n\n\n# 1.2 linux容器技术\n\ndocker引擎的基础是linux容器（linux containers，lxc）技术。容器则是有效地将由单个操作系统管理的资源划分到孤立的组中，以便更好地在孤立间平衡有冲突的资源使用需求，而lxc项目则是借助容器设计理念，并基于一系列新的内核特性实现了更具有扩展性的虚拟化容器方案。更关键的是，lxc被集成到了主流linux内核中，进而成为linux系统轻量级容器技术的事实标准。 那么在lxc的基础上，docker进一步优化了容器的使用体验。docker提供了各种容器管理工具（如分发、版本、移植等）让用户无需关注底层的操作，可以简单明了管理和使用容器。用户操作docker容器就像操作一个轻量级的虚拟机那样简单。\n\n我们可以将docker容器理解为一种沙盒，每个容器运行一个应用，不同的容器相互隔离，容器之间也可以建立通信机制。容器的创建和停止都十分迅速，容器自身对资源的需求也十分有限，远远低于虚拟机。很多时候，甚至将容器比作是应用本身也没有问题。\n\n\n# 1.3 为什么要使用docker\n\n * docker容器虚拟化 举个简单的应用场景的例子，假设用户试图基于最常用的lamp（linux+apache+mysql+php）组合来运维一个网站。按照最传统的做法，首先需要安装apache、mysql和php以及它们各自运行所依赖的环境；之后分别对它们进行配置。经过大量操作后，然后还需要进行功能测试，看是否工作正常；如果不正常，则意味着更多的时间代价和不可控的风险。可以想象，如果再加上更多的应用，事情会变得更加难以处理。更为可怕的是，如果需要进行服务器迁移，如从腾讯云迁移到阿里云，往往需要重新部署和调试。而docker提供了一种更为聪明的方式，通过容器来打包应用，意味着迁移只需要再服务器上启动需要的容器就可以了，节约大量的宝贵时间，并降低部署过程中出现问题的风险。\n * docker在开发和运维的优势 docker可以在任何环境、任意时间让应用正常运行。在开发和运维中有4大优势：更快速的交付和部署；更高效的资源利用；更轻松的迁移和扩展；更简单的更新管理。\n * docker与虚拟机的比较\n\n特性      容器          虚拟机\n启动速度    秒级          分钟级\n硬盘使用    一般为mb       一般为gb\n性能      接近原生        弱于\n系统支持量   单机支持上千个容器   一般为几十个\n隔离性     安全隔离        完全隔离\n\n\n# 1.4 docker的核心概念\n\ndocker有三大核心概念，如果我们理解了这三个核心概念，就能顺利理解docker的整个生命周期。\n\n * 镜像（image） docker镜像（image）类似于虚拟机镜像，可以理解为一个面向docker引擎的只读模板，包含了文件系统。例如一个镜像可以只包含一个完整的ubuntu操作系统环境，可以把它称为一个ubuntu镜像。镜像也可以安装了apache应用程序，可以把它称为一个apache镜像。 镜像是创建docker容器的基础。通过版本管理和增量的文件系统，docker提供了一套十分简单的机制来创建和更新现有的镜像，用户甚至可以从网上下载一个已经做好的应用镜像，并通过简单的命令就可以直接使用。\n * 容器（container） docker容器（container）类似于一个轻量级的沙箱，docker利用容器来运行和隔离应用。容器是从镜像创建的应用运行实例，可以将其启动、开始、停止、删除，而这些容器都是相互隔离、互不可见的。我们实际是可以将容器看作是一个简易版的linux系统环境（包括root用户权限、进程空间、用户空间和网络空间等），以及运行在其中的应用程序打包而成的应用盒子。 镜像自身是只读的。容器从镜像启动的时候，docker会在镜像的最上层创建一个可写层，镜像本身将保持不变。如果认为虚拟机是模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用，那么docker容器就是独立运行的一个或一组应用，以及它们的必需运行环境。\n * 仓库（repository） docker仓库（repository）类似于代码仓库，是docker集中存放镜像文件的场所。而注册服务器（registry）是存放仓库的地方，其上往往存放着多个仓库。每个仓库集中存放某一类镜像，往往包括多个镜像文件，通过不同的标签（tag）来进行区分。例如存放ubuntu操作系统镜像的仓库，称为ubuntu仓库，其中可能包括20.04等不同版本的镜像。根据所存储的镜像公开分享与否，docker仓库可以分为公开仓库（public）和私有仓库（private）两种形式。目前，最大的公开仓库是docker hub，存放着数量庞大的镜像供用户下载，国内的公开仓库包括docker pool等，可提供稳定的国内访问。 当然，用户如果不希望公开分享自己的镜像文件，docker也支持用户在本地网络内创建一个只能自己访问的私有仓库。当用户创建了自己的镜像之后就可以使用push命令将它上传到指定的公有或者私有仓库。这样用户下次在另外一台机器上使用该镜像时，只需将其从仓库上pull下来就可以了。\n\n\n# 1.5 docker安装（linux）\n\n安装教程\n\n\n# 2 镜像具体操作\n\n\n# 2.1 获取镜像\n\n镜像是docker运行容器的前提。使用docker pull命令即可从镜像仓库上下载指定镜像到本地。命令格式如下： docker pull [options] name[:tag] options参数说明：\n\n * -a：拉取所有tagged镜像\n\n例如从docker hub的ubuntu仓库下载一个最新版的ubuntu操作系统的镜像\n\ndocker pull ubuntu:20.04 # 指定版本号，目前最新为20.04\ndocker pull ubuntu #该命令实际上下载的就是ubuntu:latest镜像。\n\n\n1\n2\n\n1\n2\n\n\n\n\n上面这两条命令实际上相当于docker pull registry.hub.docker.com/ubuntu:latest命令，即从默认的注册服务器registry.hub.docker.com中的ubuntu仓库来下载标记为latest的镜像。 我们也可以选择其他注册服务器的仓库下载。那么这个时候我们需要在仓库前指定完整的仓库注册服务器地址。例如从docker pool社区的镜像源d1.dockerpool.com下载最新的ubuntu镜像。 docker pull d1.dockerpool.com:5000/ubuntu\n\n\n# 2.2 查看镜像信息\n\n使用docker images命令可以列出本地主机上的所有镜像。命令格式如下： docker images [options] [repository:[tag]] options参数说明：\n\n * -a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；\n * -f :显示满足条件的镜像；\n * -q :只显示镜像id。\n\n如果没有给出仓库名，那么默认列出本地主机上已有的镜像。我们使用docker images可以查看到如下信息： 可以看到几个字段信息：\n\n * repository：来自于哪个仓库，比如ubuntu仓库。\n * tag：镜像的标签信息，比如20.04或latest。用于标记来自同一个仓库的不同镜像。\n * image id：镜像的id号，这个特别重要，唯一标识镜像。\n * created：镜像创建时间。\n * size：镜像大小。\n\n我们从图中可以发现，20.04和latest标签的镜像id是完全一致的，说明它们实际上指向了同一个镜像文件，只是别名不同而已。标签在这里起到了引用或者快捷方式的作用。 我们使用docker inpsect name|id即可查看该镜像的详细信息，为json格式。 我们还可以使用docker history命令查看指定镜像的创建历史，命令格式如下： docker history [options] image options说明：\n\n * -q :仅列出提交记录id。\n\n\n# 2.3 搜寻镜像\n\n使用docker search命令可以搜索云端仓库中共享的镜像，默认搜寻docker hub官方仓库的镜像。命令格式如下： docker search [options] term options说明：\n\n * --automated :只列出 automated build类型的镜像；\n * --no-trunc :显示完整的镜像描述；\n * -f <过滤条件>:例如列出收藏数不小于指定值的镜像。\n\n例如搜寻带mysql关键字的镜像如下：\n\n\n# 2.4 删除镜像\n\n使用docker rmi命令可以删除镜像，命令格式如下： docker rmi image [image...] 其中image可以为镜像标签或者镜像id，这id可以为能进行区分的部分前缀串。 需要注意的是，当有该镜像创建的容器存在时，镜像文件时默认无法删除的，若想要强行删除文件则需要加入-f参数来强制删除一个存在容器依赖的镜像，但这样往往会造成一些遗留问题。正确的做法应该是先删除依赖该镜像的所有容器，再来删除镜像。 若要删除所有镜像，可用docker images -q列出所有的id，正确命令为：docker rmi $(docker images -q)。\n\n\n# 2.5 创建镜像\n\n创建镜像的方法有三种：基于已有镜像的容器创建、基于本地模板导入、基于dockerfile创建。\n\n# 2.5.1 基于已有镜像的容器创建\n\n使用docker commit命令即可从容器创建一个镜像，命令格式如下： docker commit [options] container [repository[:tag]] options说明：\n\n * -a :提交的镜像作者；\n * -c :使用dockerfile指令来创建镜像；\n * -m :提交时的说明文字；\n * -p :在commit时，将容器暂停。\n\ncontainer为容器id。 顺利的话，命令会返回新创建的镜像的id信息。 实例如下： docker commit -a "pursuit" -m "my ubuntu" 3c61e963210c myubuntu:v1\n\n# 2.5.2 基于本地模板导入\n\n可以从一个操作系统模板文件导入一个镜像，也可以从网上下载一个模板。一般使用openvz提供的模板来创建。openvz下载地址。 首先下载一个，命令如下： wget https://download.openvz.org/template/precreated/contrib/arch-20161108-x86_64.tar.gz\n\n然后将导入该镜像： cat arch-20161108-x86_64.tar.gz | docker import - arch:x86_64 查看新导入的镜像，已经本地存在了：\n\n# 2.5.3 基于dockerfile创建\n\n其中dockerfile是一个文本格式的配置文件，用户可以使用 dockerfile 快速创建自定义的镜像。 dockerfile由一行行命令语句组成，并且支持以#开头的注释。dockerfile分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。例如下面的文件模板：\n\n# this dockerfile user the ubuntu image\n# version 2 - editon 1\n# author: docker_user\n# command format: instruction [arguments / command] ..\n\n# 第一行必须指定基于的基础镜像\nfrom ubuntu\n\n# 维护者信息\n# 例如maintainer  docker_user docker_user@email.com\nmaintainer pursuit unique.hzf@gmail.com\n\n# 镜像的操作指令\n# run <command>，当命令较长，可以用\\来换行。\nrun echo "hello, world!"\n\n# 容器启动时执行指令\ncmd /bin/bash\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n创建好dockerfile后，我们利用docker build命令，命令格式如下： docker build -t path|url repository:tag 如，我们利用dockerfile生成镜像 sudo docker build . -t arch:x86_64_01 查看本地镜像如下：\n\n\n# 2.6 存出和载入镜像\n\n我们可以使用docker save和docker load命令来存出和载入镜像。 存出即将镜像保存成tar归档文件，载入即将使用docker save命令导出的tar归档文件载入称为镜像文件。 命令格式如下：\n\ndocker save -o filename image\n或者\ndocker save image>filename\n\ndocker load --input filename\n或者\ndocker load <filename\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n实例： docker save -o files/ubuntu_20_04.tar ubuntu:20.04 然后我们需要删除ubuntu:20.04镜像，再导入。\n\ndocker rmi ubuntu:20.04\ndocker load <ubuntu_20_04.tar\n\n\n1\n2\n\n1\n2\n\n\n\n\n\n# 2.7 修改镜像\n\n使用docker tag命令可以标记本地镜像，将其归入某一仓库。命令格式如下： docker tag [options] image[:tag] [registryhost/][username/]name[:tag] 实例： docker tag ubuntu:20.04 myubuntu/ubuntu:20.04\n\n\n# 2.8 上传镜像\n\n使用docker push命令将本地的镜像上传到镜像仓库，默认上传到dockerhub官方仓库。要先登陆到镜像仓库。命令格式如下： docker push name[:tag] 例如用户user上传自己的本地镜像ubuntu:20.04，需要注意的是我们需要添加新的标签user/ubuntu:20.04（其中user一定要和我们的dockerhub中用户名同名，否则会报错）然后再上传。 之后，我们即可在dockerhub官网看到自己的仓库和上传的镜像了。\n\n\n# 3 容器具体操作\n\n\n# 3.1 查看容器\n\n使用docker ps命令即可列出容器，命令格式如下： docker ps [options] 其中options说明：\n\n * -a :显示所有的容器，包括未运行的。\n * -f :根据条件过滤显示的内容。\n * -q :静默模式，只显示容器编号。\n\n我们运行docker ps -a可以得到如图： 其中输出字段说明如下：\n\n * container id: 容器 id。\n * image: 使用的镜像。\n * command: 启动容器时运行的命令。\n * created: 容器的创建时间。\n * status: 容器状态。\n * ports: 容器的端口信息和使用的连接类型（tcp\\udp）。\n * names: 自动分配的容器名称。\n\n我们也可以使用docker inspect命令列出容器的元信息，输出格式为json格式，这个命令在查看镜像章节已经说明了，用法相同，这里不再叙述。\n\n使用docker stats可以查看所有容器的统计信息，包括cpu、内存、存储、网络等信息。 使用docker top container可查看某个容器内的所有进程。\n\n\n# 3.2 创建容器\n\ndocker的容器十分轻量级，用户可以随时创建或删除容器。\n\n * 新建容器 可以使用docker create命令新建一个容器，例如： docker create -it ubuntu:20.04 即利用镜像ubuntu:20.04创建容器。\n * 新建并启动一个容器 使用docker run命令创建并启动容器。其命令格式如下： docker run [options] image [command] [arg...] 其中options说明： 1.--name：为容器指定一个名称； 2.-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； 3.-d: 后台运行容器，并返回容器id。 4.-i: 以交互模式运行容器，通常与 -t 同时使用。 当使用docker创建并启动容器时，docker在后台运行的标准操作如下： 1.检查本地是否有指定的镜像，不存在就从公有仓库下载; 2.利用镜像创建并启动一个容器； 3.分配一个文件系统，并在只读的镜像层外面挂载一层可读写层； 4.从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去； 5.从地址池配置一个ip地址给容器； 6.执行用户指定的应用程序； 7.执行完毕后容器被终止。 下面这个实例将启动一个bash终端，允许用户进行交互，可以使用linux命令。 docker run -it ubuntu:20.04 /bin/bash 其中root为用户名，@后面的为容器id。我们用ps命令查看进程发现只运行了bash应用，并没有运行其他不需要的进程。可以使用ctrl+d或输入exit命令来退出容器。当退出容器之后，该容器就自动处于终止状态了。 这是因为对于docker容器来说，当运行的应用（此例子中为bash）退出后，容器也就没有再运行的必要了。\n\n\n# 3.3 启动终止容器\n\n * 启动容器 使用docker start可以启动一个已存在的容器。命令格式如下： docker start container\n * 终止容器 使用docker stop可以启动一个已存在的容器。命令格式如下： docker stop container\n * 重启容器 使用docker restart可以启动一个已存在的容器。命令格式如下： docker restart container\n\n\n# 3.4 获取容器的日志\n\n使用docker logs即可获取容器的日志。命令格式如下： docker logs [options] container 其中options说明：\n\n * -f : 跟踪日志输出\n * --since :显示某个开始时间的所有日志\n * -t : 显示时间戳\n * --tail :仅列出最新n条容器日志\n\n实例：\n\n\n# 3.5 进入容器\n\n在使用-d参数后，容器启动后会自动进入后台，用户无法看到容器中的信息。我们如果需要进入容器进行操作，有多种方法，这里介绍两种。\n\n * 使用docker attach 命令格式为：docker attach container 在容器中，我们可以先按ctrl-p，再按ctrl-q可以挂起容器。 但是使用attach命令有时候并不方便。当多个窗口同时attach到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞后，其他窗口也无法执行操作了。\n * 使用docker exec命令 docker自1.3版本起，提供了一个更方便的工具exec，该命令可以在运行的容器中执行命令，命令格式如下： docker exec [options] container command [arg...] 其中options说明： 1.-d :分离模式: 在后台运行 2.-i :即使没有附加也保持stdin 打开 3.-t :分配一个伪终端\n\n\n# 3.6 删除容器\n\n可以使用docker rm命令来删除==处于终止状态的容器==，命令格式如下： docker rm [options] container [container...] 其中options说明：\n\n * -f :通过 sigkill 信号强制删除一个运行中的容器。\n * -l:移除容器间的网络连接，而非容器本身。即删除容器的连接，但保留容器。\n * -v :删除与容器关联的卷。\n\n如果需要删除所有容器，可使用docker rm $(docker ps -aq)。\n\n\n# 3.7 在本地和容器之间复制文件\n\n使用docker cp命令用于主机和容器之间的数据拷贝，命令格式如下：\n\ndocker cp xxx container:xxx \ndocker cp container:xxx xxx\n\n\n1\n2\n\n1\n2\n\n\n实例： docker cp data.txt 3c61e963210c:data.txt\n\n\n# 3.8 修改容器\n\n使用docker rename可以重命名容器，命令格式如下： docker rename container1 container2 使用docker update可以修改容器配置，命令格式如下： docker update container [options] 其中options参数过多，使用的时候可以自行百度，例如我们修改容器的内存限制： docker update 3c61e963210 --memory 500mb\n\n\n# 3.9 导入和导出容器\n\n# 3.9.1 导出容器\n\n导出容器是指导出一个已经创建的容器到一个文件，不管此时这个容器是否处于运行状态，可以使用docker export命令导出容器。该命令格式如下：\n\ndocker export [options] xxx.tar container \n或者\ndocker export [options] container>xxx.tar\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n其中options说明：\n\n * -o :将输入内容写到文件。\n\n例如将id为3c61e963210的容器按日期保存为tar文件： 可以将这些文件传输到其他的机器上，在其他机器上通过导入命令实现容器的迁移。\n\n# 3.9.2 导入容器\n\n导出的文件又可以使用docker import命令导入，成为镜像，命令格式如下： docker import [options] xxx.tar image_name:tag 其中options说明：\n\n * -c :应用docker 指令创建镜像；\n * -m :提交时的说明文字。\n\n实例： docker import ubuntu-20220212.tar myubunt:latest 我们知道，前面我们学习过docker load命令来导入一个镜像文件。实际上，既可以使用docker load命令来导入镜像存储文件到本地的镜像库，也可以使用docker import命令来导入一个容器快照到本地镜像库。 这两者的区别在于容器快照文件将丢弃所有的历史记录和元信息（仅保存容器当时的快照状态)，，而镜像存储文件将保存完整记录，体积也要大。\n\n\n# 4 仓库\n\n\n# 4.1 docker hub\n\n# 4.1.1 linux登录登出dockerhub\n\n首先在dockerhub官网注册一个账号，然后使用docker login即可登录。登出则直接输入docker logout即可。 实例：\n\n# 4.1.2 基本操作\n\n用户无需登录即可通过docker search命令来查找官网仓库的镜像，并利用docker pull命令来将它下载到本地。 根据是否为官方提供， 可将这些镜像资源分为两类。一种类似ubuntu这样的基础镜像，称为基础或根镜像。这些镜像是由docker公司创建、验证、支持、提供的。这样的镜像往往使用单个单词作为名字。还有一种类型，比如pursuit/ubuntu镜像，它是由dockerhub用户pursuit创建并维护的，带有用户名称为前缀，表明是某用户的某仓库。可通过用户名称前缀user_name/ 来指定使用某个用户提供的镜像，比如pursuit用户的镜像前缀为pursuit/。\n\n# 4.1.3 自动创建\n\n自动创建（automated builds）功能对于需要经常升级镜像内程序来说十分方便。有时候，用户创建了镜像，安装了某个软件，如果软件发布新版本则需要手动更新镜像。 而自动创建功能使得用户通过dockerhub指定追踪一个目标网站（目前支持github或bitbucket）上的项目，一但发现项目新的提交，则自动执行创建。 要配置自动创建，有如下步骤： 1）创建并登录docker hub，以及目标网站； * 在目标网站中连接账户到docker hub。 2）在docker hub中配置一个自动创建。 3）选取一个目标网站中的项目（需要含dockerfile）和分支。 4）指定dockerfile的位置，并提交创建。 之后，就可以在dockerhub的”自动创建“页面跟踪每次创建的状态。\n\n\n# 5 网络基础配置\n\n\n# 5.1 端口映射实现访问容器\n\n大量的互联网应用服务包括多个服务组件，这往往需要多个容器之间通过网络通信进行相互配合。docker目前提供了映射容器端口到宿主主机和容器互联机制来为容器提供互联网服务。\n\n在启动容器时，如果不指定对应参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。当容器中运行一些应用，要让外部访问这些应用时，可以通过-p参数来指定端口映射，并且，在一个指定的端口上只可以绑定一个容器。支持的格式有ip:hostport:containerport、ip::containerport、hostport:containerport。\n\n * 映射所有接口地址 使用hostport:containerport格式将本地的4000端口映射到容器的4000端口，可以执行如下命令： docker run -itd -p 4000:4000 --name my_docker_ubuntu ubuntu:20.04 我们可以看到，已经实现了端口映射。多次使用-p标记可以绑定多个端口。例如： docker run -itd -p 4000:4000 -p 3000:3000 --name my_docker_ubuntu ubuntu:20.04\n * 映射到指定地址的指定端口 可以使用ip:hostport:containerport格式指定映射使用一个特定地址，比如localhost地址127.0.0.1： docker run -itd -p 127.0.0.1:3000:3000 --name my_docker_ubuntu ubuntu:20.04\n * 映射到指定地址的任意端口 使用ip::containerport绑定localhost的任意端口到容器的5000端口，本地主机会自动分配一个端口： docker run -itd -p 127.0.0.1::5000 --name my_docker_ubuntu ubuntu:20.04\n * 查看映射端口配置 可以使用docker port container命令来查看当前映射的端口配置，也可以查看到绑定的地址。',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"Linux用户和用户组教程",frontmatter:{title:"Linux用户和用户组教程",date:"2022-05-24T10:27:01.000Z",tags:["Linux"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},categories:["开发","系统架构","Linux"],permalink:"/pages/419777/",readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/01.Linux/03.Linux%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E6%95%99%E7%A8%8B.html",relativePath:"01.开发/05.系统架构/01.Linux/03.Linux用户和用户组教程.md",key:"v-38c4edfa",path:"/pages/419777/",headers:[{level:2,title:"1 用户和用户组介绍",slug:"_1-用户和用户组介绍",normalizedTitle:"1 用户和用户组介绍",charIndex:2},{level:3,title:"1.1 用户",slug:"_1-1-用户",normalizedTitle:"1.1 用户",charIndex:17},{level:3,title:"1.2 用户组",slug:"_1-2-用户组",normalizedTitle:"1.2 用户组",charIndex:1130},{level:3,title:"1.3 文件权限",slug:"_1-3-文件权限",normalizedTitle:"1.3 文件权限",charIndex:1987},{level:4,title:"1.3.1 文件所有者（User）",slug:"_1-3-1-文件所有者-user",normalizedTitle:"1.3.1 文件所有者（user）",charIndex:2311},{level:4,title:"1.3.2 用户组成员（Group）",slug:"_1-3-2-用户组成员-group",normalizedTitle:"1.3.2 用户组成员（group）",charIndex:2614},{level:4,title:"1.3.3 其他人（Others）",slug:"_1-3-3-其他人-others",normalizedTitle:"1.3.3 其他人（others）",charIndex:2903},{level:3,title:"1.3.4 超级管理员（root）",slug:"_1-3-4-超级管理员-root",normalizedTitle:"1.3.4 超级管理员（root）",charIndex:2971},{level:3,title:"1.4 AAA基础",slug:"_1-4-aaa基础",normalizedTitle:"1.4 aaa基础",charIndex:3153},{level:2,title:"2 用户和用户组文件",slug:"_2-用户和用户组文件",normalizedTitle:"2 用户和用户组文件",charIndex:3445},{level:3,title:"2.1 用户账号文件— /etc/passwd",slug:"_2-1-用户账号文件-etc-passwd",normalizedTitle:"2.1 用户账号文件— /etc/passwd",charIndex:3460},{level:3,title:"2.2 用户影子文件—/etc/shadow",slug:"_2-2-用户影子文件-etc-shadow",normalizedTitle:"2.2 用户影子文件—/etc/shadow",charIndex:4430},{level:3,title:"2.3 创建用户的默认设置文件—/etc/login.defs",slug:"_2-3-创建用户的默认设置文件-etc-login-defs",normalizedTitle:"2.3 创建用户的默认设置文件—/etc/login.defs",charIndex:5141},{level:3,title:"2.4 用户组账号文件—/etc/group",slug:"_2-4-用户组账号文件-etc-group",normalizedTitle:"2.4 用户组账号文件—/etc/group",charIndex:6557},{level:3,title:"2.5 用户组影子文件—/etc/gshadow",slug:"_2-5-用户组影子文件-etc-gshadow",normalizedTitle:"2.5 用户组影子文件—/etc/gshadow",charIndex:7119},{level:2,title:"3 用户和用户组管理",slug:"_3-用户和用户组管理",normalizedTitle:"3 用户和用户组管理",charIndex:7405},{level:3,title:"3.1 用户管理",slug:"_3-1-用户管理",normalizedTitle:"3.1 用户管理",charIndex:7420},{level:4,title:"3.1.1 使用useradd命令添加用户",slug:"_3-1-1-使用useradd命令添加用户",normalizedTitle:"3.1.1 使用useradd命令添加用户",charIndex:7432},{level:4,title:"3.1.2 使用usermod命令修改用户信息",slug:"_3-1-2-使用usermod命令修改用户信息",normalizedTitle:"3.1.2 使用usermod命令修改用户信息",charIndex:8460},{level:4,title:"3.1.3 使用userdel命令删除用户",slug:"_3-1-3-使用userdel命令删除用户",normalizedTitle:"3.1.3 使用userdel命令删除用户",charIndex:8896},{level:4,title:"3.1.4 使用passwd命令管理用户口令",slug:"_3-1-4-使用passwd命令管理用户口令",normalizedTitle:"3.1.4 使用passwd命令管理用户口令",charIndex:9022},{level:3,title:"3.2 用户组管理",slug:"_3-2-用户组管理",normalizedTitle:"3.2 用户组管理",charIndex:9349},{level:4,title:"3.2.1 使用groupadd命令创建用户组",slug:"_3-2-1-使用groupadd命令创建用户组",normalizedTitle:"3.2.1 使用groupadd命令创建用户组",charIndex:9362},{level:4,title:"3.2.2 使用groupmod修改",slug:"_3-2-2-使用groupmod修改",normalizedTitle:"3.2.2 使用groupmod修改",charIndex:9653},{level:4,title:"3.2.3 使用groupdel命令删除用户组",slug:"_3-2-3-使用groupdel命令删除用户组",normalizedTitle:"3.2.3 使用groupdel命令删除用户组",charIndex:9853},{level:4,title:"3.2.4 使用gpasswd命令管理用户组",slug:"_3-2-4-使用gpasswd命令管理用户组",normalizedTitle:"3.2.4 使用gpasswd命令管理用户组",charIndex:10007},{level:4,title:"3.2.5 使用newgrp命令切换用户的有效组",slug:"_3-2-5-使用newgrp命令切换用户的有效组",normalizedTitle:"3.2.5 使用newgrp命令切换用户的有效组",charIndex:10533},{level:2,title:"4 其他相关命令",slug:"_4-其他相关命令",normalizedTitle:"4 其他相关命令",charIndex:10850},{level:3,title:"4.1 id命令查看用户的UID和GID",slug:"_4-1-id命令查看用户的uid和gid",normalizedTitle:"4.1 id命令查看用户的uid和gid",charIndex:10863},{level:3,title:"4.2 su命令临时切换用户身份",slug:"_4-2-su命令临时切换用户身份",normalizedTitle:"4.2 su命令临时切换用户身份",charIndex:10960},{level:3,title:"4.3 whoami和who am i命令",slug:"_4-3-whoami和who-am-i命令",normalizedTitle:"4.3 whoami和who am i命令",charIndex:11473},{level:3,title:"4.4 users和groups命令",slug:"_4-4-users和groups命令",normalizedTitle:"4.4 users和groups命令",charIndex:11710},{level:2,title:"5 高级操作示例",slug:"_5-高级操作示例",normalizedTitle:"5 高级操作示例",charIndex:12045},{level:3,title:"5.1 通过更改用户和组的配置文件，直接添加或修改用户和组",slug:"_5-1-通过更改用户和组的配置文件-直接添加或修改用户和组",normalizedTitle:"5.1 通过更改用户和组的配置文件，直接添加或修改用户和组",charIndex:12058},{level:3,title:"5.2 Linux批量添加用户",slug:"_5-2-linux批量添加用户",normalizedTitle:"5.2 linux批量添加用户",charIndex:12928}],headersStr:"1 用户和用户组介绍 1.1 用户 1.2 用户组 1.3 文件权限 1.3.1 文件所有者（User） 1.3.2 用户组成员（Group） 1.3.3 其他人（Others） 1.3.4 超级管理员（root） 1.4 AAA基础 2 用户和用户组文件 2.1 用户账号文件— /etc/passwd 2.2 用户影子文件—/etc/shadow 2.3 创建用户的默认设置文件—/etc/login.defs 2.4 用户组账号文件—/etc/group 2.5 用户组影子文件—/etc/gshadow 3 用户和用户组管理 3.1 用户管理 3.1.1 使用useradd命令添加用户 3.1.2 使用usermod命令修改用户信息 3.1.3 使用userdel命令删除用户 3.1.4 使用passwd命令管理用户口令 3.2 用户组管理 3.2.1 使用groupadd命令创建用户组 3.2.2 使用groupmod修改 3.2.3 使用groupdel命令删除用户组 3.2.4 使用gpasswd命令管理用户组 3.2.5 使用newgrp命令切换用户的有效组 4 其他相关命令 4.1 id命令查看用户的UID和GID 4.2 su命令临时切换用户身份 4.3 whoami和who am i命令 4.4 users和groups命令 5 高级操作示例 5.1 通过更改用户和组的配置文件，直接添加或修改用户和组 5.2 Linux批量添加用户",content:'# 1 用户和用户组介绍\n\n\n# 1.1 用户\n\n任何操作系统都存在“用户”的概念，Linux也不例外。Linux系统是一个多用户多任务的分时操作系统，即Linux系统支持多个用户在同一时间内登录，不同用户可以执行不同的任务，并且互不影响。每个用户账号都拥有一个用户名和各自的口令（即密码）。在登录系统时，只有正确输入用户名和密码，才能进入系统和自己的主目录。\n\n在Linux中，用户分为两大类、三小类：分别为系统管理员（一般为root）和普通用户 。普通用户中，又划分为两类，分别为系统用户和登录用户。\n\n * 系统管理员：即超级管理员，可以操作系统中任意文件和命令，拥有最高的管理权限。\n * 普通用户\n   * 登录用户：为管理员手动添加的用户，默认仅拥有操作自身家目录中文件及目录的权限，以及进入与浏览相关目录文件的权限（如/etc、/var/log等），但没有创建、修改、删除等权限。\n   * 系统用户：一般为系统安装后默认存在的，且默认情况下不能登录系统，它们的存在主要是为了满足系统进程对文件属主的需求。 Tips：在部署某些服务是，也可以手动添加某些系统用户。\n\nLinux系统使用UID（User ID）来标识不同用户，说白了，其实Linux并不认识你的用户名称，它只认识用户名对应的UID。其中UID是16bit的二进制数字，所以换算成十进制，UID的范围是0~65535，Linux根据用户类别，对UID划分做了规定：\n\n * 0（系统管理员）：，当UID是0时，代表这个用户为超级管理员，所以当你想要其他的用户也有root权限时，将该用户的UID改为0即可。但一般来说，用户的UID应当是独一无二的，其他用户不应当有相同的UID数值，只有UID等于0时可以例外。\n * 1~499（系统账号）：该范围内的UID是保留给系统使用的 ID，其实 1~65534 之间的账号并没有不同， 也就是除了 0 之外，其它的 UID 并没有不一样，预设 500 以下给系统作为保留账号只是一个习惯。这样的好处是，以有名的 DNS 服务器的启动服务『 named 』为例，这个程序的预设所有人 named 的账号 UID 是 25 ，当你自定义的账号也是 25 时，会造成系统冲突！为了杜绝这样的问题，养成好习惯，保留 500 以前的 UID 给系统使用！ 一般来说， 1到99 会保留给系统预设的账号，另外 100~499 则保留给一些服务来使用。\n * 500~65535（登录用户）：给一般使用者用的。事实上，目前的 linux 核心 (2.6.x 版)已经可以支持到 4294967295 (2^32-1) 这么大的 UID 号码。\n\n\n# 1.2 用户组\n\n用户组是具有相同特征用户的逻辑集合。简单的理解，有时我们需要让多个用户具有相同的权限，比如查看、修改某一个文件的权限，一种方法是分别对多个用户进行文件访问授权，如果有 10 个用户的话，就需要授权 10 次，那如果有 100、1000 甚至更多的用户呢？\n\n显然，这种方法不太合理。最好的方式是建立一个组，让这个组具有查看、修改此文件的权限，然后将所有需要访问此文件的用户放入这个组中。那么，所有用户就具有了和组一样的权限，这就是用户组。将用户分组是 Linux 系统中对用户进行管理及控制访问权限的一种手段，通过定义用户组，很多程序上简化了对用户的管理工作。\n\nLinux对用户组也有三种划分方式：\n\n * 第一种组类别\n   \n   * 管理员组\n   * 普通用户组（包括系统用户组和登录用户组）\n\n * 第二种组类别\n   \n   * 用户的基本组（主组）：用户必须有且只能有一个基本组。\n   * 用户的附加组 （附属组）：用户可以有0个、1个或多个附加组。\n   \n   基本组和附加组就比如，每个人有一个用来安家的房子（基本组），还可以有N个用于投资的房子（附属组）。\n\n * 第三种组类别\n   \n   * 私有组：每新建一个用户，如果不指定-g参数，都会自动创建一个和用户名同名的组，且组内只包含用户本身。\n   * 公共组：组内可包含多个用户。\n\nLinux系统也是使用GID（Group ID）来标识不同组。用户和用户组的对应关系有以下 4 种：\n\n 1. 一对一：一个用户可以存在一个组中，是组中的唯一成员；\n 2. 一对多：一个用户可以存在多个用户组中，此用户具有这多个组的共同权限；\n 3. 多对一：多个用户可以存在一个组中，这些用户具有和组相同的权限；\n 4. 多对多：多个用户可以存在多个组中，也就是以上 3 种关系的扩展。\n\n下图形象的表示了用户和用户组的4种对应关系。\n\n注意：每一个用户组也有一个口令，当我们将用户添加到指定组时需要该用户组的密码。\n\n\n# 1.3 文件权限\n\n在Linux操作系统中，任何文件都归属于某一特定的用户，其作为多用户系统，如何区分不同用户对文件的权限成了不可避免的问题。例如，小 A 希望个人文件不被其他用户读取，而如果不对文件进行权限设置，共享了主机资源的小 B 也可以读取小 A 的个人文件，这是不合理的，不同用户对不同文件所拥有的权限应该不尽相同。\n\n因此，Linux 以 “用户与用户组” 的概念，建立用户与文件权限之间的联系，保证系统能够充分考虑每个用户的隐私保护，很大程度上保障了 Linux 作为多用户系统的可行性。从文件权限的角度出发，“用户与用户组” 引申为三个具体的对象——文件所有者、用户组成员、其他人。每一个对象对某一个文件的持有权限是不同的。\n\n# 1.3.1 文件所有者（User）\n\n当一个用户创建了一个文件，这个用户就是这个文件的文件所有者。文件所有者对文件拥有最高权限，除非文件所有者开放权限，否则其他人无法对文件执行查看、修改等操作。**这也是 Linux 系统能够保护用户隐私的最关键的原因。**在文件所有者占有文件之后，需要文件所有者对其他用户开放权限，其他用户才能查看、修改文件。\n\n如果仅区分 “文件所有者” 和 “其他用户”，那么文件所有者对其他用户开放权限后，所有其他用户均能查看、修改文件。但是，若文件所有者希望仅对部分用户开放，那么仅仅区分 “用户所有者” 和 “其他用户” 显然不满足需求。这就引入了 “用户组的概念”。\n\n# 1.3.2 用户组成员（Group）\n\n将 “其他用户” 区分为用户组成员和其他人后，若文件所有者希望对部分用户开放权限，而对其他人继续保持私有，则只需要将这部分用户与文件所有者划入一个用户组。这样，这部分用户就成了与文件所有者同组的用户组成员。用户可以对用户组成员开放文件权限，用户组成员则具备了查看、修改文件的权限，而对其他无关用户保持私有。\n\n用户组成员在团队开发中非常有帮助。例如，团队成员之间保持文件资源共享，但对非团队成员保持私有，这就需要将文件所有者与团队成员用户划分为同一个用户组，再对用户组成员开放权限即可。\n\n需要注意的是，一个用户可在多个用户组中。\n\n# 1.3.3 其他人（Others）\n\n顾名思义，就是与文件所有者没有任何联系的用户，即不是文件所有者也不是所在文件所属用户组。\n\n\n# 1.3.4 超级管理员（root）\n\n由于Linux系统中，root具有最高权限，可以执行任何想要执行的操作，也正因为如此，处于安全考虑，一般情况下不推荐使用 root 用户进行日常使用。root 用户所在的用户组称为 “root组”，处于 root 组的普通用户，能够通过 sudo 命令获取 root 权限，即我们是可以通过sudo权限来操作文件的。\n\n\n# 1.4 AAA基础\n\nAAA指的是Authentication、Authorization、Accounting，即认证、授权和审计。\n\n * 认证：验证用户是否可以获得权限，是AAA的第一步，即验证身份；\n * 授权：授权用户可以使用那些服务或资源，即身份验证成功后，赋予这个身份相应的权限；\n * 审计：记录用户的操作情况，在Linux中，日志就是审计的一种手段。\n\nLinux的用户和组管理可以说是基于AAA进行的，首先用户登录输入用户名密码，就是认证的过程；其次，在用户登录成功后，所拥有的权限各不相同，这就是\n\n授权；最后，用户的操作历史会记录在日志中，这是审计。\n\n\n# 2 用户和用户组文件\n\n\n# 2.1 用户账号文件— /etc/passwd\n\n/etc/passwd文件是Linux系统安全的关键文件之一，只有系统管理员才可以修改此文件。该文件用于用户登录等操作时校验用户的登录名、加密的口令数据项、用户ID（UID）、默认的用户组ID（GID）、用户信息、用户主目录及登录后使用的shell。该文件种每一行保存一个用户的资料，而用户数据按域以冒号\':\'分割。格式如下。\n\nusername:password:uid:gid:userinfo:home:shell\n\n\n1\n\n1\n\n\n具体含义如表所示。\n\n域          含义\nusername   登录名\npassword   加密的用户口令\nuid        用户ID\ngid        用户组ID\nuserinfo   用户信息\nhome       分配给用户的主目录\nshell      用户登录后将执行的shell（若为空格泽默认为“/bin/sh”）\n\n其中关于用户主目录，每个用户都需要保存专属于自己的配置文件及其他文档，这是以免用户间相互干扰。除root账户外（root账户的主目录为"/root"），大多数Linux默认将用户主目录安置在"/home"目录下，并把每个用户的主目录命名为其上机使用的登录名。\n\n\n\n如图，acs的登录主目录为"/home/acs"。通常，“~”被指向当前用户的登录子目录。\n\n注意：用户主目录被安排在“/home”下完全是认为决定的。系统并不关心我们到底把用户主目录安排在什么地方，因为每个用户的位置是在账号文件中定义说明的。所以，用户可以自行调整，灵活使用\n\n关于shell，Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。当用户登录进入系统时，会启动一个Shell程序，默认是bash。系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用bash为默认的登录Shell，即这个字段的值为/bin/bash。用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。\n\n我们通过查看/etc/passwd文件，可以得到如下完整的系统账号文件。\n\n\n\n我们发现，第二列都为x。我们可以继续往下看。\n\n\n# 2.2 用户影子文件—/etc/shadow\n\n实际上，Linxu使用不可逆的加密算法（如MD5）来加密口令，由于加密算法是不可逆的，所以黑客从密文是得不到明文的。但/etc/passwd文件时全局可读的，且加密的算法是公开的，如果在passwd中显示密文，黑客据此可以破解口令。Linux系统目前广泛采用了“shadow（影子）文件”机制。将加密的口令转移到“/etc/shadow”文件中。/etc/shadow文件只为root超级用户可读，而相应的etc/passwd文件的密文域泽显示为一个x，从而最大限度地减少了密文泄露的机会。x表示该账户需要密码才能登录，为空时，账户无须密码即可登录。\n\n和/etc/passwd类似，/etc/shadow文件中每条记录用冒号“：”分隔，形成9个域，格式如下。\n\nusername:password:lastchg:min:max:warn:inactive:expire:flag\n\n\n1\n\n1\n\n\n域          含义\nusername   用户登陆名\npassword   加密的用户口令\nlastchg    表示从1970年1月1日起到上次修改口令所经过的天数\nmin        表示两次修改口令之间至少经过的天数\nmax        表示口令还会有效的最大天数，如果是99999则表示永不过期\nwarn       表示口令失效前多少天内系统向用户发出警告\ninactive   表示禁止登录前用户名还有效的天数\nexpire     表示用户被禁止登录的时间\nflag       保留域，暂未使用\n\n下图为系统中实际影子文件的例子。\n\n\n\n\n# 2.3 创建用户的默认设置文件—/etc/login.defs\n\n/etc/login.defs 文件用于在创建用户时，对用户的一些基本属性做默认设置，例如指定用户 UID 和 GID 的范围，用户的过期时间，密码的最大长度，等等。\n\n需要注意的是，该文件的用户默认配置对 root 用户无效。并且，当此文件中的配置与 /etc/passwd 和 /etc/shadow 文件中的用户信息有冲突时，系统会以/etc/passwd 和 /etc/shadow 为准。\n\n其中设置项含义如下表所示。\n\n设置项                        含义\nMAIL_DIR /var/spool/mail   创建用户时，系统会在目录 /var/spool/mail 中创建一个用户邮箱，比如 lamp 用户的邮箱是\n                           /var/spool/mail/lamp。\nPASS_MAX_DAYS 99999        密码有效期，99999 是自 1970 年 1 月 1 日起密码有效的天数，相当于 273 年，可理解为密码始终有效。\nPASS_MIN_DAYS 0            表示自上次修改密码以来，最少隔多少天后用户才能再次修改密码，默认值是 0。\nPASS_MIN_LEN 5             指定密码的最小长度，默认不小于 5 位，但是现在用户登录时验证已经被 PAM 模块取代，所以这个选项并不生效。\nPASS_WARN_AGE 7            指定在密码到期前多少天，系统就开始通过用户密码即将到期，默认为 7 天。\nUID_MIN 500                指定最小 UID 为 500，也就是说，添加用户时，默认 UID 从 500 开始。注意，如果手工指定了一个用户的\n                           UID 是 550，那么下一个创建的用户的 UID 就会从 551 开始，哪怕 500~549 之间的 UID\n                           没有使用。\nUID_MAX 60000              指定用户最大的 UID 为 60000。\nGID_MIN 500                指定最小 GID 为 500，也就是在添加组时，组的 GID 从 500 开始。\nGID_MAX 60000              用户 GID 最大为 60000。\nCREATE_HOME yes            指定在创建用户时，是否同时创建用户主目录，yes 表示创建，no 则不创建，默认是 yes。\nUMASK 077                  用户主目录的权限默认设置为 077。\nUSERGROUPS_ENAB yes        指定删除用户的时候是否同时删除用户组，准备地说，这里指的是删除用户的初始组，此项的默认值为 yes。\nENCRYPT_METHOD SHA512      指定用户密码采用的加密规则，默认采用 SHA512，这是新的密码加密模式，原先的 Linux 只能用 DES 或 MD5\n                           加密。\n\n如果我们想修改默认配置即可修改配置项的值即可。\n\n\n# 2.4 用户组账号文件—/etc/group\n\n我们知道，/etc/passwd文件中包含着每个用户的用户组ID（GID），但如果我们需要找一个用户组中的所有用户，通过/etc/passwd难免有些复杂，需要从头到尾寻找同组用户。而/etc/group文件包含关于用户组信息，GID被映射到用户分组的名称及同一分组中的其他成员，这样找同组用户以及配置用户组就方便了许多。/etc/group文件对用户组的许可权限的控制并不是必要的，这是因为Linux系统用来自于/etc/passwd文件的UID、GID来决定文件存取权限。即使/etc/group文件不存在于系统中，具有相同的GID用户也能以用户组的许可权限共享文件。\n\n/etc/group文件记录格式如下。\n\ngroup_name:group_password:group_id:group_members\n\n\n1\n\n1\n\n\n其中，各个域的含义如下表。\n\n域                含义\ngroup_name       用户组名\ngroup_password   加密后的用户组口令\ngroup_id         用户组ID（GID）\ngroup_members    以逗号分隔的成员用户清单\n\n以下是一个/etc/group文件的实例。\n\n\n\n\n# 2.5 用户组影子文件—/etc/gshadow\n\n和用户账号文件passwd一样，为了应对黑客对其进行的暴力攻击，用户组文件也采用一种将组口令与组的其他信息相分离的安全机制——gshadow。/etc/shadow文件记录格式如下。\n\ngroup_name:group_password:group_members\n\n\n1\n\n1\n\n\n其中，各个域的含义如下表。\n\n域                含义\ngroup_name       用户组名\ngroup_password   加密后的用户组口令\ngroup_members    以逗号分隔的成员用户清单\n\n\n# 3 用户和用户组管理\n\n\n# 3.1 用户管理\n\n# 3.1.1 使用useradd命令添加用户\n\nLinux使用useradd命令添加用户或更新新创建用户的默认信息。其命令格式如下。\n\nuseradd [option] username\n\n\n1\n\n1\n\n\n可使用的选项如下：\n\n * -c comment：描述新用户账号，通常为用户全名。\n * -d home_dir：设置用户主目录。默认值为用户的登录名，并放在"/home"目录下。\n * -g group：指定用户所属的基本组。\n * -G group：指定用户所属的附加组。\n * -u uid：设置用户的ID。\n * -s shell类型：设定用户使用的登录shell类型。\n * -k dir：设置框架目录，创建用户时该目录下的文件都被复制到主目录。\n * -e expire_date：设置账号过期时间。\n * -f inactivity：设置口令失效时间。\n * -n：不为用户创建私有用户组。\n * -p password：为新建用户指定登录密码。此处的 password 是对应登录密码经 MD5 加密后所得到的密码值，不是真实密码原文，因此在实际应用中，该参数选项使用较少，通常单独使用 passwd 命令来为用户设置登录密码。\n * -r：创建一个用户 ID 小于 500 的系统账户，默认不创建对应的主目录。\n * -m：若主目录不存在，则创建它。通常与-r结合，可为系统用户主目录。\n * -M：不创建主目录。\n\n实例1：创建一个普通用户，名为hzf，其中uid为6666，用户主目录指定在/hzf/。\n\nuseradd -u 6666 -d /hzf/ hzf\n\n\n1\n\n1\n\n\n实例2：创建一个系统账户，名为mysystem，其中为系统用户创建主目录，指定密码为12345678\n\n> 首先需要加密密码串，这里使用md5sum工具。\n> \n> 利用md5sum加密字符串的方法\n> \n> # md5sum //然后回车\n> \n> 12345678 //输入12345678，然后按两次ctrl+d。\n> \n> 这个时候就会得到一串密文。\n> \n> 使用以下命令即可创建该系统用户\n> \n> useradd -r -m -p 1234567825d55ad283aa400af464c76d713c07ad mysystem\n> \n> \n> 1\n> \n> 1\n\n查看/etc/passwd即可看到我们创建得用户信息。\n\n\n\n# 3.1.2 使用usermod命令修改用户信息\n\n对于已创建好的用户，可使用 usermod 命令来修改和设置账户的各项属性，包括登录名，主目录，用户组，登录 shell 等，该命令格式如下。\n\nusermod [option] username\n\n\n1\n\n1\n\n\n常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。\n\n另外，有些系统还可以使用-l修改用户名。用法为：usermod -l newusername\n\n使用-L可以锁定用户账号，临时禁止用户登录。用法为：usermod -L username，Linux锁定用户，是通过在密码文件 shadow 的密码字段前加 “！” 来标识该用户被锁定。\n\n但如果我们是用root用户登录，再用su命令切换到被锁定的账号是可以进去的。\n\n使用-U可以解锁用户账号。用法为：usermod -U username。\n\n# 3.1.3 使用userdel命令删除用户\n\n要删除用户，可以使用userdel命令删除，命令格式如下。\n\nuserdel [-r] username\n\n\n1\n\n1\n\n\n其中-r参数可选，若带上参数，表示在删除账户的同时，一并删除用户的主目录。\n\n# 3.1.4 使用passwd命令管理用户口令\n\n用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。\n\n指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式如下。\n\npasswd [option] username\n\n\n1\n\n1\n\n\n可使用的选项如下：\n\n * -l：锁定口令，即禁用账号。\n * -u：口令解锁。\n * -d：使账号无口令。这样，下次登录的时候，系统就不再允许该用户登录了。\n * -f：强迫用户下次登陆时修改口令。\n\n如果不指定用户名，则表示修改自己的口令。\n\n\n# 3.2 用户组管理\n\n# 3.2.1 使用groupadd命令创建用户组\n\n增加一个新的用户组使用groupadd命令。命令格式如下。\n\ngroupadd [option] groupname\n\n\n1\n\n1\n\n\n可使用的选项如下：\n\n * -r：表示创建系统用户组，该类用户组的 GID 值小于 500；若没有 - r 参数，则创建普通用户组，其 GID 值大于或等于 500。\n * -g gid：指定新用户组的标识号GID。\n * -o：一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。\n\n如果没有指定选择参数，新组的组标识号是在当前已有的最大组标识号的基础上加1。\n\n# 3.2.2 使用groupmod修改\n\n修改用户组的属性使用groupmod命令。命令格式如下。\n\ngroupmod [option] groupname\n\n\n1\n\n1\n\n\n可使用的选项如下：\n\n * -g gid：为用户组指定新的组标识号。\n * -o：与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。\n * -n newgroupname： 将用户组的名字改为新名字\n\n# 3.2.3 使用groupdel命令删除用户组\n\n使用groupdel命令可以删除用户组。命令格式如下。\n\ngroupdel groupname\n\n\n1\n\n1\n\n\n在删除用户组时，被删除的用户组不能是某个账户的私有用户组，否则将无法删除，若要删除，则应先删除引用该私有用户组的账户，然后再删除用户组。\n\n# 3.2.4 使用gpasswd命令管理用户组\n\n为了避免系统管理员（root）太忙碌，无法及时管理群组，我们可以使用 gpasswd 命令给群组设置一个群组管理员，代替 root 完成将用户加入或移出群组的操作。gpasswd命令格式如下。\n\ngpasswd [option] groupname\n\n\n1\n\n1\n\n\n可选择的选项如下：\n\n选项             功能\n               选项为空时，表示给群组设置密码，仅 root 用户可用。\n-A user1,...   将群组的控制权交给 user1,... 等用户管理，也就是说，设置 user1,... 等用户为群组的管理员，仅\n               root 用户可用。\n-M user1,...   将 user1,... 加入到此群组中，仅 root 用户可用。\n-r             移除群组的密码，仅 root 用户可用。\n-R             让群组的密码失效，仅 root 用户可用。\n-a user        将 user 用户加入到群组中。\n-d user        将 user 用户从群组中移除。\n\n实例如下。\n\n\n\n# 3.2.5 使用newgrp命令切换用户的有效组\n\n我们知道，每个用户可以属于一个初始组（用户是这个组的初始用户），也可以属于多个附加组（用户是这个组的附加用户）。既然用户可以属于这么多用户组，那么用户在创建文件后，默认生效的组身份是哪个呢？\n\n当然是初始用户组的组身份生效，因为初始组是用户一旦登陆就获得的组身份。也就是说，用户的有效组默认是初始组，因此所创建文件的属组是用户的初始组。那么，既然用户属于多个用户组，能不能改变用户的初始组呢？使用命令 newgrp 就可以。此命令基本格式如下。\n\nnewgrp groupname\n\n\n1\n\n1\n\n\nnewgrp 命令可以从用户的附加组中选择一个群组，作为用户新的初始组。\n\n\n# 4 其他相关命令\n\n\n# 4.1 id命令查看用户的UID和GID\n\nid 命令可以查询用户的UID、GID 和附加组的信息。命令比较简单，格式如下。\n\nid username\n\n\n1\n\n1\n\n\n实例如下：\n\n\n\n\n# 4.2 su命令临时切换用户身份\n\nsu 是最简单的用户切换命令，通过该命令可以实现任何身份的切换，包括从普通用户切换为 root 用户、从 root 用户切换为普通用户以及普通用户之间的切换。\n\n普通用户之间切换以及普通用户切换至 root 用户，都需要知晓对方的密码，只有正确输入密码，才能实现切换；从 root 用户切换至其他用户，无需知晓对方密码，直接可切换成功。\n\nsu命令格式如下。\n\nsu [option] username\n\n\n1\n\n1\n\n\n可使用的选项如下：\n\n * -l或-：带这个参数就好像是重新 login 为该使用者一样，大部份环境参数都是以该使用者为主，并且工作目录也会改变，如果没有指定 USER ，内定是 root。\n * -c <command> ：仅切换用户执行一次命令，执行后自动切换回来，该选项后通常会带有要执行的命令。\n * -s <shell>： 指定要执行的 shell （bash csh tcsh 等），预设值为 /etc/passwd 内的该使用者shell\n * -h：显示说明文件。\n * -V：显示版本资讯。\n * -m或-p：执行su时不改变工作环境。\n\n\n\n\n# 4.3 whoami和who am i命令\n\nwhoami 命令和 who am i 命令是不同的 2 个命令，前者用来打印当前执行操作的用户名，后者则用来打印登陆当前 Linux 系统的用户名。\n\n我们可以看一下操作实例来感受区别：\n\n\n\n在未切换用户身份之前，whoami 和 who am i 命令的输出是一样的，但使用 su 命令切换用户身份后，使用 whoami 命令打印的是切换后的用户名，而 who am i 命令打印的仍旧是登陆系统时所用的用户名。\n\n\n# 4.4 users和groups命令\n\nusers命令格式如下。\n\nusers [option]\n\n\n1\n\n1\n\n * 如果没有参数，则显示当前登录系统的所有用户的用户列表。每个显示的用户名对应一个登录会话。如果一个用户有不止一个登录会话，那他的用户名将显示相同的次数。\n * --help：显示命令的帮助信息。\n * --version：显示命令的版本信息。\n\ngroups命令格式如下。\n\ngroups [option] [groupname]\n\n\n1\n\n1\n\n * 如果没有参数，查看当前登录用户的组内成员。如果指定了groupname，则显示该group的成员。\n * --help：显示命令的帮助信息。\n * --version：显示命令的版本信息。\n\n\n# 5 高级操作示例\n\n\n# 5.1 通过更改用户和组的配置文件，直接添加或修改用户和组\n\n为了更深入了解用户和组的相关配置文件，可以手动更改配置文件以达到命令的执行效果。\n\n首先我们需要了解Linux中的/etc/skel目录。skel是skeleton的缩写，意为骨骼、框架。故此目录的作用是在建立新用户时，用于初始化用户根目录。系统会将此目录下的所有文件、目录都复制到新建用户的主目录，并且将用户属主与用户组调整为与此主目录相同。所以可将用户配置文件预置到/etc/skel目录下，比如说.bashrc、.profile与.vimrc等。\n\n注意：\n\n * 如果在新建用户时，没有自动建立用户根目录，则无法调用到此框架目录。\n * 如果不想以默认的/etc/skel目录作为框架目录，可以在运行useradd命令时使用-k指定新的框架目录。\n * 如果不想在每次新建用户时，都重新指定新的框架目录，可以通过修改/etc/default/useradd配置文件来改变默认的框架目录。修改SKEL变量的值即可。原来为SKEL=/etc/skel。\n\n实际操作步骤如下：\n\n 1. 编辑/etc/group文件，添加组test，其中GID为1500。\n    \n    echo \'test:x:1500\' >> /etc/group\n\n 2. 创建用户的主目录。\n    \n    我们需要将框架目录中的文件放到主目录中。同时还需要修改好主目录对其他用户都没有任何访问权限。\n    \n    \n\n 3. 编辑/etc/passwd文件，添加用户test，UID为1500，其中基本组ID为test组的GID，其家目录为/home/test。\n    \n    echo \'test:x:1500:1500::/home/test:/bin/bash\' >> /etc/passwd\n\n 4. 修改/home/test目录及其内部所有文件的属主为test，属组为test。\n    \n    \n\n 5. 修改test用户的密码并尝试登录。\n    \n    \n\n\n# 5.2 Linux批量添加用户\n\n我们可以使用useradd+passwd命令配合shell脚本来实现该功能。\n\n首先我们将需要创建的用户名写入一个文本文件，其中每行代表一个用户名：\n\n\n\n然后实际上我们的思路就是提取出文件中的用户名然后自动执行useradd命令，再执行passwd自动填入初始密码。编写的shell脚本文件如下：\n\n#! /bin/bash\n\nfor username in $(more username.txt)\ndo\nif [ -n $username ]\nthen\n        useradd -m $username # 执行useradd命令\n        echo $username"123456" | passwd --stdin $username\n        echo "User $username\'s password is changed!"\nelse\n        echo "The username is null!"\nfi\ndone\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n测试登录，登录成功！\n\n',normalizedContent:'# 1 用户和用户组介绍\n\n\n# 1.1 用户\n\n任何操作系统都存在“用户”的概念，linux也不例外。linux系统是一个多用户多任务的分时操作系统，即linux系统支持多个用户在同一时间内登录，不同用户可以执行不同的任务，并且互不影响。每个用户账号都拥有一个用户名和各自的口令（即密码）。在登录系统时，只有正确输入用户名和密码，才能进入系统和自己的主目录。\n\n在linux中，用户分为两大类、三小类：分别为系统管理员（一般为root）和普通用户 。普通用户中，又划分为两类，分别为系统用户和登录用户。\n\n * 系统管理员：即超级管理员，可以操作系统中任意文件和命令，拥有最高的管理权限。\n * 普通用户\n   * 登录用户：为管理员手动添加的用户，默认仅拥有操作自身家目录中文件及目录的权限，以及进入与浏览相关目录文件的权限（如/etc、/var/log等），但没有创建、修改、删除等权限。\n   * 系统用户：一般为系统安装后默认存在的，且默认情况下不能登录系统，它们的存在主要是为了满足系统进程对文件属主的需求。 tips：在部署某些服务是，也可以手动添加某些系统用户。\n\nlinux系统使用uid（user id）来标识不同用户，说白了，其实linux并不认识你的用户名称，它只认识用户名对应的uid。其中uid是16bit的二进制数字，所以换算成十进制，uid的范围是0~65535，linux根据用户类别，对uid划分做了规定：\n\n * 0（系统管理员）：，当uid是0时，代表这个用户为超级管理员，所以当你想要其他的用户也有root权限时，将该用户的uid改为0即可。但一般来说，用户的uid应当是独一无二的，其他用户不应当有相同的uid数值，只有uid等于0时可以例外。\n * 1~499（系统账号）：该范围内的uid是保留给系统使用的 id，其实 1~65534 之间的账号并没有不同， 也就是除了 0 之外，其它的 uid 并没有不一样，预设 500 以下给系统作为保留账号只是一个习惯。这样的好处是，以有名的 dns 服务器的启动服务『 named 』为例，这个程序的预设所有人 named 的账号 uid 是 25 ，当你自定义的账号也是 25 时，会造成系统冲突！为了杜绝这样的问题，养成好习惯，保留 500 以前的 uid 给系统使用！ 一般来说， 1到99 会保留给系统预设的账号，另外 100~499 则保留给一些服务来使用。\n * 500~65535（登录用户）：给一般使用者用的。事实上，目前的 linux 核心 (2.6.x 版)已经可以支持到 4294967295 (2^32-1) 这么大的 uid 号码。\n\n\n# 1.2 用户组\n\n用户组是具有相同特征用户的逻辑集合。简单的理解，有时我们需要让多个用户具有相同的权限，比如查看、修改某一个文件的权限，一种方法是分别对多个用户进行文件访问授权，如果有 10 个用户的话，就需要授权 10 次，那如果有 100、1000 甚至更多的用户呢？\n\n显然，这种方法不太合理。最好的方式是建立一个组，让这个组具有查看、修改此文件的权限，然后将所有需要访问此文件的用户放入这个组中。那么，所有用户就具有了和组一样的权限，这就是用户组。将用户分组是 linux 系统中对用户进行管理及控制访问权限的一种手段，通过定义用户组，很多程序上简化了对用户的管理工作。\n\nlinux对用户组也有三种划分方式：\n\n * 第一种组类别\n   \n   * 管理员组\n   * 普通用户组（包括系统用户组和登录用户组）\n\n * 第二种组类别\n   \n   * 用户的基本组（主组）：用户必须有且只能有一个基本组。\n   * 用户的附加组 （附属组）：用户可以有0个、1个或多个附加组。\n   \n   基本组和附加组就比如，每个人有一个用来安家的房子（基本组），还可以有n个用于投资的房子（附属组）。\n\n * 第三种组类别\n   \n   * 私有组：每新建一个用户，如果不指定-g参数，都会自动创建一个和用户名同名的组，且组内只包含用户本身。\n   * 公共组：组内可包含多个用户。\n\nlinux系统也是使用gid（group id）来标识不同组。用户和用户组的对应关系有以下 4 种：\n\n 1. 一对一：一个用户可以存在一个组中，是组中的唯一成员；\n 2. 一对多：一个用户可以存在多个用户组中，此用户具有这多个组的共同权限；\n 3. 多对一：多个用户可以存在一个组中，这些用户具有和组相同的权限；\n 4. 多对多：多个用户可以存在多个组中，也就是以上 3 种关系的扩展。\n\n下图形象的表示了用户和用户组的4种对应关系。\n\n注意：每一个用户组也有一个口令，当我们将用户添加到指定组时需要该用户组的密码。\n\n\n# 1.3 文件权限\n\n在linux操作系统中，任何文件都归属于某一特定的用户，其作为多用户系统，如何区分不同用户对文件的权限成了不可避免的问题。例如，小 a 希望个人文件不被其他用户读取，而如果不对文件进行权限设置，共享了主机资源的小 b 也可以读取小 a 的个人文件，这是不合理的，不同用户对不同文件所拥有的权限应该不尽相同。\n\n因此，linux 以 “用户与用户组” 的概念，建立用户与文件权限之间的联系，保证系统能够充分考虑每个用户的隐私保护，很大程度上保障了 linux 作为多用户系统的可行性。从文件权限的角度出发，“用户与用户组” 引申为三个具体的对象——文件所有者、用户组成员、其他人。每一个对象对某一个文件的持有权限是不同的。\n\n# 1.3.1 文件所有者（user）\n\n当一个用户创建了一个文件，这个用户就是这个文件的文件所有者。文件所有者对文件拥有最高权限，除非文件所有者开放权限，否则其他人无法对文件执行查看、修改等操作。**这也是 linux 系统能够保护用户隐私的最关键的原因。**在文件所有者占有文件之后，需要文件所有者对其他用户开放权限，其他用户才能查看、修改文件。\n\n如果仅区分 “文件所有者” 和 “其他用户”，那么文件所有者对其他用户开放权限后，所有其他用户均能查看、修改文件。但是，若文件所有者希望仅对部分用户开放，那么仅仅区分 “用户所有者” 和 “其他用户” 显然不满足需求。这就引入了 “用户组的概念”。\n\n# 1.3.2 用户组成员（group）\n\n将 “其他用户” 区分为用户组成员和其他人后，若文件所有者希望对部分用户开放权限，而对其他人继续保持私有，则只需要将这部分用户与文件所有者划入一个用户组。这样，这部分用户就成了与文件所有者同组的用户组成员。用户可以对用户组成员开放文件权限，用户组成员则具备了查看、修改文件的权限，而对其他无关用户保持私有。\n\n用户组成员在团队开发中非常有帮助。例如，团队成员之间保持文件资源共享，但对非团队成员保持私有，这就需要将文件所有者与团队成员用户划分为同一个用户组，再对用户组成员开放权限即可。\n\n需要注意的是，一个用户可在多个用户组中。\n\n# 1.3.3 其他人（others）\n\n顾名思义，就是与文件所有者没有任何联系的用户，即不是文件所有者也不是所在文件所属用户组。\n\n\n# 1.3.4 超级管理员（root）\n\n由于linux系统中，root具有最高权限，可以执行任何想要执行的操作，也正因为如此，处于安全考虑，一般情况下不推荐使用 root 用户进行日常使用。root 用户所在的用户组称为 “root组”，处于 root 组的普通用户，能够通过 sudo 命令获取 root 权限，即我们是可以通过sudo权限来操作文件的。\n\n\n# 1.4 aaa基础\n\naaa指的是authentication、authorization、accounting，即认证、授权和审计。\n\n * 认证：验证用户是否可以获得权限，是aaa的第一步，即验证身份；\n * 授权：授权用户可以使用那些服务或资源，即身份验证成功后，赋予这个身份相应的权限；\n * 审计：记录用户的操作情况，在linux中，日志就是审计的一种手段。\n\nlinux的用户和组管理可以说是基于aaa进行的，首先用户登录输入用户名密码，就是认证的过程；其次，在用户登录成功后，所拥有的权限各不相同，这就是\n\n授权；最后，用户的操作历史会记录在日志中，这是审计。\n\n\n# 2 用户和用户组文件\n\n\n# 2.1 用户账号文件— /etc/passwd\n\n/etc/passwd文件是linux系统安全的关键文件之一，只有系统管理员才可以修改此文件。该文件用于用户登录等操作时校验用户的登录名、加密的口令数据项、用户id（uid）、默认的用户组id（gid）、用户信息、用户主目录及登录后使用的shell。该文件种每一行保存一个用户的资料，而用户数据按域以冒号\':\'分割。格式如下。\n\nusername:password:uid:gid:userinfo:home:shell\n\n\n1\n\n1\n\n\n具体含义如表所示。\n\n域          含义\nusername   登录名\npassword   加密的用户口令\nuid        用户id\ngid        用户组id\nuserinfo   用户信息\nhome       分配给用户的主目录\nshell      用户登录后将执行的shell（若为空格泽默认为“/bin/sh”）\n\n其中关于用户主目录，每个用户都需要保存专属于自己的配置文件及其他文档，这是以免用户间相互干扰。除root账户外（root账户的主目录为"/root"），大多数linux默认将用户主目录安置在"/home"目录下，并把每个用户的主目录命名为其上机使用的登录名。\n\n\n\n如图，acs的登录主目录为"/home/acs"。通常，“~”被指向当前用户的登录子目录。\n\n注意：用户主目录被安排在“/home”下完全是认为决定的。系统并不关心我们到底把用户主目录安排在什么地方，因为每个用户的位置是在账号文件中定义说明的。所以，用户可以自行调整，灵活使用\n\n关于shell，shell是用户与linux系统之间的接口。linux的shell有许多种，每种都有不同的特点。当用户登录进入系统时，会启动一个shell程序，默认是bash。系统管理员可以根据系统情况和用户习惯为用户指定某个shell。如果不指定shell，那么系统使用bash为默认的登录shell，即这个字段的值为/bin/bash。用户的登录shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。\n\n我们通过查看/etc/passwd文件，可以得到如下完整的系统账号文件。\n\n\n\n我们发现，第二列都为x。我们可以继续往下看。\n\n\n# 2.2 用户影子文件—/etc/shadow\n\n实际上，linxu使用不可逆的加密算法（如md5）来加密口令，由于加密算法是不可逆的，所以黑客从密文是得不到明文的。但/etc/passwd文件时全局可读的，且加密的算法是公开的，如果在passwd中显示密文，黑客据此可以破解口令。linux系统目前广泛采用了“shadow（影子）文件”机制。将加密的口令转移到“/etc/shadow”文件中。/etc/shadow文件只为root超级用户可读，而相应的etc/passwd文件的密文域泽显示为一个x，从而最大限度地减少了密文泄露的机会。x表示该账户需要密码才能登录，为空时，账户无须密码即可登录。\n\n和/etc/passwd类似，/etc/shadow文件中每条记录用冒号“：”分隔，形成9个域，格式如下。\n\nusername:password:lastchg:min:max:warn:inactive:expire:flag\n\n\n1\n\n1\n\n\n域          含义\nusername   用户登陆名\npassword   加密的用户口令\nlastchg    表示从1970年1月1日起到上次修改口令所经过的天数\nmin        表示两次修改口令之间至少经过的天数\nmax        表示口令还会有效的最大天数，如果是99999则表示永不过期\nwarn       表示口令失效前多少天内系统向用户发出警告\ninactive   表示禁止登录前用户名还有效的天数\nexpire     表示用户被禁止登录的时间\nflag       保留域，暂未使用\n\n下图为系统中实际影子文件的例子。\n\n\n\n\n# 2.3 创建用户的默认设置文件—/etc/login.defs\n\n/etc/login.defs 文件用于在创建用户时，对用户的一些基本属性做默认设置，例如指定用户 uid 和 gid 的范围，用户的过期时间，密码的最大长度，等等。\n\n需要注意的是，该文件的用户默认配置对 root 用户无效。并且，当此文件中的配置与 /etc/passwd 和 /etc/shadow 文件中的用户信息有冲突时，系统会以/etc/passwd 和 /etc/shadow 为准。\n\n其中设置项含义如下表所示。\n\n设置项                        含义\nmail_dir /var/spool/mail   创建用户时，系统会在目录 /var/spool/mail 中创建一个用户邮箱，比如 lamp 用户的邮箱是\n                           /var/spool/mail/lamp。\npass_max_days 99999        密码有效期，99999 是自 1970 年 1 月 1 日起密码有效的天数，相当于 273 年，可理解为密码始终有效。\npass_min_days 0            表示自上次修改密码以来，最少隔多少天后用户才能再次修改密码，默认值是 0。\npass_min_len 5             指定密码的最小长度，默认不小于 5 位，但是现在用户登录时验证已经被 pam 模块取代，所以这个选项并不生效。\npass_warn_age 7            指定在密码到期前多少天，系统就开始通过用户密码即将到期，默认为 7 天。\nuid_min 500                指定最小 uid 为 500，也就是说，添加用户时，默认 uid 从 500 开始。注意，如果手工指定了一个用户的\n                           uid 是 550，那么下一个创建的用户的 uid 就会从 551 开始，哪怕 500~549 之间的 uid\n                           没有使用。\nuid_max 60000              指定用户最大的 uid 为 60000。\ngid_min 500                指定最小 gid 为 500，也就是在添加组时，组的 gid 从 500 开始。\ngid_max 60000              用户 gid 最大为 60000。\ncreate_home yes            指定在创建用户时，是否同时创建用户主目录，yes 表示创建，no 则不创建，默认是 yes。\numask 077                  用户主目录的权限默认设置为 077。\nusergroups_enab yes        指定删除用户的时候是否同时删除用户组，准备地说，这里指的是删除用户的初始组，此项的默认值为 yes。\nencrypt_method sha512      指定用户密码采用的加密规则，默认采用 sha512，这是新的密码加密模式，原先的 linux 只能用 des 或 md5\n                           加密。\n\n如果我们想修改默认配置即可修改配置项的值即可。\n\n\n# 2.4 用户组账号文件—/etc/group\n\n我们知道，/etc/passwd文件中包含着每个用户的用户组id（gid），但如果我们需要找一个用户组中的所有用户，通过/etc/passwd难免有些复杂，需要从头到尾寻找同组用户。而/etc/group文件包含关于用户组信息，gid被映射到用户分组的名称及同一分组中的其他成员，这样找同组用户以及配置用户组就方便了许多。/etc/group文件对用户组的许可权限的控制并不是必要的，这是因为linux系统用来自于/etc/passwd文件的uid、gid来决定文件存取权限。即使/etc/group文件不存在于系统中，具有相同的gid用户也能以用户组的许可权限共享文件。\n\n/etc/group文件记录格式如下。\n\ngroup_name:group_password:group_id:group_members\n\n\n1\n\n1\n\n\n其中，各个域的含义如下表。\n\n域                含义\ngroup_name       用户组名\ngroup_password   加密后的用户组口令\ngroup_id         用户组id（gid）\ngroup_members    以逗号分隔的成员用户清单\n\n以下是一个/etc/group文件的实例。\n\n\n\n\n# 2.5 用户组影子文件—/etc/gshadow\n\n和用户账号文件passwd一样，为了应对黑客对其进行的暴力攻击，用户组文件也采用一种将组口令与组的其他信息相分离的安全机制——gshadow。/etc/shadow文件记录格式如下。\n\ngroup_name:group_password:group_members\n\n\n1\n\n1\n\n\n其中，各个域的含义如下表。\n\n域                含义\ngroup_name       用户组名\ngroup_password   加密后的用户组口令\ngroup_members    以逗号分隔的成员用户清单\n\n\n# 3 用户和用户组管理\n\n\n# 3.1 用户管理\n\n# 3.1.1 使用useradd命令添加用户\n\nlinux使用useradd命令添加用户或更新新创建用户的默认信息。其命令格式如下。\n\nuseradd [option] username\n\n\n1\n\n1\n\n\n可使用的选项如下：\n\n * -c comment：描述新用户账号，通常为用户全名。\n * -d home_dir：设置用户主目录。默认值为用户的登录名，并放在"/home"目录下。\n * -g group：指定用户所属的基本组。\n * -g group：指定用户所属的附加组。\n * -u uid：设置用户的id。\n * -s shell类型：设定用户使用的登录shell类型。\n * -k dir：设置框架目录，创建用户时该目录下的文件都被复制到主目录。\n * -e expire_date：设置账号过期时间。\n * -f inactivity：设置口令失效时间。\n * -n：不为用户创建私有用户组。\n * -p password：为新建用户指定登录密码。此处的 password 是对应登录密码经 md5 加密后所得到的密码值，不是真实密码原文，因此在实际应用中，该参数选项使用较少，通常单独使用 passwd 命令来为用户设置登录密码。\n * -r：创建一个用户 id 小于 500 的系统账户，默认不创建对应的主目录。\n * -m：若主目录不存在，则创建它。通常与-r结合，可为系统用户主目录。\n * -m：不创建主目录。\n\n实例1：创建一个普通用户，名为hzf，其中uid为6666，用户主目录指定在/hzf/。\n\nuseradd -u 6666 -d /hzf/ hzf\n\n\n1\n\n1\n\n\n实例2：创建一个系统账户，名为mysystem，其中为系统用户创建主目录，指定密码为12345678\n\n> 首先需要加密密码串，这里使用md5sum工具。\n> \n> 利用md5sum加密字符串的方法\n> \n> # md5sum //然后回车\n> \n> 12345678 //输入12345678，然后按两次ctrl+d。\n> \n> 这个时候就会得到一串密文。\n> \n> 使用以下命令即可创建该系统用户\n> \n> useradd -r -m -p 1234567825d55ad283aa400af464c76d713c07ad mysystem\n> \n> \n> 1\n> \n> 1\n\n查看/etc/passwd即可看到我们创建得用户信息。\n\n\n\n# 3.1.2 使用usermod命令修改用户信息\n\n对于已创建好的用户，可使用 usermod 命令来修改和设置账户的各项属性，包括登录名，主目录，用户组，登录 shell 等，该命令格式如下。\n\nusermod [option] username\n\n\n1\n\n1\n\n\n常用的选项包括-c, -d, -m, -g, -g, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。\n\n另外，有些系统还可以使用-l修改用户名。用法为：usermod -l newusername\n\n使用-l可以锁定用户账号，临时禁止用户登录。用法为：usermod -l username，linux锁定用户，是通过在密码文件 shadow 的密码字段前加 “！” 来标识该用户被锁定。\n\n但如果我们是用root用户登录，再用su命令切换到被锁定的账号是可以进去的。\n\n使用-u可以解锁用户账号。用法为：usermod -u username。\n\n# 3.1.3 使用userdel命令删除用户\n\n要删除用户，可以使用userdel命令删除，命令格式如下。\n\nuserdel [-r] username\n\n\n1\n\n1\n\n\n其中-r参数可选，若带上参数，表示在删除账户的同时，一并删除用户的主目录。\n\n# 3.1.4 使用passwd命令管理用户口令\n\n用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。\n\n指定和修改用户口令的shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式如下。\n\npasswd [option] username\n\n\n1\n\n1\n\n\n可使用的选项如下：\n\n * -l：锁定口令，即禁用账号。\n * -u：口令解锁。\n * -d：使账号无口令。这样，下次登录的时候，系统就不再允许该用户登录了。\n * -f：强迫用户下次登陆时修改口令。\n\n如果不指定用户名，则表示修改自己的口令。\n\n\n# 3.2 用户组管理\n\n# 3.2.1 使用groupadd命令创建用户组\n\n增加一个新的用户组使用groupadd命令。命令格式如下。\n\ngroupadd [option] groupname\n\n\n1\n\n1\n\n\n可使用的选项如下：\n\n * -r：表示创建系统用户组，该类用户组的 gid 值小于 500；若没有 - r 参数，则创建普通用户组，其 gid 值大于或等于 500。\n * -g gid：指定新用户组的标识号gid。\n * -o：一般与-g选项同时使用，表示新用户组的gid可以与系统已有用户组的gid相同。\n\n如果没有指定选择参数，新组的组标识号是在当前已有的最大组标识号的基础上加1。\n\n# 3.2.2 使用groupmod修改\n\n修改用户组的属性使用groupmod命令。命令格式如下。\n\ngroupmod [option] groupname\n\n\n1\n\n1\n\n\n可使用的选项如下：\n\n * -g gid：为用户组指定新的组标识号。\n * -o：与-g选项同时使用，用户组的新gid可以与系统已有用户组的gid相同。\n * -n newgroupname： 将用户组的名字改为新名字\n\n# 3.2.3 使用groupdel命令删除用户组\n\n使用groupdel命令可以删除用户组。命令格式如下。\n\ngroupdel groupname\n\n\n1\n\n1\n\n\n在删除用户组时，被删除的用户组不能是某个账户的私有用户组，否则将无法删除，若要删除，则应先删除引用该私有用户组的账户，然后再删除用户组。\n\n# 3.2.4 使用gpasswd命令管理用户组\n\n为了避免系统管理员（root）太忙碌，无法及时管理群组，我们可以使用 gpasswd 命令给群组设置一个群组管理员，代替 root 完成将用户加入或移出群组的操作。gpasswd命令格式如下。\n\ngpasswd [option] groupname\n\n\n1\n\n1\n\n\n可选择的选项如下：\n\n选项             功能\n               选项为空时，表示给群组设置密码，仅 root 用户可用。\n-a user1,...   将群组的控制权交给 user1,... 等用户管理，也就是说，设置 user1,... 等用户为群组的管理员，仅\n               root 用户可用。\n-m user1,...   将 user1,... 加入到此群组中，仅 root 用户可用。\n-r             移除群组的密码，仅 root 用户可用。\n-r             让群组的密码失效，仅 root 用户可用。\n-a user        将 user 用户加入到群组中。\n-d user        将 user 用户从群组中移除。\n\n实例如下。\n\n\n\n# 3.2.5 使用newgrp命令切换用户的有效组\n\n我们知道，每个用户可以属于一个初始组（用户是这个组的初始用户），也可以属于多个附加组（用户是这个组的附加用户）。既然用户可以属于这么多用户组，那么用户在创建文件后，默认生效的组身份是哪个呢？\n\n当然是初始用户组的组身份生效，因为初始组是用户一旦登陆就获得的组身份。也就是说，用户的有效组默认是初始组，因此所创建文件的属组是用户的初始组。那么，既然用户属于多个用户组，能不能改变用户的初始组呢？使用命令 newgrp 就可以。此命令基本格式如下。\n\nnewgrp groupname\n\n\n1\n\n1\n\n\nnewgrp 命令可以从用户的附加组中选择一个群组，作为用户新的初始组。\n\n\n# 4 其他相关命令\n\n\n# 4.1 id命令查看用户的uid和gid\n\nid 命令可以查询用户的uid、gid 和附加组的信息。命令比较简单，格式如下。\n\nid username\n\n\n1\n\n1\n\n\n实例如下：\n\n\n\n\n# 4.2 su命令临时切换用户身份\n\nsu 是最简单的用户切换命令，通过该命令可以实现任何身份的切换，包括从普通用户切换为 root 用户、从 root 用户切换为普通用户以及普通用户之间的切换。\n\n普通用户之间切换以及普通用户切换至 root 用户，都需要知晓对方的密码，只有正确输入密码，才能实现切换；从 root 用户切换至其他用户，无需知晓对方密码，直接可切换成功。\n\nsu命令格式如下。\n\nsu [option] username\n\n\n1\n\n1\n\n\n可使用的选项如下：\n\n * -l或-：带这个参数就好像是重新 login 为该使用者一样，大部份环境参数都是以该使用者为主，并且工作目录也会改变，如果没有指定 user ，内定是 root。\n * -c <command> ：仅切换用户执行一次命令，执行后自动切换回来，该选项后通常会带有要执行的命令。\n * -s <shell>： 指定要执行的 shell （bash csh tcsh 等），预设值为 /etc/passwd 内的该使用者shell\n * -h：显示说明文件。\n * -v：显示版本资讯。\n * -m或-p：执行su时不改变工作环境。\n\n\n\n\n# 4.3 whoami和who am i命令\n\nwhoami 命令和 who am i 命令是不同的 2 个命令，前者用来打印当前执行操作的用户名，后者则用来打印登陆当前 linux 系统的用户名。\n\n我们可以看一下操作实例来感受区别：\n\n\n\n在未切换用户身份之前，whoami 和 who am i 命令的输出是一样的，但使用 su 命令切换用户身份后，使用 whoami 命令打印的是切换后的用户名，而 who am i 命令打印的仍旧是登陆系统时所用的用户名。\n\n\n# 4.4 users和groups命令\n\nusers命令格式如下。\n\nusers [option]\n\n\n1\n\n1\n\n * 如果没有参数，则显示当前登录系统的所有用户的用户列表。每个显示的用户名对应一个登录会话。如果一个用户有不止一个登录会话，那他的用户名将显示相同的次数。\n * --help：显示命令的帮助信息。\n * --version：显示命令的版本信息。\n\ngroups命令格式如下。\n\ngroups [option] [groupname]\n\n\n1\n\n1\n\n * 如果没有参数，查看当前登录用户的组内成员。如果指定了groupname，则显示该group的成员。\n * --help：显示命令的帮助信息。\n * --version：显示命令的版本信息。\n\n\n# 5 高级操作示例\n\n\n# 5.1 通过更改用户和组的配置文件，直接添加或修改用户和组\n\n为了更深入了解用户和组的相关配置文件，可以手动更改配置文件以达到命令的执行效果。\n\n首先我们需要了解linux中的/etc/skel目录。skel是skeleton的缩写，意为骨骼、框架。故此目录的作用是在建立新用户时，用于初始化用户根目录。系统会将此目录下的所有文件、目录都复制到新建用户的主目录，并且将用户属主与用户组调整为与此主目录相同。所以可将用户配置文件预置到/etc/skel目录下，比如说.bashrc、.profile与.vimrc等。\n\n注意：\n\n * 如果在新建用户时，没有自动建立用户根目录，则无法调用到此框架目录。\n * 如果不想以默认的/etc/skel目录作为框架目录，可以在运行useradd命令时使用-k指定新的框架目录。\n * 如果不想在每次新建用户时，都重新指定新的框架目录，可以通过修改/etc/default/useradd配置文件来改变默认的框架目录。修改skel变量的值即可。原来为skel=/etc/skel。\n\n实际操作步骤如下：\n\n 1. 编辑/etc/group文件，添加组test，其中gid为1500。\n    \n    echo \'test:x:1500\' >> /etc/group\n\n 2. 创建用户的主目录。\n    \n    我们需要将框架目录中的文件放到主目录中。同时还需要修改好主目录对其他用户都没有任何访问权限。\n    \n    \n\n 3. 编辑/etc/passwd文件，添加用户test，uid为1500，其中基本组id为test组的gid，其家目录为/home/test。\n    \n    echo \'test:x:1500:1500::/home/test:/bin/bash\' >> /etc/passwd\n\n 4. 修改/home/test目录及其内部所有文件的属主为test，属组为test。\n    \n    \n\n 5. 修改test用户的密码并尝试登录。\n    \n    \n\n\n# 5.2 linux批量添加用户\n\n我们可以使用useradd+passwd命令配合shell脚本来实现该功能。\n\n首先我们将需要创建的用户名写入一个文本文件，其中每行代表一个用户名：\n\n\n\n然后实际上我们的思路就是提取出文件中的用户名然后自动执行useradd命令，再执行passwd自动填入初始密码。编写的shell脚本文件如下：\n\n#! /bin/bash\n\nfor username in $(more username.txt)\ndo\nif [ -n $username ]\nthen\n        useradd -m $username # 执行useradd命令\n        echo $username"123456" | passwd --stdin $username\n        echo "user $username\'s password is changed!"\nelse\n        echo "the username is null!"\nfi\ndone\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n测试登录，登录成功！\n\n',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"Git Commit 之道：规范化 Commit Message 写作指南",frontmatter:{title:"Git Commit 之道：规范化 Commit Message 写作指南",date:"2023-11-12T22:32:20.000Z",tags:["Git"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/4f7ea8/",categories:["工具","版本控制"],readingShow:"top"},regularPath:"/02.%E5%B7%A5%E5%85%B7/01.%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/01.Git%20Commit%20%E4%B9%8B%E9%81%93%EF%BC%9A%E8%A7%84%E8%8C%83%E5%8C%96%20Commit%20Message%20%E5%86%99%E4%BD%9C%E6%8C%87%E5%8D%97.html",relativePath:"02.工具/01.版本控制/01.Git Commit 之道：规范化 Commit Message 写作指南.md",key:"v-476ed16d",path:"/pages/4f7ea8/",headers:[{level:2,title:"1 commit message 规范",slug:"_1-commit-message-规范",normalizedTitle:"1 commit message 规范",charIndex:2},{level:3,title:"1.1 Header",slug:"_1-1-header",normalizedTitle:"1.1 header",charIndex:168},{level:3,title:"1.2 Body",slug:"_1-2-body",normalizedTitle:"1.2 body",charIndex:2552},{level:3,title:"1.3 Footer",slug:"_1-3-footer",normalizedTitle:"1.3 footer",charIndex:2790},{level:3,title:"1.4 示例",slug:"_1-4-示例",normalizedTitle:"1.4 示例",charIndex:3145},{level:2,title:"2 git commit 工具",slug:"_2-git-commit-工具",normalizedTitle:"2 git commit 工具",charIndex:6685},{level:3,title:"2.1 commitizen",slug:"_2-1-commitizen",normalizedTitle:"2.1 commitizen",charIndex:6705},{level:3,title:"2.2 commitlint",slug:"_2-2-commitlint",normalizedTitle:"2.2 commitlint",charIndex:7377},{level:2,title:"3 生成Change log",slug:"_3-生成change-log",normalizedTitle:"3 生成change log",charIndex:8618},{level:2,title:"4 参考资料",slug:"_4-参考资料",normalizedTitle:"4 参考资料",charIndex:9710}],headersStr:"1 commit message 规范 1.1 Header 1.2 Body 1.3 Footer 1.4 示例 2 git commit 工具 2.1 commitizen 2.2 commitlint 3 生成Change log 4 参考资料",content:'# 1 commit message 规范\n\ncommit message格式都包括三部分：Header，Body和Footer\n\n<type>(<scope>): <subject>\n\n<body>\n\n<footer>\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\nHeader是必需的，Body和Footer则可以省略\n\n\n# 1.1 Header\n\n 1. Type（必需）\n    \n    type用于说明git commit的类别，允许使用下面几个标识。\n    \n    >  * feat：新功能（Feature）\n    >    \n    >    "feat"用于表示引入新功能或特性的变动。这种变动通常是在代码库中新增的功能，而不仅仅是修复错误或进行代码重构。\n    > \n    >  * fix/to：修复bug。这些bug可能由QA团队发现，或由开发人员在开发过程中识别。\n    >    \n    >    * fix关键字用于那些直接解决问题的提交。当创建一个包含必要更改的提交，并且这些更改能够直接修复已识别的bug时，应使用fix。这表明提交的代码引入了解决方案，并且问题已被立即解决。\n    >    * to关键字则用于那些部分处理问题的提交。在一些复杂的修复过程中，可能需要多个步骤或多次提交来完全解决问题。在这种情况下，初始和中间的提交应使用to标记，表示它们为最终解决方案做出了贡献，但并未完全解决问题。最终解决问题的提交应使用fix标记，以表明问题已被彻底修复。\n    > \n    >  * docs：文档（Documentation）\n    >    \n    >    "docs" 表示对文档的变动，这包括对代码库中的注释、README 文件或其他文档的修改。这个前缀的提交通常用于更新文档以反映代码的变更，或者提供更好的代码理解和使用说明。\n    > \n    >  * style: 格式（Format）\n    >    \n    >    "style" 用于表示对代码格式的变动，这些变动不影响代码的运行。通常包括空格、缩进、换行等风格调整。\n    > \n    >  * refactor：重构（即不是新增功能，也不是修改bug的代码变动）\n    >    \n    >    "refactor" 表示对代码的重构，即修改代码的结构和实现方式，但不影响其外部行为。重构的目的是改进代码的可读性、可维护性和性能，而不是引入新功能或修复错误。\n    > \n    >  * perf: 优化相关，比如提升性能、体验\n    >    \n    >    "perf" 表示与性能优化相关的变动。这可能包括对算法、数据结构或代码实现的修改，以提高代码的执行效率和用户体验。\n    > \n    >  * test：增加测试\n    >    \n    >    "test" 表示增加测试，包括单元测试、集成测试或其他类型的测试。\n    > \n    >  * chore：构建过程或辅助工具的变动\n    >    \n    >    "chore" 表示对构建过程或辅助工具的变动。这可能包括更新构建脚本、配置文件或其他与构建和工具相关的内容。\n    > \n    >  * revert：回滚到上一个版本\n    >    \n    >    "revert" 用于回滚到以前的版本，撤销之前的提交。\n    > \n    >  * merge：代码合并\n    >    \n    >    "merge" 表示进行代码合并，通常是在分支开发完成后将代码合并回主线。\n    > \n    >  * sync：同步主线或分支的Bug\n    >    \n    >    "sync" 表示同步主线或分支的 Bug，通常用于解决因为合并而引入的问题。\n\n 2. Scope（可选）\n    \n    scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。\n    \n    例如修改了Dao或者Controller，则可以添加表示这些范围受到影响，这有助于更清晰地理解提交的变更影响范围。例如：\n    \n    feat(Controller): 添加用户登录功能\n    \n    \n    1\n    \n    1\n    \n    \n    这个提交消息中，Controller 是 scope，表示这次提交影响了控制层。\n    \n    fix(DataAccess): 修复数据查询逻辑\n    \n    \n    1\n    \n    1\n    \n    \n    这个提交消息中，DataAccess 是 scope，表示这次提交影响了数据访问层。\n    \n    如果你的修改影响了不止一个scope，你可以使用*代替。\n\n 3. Subject（必需）\n    \n    subject是 commit 目的的简短描述，不超过50个字符。规范如下：\n    \n    >  * 以动词开头，使用第一人称现在时，比如change，而不是changed或changes\n    >  * 第一个字母小写\n    >  * 结尾不加句号（.）\n    \n    例如：\n    \n    feat(UserAuth): implement user authentication\n    \n    \n    1\n    \n    1\n    \n    \n    这个提交消息中，implement user authentication 是 subject，简洁明了地描述了引入用户认证功能的目的。\n    \n    fix(Validation): correct input validation logic\n    \n    \n    1\n    \n    1\n    \n    \n    这个提交消息中，correct input validation logic 是 subject，清晰地说明了修复输入验证逻辑的目的。\n\n\n# 1.2 Body\n\nBody 部分是对本次 commit 的详细描述，可以分成多行。Body编写有两个注意点。\n\n>  1. 使用第一人称现在时，比如使用change而不是changed或changes。这有助于使描述更加直观和连贯，增强可读性。\n>  2. 应该说明代码变动的动机，以及与以前行为的对比。 Body 部分不仅仅是描述代码的变动，还应该解释为什么进行这个变动，以及与之前的代码行为相比有哪些改进。这有助于其他开发者更好地理解代码变更的背后动机和意图。\n\n\n# 1.3 Footer\n\nFooter 部分只用于两种情况。\n\n 1. 不兼容变动\n    \n    如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。\n\n 2. 关闭 Issue\n    \n    如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。\n    \n    > Closes #234\n    > \n    > \n    > 1\n    > \n    > 1\n    \n    也可以一次关闭多个 issue 。\n    \n    > Closes #123, #245, #992\n    > \n    > \n    > 1\n    > \n    > 1\n\n\n# 1.4 示例\n\n * 添加用户配置文件编辑功能\n   \n   > feat(UserProfile): add user profile editing feature\n   > \n   > This commit introduces a new feature that allows users to edit their profiles\n   > directly from the user interface. The motivation behind this change is to\n   > enhance user interaction and provide a more seamless experience.\n   > \n   > Previously, users had to navigate to a separate editing page to update their\n   > profile information. With this new feature, users can now make changes\n   > efficiently from their profile page, eliminating unnecessary steps in the\n   > workflow.\n   > \n   > Changes included in this commit:\n   > - Added a new \'Edit Profile\' button on the user profile page.\n   > - Implemented frontend components for profile editing.\n   > - Updated backend API to handle profile updates securely.\n   > \n   > By streamlining the profile editing process, we aim to improve overall user\n   > satisfaction and make our application more user-friendly. This enhancement is\n   > in response to user feedback, addressing the need for a more intuitive and\n   > accessible way to modify profile details.\n   > \n   > Closes #234\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n   > 16\n   > 17\n   > 18\n   > 19\n   > 20\n   > 21\n   > 22\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n   > 16\n   > 17\n   > 18\n   > 19\n   > 20\n   > 21\n   > 22\n\n * 纠正输入验证逻辑\n   \n   > fix(Validation): correct input validation logic\n   > \n   > This commit addresses an issue related to input validation logic in the\n   > application. Previously, the validation process was not handling certain edge\n   > cases correctly, leading to unexpected behavior in specific scenarios.\n   > \n   > To resolve this issue, the validation logic has been revised to properly\n   > handle various input scenarios. This ensures that user input is thoroughly\n   > validated, reducing the likelihood of errors in the application.\n   > \n   > The changes made in this commit include:\n   > - Correcting boundary checks for user input.\n   > - Improving error messages for better user guidance.\n   > \n   > These adjustments align with our commitment to delivering a robust and\n   > reliable application experience.\n   > \n   > Closes #123\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n   > 16\n   > 17\n   > 18\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n   > 16\n   > 17\n   > 18\n\n * 优化数据库查询\n   \n   > refactor(DataAccess): optimize database queries\n   > \n   > In this commit, we have refactored the data access layer to optimize database\n   > queries and improve overall system performance. The existing query structure\n   > was identified as a bottleneck during performance testing, leading to longer\n   > response times.\n   > \n   > Changes made in this commit:\n   > - Reorganized database queries to reduce redundant operations.\n   > - Utilized database indexing for faster data retrieval.\n   > \n   > By optimizing database queries, we expect to see a significant improvement in\n   > system responsiveness and user experience.\n   > \n   > Closes #456\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n\n\n# 2 git commit 工具\n\n\n# 2.1 commitizen\n\nCommitizen是一个强大的工具，用于撰写合格的 Git 提交消息。使用 Commitizen 可以帮助团队遵循统一的提交消息规范，使提交历史更加清晰和易读。\n\n首先，通过以下命令全局安装 Commitizen：\n\n> npm install -g commitizen\n> \n> \n> 1\n> \n> 1\n\n然后，在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。\n\n> commitizen init cz-conventional-changelog --save --save-exact\n> \n> \n> 1\n> \n> 1\n\n这个命令会配置项目，使其支持 Angular 规范的 Commit Message。在执行命令时，你可以选择其他预定义的规范或者创建自定义规范。\n\n之后，当你执行 git commit 命令时，将其替换为 git cz。此时，Commitizen 将引导你通过一个交互式的界面，以生成符合规范的 Commit Message。\n\n在这个交互式界面中，你可以选择提交的类型（feat、fix、docs 等）、影响的范围（scope）、简短的描述（subject）以及其他相关信息。通过这种方式，可以确保提交消息符合规范，并提供了更多的上下文信息，便于他人理解变更的目的。\n\n使用 Commitizen 和规范化的提交消息格式，有助于提高代码库的可读性，方便生成自动化的变更日志，并促使开发者更注重写出清晰、明确的提交消息。\n\n\n# 2.2 commitlint\n\ncommitlint是一个用于检查提交消息是否符合指定规范的工具。它可以帮助团队确保 Git 提交消息的一致性和规范性，尤其是当项目采用类似 Angular Commit Message Conventions 的规范时。\n\n 1. 安装 Commitlint\n    \n    > 首先，你需要安装 commitlint 及其相关的配置和规则。通常，@commitlint/config-conventional 是与 Angular 规范兼容的配置。\n    > \n    > npm install --save-dev @commitlint/config-conventional @commitlint/cli\n    > \n    > \n    > 1\n    > \n    > 1\n\n 2. 配置 Commitlint\n    \n    > 在项目根目录下创建 commitlint.config.js 文件，并添加如下内容：\n    > \n    > module.exports = {\n    >   extends: [\'@commitlint/config-conventional\'],\n    > };\n    > \n    > \n    > 1\n    > 2\n    > 3\n    > \n    > 1\n    > 2\n    > 3\n    > \n    > \n    > 这个配置文件使用了 @commitlint/config-conventional 中预定义的规则，确保符合常见的提交规范。\n\n 3. 配置Git钩子\n    \n    > 你可以使用 Husky 钩子工具来在提交前运行 commitlint。首先，安装 Husky：\n    > \n    > bashCopy code\n    > npm install --save-dev husky\n    > \n    > \n    > 1\n    > 2\n    > \n    > 1\n    > 2\n    > \n    > \n    > 然后，在 package.json 中添加以下配置：\n    > \n    > jsonCopy code\n    > "husky": {\n    >   "hooks": {\n    >     "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"\n    >   }\n    > }\n    > \n    > \n    > 1\n    > 2\n    > 3\n    > 4\n    > 5\n    > 6\n    > \n    > 1\n    > 2\n    > 3\n    > 4\n    > 5\n    > 6\n    > \n    > \n    > 这样配置后，每次提交前都会自动运行 commitlint 检查提交消息是否符合规范。\n\n\n# 3 生成Change log\n\n如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成（例1，例2）。\n\n![image-20231112222340929](/Users/zfhe/Library/Application Support/typora-user-images/image-20231112222340929.png)\n\n生成的文档包括以下三个部分。\n\n>  * New features（新特性）\n>  * Bug fixes（bug修复）\n>  * Breaking changes（重大变更）\n\n每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。\n\nconventional-changelog 就是生成 Change log 的工具，运行下面的命令即可。\n\n> npm install -g conventional-changelog\n> cd my-project\n> conventional-changelog -p angular -i CHANGELOG.md -w\n> \n> \n> 1\n> 2\n> 3\n> \n> 1\n> 2\n> 3\n\n上面命令不会覆盖以前的 Change log，只会在CHANGELOG.md的头部加上自从上次发布以来的变动。\n\n如果你想生成所有发布的 Change log，要改为运行下面的命令。\n\n> $ conventional-changelog -p angular -i CHANGELOG.md -w -r 0\n> \n> \n> 1\n> \n> 1\n\n为了方便使用，可以将其写入package.json的scripts字段。\n\n> {\n>   "scripts": {\n>     "changelog": "conventional-changelog -p angular -i CHANGELOG.md -w -r 0"\n>   }\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n以后，直接运行下面的命令即可。\n\n> $ npm run changelog\n> \n> \n> 1\n> \n> 1\n\n这个自动化流程不仅简化了 Change log 的生成过程，还确保了记录项目变更的一致性和准确性。生成的文档会按照新特性、bug 修复和重大变更等分类，方便用户快速了解每个版本的变更情况。\n\n\n# 4 参考资料\n\n 1. 如何规范你的Git commit？—阿里云开发者\n 2. Commit message 和 Change log 编写指南—阮一峰的网络日志',normalizedContent:'# 1 commit message 规范\n\ncommit message格式都包括三部分：header，body和footer\n\n<type>(<scope>): <subject>\n\n<body>\n\n<footer>\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\nheader是必需的，body和footer则可以省略\n\n\n# 1.1 header\n\n 1. type（必需）\n    \n    type用于说明git commit的类别，允许使用下面几个标识。\n    \n    >  * feat：新功能（feature）\n    >    \n    >    "feat"用于表示引入新功能或特性的变动。这种变动通常是在代码库中新增的功能，而不仅仅是修复错误或进行代码重构。\n    > \n    >  * fix/to：修复bug。这些bug可能由qa团队发现，或由开发人员在开发过程中识别。\n    >    \n    >    * fix关键字用于那些直接解决问题的提交。当创建一个包含必要更改的提交，并且这些更改能够直接修复已识别的bug时，应使用fix。这表明提交的代码引入了解决方案，并且问题已被立即解决。\n    >    * to关键字则用于那些部分处理问题的提交。在一些复杂的修复过程中，可能需要多个步骤或多次提交来完全解决问题。在这种情况下，初始和中间的提交应使用to标记，表示它们为最终解决方案做出了贡献，但并未完全解决问题。最终解决问题的提交应使用fix标记，以表明问题已被彻底修复。\n    > \n    >  * docs：文档（documentation）\n    >    \n    >    "docs" 表示对文档的变动，这包括对代码库中的注释、readme 文件或其他文档的修改。这个前缀的提交通常用于更新文档以反映代码的变更，或者提供更好的代码理解和使用说明。\n    > \n    >  * style: 格式（format）\n    >    \n    >    "style" 用于表示对代码格式的变动，这些变动不影响代码的运行。通常包括空格、缩进、换行等风格调整。\n    > \n    >  * refactor：重构（即不是新增功能，也不是修改bug的代码变动）\n    >    \n    >    "refactor" 表示对代码的重构，即修改代码的结构和实现方式，但不影响其外部行为。重构的目的是改进代码的可读性、可维护性和性能，而不是引入新功能或修复错误。\n    > \n    >  * perf: 优化相关，比如提升性能、体验\n    >    \n    >    "perf" 表示与性能优化相关的变动。这可能包括对算法、数据结构或代码实现的修改，以提高代码的执行效率和用户体验。\n    > \n    >  * test：增加测试\n    >    \n    >    "test" 表示增加测试，包括单元测试、集成测试或其他类型的测试。\n    > \n    >  * chore：构建过程或辅助工具的变动\n    >    \n    >    "chore" 表示对构建过程或辅助工具的变动。这可能包括更新构建脚本、配置文件或其他与构建和工具相关的内容。\n    > \n    >  * revert：回滚到上一个版本\n    >    \n    >    "revert" 用于回滚到以前的版本，撤销之前的提交。\n    > \n    >  * merge：代码合并\n    >    \n    >    "merge" 表示进行代码合并，通常是在分支开发完成后将代码合并回主线。\n    > \n    >  * sync：同步主线或分支的bug\n    >    \n    >    "sync" 表示同步主线或分支的 bug，通常用于解决因为合并而引入的问题。\n\n 2. scope（可选）\n    \n    scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。\n    \n    例如修改了dao或者controller，则可以添加表示这些范围受到影响，这有助于更清晰地理解提交的变更影响范围。例如：\n    \n    feat(controller): 添加用户登录功能\n    \n    \n    1\n    \n    1\n    \n    \n    这个提交消息中，controller 是 scope，表示这次提交影响了控制层。\n    \n    fix(dataaccess): 修复数据查询逻辑\n    \n    \n    1\n    \n    1\n    \n    \n    这个提交消息中，dataaccess 是 scope，表示这次提交影响了数据访问层。\n    \n    如果你的修改影响了不止一个scope，你可以使用*代替。\n\n 3. subject（必需）\n    \n    subject是 commit 目的的简短描述，不超过50个字符。规范如下：\n    \n    >  * 以动词开头，使用第一人称现在时，比如change，而不是changed或changes\n    >  * 第一个字母小写\n    >  * 结尾不加句号（.）\n    \n    例如：\n    \n    feat(userauth): implement user authentication\n    \n    \n    1\n    \n    1\n    \n    \n    这个提交消息中，implement user authentication 是 subject，简洁明了地描述了引入用户认证功能的目的。\n    \n    fix(validation): correct input validation logic\n    \n    \n    1\n    \n    1\n    \n    \n    这个提交消息中，correct input validation logic 是 subject，清晰地说明了修复输入验证逻辑的目的。\n\n\n# 1.2 body\n\nbody 部分是对本次 commit 的详细描述，可以分成多行。body编写有两个注意点。\n\n>  1. 使用第一人称现在时，比如使用change而不是changed或changes。这有助于使描述更加直观和连贯，增强可读性。\n>  2. 应该说明代码变动的动机，以及与以前行为的对比。 body 部分不仅仅是描述代码的变动，还应该解释为什么进行这个变动，以及与之前的代码行为相比有哪些改进。这有助于其他开发者更好地理解代码变更的背后动机和意图。\n\n\n# 1.3 footer\n\nfooter 部分只用于两种情况。\n\n 1. 不兼容变动\n    \n    如果当前代码与上一个版本不兼容，则 footer 部分以breaking change开头，后面是对变动的描述、以及变动理由和迁移方法。\n\n 2. 关闭 issue\n    \n    如果当前 commit 针对某个issue，那么可以在 footer 部分关闭这个 issue 。\n    \n    > closes #234\n    > \n    > \n    > 1\n    > \n    > 1\n    \n    也可以一次关闭多个 issue 。\n    \n    > closes #123, #245, #992\n    > \n    > \n    > 1\n    > \n    > 1\n\n\n# 1.4 示例\n\n * 添加用户配置文件编辑功能\n   \n   > feat(userprofile): add user profile editing feature\n   > \n   > this commit introduces a new feature that allows users to edit their profiles\n   > directly from the user interface. the motivation behind this change is to\n   > enhance user interaction and provide a more seamless experience.\n   > \n   > previously, users had to navigate to a separate editing page to update their\n   > profile information. with this new feature, users can now make changes\n   > efficiently from their profile page, eliminating unnecessary steps in the\n   > workflow.\n   > \n   > changes included in this commit:\n   > - added a new \'edit profile\' button on the user profile page.\n   > - implemented frontend components for profile editing.\n   > - updated backend api to handle profile updates securely.\n   > \n   > by streamlining the profile editing process, we aim to improve overall user\n   > satisfaction and make our application more user-friendly. this enhancement is\n   > in response to user feedback, addressing the need for a more intuitive and\n   > accessible way to modify profile details.\n   > \n   > closes #234\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n   > 16\n   > 17\n   > 18\n   > 19\n   > 20\n   > 21\n   > 22\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n   > 16\n   > 17\n   > 18\n   > 19\n   > 20\n   > 21\n   > 22\n\n * 纠正输入验证逻辑\n   \n   > fix(validation): correct input validation logic\n   > \n   > this commit addresses an issue related to input validation logic in the\n   > application. previously, the validation process was not handling certain edge\n   > cases correctly, leading to unexpected behavior in specific scenarios.\n   > \n   > to resolve this issue, the validation logic has been revised to properly\n   > handle various input scenarios. this ensures that user input is thoroughly\n   > validated, reducing the likelihood of errors in the application.\n   > \n   > the changes made in this commit include:\n   > - correcting boundary checks for user input.\n   > - improving error messages for better user guidance.\n   > \n   > these adjustments align with our commitment to delivering a robust and\n   > reliable application experience.\n   > \n   > closes #123\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n   > 16\n   > 17\n   > 18\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n   > 16\n   > 17\n   > 18\n\n * 优化数据库查询\n   \n   > refactor(dataaccess): optimize database queries\n   > \n   > in this commit, we have refactored the data access layer to optimize database\n   > queries and improve overall system performance. the existing query structure\n   > was identified as a bottleneck during performance testing, leading to longer\n   > response times.\n   > \n   > changes made in this commit:\n   > - reorganized database queries to reduce redundant operations.\n   > - utilized database indexing for faster data retrieval.\n   > \n   > by optimizing database queries, we expect to see a significant improvement in\n   > system responsiveness and user experience.\n   > \n   > closes #456\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > 14\n   > 15\n\n\n# 2 git commit 工具\n\n\n# 2.1 commitizen\n\ncommitizen是一个强大的工具，用于撰写合格的 git 提交消息。使用 commitizen 可以帮助团队遵循统一的提交消息规范，使提交历史更加清晰和易读。\n\n首先，通过以下命令全局安装 commitizen：\n\n> npm install -g commitizen\n> \n> \n> 1\n> \n> 1\n\n然后，在项目目录里，运行下面的命令，使其支持 angular 的 commit message 格式。\n\n> commitizen init cz-conventional-changelog --save --save-exact\n> \n> \n> 1\n> \n> 1\n\n这个命令会配置项目，使其支持 angular 规范的 commit message。在执行命令时，你可以选择其他预定义的规范或者创建自定义规范。\n\n之后，当你执行 git commit 命令时，将其替换为 git cz。此时，commitizen 将引导你通过一个交互式的界面，以生成符合规范的 commit message。\n\n在这个交互式界面中，你可以选择提交的类型（feat、fix、docs 等）、影响的范围（scope）、简短的描述（subject）以及其他相关信息。通过这种方式，可以确保提交消息符合规范，并提供了更多的上下文信息，便于他人理解变更的目的。\n\n使用 commitizen 和规范化的提交消息格式，有助于提高代码库的可读性，方便生成自动化的变更日志，并促使开发者更注重写出清晰、明确的提交消息。\n\n\n# 2.2 commitlint\n\ncommitlint是一个用于检查提交消息是否符合指定规范的工具。它可以帮助团队确保 git 提交消息的一致性和规范性，尤其是当项目采用类似 angular commit message conventions 的规范时。\n\n 1. 安装 commitlint\n    \n    > 首先，你需要安装 commitlint 及其相关的配置和规则。通常，@commitlint/config-conventional 是与 angular 规范兼容的配置。\n    > \n    > npm install --save-dev @commitlint/config-conventional @commitlint/cli\n    > \n    > \n    > 1\n    > \n    > 1\n\n 2. 配置 commitlint\n    \n    > 在项目根目录下创建 commitlint.config.js 文件，并添加如下内容：\n    > \n    > module.exports = {\n    >   extends: [\'@commitlint/config-conventional\'],\n    > };\n    > \n    > \n    > 1\n    > 2\n    > 3\n    > \n    > 1\n    > 2\n    > 3\n    > \n    > \n    > 这个配置文件使用了 @commitlint/config-conventional 中预定义的规则，确保符合常见的提交规范。\n\n 3. 配置git钩子\n    \n    > 你可以使用 husky 钩子工具来在提交前运行 commitlint。首先，安装 husky：\n    > \n    > bashcopy code\n    > npm install --save-dev husky\n    > \n    > \n    > 1\n    > 2\n    > \n    > 1\n    > 2\n    > \n    > \n    > 然后，在 package.json 中添加以下配置：\n    > \n    > jsoncopy code\n    > "husky": {\n    >   "hooks": {\n    >     "commit-msg": "commitlint -e husky_git_params"\n    >   }\n    > }\n    > \n    > \n    > 1\n    > 2\n    > 3\n    > 4\n    > 5\n    > 6\n    > \n    > 1\n    > 2\n    > 3\n    > 4\n    > 5\n    > 6\n    > \n    > \n    > 这样配置后，每次提交前都会自动运行 commitlint 检查提交消息是否符合规范。\n\n\n# 3 生成change log\n\n如果你的所有 commit 都符合 angular 格式，那么发布新版本时， change log 就可以用脚本自动生成（例1，例2）。\n\n![image-20231112222340929](/users/zfhe/library/application support/typora-user-images/image-20231112222340929.png)\n\n生成的文档包括以下三个部分。\n\n>  * new features（新特性）\n>  * bug fixes（bug修复）\n>  * breaking changes（重大变更）\n\n每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。\n\nconventional-changelog 就是生成 change log 的工具，运行下面的命令即可。\n\n> npm install -g conventional-changelog\n> cd my-project\n> conventional-changelog -p angular -i changelog.md -w\n> \n> \n> 1\n> 2\n> 3\n> \n> 1\n> 2\n> 3\n\n上面命令不会覆盖以前的 change log，只会在changelog.md的头部加上自从上次发布以来的变动。\n\n如果你想生成所有发布的 change log，要改为运行下面的命令。\n\n> $ conventional-changelog -p angular -i changelog.md -w -r 0\n> \n> \n> 1\n> \n> 1\n\n为了方便使用，可以将其写入package.json的scripts字段。\n\n> {\n>   "scripts": {\n>     "changelog": "conventional-changelog -p angular -i changelog.md -w -r 0"\n>   }\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n以后，直接运行下面的命令即可。\n\n> $ npm run changelog\n> \n> \n> 1\n> \n> 1\n\n这个自动化流程不仅简化了 change log 的生成过程，还确保了记录项目变更的一致性和准确性。生成的文档会按照新特性、bug 修复和重大变更等分类，方便用户快速了解每个版本的变更情况。\n\n\n# 4 参考资料\n\n 1. 如何规范你的git commit？—阿里云开发者\n 2. commit message 和 change log 编写指南—阮一峰的网络日志',charsets:{cjk:!0},lastUpdated:"2023/11/25, 12:26:00",lastUpdatedTimestamp:170088636e4},{title:"Git教程",frontmatter:{title:"Git教程",date:"2022-01-26T16:15:34.000Z",tags:["Git"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/992deb/",categories:["工具","版本控制"],readingShow:"top"},regularPath:"/02.%E5%B7%A5%E5%85%B7/01.%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/02.Git%E6%95%99%E7%A8%8B.html",relativePath:"02.工具/01.版本控制/02.Git教程.md",key:"v-3a3276c2",path:"/pages/992deb/",headers:[{level:2,title:"1 git简介",slug:"_1-git简介",normalizedTitle:"1 git简介",charIndex:2},{level:3,title:"1.1 什么是版本控制",slug:"_1-1-什么是版本控制",normalizedTitle:"1.1 什么是版本控制",charIndex:14},{level:3,title:"1.2 什么是git",slug:"_1-2-什么是git",normalizedTitle:"1.2 什么是git",charIndex:1018},{level:3,title:"1.3 git的几个核心概念",slug:"_1-3-git的几个核心概念",normalizedTitle:"1.3 git的几个核心概念",charIndex:1385},{level:3,title:"1.4 git工作流程",slug:"_1-4-git工作流程",normalizedTitle:"1.4 git工作流程",charIndex:1800},{level:2,title:"2 git安装配置",slug:"_2-git安装配置",normalizedTitle:"2 git安装配置",charIndex:1975},{level:3,title:"2.1 windows平台安装",slug:"_2-1-windows平台安装",normalizedTitle:"2.1 windows平台安装",charIndex:1989},{level:3,title:"2.2 Linux平台安装",slug:"_2-2-linux平台安装",normalizedTitle:"2.2 linux平台安装",charIndex:2049},{level:3,title:"2.3 Mac平台安装",slug:"_2-3-mac平台安装",normalizedTitle:"2.3 mac平台安装",charIndex:2320},{level:3,title:"2.4 配置",slug:"_2-4-配置",normalizedTitle:"2.4 配置",charIndex:2376},{level:2,title:"3 git基本命令",slug:"_3-git基本命令",normalizedTitle:"3 git基本命令",charIndex:2576},{level:3,title:"3.1 建立本地仓库",slug:"_3-1-建立本地仓库",normalizedTitle:"3.1 建立本地仓库",charIndex:2590},{level:3,title:"3.2 提交、修改和删除",slug:"_3-2-提交、修改和删除",normalizedTitle:"3.2 提交、修改和删除",charIndex:2935},{level:3,title:"3.3 查看日志",slug:"_3-3-查看日志",normalizedTitle:"3.3 查看日志",charIndex:4582},{level:3,title:"3.4 分支管理",slug:"_3-4-分支管理",normalizedTitle:"3.4 分支管理",charIndex:4851},{level:3,title:"3.5 远程操作",slug:"_3-5-远程操作",normalizedTitle:"3.5 远程操作",charIndex:5389},{level:3,title:"3.6 保存和恢复进度",slug:"_3-6-保存和恢复进度",normalizedTitle:"3.6 保存和恢复进度",charIndex:6361},{level:2,title:"4 Git用法思维导图",slug:"_4-git用法思维导图",normalizedTitle:"4 git用法思维导图",charIndex:6967}],headersStr:"1 git简介 1.1 什么是版本控制 1.2 什么是git 1.3 git的几个核心概念 1.4 git工作流程 2 git安装配置 2.1 windows平台安装 2.2 Linux平台安装 2.3 Mac平台安装 2.4 配置 3 git基本命令 3.1 建立本地仓库 3.2 提交、修改和删除 3.3 查看日志 3.4 分支管理 3.5 远程操作 3.6 保存和恢复进度 4 Git用法思维导图",content:'# 1 git简介\n\n\n# 1.1 什么是版本控制\n\n版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 除了项目源代码，你可以对任何类型的文件进行版本控制。 有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。 而版本控制系统（VCS）则是一种软件，可以帮助软件团队的开发人员协同工作，并存档他们工作的完整历史记录。 目前版本控制系统有如下三种：\n\n * 本地版本控制系统：即通过用文件目录形式保存每个项目版本，其中目录名会备注一些版本信息、修改时间等。其最大的好处就是简单，但特别容易犯错，不利于管理，容易覆盖重要的文件，而且不适合协同工作。\n\n * 集中式版本控制系统（Centralized Version Control Systems，CVCS）：集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。这么做虽然解决了本地版本控制系统无法让在不同系统上的开发者协同工作的诟病，但也还是存在下面的问题：如果中央服务器宕机，则其他人无法使用；必须联网才能工作。\n\n * 分布式版本控制系统（Distributed Version Control Systems，DVCS）：在这类系统中，像 Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。 分布式版本控制系统可以不用联网就可以工作，因为每个人的电脑上都是完整的版本库，当你修改了某个文件后，你只需要将自己的修改推送给别人就可以了。但是，在实际使用分布式版本控制系统的时候，很少会直接进行推送修改，而是使用一台充当“中央服务器”的东西。这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 分布式版本控制系统的优势不单是不必联网这么简单，后面我们还会看到 Git 极其强大的分支管理等功能。\n\n\n# 1.2 什么是git\n\nGit是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。其是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 官网地址为：https://git-scm.com/，在上面有权威的git介绍以及git下载地址。 SVN是集中式版本控制系统，而Git是分布式版本控制系统，Git与SVN的区别可参考Git与SVN的区别。 git有以下优点：\n\n * 适合分布式开发，强调个体；公共服务器压力和数据量都不会太大；\n\n * 速度快、灵活；\n\n * 任意两个开发者之间可以很容易的解决冲突；\n\n * 离线工作。\n\n\n# 1.3 git的几个核心概念\n\n * 工作区（workspace）：仓库的目录。工作区是独立于各个分支的。在当前仓库中，新增，更改，删除文件这些动作，都发生在工作区里面。\n * 暂存区（index/stage）：数据暂时存放的区域，类似于工作区写入版本库前的缓存区。暂存区是独立于各个分支的。一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。\n * 版本库（Repository）：也可以叫仓库区，实际上就是我们的本地仓库。就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本\n * 版本结构：树结构，树中每个节点代表一个代码版本。\n * 远程仓库（Remote Repository）： 托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换。目前流行的远程仓库有：Github、Gitee。\n\n\n# 1.4 git工作流程\n\n一般工作流程如下：\n\n * 从远程仓库中克隆 Git 资源作为本地仓库；\n * 从本地仓库中checkout代码然后进行代码修改；\n * 在提交本地仓库前先将代码提交到暂存区；\n * 提交修改，提交到本地仓库；本地仓库中保存修改的各个历史版本；\n * 在需要和团队成员共享代码时，可以将修改代码push到远程仓库。\n\n\n# 2 git安装配置\n\n\n# 2.1 windows平台安装\n\n主要学linux，这里列出其他blog的windows平台安装教程：安装教程\n\n\n# 2.2 Linux平台安装\n\n首先，我们可以尝试着输入git，看看系统有没有安装Git：\n\n$ git\nThe program \'git\' is currently not installed. You can install it by typing:\nsudo apt-get install git\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n如果出现这个，则说明Git还没有安装，如果我们使用得是Debian或者Ubuntu Linux，通过命令：sudo apt-get install git就可以直接完成Git的安装，非常简单。\n\n\n# 2.3 Mac平台安装\n\n主要学linux，这里列出其他blog的Mac平台安装配置教程：安装配置教程\n\n\n# 2.4 配置\n\n安装好git之后，就需要对git进行配置操作了，需要配置自己的用户名和Email。配置的命令如下：\n\n$ git config --global user.name "用户名"\n$ git config --global user.email "邮箱"\n\n\n1\n2\n\n1\n2\n\n\n如果你需要检查你的配置信息，可以使用git config --list命令来列出所有配置信息：\n\n\n# 3 git基本命令\n\n\n# 3.1 建立本地仓库\n\n(1). 创建一个目录，并将其初始化为本地仓库 git init 本地仓库名 (2). 使用当前目录作为本地仓库 git init (3). 将远程仓库克隆下来作为本地仓库 此命令支持多种协议，但我一般是通过SSH协议，其内部实现是通过SSH，所以进行这步操作之前我们需要确保在远程仓库添加了SSH公钥，如果没有添加需要在本地主机通过ssh-keygen，然后会生成ssh公钥和密钥，我们将公钥添加到远程仓库即可。 git clone git@服务器名:仓库路径 该格式和scp命令一致，@前面表示用户名，这个一般都是git，后面表示服务器名，可以是IP地址，也可以是域名，例如github.com，:后面表示仓库路径。不过不需要担心，这个远程仓库会给出。\n\n\n# 3.2 提交、修改和删除\n\n(1). 将文件提交到暂存区\n\n# 将指定文件添加到暂存区\ngit add file1 file2 ... fileN \n# 将指定目录添加到暂存区\ngit add dir1 dir2 ... dirN\n# 添加当前目录下的所有文件到暂存区\ngit add .\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n(2). 将文件从暂存区中撤出，但不会撤销文件的更改 git restore --staged (3). 将不在暂存区的文件撤销更改，需要和(2)作区分，两者作用完全不一样。\n\ngit restore file\n或\ngit checkout -- file\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n(4). 比较暂存区和工作区文件之间的差异\n\n# 显示暂存区和工作区之间的差异\ngit diff [file]\n# 显示暂存区和上一次提交的差异\ngit diff --cached [file]\n或\ngit diff --staged [file]\n# 显示两次提交的差异\n \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n该file可以省略，如果省略，则是比较暂存区中的所有文件。注意，如果暂存区没有内容，则是比较HEAD指针指向的版本库内容。 (5). 查看仓库状态 git status 该命令用于查看在你上次提交之后是否有对文件进行再次修改，如果我们需要获取简短的输出结果，可添加-s参数来实现。 (6). 提交暂存区内容到本地仓库 暂存区的内容可以通过git commit来提交到本地仓库。 git commit [file1] [file2]...[fileN] -m [备注信息] 其中file1等是可以直接省略的，如果意味着提交所有信息，而-m是参数，后面接备注信息。当然，在进行git commit之前，我们需要通过git add命令将修改添加到暂存区。 (7). 回退版本 我们可以通过git reset命令来回退版本，可以指定退回某一次提交的版本。具体如下：\n\n# 将代码库回退到上一个版本\ngit reset --hard HEAD^ \n或\ngit reset --hard HEAD~\n# 向上回滚两次，一次类推\ngit reset --hard HEAD^^\n# 向上回滚n次。\ngit rest --hard HEAD~n\n# 回滚到某一特定版本，用版本号实现，版本号唯一标识一个版本\ngit reset --hard 版本号\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n(8). 删除文件 在Git中，删除文件也是一种修改操作，删除文件有三种形式：\n\n> 利用rm file实现删除，此形式只是会删除工作区的文件，并没有删除版本库的文件，如果还需要删除版本库的文件还需要执行下列命令，这样就可以实现工作区和版本库的文件：\n\ngit add file # 加入暂存区\ngit commit -m  "delete file"\n\n\n1\n2\n\n1\n2\n\n\n> 利用git rm file实现删除，会删除工作区的文件，并且将此次删除加入暂存区。但需要注意要删除的文件是没有修改过的，如果需要删除修改过的，需要加入-f，当然，这个时候我们也还没有删除版本库的文件，只是我们只需要执行git commit -m "delete file"就可以。\n\n利用git rm --cached file实现删除，只会删除暂存区的文件，但会保留工作区的文件，并且会将这次删除放入暂存区，然后我们执行git commit -m "delete file"就可以实现删除暂存区和版本库的文件。 (9). 移动或者重命名文件 git mv [file] [newFile]可以用来移动或者重命名一个文件、目录或者软连接。如果新文件名已经存在，还需要添加-f参数。\n\n\n# 3.3 查看日志\n\n(1). 查看当前分支的所有版本 git log，我们可以用这个命令历史提交记录，当然这个命令还有许多参数供我们使用：\n\n * --oneline：查看历史记录的简洁版本。\n * --graph：查看历史中什么时候出现了分支、合并。开启拓扑图选项。\n * --reverse：逆向显示所有日志。\n * --author=user：指定查看user提交的部分。\n * --since、--before、--after等：指定日期。 (2). 查看HEAD指针的移动历史（包括被回滚的版本） git reflog\n\n\n# 3.4 分支管理\n\n几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。 有人把 Git 的分支模型称为必杀技特性，而正是因为它，将 Git 从版本控制系统家族里区分出来。 (1). 创建分支 git branch (branchName) (2). 切换分支 git checkout (branchName) 当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。 添加-b参数可以创建并切换分支。 (3). 合并分支 git merge (branchName) 将branch_name合并到当前分支上。 (4) 删除分支 git branch -d (branchName) 删除本地仓库的branchName分支。 (5). 列出分支 git branch 没有参数时，git branch会列出你在本地的分支。 (6). 合并冲突 合并并不仅仅是简单的文件添加、移除的操作。Git也会合并修改，当两个分支对同一个文件都进行了修改，那么就会产生合并冲突，我们需要去手动修改它。然后需要使用git add命令来告诉Git冲突已经解决了。\n\n\n# 3.5 远程操作\n\n(1). 将本地仓库关联到远程仓库 git remote add [short-name] [url] 其中short-name指定一个方便使用的简写，为远程仓库的别名。例如git remote add origin git@git.acwing.com:unique_pursuit/test.git即可添加远程仓库。 (2). 查看当前配置有哪些远程库 git remote 执行时添加上-v参数可查看到每个别名的实际链接地址。 (3). 删除远程仓库 git remote rm name 其中name为仓库的别名。 (4). 修改仓库名 git remote rename old_name new_name (5). 查看主机的详细信息 git remote show <主机名> (6) 设置本地分支与远程仓库分支对应 git push --set-upstream <远程主机名> <branchName> 设置本地的branchName分支对应远程仓库的branchName分支，远程主机名为git clone设置的仓库别名。 git branch --set-upstream-to=origin/branchName1 branchName2 将远程仓库的branchName1分支与本地的branchName2分支对应。 (7). 将本地当前分支推送到远程主机 git push <远程主机名> <本地分支名>:<远程分支名> 如果本地分支名和远程分支名相同，则可以直接使用下面的命令。 git push <远程主机名> <branchName> 将本地的branchName分支推到远程仓库，在此之前需要先设置与远程仓库对应分支。 如果当前分支与多个主机存在追踪关系，需要使用-u参数指定一个默认主机，这样后面可以不加任何参数使用git push。 (8). 删除远程仓库的branchName分支 git push -d <远程主机名> branchName (9). 将远程仓库的分支与本地仓库的分支合并 git pull <远程主机名> <远程分支名>:<本地分支名> 如果本地分支名和远程分支名相同，则可以使用下面的命令。 git push <远程分支名> <branchName>\n\n\n# 3.6 保存和恢复进度\n\n我们有时会遇到这样的情况，正在dev分支开发新功能，做到一半时有人过来反馈一个bug，让马上解决，但是新功能做到了一半你又不想提交，又想保存它，这个时候就可以使用git stash命令先把进度保存起来。 (1). 保存当前工作进度 git stash 将工作区和暂存区尚未提交的修改存入栈中。再运行git status可以发现是一个干净的工作区，没有任何改动。使用git stash save \'message\'可以添加一些注释 (2). 恢复工作进度 恢复最新的进度到工作区。git会默认把工作区和暂存区的改动都恢复到工作区。 git stash pop 恢复最新的进度到工作区和暂存区。 git stash pop --index 恢复指定的进度到工作区。 git stash pop stash_id 其中stash_id是通过git stash list获取的。 通过git stash pop恢复进度后，会删除当前进度。 还有一个git stash apply命令除了不删除进度，其他和git stash pop一样。 (3). 显示保存进度的列表 git stash list (4) 删除进度 删除所有进度 git stash clear 删除一个存储的进度，如果不指定stash_id，则默认删除最新的进度。 git stash drop [stash_id]\n\n\n# 4 Git用法思维导图\n\n',normalizedContent:'# 1 git简介\n\n\n# 1.1 什么是版本控制\n\n版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 除了项目源代码，你可以对任何类型的文件进行版本控制。 有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。 而版本控制系统（vcs）则是一种软件，可以帮助软件团队的开发人员协同工作，并存档他们工作的完整历史记录。 目前版本控制系统有如下三种：\n\n * 本地版本控制系统：即通过用文件目录形式保存每个项目版本，其中目录名会备注一些版本信息、修改时间等。其最大的好处就是简单，但特别容易犯错，不利于管理，容易覆盖重要的文件，而且不适合协同工作。\n\n * 集中式版本控制系统（centralized version control systems，cvcs）：集中化的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。这么做虽然解决了本地版本控制系统无法让在不同系统上的开发者协同工作的诟病，但也还是存在下面的问题：如果中央服务器宕机，则其他人无法使用；必须联网才能工作。\n\n * 分布式版本控制系统（distributed version control systems，dvcs）：在这类系统中，像 git、mercurial、bazaar 以及 darcs 等，客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。 分布式版本控制系统可以不用联网就可以工作，因为每个人的电脑上都是完整的版本库，当你修改了某个文件后，你只需要将自己的修改推送给别人就可以了。但是，在实际使用分布式版本控制系统的时候，很少会直接进行推送修改，而是使用一台充当“中央服务器”的东西。这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 分布式版本控制系统的优势不单是不必联网这么简单，后面我们还会看到 git 极其强大的分支管理等功能。\n\n\n# 1.2 什么是git\n\ngit是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。其是 linus torvalds 为了帮助管理 linux 内核开发而开发的一个开放源码的版本控制软件。git 与常用的版本控制工具 cvs, subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 官网地址为：https://git-scm.com/，在上面有权威的git介绍以及git下载地址。 svn是集中式版本控制系统，而git是分布式版本控制系统，git与svn的区别可参考git与svn的区别。 git有以下优点：\n\n * 适合分布式开发，强调个体；公共服务器压力和数据量都不会太大；\n\n * 速度快、灵活；\n\n * 任意两个开发者之间可以很容易的解决冲突；\n\n * 离线工作。\n\n\n# 1.3 git的几个核心概念\n\n * 工作区（workspace）：仓库的目录。工作区是独立于各个分支的。在当前仓库中，新增，更改，删除文件这些动作，都发生在工作区里面。\n * 暂存区（index/stage）：数据暂时存放的区域，类似于工作区写入版本库前的缓存区。暂存区是独立于各个分支的。一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。\n * 版本库（repository）：也可以叫仓库区，实际上就是我们的本地仓库。就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中head指向最新放入仓库的版本\n * 版本结构：树结构，树中每个节点代表一个代码版本。\n * 远程仓库（remote repository）： 托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换。目前流行的远程仓库有：github、gitee。\n\n\n# 1.4 git工作流程\n\n一般工作流程如下：\n\n * 从远程仓库中克隆 git 资源作为本地仓库；\n * 从本地仓库中checkout代码然后进行代码修改；\n * 在提交本地仓库前先将代码提交到暂存区；\n * 提交修改，提交到本地仓库；本地仓库中保存修改的各个历史版本；\n * 在需要和团队成员共享代码时，可以将修改代码push到远程仓库。\n\n\n# 2 git安装配置\n\n\n# 2.1 windows平台安装\n\n主要学linux，这里列出其他blog的windows平台安装教程：安装教程\n\n\n# 2.2 linux平台安装\n\n首先，我们可以尝试着输入git，看看系统有没有安装git：\n\n$ git\nthe program \'git\' is currently not installed. you can install it by typing:\nsudo apt-get install git\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n如果出现这个，则说明git还没有安装，如果我们使用得是debian或者ubuntu linux，通过命令：sudo apt-get install git就可以直接完成git的安装，非常简单。\n\n\n# 2.3 mac平台安装\n\n主要学linux，这里列出其他blog的mac平台安装配置教程：安装配置教程\n\n\n# 2.4 配置\n\n安装好git之后，就需要对git进行配置操作了，需要配置自己的用户名和email。配置的命令如下：\n\n$ git config --global user.name "用户名"\n$ git config --global user.email "邮箱"\n\n\n1\n2\n\n1\n2\n\n\n如果你需要检查你的配置信息，可以使用git config --list命令来列出所有配置信息：\n\n\n# 3 git基本命令\n\n\n# 3.1 建立本地仓库\n\n(1). 创建一个目录，并将其初始化为本地仓库 git init 本地仓库名 (2). 使用当前目录作为本地仓库 git init (3). 将远程仓库克隆下来作为本地仓库 此命令支持多种协议，但我一般是通过ssh协议，其内部实现是通过ssh，所以进行这步操作之前我们需要确保在远程仓库添加了ssh公钥，如果没有添加需要在本地主机通过ssh-keygen，然后会生成ssh公钥和密钥，我们将公钥添加到远程仓库即可。 git clone git@服务器名:仓库路径 该格式和scp命令一致，@前面表示用户名，这个一般都是git，后面表示服务器名，可以是ip地址，也可以是域名，例如github.com，:后面表示仓库路径。不过不需要担心，这个远程仓库会给出。\n\n\n# 3.2 提交、修改和删除\n\n(1). 将文件提交到暂存区\n\n# 将指定文件添加到暂存区\ngit add file1 file2 ... filen \n# 将指定目录添加到暂存区\ngit add dir1 dir2 ... dirn\n# 添加当前目录下的所有文件到暂存区\ngit add .\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n(2). 将文件从暂存区中撤出，但不会撤销文件的更改 git restore --staged (3). 将不在暂存区的文件撤销更改，需要和(2)作区分，两者作用完全不一样。\n\ngit restore file\n或\ngit checkout -- file\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n(4). 比较暂存区和工作区文件之间的差异\n\n# 显示暂存区和工作区之间的差异\ngit diff [file]\n# 显示暂存区和上一次提交的差异\ngit diff --cached [file]\n或\ngit diff --staged [file]\n# 显示两次提交的差异\n \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n该file可以省略，如果省略，则是比较暂存区中的所有文件。注意，如果暂存区没有内容，则是比较head指针指向的版本库内容。 (5). 查看仓库状态 git status 该命令用于查看在你上次提交之后是否有对文件进行再次修改，如果我们需要获取简短的输出结果，可添加-s参数来实现。 (6). 提交暂存区内容到本地仓库 暂存区的内容可以通过git commit来提交到本地仓库。 git commit [file1] [file2]...[filen] -m [备注信息] 其中file1等是可以直接省略的，如果意味着提交所有信息，而-m是参数，后面接备注信息。当然，在进行git commit之前，我们需要通过git add命令将修改添加到暂存区。 (7). 回退版本 我们可以通过git reset命令来回退版本，可以指定退回某一次提交的版本。具体如下：\n\n# 将代码库回退到上一个版本\ngit reset --hard head^ \n或\ngit reset --hard head~\n# 向上回滚两次，一次类推\ngit reset --hard head^^\n# 向上回滚n次。\ngit rest --hard head~n\n# 回滚到某一特定版本，用版本号实现，版本号唯一标识一个版本\ngit reset --hard 版本号\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n(8). 删除文件 在git中，删除文件也是一种修改操作，删除文件有三种形式：\n\n> 利用rm file实现删除，此形式只是会删除工作区的文件，并没有删除版本库的文件，如果还需要删除版本库的文件还需要执行下列命令，这样就可以实现工作区和版本库的文件：\n\ngit add file # 加入暂存区\ngit commit -m  "delete file"\n\n\n1\n2\n\n1\n2\n\n\n> 利用git rm file实现删除，会删除工作区的文件，并且将此次删除加入暂存区。但需要注意要删除的文件是没有修改过的，如果需要删除修改过的，需要加入-f，当然，这个时候我们也还没有删除版本库的文件，只是我们只需要执行git commit -m "delete file"就可以。\n\n利用git rm --cached file实现删除，只会删除暂存区的文件，但会保留工作区的文件，并且会将这次删除放入暂存区，然后我们执行git commit -m "delete file"就可以实现删除暂存区和版本库的文件。 (9). 移动或者重命名文件 git mv [file] [newfile]可以用来移动或者重命名一个文件、目录或者软连接。如果新文件名已经存在，还需要添加-f参数。\n\n\n# 3.3 查看日志\n\n(1). 查看当前分支的所有版本 git log，我们可以用这个命令历史提交记录，当然这个命令还有许多参数供我们使用：\n\n * --oneline：查看历史记录的简洁版本。\n * --graph：查看历史中什么时候出现了分支、合并。开启拓扑图选项。\n * --reverse：逆向显示所有日志。\n * --author=user：指定查看user提交的部分。\n * --since、--before、--after等：指定日期。 (2). 查看head指针的移动历史（包括被回滚的版本） git reflog\n\n\n# 3.4 分支管理\n\n几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。 有人把 git 的分支模型称为必杀技特性，而正是因为它，将 git 从版本控制系统家族里区分出来。 (1). 创建分支 git branch (branchname) (2). 切换分支 git checkout (branchname) 当你切换分支的时候，git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。 添加-b参数可以创建并切换分支。 (3). 合并分支 git merge (branchname) 将branch_name合并到当前分支上。 (4) 删除分支 git branch -d (branchname) 删除本地仓库的branchname分支。 (5). 列出分支 git branch 没有参数时，git branch会列出你在本地的分支。 (6). 合并冲突 合并并不仅仅是简单的文件添加、移除的操作。git也会合并修改，当两个分支对同一个文件都进行了修改，那么就会产生合并冲突，我们需要去手动修改它。然后需要使用git add命令来告诉git冲突已经解决了。\n\n\n# 3.5 远程操作\n\n(1). 将本地仓库关联到远程仓库 git remote add [short-name] [url] 其中short-name指定一个方便使用的简写，为远程仓库的别名。例如git remote add origin git@git.acwing.com:unique_pursuit/test.git即可添加远程仓库。 (2). 查看当前配置有哪些远程库 git remote 执行时添加上-v参数可查看到每个别名的实际链接地址。 (3). 删除远程仓库 git remote rm name 其中name为仓库的别名。 (4). 修改仓库名 git remote rename old_name new_name (5). 查看主机的详细信息 git remote show <主机名> (6) 设置本地分支与远程仓库分支对应 git push --set-upstream <远程主机名> <branchname> 设置本地的branchname分支对应远程仓库的branchname分支，远程主机名为git clone设置的仓库别名。 git branch --set-upstream-to=origin/branchname1 branchname2 将远程仓库的branchname1分支与本地的branchname2分支对应。 (7). 将本地当前分支推送到远程主机 git push <远程主机名> <本地分支名>:<远程分支名> 如果本地分支名和远程分支名相同，则可以直接使用下面的命令。 git push <远程主机名> <branchname> 将本地的branchname分支推到远程仓库，在此之前需要先设置与远程仓库对应分支。 如果当前分支与多个主机存在追踪关系，需要使用-u参数指定一个默认主机，这样后面可以不加任何参数使用git push。 (8). 删除远程仓库的branchname分支 git push -d <远程主机名> branchname (9). 将远程仓库的分支与本地仓库的分支合并 git pull <远程主机名> <远程分支名>:<本地分支名> 如果本地分支名和远程分支名相同，则可以使用下面的命令。 git push <远程分支名> <branchname>\n\n\n# 3.6 保存和恢复进度\n\n我们有时会遇到这样的情况，正在dev分支开发新功能，做到一半时有人过来反馈一个bug，让马上解决，但是新功能做到了一半你又不想提交，又想保存它，这个时候就可以使用git stash命令先把进度保存起来。 (1). 保存当前工作进度 git stash 将工作区和暂存区尚未提交的修改存入栈中。再运行git status可以发现是一个干净的工作区，没有任何改动。使用git stash save \'message\'可以添加一些注释 (2). 恢复工作进度 恢复最新的进度到工作区。git会默认把工作区和暂存区的改动都恢复到工作区。 git stash pop 恢复最新的进度到工作区和暂存区。 git stash pop --index 恢复指定的进度到工作区。 git stash pop stash_id 其中stash_id是通过git stash list获取的。 通过git stash pop恢复进度后，会删除当前进度。 还有一个git stash apply命令除了不删除进度，其他和git stash pop一样。 (3). 显示保存进度的列表 git stash list (4) 删除进度 删除所有进度 git stash clear 删除一个存储的进度，如果不指定stash_id，则默认删除最新的进度。 git stash drop [stash_id]\n\n\n# 4 git用法思维导图\n\n',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"Github搜索技巧",frontmatter:{title:"Github搜索技巧",date:"2023-11-21T11:14:47.000Z",tags:["Github"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/031ffb/",categories:["工具","版本控制"],readingShow:"top"},regularPath:"/02.%E5%B7%A5%E5%85%B7/01.%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/03.Github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7.html",relativePath:"02.工具/01.版本控制/03.Github搜索技巧.md",key:"v-279b57f8",path:"/pages/031ffb/",headers:[{level:2,title:"1 普通搜索",slug:"_1-普通搜索",normalizedTitle:"1 普通搜索",charIndex:2},{level:2,title:"2 高级搜索技巧",slug:"_2-高级搜索技巧",normalizedTitle:"2 高级搜索技巧",charIndex:127},{level:2,title:"3 github advance查找工具",slug:"_3-github-advance查找工具",normalizedTitle:"3 github advance查找工具",charIndex:868}],headersStr:"1 普通搜索 2 高级搜索技巧 3 github advance查找工具",content:"# 1 普通搜索\n\n我们一般在github搜索项目，都是直接在根据仓库关键字搜索项目，可能还会用到图中的匹配条件进行筛选。\n\n\n\n这样虽然能实现我们的大部分需求，但还不足实现精确查找。而github有自己的一套搜索语法，能帮助我们实现精确查找。\n\n\n# 2 高级搜索技巧\n\nin:name <关键字> 根据仓库名称搜索仓库。\n\nin:description <关键字>：根据仓库描述搜索仓库。\n\nin:readme <关键字>：根据 README 文件内容搜索仓库。\n\nstars(fork): >(=) <数字> <关键字>：搜索 star 或 fork 数大于（或等于）指定数字的仓库，并包含关键字。\n\nstars(fork): 10..20 <关键词>：搜索 star 或 fork 数在 10 到 20 之间的仓库，并包含关键字。\n\nsize:>=5000 <关键词>：搜索仓库大小≥\\geq≥ 5000KB，并包含关键字。\n\npushed(created):>2023-7-1 <关键字>：搜索更新或创建日期在 2023 年 7 月 1 日之后的仓库，并包含关键字。\n\nlicense:mit <关键字>：搜索 LICENSE 为 MIT 的仓库，并包含关键字。\n\nlanguage:Go <关键字>：搜索仓库语言为 Go 的仓库，并包含关键字。\n\nuser:<用户名> <关键字>：查询某个用户的项目，并包含关键字。\n\norg:<组织名> <关键字>：查询某个组织的项目，并包含关键字。\n\nrepo:owner/name： 匹配特定仓库名称，例如repo:unique-pure/unique-pure.github.io\n\nis:public/private <关键字>：根据公有或私有仓库搜索，并包含关键字。当然，只有你具有访问权限的私有仓库才可以搜索到。\n\ntopic:<关键字>：根据主题搜索仓库。\n\ntopics:>5：搜索具有3个以上主题的仓库。\n\nfollowers:n：根据仓库关注者数量搜索仓库。\n\n\n# 3 github advance查找工具\n\ngithub开发了一套查找工具，非常全面，也可以使用这个工具进行精确查找。\n\nhttps://github.com/search/advanced",normalizedContent:"# 1 普通搜索\n\n我们一般在github搜索项目，都是直接在根据仓库关键字搜索项目，可能还会用到图中的匹配条件进行筛选。\n\n\n\n这样虽然能实现我们的大部分需求，但还不足实现精确查找。而github有自己的一套搜索语法，能帮助我们实现精确查找。\n\n\n# 2 高级搜索技巧\n\nin:name <关键字> 根据仓库名称搜索仓库。\n\nin:description <关键字>：根据仓库描述搜索仓库。\n\nin:readme <关键字>：根据 readme 文件内容搜索仓库。\n\nstars(fork): >(=) <数字> <关键字>：搜索 star 或 fork 数大于（或等于）指定数字的仓库，并包含关键字。\n\nstars(fork): 10..20 <关键词>：搜索 star 或 fork 数在 10 到 20 之间的仓库，并包含关键字。\n\nsize:>=5000 <关键词>：搜索仓库大小≥\\geq≥ 5000kb，并包含关键字。\n\npushed(created):>2023-7-1 <关键字>：搜索更新或创建日期在 2023 年 7 月 1 日之后的仓库，并包含关键字。\n\nlicense:mit <关键字>：搜索 license 为 mit 的仓库，并包含关键字。\n\nlanguage:go <关键字>：搜索仓库语言为 go 的仓库，并包含关键字。\n\nuser:<用户名> <关键字>：查询某个用户的项目，并包含关键字。\n\norg:<组织名> <关键字>：查询某个组织的项目，并包含关键字。\n\nrepo:owner/name： 匹配特定仓库名称，例如repo:unique-pure/unique-pure.github.io\n\nis:public/private <关键字>：根据公有或私有仓库搜索，并包含关键字。当然，只有你具有访问权限的私有仓库才可以搜索到。\n\ntopic:<关键字>：根据主题搜索仓库。\n\ntopics:>5：搜索具有3个以上主题的仓库。\n\nfollowers:n：根据仓库关注者数量搜索仓库。\n\n\n# 3 github advance查找工具\n\ngithub开发了一套查找工具，非常全面，也可以使用这个工具进行精确查找。\n\nhttps://github.com/search/advanced",charsets:{cjk:!0},lastUpdated:"2023/11/25, 14:50:49",lastUpdatedTimestamp:1700895049e3},{title:"WireGuard组网教程",frontmatter:{title:"WireGuard组网教程",date:"2023-11-16T09:50:44.000Z",permalink:"/pages/50ca39/",tags:["VPN"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},categories:["工具","网络工具"],readingShow:"top"},regularPath:"/02.%E5%B7%A5%E5%85%B7/02.%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/01.WireGuard%E7%BB%84%E7%BD%91%E6%95%99%E7%A8%8B.html",relativePath:"02.工具/02.网络工具/01.WireGuard组网教程.md",key:"v-0c700bb1",path:"/pages/50ca39/",headers:[{level:2,title:"1 引言",slug:"_1-引言",normalizedTitle:"1 引言",charIndex:2},{level:3,title:"1.1 什么是WireGuard",slug:"_1-1-什么是wireguard",normalizedTitle:"1.1 什么是wireguard",charIndex:11},{level:3,title:"1.2 WireGuard可以用来做什么",slug:"_1-2-wireguard可以用来做什么",normalizedTitle:"1.2 wireguard可以用来做什么",charIndex:650},{level:3,title:"1.3 WireGuard原理",slug:"_1-3-wireguard原理",normalizedTitle:"1.3 wireguard原理",charIndex:1459},{level:3,title:"1.4 WireGuard安装",slug:"_1-4-wireguard安装",normalizedTitle:"1.4 wireguard安装",charIndex:3674},{level:2,title:"2 WireGuard组网实现内网穿透",slug:"_2-wireguard组网实现内网穿透",normalizedTitle:"2 wireguard组网实现内网穿透",charIndex:3711},{level:3,title:"2.1 前提条件",slug:"_2-1-前提条件",normalizedTitle:"2.1 前提条件",charIndex:3735},{level:3,title:"2.2 网络拓扑结构",slug:"_2-2-网络拓扑结构",normalizedTitle:"2.2 网络拓扑结构",charIndex:4122},{level:3,title:"2.3 具体步骤",slug:"_2-3-具体步骤",normalizedTitle:"2.3 具体步骤",charIndex:4139},{level:4,title:"2.3.1 中继服务器配置",slug:"_2-3-1-中继服务器配置",normalizedTitle:"2.3.1 中继服务器配置",charIndex:4151},{level:4,title:"2.3.2 其他peer",slug:"_2-3-2-其他peer",normalizedTitle:"2.3.2 其他peer",charIndex:6113},{level:4,title:"2.3.3 测试",slug:"_2-3-3-测试",normalizedTitle:"2.3.3 测试",charIndex:6588},{level:3,title:"2.4 WireGuard配置文件说明",slug:"_2-4-wireguard配置文件说明",normalizedTitle:"2.4 wireguard配置文件说明",charIndex:6627},{level:2,title:"3 WireGuard工具",slug:"_3-wireguard工具",normalizedTitle:"3 wireguard工具",charIndex:8033},{level:3,title:"3.1 wg-easy",slug:"_3-1-wg-easy",normalizedTitle:"3.1 wg-easy",charIndex:8051},{level:3,title:"3.2 wg-gen-web",slug:"_3-2-wg-gen-web",normalizedTitle:"3.2 wg-gen-web",charIndex:9077},{level:3,title:"3.3 dsnet",slug:"_3-3-dsnet",normalizedTitle:"3.3 dsnet",charIndex:9131}],headersStr:"1 引言 1.1 什么是WireGuard 1.2 WireGuard可以用来做什么 1.3 WireGuard原理 1.4 WireGuard安装 2 WireGuard组网实现内网穿透 2.1 前提条件 2.2 网络拓扑结构 2.3 具体步骤 2.3.1 中继服务器配置 2.3.2 其他peer 2.3.3 测试 2.4 WireGuard配置文件说明 3 WireGuard工具 3.1 wg-easy 3.2 wg-gen-web 3.3 dsnet",content:'# 1 引言\n\n\n# 1.1 什么是WireGuard\n\n\n\n官方介绍如下：\n\n> WireGuard ® 是一款极其简单但快速且现代的 VPN，采用最先进的加密技术。它的目标是比 IPsec 更快、更简单、更精简、更有用，同时避免令人头疼的问题。它的性能远高于 OpenVPN。\n> \n> WireGuard 被设计为通用 VPN，可在嵌入式接口和超级计算机上运行，适合许多不同的情况。它最初针对 Linux 内核发布，现在已跨平台（Windows、macOS、BSD、iOS、Android）且可广泛部署。它目前正在大力开发中，但它可能已被视为业内最安全、最易于使用且最简单的 VPN 解决方案。\n\n我们可以用一句话概括它：\n\nWGuard是一款可以组建虚拟私人局域网（VPN）的软件，允许用户通过公共网络（如互联网）安全地传输数据，同时保持数据的机密性和完整性。\n\nWireGuard有如下优势：\n\n * 更轻便：以Linux内核模块的形式运行，资源占用小。\n * 更高效：相比目前主流的IPSec、OpenVPN等协议，WireGuard的效率要更高。\n * 更快速：比目前主流的VPN协议，连接速度要更快。\n * 更安全：使用了更先进的加密技术。\n * 更易搭建：部署难度相对更低。\n * 更隐蔽：以UDP协议进行数据传输，比TCP协议更低调。\n * 不易被封锁：TCP阻断对WireGuard无效，IP被墙的情况下仍然可用。\n * 更省电：不使用时不进行数据传输，移动端更省电。\n\n\n# 1.2 WireGuard可以用来做什么\n\n 1. 建立VPN（不限设备类型）\n    \n    WireGuard支持多种平台，包括电脑、智能手机和路由器。这一特性使其成为构建虚拟私有网络（VPN）的理想选择，能在这些设备上实现安全连接。无论是用于远程工作、保护数据隐私，还是绕过地理限制，WireGuard都能提供稳定且安全的网络连接。\n\n 2. 实现内网穿透\n    \n    > 内网穿透，即NAT（Network Address Translator）穿透，是指计算机在内网（局域网）内使用私有IP地址，在连接外网（互联网）时使用全局IP地址的技术。该技术被普遍使用在有多台主机但只通过一个公有IP地址访问的私有网络中。\n    > \n    > 举个例子：比如我在实验室配置了一个服务器 Server A，当我在实验室的时候，就可以通过自己的笔记本使用SSH连接【因为我和服务器处于一个局域网】，当我回宿舍以后，就没有办法直接使用SSH连接了【因为我和服务器不在一个局域网】，这个时候就需要进行NAT穿透，让我在宿舍也可以使用SSH连接Server A。\n    \n    > 通过Wireguard可以将广域网上的主机连接起来，形成一个局域网。只需要有一台具有固定公网IP的服务器，就可以将其作为我们搭建的局域网的中心节点，让其他的主机（不论是否有公网IP，不论是否在NAT内），都通过这个中心节点和彼此相连。由此就构建了一个中心辐射型的局域网，实现了内网穿透等功能。\n\n 3. Docker容器通信\n    \n    WireGuard还可用于Docker容器之间的通信。在Docker环境中，容器之间的网络通信是一个重要的问题。WireGuard通过提供一种安全的通信方式，能够在不同容器之间建立一个加密的网络连接，从而保障数据的安全传输。这对于需要在不同容器间安全共享数据的应用尤为重要。\n\n\n# 1.3 WireGuard原理\n\nWireGuard源码地址\n\nWireGuard 是一种在第 3 层（网络层）运行的安全网络隧道，与传统的 VPN 解决方案（如 IPsec 和 OpenVPN）相比，它的设计更安全、性能更高且更易于使用。它是作为 Linux 内核虚拟网络接口实现的，基于安全隧道的基本原理：将peer的公钥与隧道源 IP 地址关联。\n\n相关术语：\n\n>  * Peer/Node/Device\n>    \n>    连接到VPN 并为自己注册一个VPN子网地址（如 192.0.2.3）的主机。还可以通过使用逗号分隔的 CIDR 指定子网范围，为其自身地址以外的 IP 地址选择路由。\n> \n>  * 中继服务器（Bounce Server）\n>    \n>    一个公网可达的peer，可以将流量中继到 NAT 后面的其他peer。Bounce Server 并不是特殊的节点，它和其他peer一样，唯一的区别是它有公网 IP，并且开启了内核级别的 IP 转发，可以将 威屁恩 的流量转发到其他客户端。\n> \n>  * 子网（Subnet）\n>    \n>    一组私有 IP，例如 192.0.2.1-255 或 192.168.1.1/24，一般在 NAT 后面，例如办公室局域网或家庭网络。\n> \n>  * CIDR 表示法\n>    \n>    CIDR，即无类域间路由（Classless Inter-Domain Routing），是一种用于对IP地址进行灵活表示和分配的标准。\n> \n>  * NAT\n>    \n>    子网的私有 IP 地址由路由器提供，通过公网无法直接访问私有子网设备，需要通过 NAT 做网络地址转换。路由器会跟踪发出的连接，并将响应转发到正确的内部 IP。\n> \n>  * 公开端点（Public Endpoint）\n>    \n>    节点的公网 IP 地址:端口，例如 123.124.125.126:1234，或者直接使用域名 some.domain.tld:1234。如果peer节点不在同一子网中，那么节点的公开端点必须使用公网 IP 地址。\n> \n>  * 私钥（Private key）\n>    \n>    单个节点的 WireGuard 私钥，生成方法是：wg genkey > example.key。\n> \n>  * 公钥（Public key）\n>    \n>    单个节点的 WireGuard 公钥，生成方式为：wg pubkey < example.key > example.key.pub。\n> \n>  * DNS\n>    \n>    域名服务器，用于将域名解析为 VPN 客户端的 IP，不让 DNS请求泄漏到 VPN 之外。\n\n主要功能和原理如下\n\n> WireGuard 通过添加一个（或多个）网络接口来工作，例如 eth0 或 wlan0 ，称为 wg0 （或 wg1 、 wg2 、 wg3 等）。然后可以使用 ifconfig(8) 或 ip-address(8) 正常配置该网络接口，并使用 route(8) 或 ip-route(8) 添加和删除其路由，以及所有普通网络实用程序都是如此。接口的特定 WireGuard 方面使用 wg(8) 工具进行配置。该接口充当隧道接口。\n> \n> WireGuard 将隧道 IP 地址与公钥和远程端点相关联。当接口向peer发送数据包时，它会执行以下操作：\n> \n>  1. 该数据包适用于 192.168.30.8。那是哪位peer啊？让我看看...好吧，这是给peer ABCDEFGH 的。 （或者，如果它不适合任何已配置的peer，则丢弃该数据包。）\n>  2. 使用peer ABCDEFGH 的公钥加密整个 IP 数据包。\n>  3. Peer ABCDEFGH 的远程端点是什么？让我看看...好的，端点是主机 216.58.211.110 上的 UDP 端口 53133。\n>  4. 使用 UDP 通过 Internet 将步骤 2 中的加密字节发送到 216.58.211.110:53133。\n> \n> 当接口收到数据包时，会发生以下情况：\n> \n>  1. 我刚刚从主机 98.139.183.24 上的 UDP 端口 7361 收到一个数据包。让我们来解密吧！\n>  2. 它为peer LMNOPQRS 正确解密和验证。好的，让我们记住，peer LMNOPQRS 的最新 Internet 端点是使用 UDP 的 98.139.183.24:7361。\n>  3. 解密后，明文数据包来自 192.168.43.89。是否允许peer LMNOPQRS 以 192.168.43.89 向我们发送数据包？\n>  4. 如果是，则在接口上接受数据包。如果没有，就放弃它。\n> \n> WireGuard 的核心是一个称为加密密钥路由的概念，它的工作原理是将公钥与隧道内允许的隧道 IP 地址列表相关联。每个网络接口都有一个私钥和一个peer点列表。每个peer都有一个公钥。公钥短小且简单，由peer用来相互验证。它们可以通过任何带外方法传递以在配置文件中使用，类似于将 SSH 公钥发送给朋友以访问 shell 服务器的方式。\n\n\n# 1.4 WireGuard安装\n\nwireGuard官方安装教程\n\n\n# 2 WireGuard组网实现内网穿透\n\n\n# 2.1 前提条件\n\n 1. 公网服务器： 必须拥有一台具有公网IP地址的服务器，这是内网穿透的关键。该服务器充当中转站，负责将外部请求传递到内部网络。\n 2. 网络设备配置权限： 需要对内部网络的路由器或防火墙有一定的配置权限，以便进行端口映射或其他必要的网络设置。这确保了从公网服务器到内网的连接是有效的。\n 3. 安装WireGuard： 在公网服务器和内网设备上都需要安装和配置WireGuard软件。确保两端的WireGuard配置一致，包括公私钥的生成和网络接口的配置。\n 4. 开启相应端口： 在公网服务器的防火墙配置中，需要打开WireGuard所使用的端口（默认是51820/UDP），以确保能够接收来自内网设备的连接请求。\n 5. 合适的网络拓扑： 确保了解内部网络的拓扑结构，以便正确设置WireGuard配置，包括允许流量通过的子网、路由等。\n\n\n# 2.2 网络拓扑结构\n\n\n\n\n# 2.3 具体步骤\n\n# 2.3.1 中继服务器配置\n\n 1. 创建密钥对\n    \n    > wg genkey | tee server_privatekey | wg pubkey > server_publickey\n    > \n    > 执行以上两条命令后，会在执行命令的当前文件夹自动生成2个文件：\n\n * 开启IP地址转发\n   \n   > sudo sysctl net.ipv4.ip_forward\n   > \n   > 如果显示1则说明已开启，否则则未开启。\n   > \n   > echo "net.ipv4.ip_forward = 1" >> /etc/sysctl.conf\n   > echo "net.ipv4.conf.all.proxy_arp = 1" >> /etc/sysctl.conf\n   > sysctl -p /etc/sysctl.conf\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > \n   > 1\n   > 2\n   > 3\n\n * 设置IP地址伪装\n   \n   # 允许防火墙伪装IP\n   firewall-cmd --add-masquerade\n   # 检查是否允许伪装IP\n   firewall-cmd --query-masquerade\n   # 禁止防火墙伪装IP\n   firewall-cmd --remove-masquerade\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * 配置wireguard虚拟网卡（不推荐，只是让读者直观了解过程）\n   \n   sudo ip link add wg0 type wireguard # 添加一块叫 wg0 的虚拟 wireguard 网卡\n   sudo ip addr add 192.168.71.1/24 dev wg0 # 给 wg0 网卡添加 ip 地址 192.168.71.1，子网掩码 255.255.255.0\n   sudo wg set wg0 private-key ./server-privatekey # wireguard 设置密钥\n   sudo ip link set wg0 up # 启用刚刚添加的网卡\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n   \n   > 我们可以通过ip addr命令查看到wg0网卡的状态\n   > \n   > \n   > \n   > 可以看到网卡wg0 接口是已启用的，具有 IPv4 地址 192.168.71.1\n   > \n   > 输入wg命令则可以看到配置信息，配置文件通常在\n   \n   有想继续尝试这种方式的可以看一下官方教程\n\n * 编写配置文件配置网卡（推荐，应该wg set命令需要提供很多参数，很容易出错）\n   \n   > 我们在/etc/wireguard目录中创建wg0.conf并编写配置，配置项请看2.4 配置项说明\n   > \n   > [Interface]\n   > # 本机密钥\n   > PrivateKey = KIDTljv66CgVYBNlrSD13Au6qfUdIcFJkTBkuErhTEk=\n   > # 本机地址\n   > Address = 192.168.71.1/24\n   > # 监听端口\n   > ListenPort = 51820\n   > \n   > [Peer]\n   > # 对端的publickey\n   > PublicKey = iWy57DmR6wVXcVzMDOa2WyywO0WT5JRAGYIlh0v/nW8=\n   > # 对端地址\n   > AllowedIPs = 192.168.71.2/24\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n\n * 重新启动网卡\n   \n   sudo wg-quick down wg0\n   sudo wg-quick up wg0\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n# 2.3.2 其他peer\n\n我这里只列举MacOS的操作方式（其他都同理，就是要配置私钥和公钥）\n\n\n\n操作完之后，它会给出密钥对，我们只需要添加好其他信息即可。\n\n\n\n配置文件如下：\n\n[Interface]\n# 本机密钥\nPrivateKey = kDUqWzkbaB1EU5C2ADoId1TXtZF89xxn0VV45EcjFHs=\n# 本机地址\nAddress = 192.168.71.2/24\n\n[Peer]\n# 对端公钥，即公网服务器公钥\nPublicKey = bEm1p736FQySfKlTTUCeHmiwTmna5umZWOWLGWqioSk=\n# 允许此对等方的传入流量并指定传出流量的目标。\nAllowedIPs = 192.168.71.0/24\n# 公网IP+监听端口号\nEndpoint = 1.1.1.1:51820\nPersistentKeepalive = 25\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 2.3.3 测试\n\nMacOS端：\n\n\n\n服务器Ping 主机：\n\n\n\n\n# 2.4 WireGuard配置文件说明\n\n * interface部分：\n   * PrivateKey: 由 wg genkey 生成的 Base64 编码的私钥。必须配置。\n   * ListenPort: 用于监听的 16 位端口。可选，如果未指定，则随机选择端口。\n   * DNS: 指定 DNS 服务器的 IP 地址。\n   * FwMark: 用于传出数据包的 32 位 fwmark。如果设置为 0 或 "off"，则禁用此选项。可选。可以以十六进制形式指定，例如，以 "0x" 开头。可选。\n * Peer 部分：\n   * PublicKey: 由 wg pubkey 根据私钥计算的 Base64 编码的公钥。必须配置。\n   * PresharedKey: 由 wg genpsk 生成的 Base64 编码的预共享密钥。可选，可以省略。此选项为现有的公钥加密提供了额外的对称密钥加密层，以增强对抗后量子计算的能力。\n   * AllowedIPs: 逗号分隔的 IP 地址（IPv4 或 IPv6）列表，带有 CIDR 掩码，用于允许此对等方的传入流量并指定传出流量的目标。可以多次指定。可用 0.0.0.0/0 匹配所有 IPv4 地址，使用 ::/0 匹配所有 IPv6 地址。\n   * Endpoint: 一个 IP 地址或主机名，后跟冒号，然后是一个端口号。此端点将自动更新为来自对等方的正确经过身份验证的数据包的最新源 IP 地址和端口。可选。\n   * PersistentKeepalive: 保持活跃的时间间隔，介于 1 和 65535 之间，表示多久发送一次对等方的身份验证空数据包，以保持有状态的防火墙或 NAT 映射的有效性。如果设置为 0 或 "off"，则禁用此选项。可选，默认情况下此选项被禁用。\n\n下面是一个简单的配置文件示例：\n\n[Interface]\nPrivateKey = yAnz5TF+lXXJte14tji3zlMNq+hd2rYUIgJBgB3fBmk=\nListenPort = 51820\n\n[Peer]\nPublicKey = xTIBA5rboUvnH4htodjb6e697QjLERt1NAB4mZqp8Dg=\nEndpoint = 192.95.5.67:1234\nAllowedIPs = 10.192.122.3/32, 10.192.124.1/24\n\n[Peer]\nPublicKey = TrMvSoP4jYQlY6RIzBgbssQqY3vxI2Pi+y71lOWWXX0=\nEndpoint = [2607:5300:60:6b0::c05f:543]:2468\nAllowedIPs = 10.192.122.4/32, 192.168.0.0/16\n\n[Peer]\nPublicKey = gN65BkIKy1eCE9pP1wdc8ROUtkHLF2PfAqYdyYBz6EA=\nEndpoint = test.wireguard.com:18981\nAllowedIPs = 10.10.10.230/32\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 3 WireGuard工具\n\n\n# 3.1 wg-easy\n\ngithub地址\n\n这是一个用于管理 WireGuard 设置的 Web 用户界面。使用它之前我们得先安装docker和docker-compose。这里我给出docker-compose.yml配置文件示例。还有很多配置项可在仓库中找到，灵活配置VPN\n\nversion: \'3\'\nservices:\n  wg-easy:\n    image: weejewel/wg-easy\n    container_name: wg-easy\n    environment:\n      - WG_HOST=YOUR_SERVER_IP # 公网IP\n      - PASSWORD=YOUR_ADMIN_PASSWORD # Web UI登录密码\n      - WG_PORT=51820 # 监听端口\n      - WG_PERSISTENT_KEEPALIVE=25 # 保持“连接”打开的值（以秒为单位）\n      - WG_DEFAULT_ADDRESS=192.168.71.0 # 客户端 IP 地址范围\n      - WG_ALLOWED_IPS=192.168.71.0/24 # 客户端将使用的允许 IP\n    volumes:\n      - ~/.wg-easy:/etc/wireguard\n    ports:\n      - 51820:51820/udp\n      - 51821:51821/tcp\n    cap_add:\n      - NET_ADMIN\n      - SYS_MODULE\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1\n      - net.ipv4.ip_forward=1\n    restart: unless-stopped\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n通过docker compose up -d部署好后，我们进入Web界面即可添加Client。\n\n这里，我们只需要将这三个配置文件分给对应的Client的即可完成网络搭建，特别方便！\n\n\n# 3.2 wg-gen-web\n\nwg-gen-web\n\n跟wg-easy类似，不过功能更强大。\n\n\n\n\n# 3.3 dsnet\n\ngithub地址\n\n一款用于管理集中式wireguard VPN 的FAST 命令。\n\n',normalizedContent:'# 1 引言\n\n\n# 1.1 什么是wireguard\n\n\n\n官方介绍如下：\n\n> wireguard ® 是一款极其简单但快速且现代的 vpn，采用最先进的加密技术。它的目标是比 ipsec 更快、更简单、更精简、更有用，同时避免令人头疼的问题。它的性能远高于 openvpn。\n> \n> wireguard 被设计为通用 vpn，可在嵌入式接口和超级计算机上运行，适合许多不同的情况。它最初针对 linux 内核发布，现在已跨平台（windows、macos、bsd、ios、android）且可广泛部署。它目前正在大力开发中，但它可能已被视为业内最安全、最易于使用且最简单的 vpn 解决方案。\n\n我们可以用一句话概括它：\n\nwguard是一款可以组建虚拟私人局域网（vpn）的软件，允许用户通过公共网络（如互联网）安全地传输数据，同时保持数据的机密性和完整性。\n\nwireguard有如下优势：\n\n * 更轻便：以linux内核模块的形式运行，资源占用小。\n * 更高效：相比目前主流的ipsec、openvpn等协议，wireguard的效率要更高。\n * 更快速：比目前主流的vpn协议，连接速度要更快。\n * 更安全：使用了更先进的加密技术。\n * 更易搭建：部署难度相对更低。\n * 更隐蔽：以udp协议进行数据传输，比tcp协议更低调。\n * 不易被封锁：tcp阻断对wireguard无效，ip被墙的情况下仍然可用。\n * 更省电：不使用时不进行数据传输，移动端更省电。\n\n\n# 1.2 wireguard可以用来做什么\n\n 1. 建立vpn（不限设备类型）\n    \n    wireguard支持多种平台，包括电脑、智能手机和路由器。这一特性使其成为构建虚拟私有网络（vpn）的理想选择，能在这些设备上实现安全连接。无论是用于远程工作、保护数据隐私，还是绕过地理限制，wireguard都能提供稳定且安全的网络连接。\n\n 2. 实现内网穿透\n    \n    > 内网穿透，即nat（network address translator）穿透，是指计算机在内网（局域网）内使用私有ip地址，在连接外网（互联网）时使用全局ip地址的技术。该技术被普遍使用在有多台主机但只通过一个公有ip地址访问的私有网络中。\n    > \n    > 举个例子：比如我在实验室配置了一个服务器 server a，当我在实验室的时候，就可以通过自己的笔记本使用ssh连接【因为我和服务器处于一个局域网】，当我回宿舍以后，就没有办法直接使用ssh连接了【因为我和服务器不在一个局域网】，这个时候就需要进行nat穿透，让我在宿舍也可以使用ssh连接server a。\n    \n    > 通过wireguard可以将广域网上的主机连接起来，形成一个局域网。只需要有一台具有固定公网ip的服务器，就可以将其作为我们搭建的局域网的中心节点，让其他的主机（不论是否有公网ip，不论是否在nat内），都通过这个中心节点和彼此相连。由此就构建了一个中心辐射型的局域网，实现了内网穿透等功能。\n\n 3. docker容器通信\n    \n    wireguard还可用于docker容器之间的通信。在docker环境中，容器之间的网络通信是一个重要的问题。wireguard通过提供一种安全的通信方式，能够在不同容器之间建立一个加密的网络连接，从而保障数据的安全传输。这对于需要在不同容器间安全共享数据的应用尤为重要。\n\n\n# 1.3 wireguard原理\n\nwireguard源码地址\n\nwireguard 是一种在第 3 层（网络层）运行的安全网络隧道，与传统的 vpn 解决方案（如 ipsec 和 openvpn）相比，它的设计更安全、性能更高且更易于使用。它是作为 linux 内核虚拟网络接口实现的，基于安全隧道的基本原理：将peer的公钥与隧道源 ip 地址关联。\n\n相关术语：\n\n>  * peer/node/device\n>    \n>    连接到vpn 并为自己注册一个vpn子网地址（如 192.0.2.3）的主机。还可以通过使用逗号分隔的 cidr 指定子网范围，为其自身地址以外的 ip 地址选择路由。\n> \n>  * 中继服务器（bounce server）\n>    \n>    一个公网可达的peer，可以将流量中继到 nat 后面的其他peer。bounce server 并不是特殊的节点，它和其他peer一样，唯一的区别是它有公网 ip，并且开启了内核级别的 ip 转发，可以将 威屁恩 的流量转发到其他客户端。\n> \n>  * 子网（subnet）\n>    \n>    一组私有 ip，例如 192.0.2.1-255 或 192.168.1.1/24，一般在 nat 后面，例如办公室局域网或家庭网络。\n> \n>  * cidr 表示法\n>    \n>    cidr，即无类域间路由（classless inter-domain routing），是一种用于对ip地址进行灵活表示和分配的标准。\n> \n>  * nat\n>    \n>    子网的私有 ip 地址由路由器提供，通过公网无法直接访问私有子网设备，需要通过 nat 做网络地址转换。路由器会跟踪发出的连接，并将响应转发到正确的内部 ip。\n> \n>  * 公开端点（public endpoint）\n>    \n>    节点的公网 ip 地址:端口，例如 123.124.125.126:1234，或者直接使用域名 some.domain.tld:1234。如果peer节点不在同一子网中，那么节点的公开端点必须使用公网 ip 地址。\n> \n>  * 私钥（private key）\n>    \n>    单个节点的 wireguard 私钥，生成方法是：wg genkey > example.key。\n> \n>  * 公钥（public key）\n>    \n>    单个节点的 wireguard 公钥，生成方式为：wg pubkey < example.key > example.key.pub。\n> \n>  * dns\n>    \n>    域名服务器，用于将域名解析为 vpn 客户端的 ip，不让 dns请求泄漏到 vpn 之外。\n\n主要功能和原理如下\n\n> wireguard 通过添加一个（或多个）网络接口来工作，例如 eth0 或 wlan0 ，称为 wg0 （或 wg1 、 wg2 、 wg3 等）。然后可以使用 ifconfig(8) 或 ip-address(8) 正常配置该网络接口，并使用 route(8) 或 ip-route(8) 添加和删除其路由，以及所有普通网络实用程序都是如此。接口的特定 wireguard 方面使用 wg(8) 工具进行配置。该接口充当隧道接口。\n> \n> wireguard 将隧道 ip 地址与公钥和远程端点相关联。当接口向peer发送数据包时，它会执行以下操作：\n> \n>  1. 该数据包适用于 192.168.30.8。那是哪位peer啊？让我看看...好吧，这是给peer abcdefgh 的。 （或者，如果它不适合任何已配置的peer，则丢弃该数据包。）\n>  2. 使用peer abcdefgh 的公钥加密整个 ip 数据包。\n>  3. peer abcdefgh 的远程端点是什么？让我看看...好的，端点是主机 216.58.211.110 上的 udp 端口 53133。\n>  4. 使用 udp 通过 internet 将步骤 2 中的加密字节发送到 216.58.211.110:53133。\n> \n> 当接口收到数据包时，会发生以下情况：\n> \n>  1. 我刚刚从主机 98.139.183.24 上的 udp 端口 7361 收到一个数据包。让我们来解密吧！\n>  2. 它为peer lmnopqrs 正确解密和验证。好的，让我们记住，peer lmnopqrs 的最新 internet 端点是使用 udp 的 98.139.183.24:7361。\n>  3. 解密后，明文数据包来自 192.168.43.89。是否允许peer lmnopqrs 以 192.168.43.89 向我们发送数据包？\n>  4. 如果是，则在接口上接受数据包。如果没有，就放弃它。\n> \n> wireguard 的核心是一个称为加密密钥路由的概念，它的工作原理是将公钥与隧道内允许的隧道 ip 地址列表相关联。每个网络接口都有一个私钥和一个peer点列表。每个peer都有一个公钥。公钥短小且简单，由peer用来相互验证。它们可以通过任何带外方法传递以在配置文件中使用，类似于将 ssh 公钥发送给朋友以访问 shell 服务器的方式。\n\n\n# 1.4 wireguard安装\n\nwireguard官方安装教程\n\n\n# 2 wireguard组网实现内网穿透\n\n\n# 2.1 前提条件\n\n 1. 公网服务器： 必须拥有一台具有公网ip地址的服务器，这是内网穿透的关键。该服务器充当中转站，负责将外部请求传递到内部网络。\n 2. 网络设备配置权限： 需要对内部网络的路由器或防火墙有一定的配置权限，以便进行端口映射或其他必要的网络设置。这确保了从公网服务器到内网的连接是有效的。\n 3. 安装wireguard： 在公网服务器和内网设备上都需要安装和配置wireguard软件。确保两端的wireguard配置一致，包括公私钥的生成和网络接口的配置。\n 4. 开启相应端口： 在公网服务器的防火墙配置中，需要打开wireguard所使用的端口（默认是51820/udp），以确保能够接收来自内网设备的连接请求。\n 5. 合适的网络拓扑： 确保了解内部网络的拓扑结构，以便正确设置wireguard配置，包括允许流量通过的子网、路由等。\n\n\n# 2.2 网络拓扑结构\n\n\n\n\n# 2.3 具体步骤\n\n# 2.3.1 中继服务器配置\n\n 1. 创建密钥对\n    \n    > wg genkey | tee server_privatekey | wg pubkey > server_publickey\n    > \n    > 执行以上两条命令后，会在执行命令的当前文件夹自动生成2个文件：\n\n * 开启ip地址转发\n   \n   > sudo sysctl net.ipv4.ip_forward\n   > \n   > 如果显示1则说明已开启，否则则未开启。\n   > \n   > echo "net.ipv4.ip_forward = 1" >> /etc/sysctl.conf\n   > echo "net.ipv4.conf.all.proxy_arp = 1" >> /etc/sysctl.conf\n   > sysctl -p /etc/sysctl.conf\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > \n   > 1\n   > 2\n   > 3\n\n * 设置ip地址伪装\n   \n   # 允许防火墙伪装ip\n   firewall-cmd --add-masquerade\n   # 检查是否允许伪装ip\n   firewall-cmd --query-masquerade\n   # 禁止防火墙伪装ip\n   firewall-cmd --remove-masquerade\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * 配置wireguard虚拟网卡（不推荐，只是让读者直观了解过程）\n   \n   sudo ip link add wg0 type wireguard # 添加一块叫 wg0 的虚拟 wireguard 网卡\n   sudo ip addr add 192.168.71.1/24 dev wg0 # 给 wg0 网卡添加 ip 地址 192.168.71.1，子网掩码 255.255.255.0\n   sudo wg set wg0 private-key ./server-privatekey # wireguard 设置密钥\n   sudo ip link set wg0 up # 启用刚刚添加的网卡\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n   \n   > 我们可以通过ip addr命令查看到wg0网卡的状态\n   > \n   > \n   > \n   > 可以看到网卡wg0 接口是已启用的，具有 ipv4 地址 192.168.71.1\n   > \n   > 输入wg命令则可以看到配置信息，配置文件通常在\n   \n   有想继续尝试这种方式的可以看一下官方教程\n\n * 编写配置文件配置网卡（推荐，应该wg set命令需要提供很多参数，很容易出错）\n   \n   > 我们在/etc/wireguard目录中创建wg0.conf并编写配置，配置项请看2.4 配置项说明\n   > \n   > [interface]\n   > # 本机密钥\n   > privatekey = kidtljv66cgvybnlrsd13au6qfudicfjktbkuerhtek=\n   > # 本机地址\n   > address = 192.168.71.1/24\n   > # 监听端口\n   > listenport = 51820\n   > \n   > [peer]\n   > # 对端的publickey\n   > publickey = iwy57dmr6wvxcvzmdoa2wyywo0wt5jragyilh0v/nw8=\n   > # 对端地址\n   > allowedips = 192.168.71.2/24\n   > \n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n   > \n   > 1\n   > 2\n   > 3\n   > 4\n   > 5\n   > 6\n   > 7\n   > 8\n   > 9\n   > 10\n   > 11\n   > 12\n   > 13\n\n * 重新启动网卡\n   \n   sudo wg-quick down wg0\n   sudo wg-quick up wg0\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n# 2.3.2 其他peer\n\n我这里只列举macos的操作方式（其他都同理，就是要配置私钥和公钥）\n\n\n\n操作完之后，它会给出密钥对，我们只需要添加好其他信息即可。\n\n\n\n配置文件如下：\n\n[interface]\n# 本机密钥\nprivatekey = kduqwzkbab1eu5c2adoid1txtzf89xxn0vv45ecjfhs=\n# 本机地址\naddress = 192.168.71.2/24\n\n[peer]\n# 对端公钥，即公网服务器公钥\npublickey = bem1p736fqysfklttucehmiwtmna5umzwowlgwqiosk=\n# 允许此对等方的传入流量并指定传出流量的目标。\nallowedips = 192.168.71.0/24\n# 公网ip+监听端口号\nendpoint = 1.1.1.1:51820\npersistentkeepalive = 25\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 2.3.3 测试\n\nmacos端：\n\n\n\n服务器ping 主机：\n\n\n\n\n# 2.4 wireguard配置文件说明\n\n * interface部分：\n   * privatekey: 由 wg genkey 生成的 base64 编码的私钥。必须配置。\n   * listenport: 用于监听的 16 位端口。可选，如果未指定，则随机选择端口。\n   * dns: 指定 dns 服务器的 ip 地址。\n   * fwmark: 用于传出数据包的 32 位 fwmark。如果设置为 0 或 "off"，则禁用此选项。可选。可以以十六进制形式指定，例如，以 "0x" 开头。可选。\n * peer 部分：\n   * publickey: 由 wg pubkey 根据私钥计算的 base64 编码的公钥。必须配置。\n   * presharedkey: 由 wg genpsk 生成的 base64 编码的预共享密钥。可选，可以省略。此选项为现有的公钥加密提供了额外的对称密钥加密层，以增强对抗后量子计算的能力。\n   * allowedips: 逗号分隔的 ip 地址（ipv4 或 ipv6）列表，带有 cidr 掩码，用于允许此对等方的传入流量并指定传出流量的目标。可以多次指定。可用 0.0.0.0/0 匹配所有 ipv4 地址，使用 ::/0 匹配所有 ipv6 地址。\n   * endpoint: 一个 ip 地址或主机名，后跟冒号，然后是一个端口号。此端点将自动更新为来自对等方的正确经过身份验证的数据包的最新源 ip 地址和端口。可选。\n   * persistentkeepalive: 保持活跃的时间间隔，介于 1 和 65535 之间，表示多久发送一次对等方的身份验证空数据包，以保持有状态的防火墙或 nat 映射的有效性。如果设置为 0 或 "off"，则禁用此选项。可选，默认情况下此选项被禁用。\n\n下面是一个简单的配置文件示例：\n\n[interface]\nprivatekey = yanz5tf+lxxjte14tji3zlmnq+hd2ryuigjbgb3fbmk=\nlistenport = 51820\n\n[peer]\npublickey = xtiba5rbouvnh4htodjb6e697qjlert1nab4mzqp8dg=\nendpoint = 192.95.5.67:1234\nallowedips = 10.192.122.3/32, 10.192.124.1/24\n\n[peer]\npublickey = trmvsop4jyqly6rizbgbssqqy3vxi2pi+y71lowwxx0=\nendpoint = [2607:5300:60:6b0::c05f:543]:2468\nallowedips = 10.192.122.4/32, 192.168.0.0/16\n\n[peer]\npublickey = gn65bkiky1ece9pp1wdc8routkhlf2pfaqydyybz6ea=\nendpoint = test.wireguard.com:18981\nallowedips = 10.10.10.230/32\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 3 wireguard工具\n\n\n# 3.1 wg-easy\n\ngithub地址\n\n这是一个用于管理 wireguard 设置的 web 用户界面。使用它之前我们得先安装docker和docker-compose。这里我给出docker-compose.yml配置文件示例。还有很多配置项可在仓库中找到，灵活配置vpn\n\nversion: \'3\'\nservices:\n  wg-easy:\n    image: weejewel/wg-easy\n    container_name: wg-easy\n    environment:\n      - wg_host=your_server_ip # 公网ip\n      - password=your_admin_password # web ui登录密码\n      - wg_port=51820 # 监听端口\n      - wg_persistent_keepalive=25 # 保持“连接”打开的值（以秒为单位）\n      - wg_default_address=192.168.71.0 # 客户端 ip 地址范围\n      - wg_allowed_ips=192.168.71.0/24 # 客户端将使用的允许 ip\n    volumes:\n      - ~/.wg-easy:/etc/wireguard\n    ports:\n      - 51820:51820/udp\n      - 51821:51821/tcp\n    cap_add:\n      - net_admin\n      - sys_module\n    sysctls:\n      - net.ipv4.conf.all.src_valid_mark=1\n      - net.ipv4.ip_forward=1\n    restart: unless-stopped\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n通过docker compose up -d部署好后，我们进入web界面即可添加client。\n\n这里，我们只需要将这三个配置文件分给对应的client的即可完成网络搭建，特别方便！\n\n\n# 3.2 wg-gen-web\n\nwg-gen-web\n\n跟wg-easy类似，不过功能更强大。\n\n\n\n\n# 3.3 dsnet\n\ngithub地址\n\n一款用于管理集中式wireguard vpn 的fast 命令。\n\n',charsets:{cjk:!0},lastUpdated:"2023/11/25, 14:50:49",lastUpdatedTimestamp:1700895049e3},{title:"SSH教程",frontmatter:{title:"SSH教程",date:"2022-01-23T13:12:04.000Z",tags:["SSH"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/975871/",categories:["工具","网络工具"],readingShow:"top"},regularPath:"/02.%E5%B7%A5%E5%85%B7/02.%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/02.SSH%E6%95%99%E7%A8%8B.html",relativePath:"02.工具/02.网络工具/02.SSH教程.md",key:"v-2472c4c6",path:"/pages/975871/",headers:[{level:2,title:"1 SSH基本知识",slug:"_1-ssh基本知识",normalizedTitle:"1 ssh基本知识",charIndex:2},{level:3,title:"1.1 SSH是什么",slug:"_1-1-ssh是什么",normalizedTitle:"1.1 ssh是什么",charIndex:16},{level:3,title:"1.2 SSH架构",slug:"_1-2-ssh架构",normalizedTitle:"1.2 ssh架构",charIndex:142},{level:2,title:"2 ssh登录",slug:"_2-ssh登录",normalizedTitle:"2 ssh登录",charIndex:565},{level:3,title:"2.1 基本用法",slug:"_2-1-基本用法",normalizedTitle:"2.1 基本用法",charIndex:577},{level:3,title:"2.2 配置文件",slug:"_2-2-配置文件",normalizedTitle:"2.2 配置文件",charIndex:1482},{level:3,title:"2.3 密钥登录",slug:"_2-3-密钥登录",normalizedTitle:"2.3 密钥登录",charIndex:1801},{level:2,title:"3 scp传文件",slug:"_3-scp传文件",normalizedTitle:"3 scp传文件",charIndex:2774},{level:3,title:"3.1 scp命令简介",slug:"_3-1-scp命令简介",normalizedTitle:"3.1 scp命令简介",charIndex:2787},{level:3,title:"3.2 基本语法",slug:"_3-2-基本语法",normalizedTitle:"3.2 基本语法",charIndex:2974},{level:2,title:"4 参考文献",slug:"_4-参考文献",normalizedTitle:"4 参考文献",charIndex:3371}],headersStr:"1 SSH基本知识 1.1 SSH是什么 1.2 SSH架构 2 ssh登录 2.1 基本用法 2.2 配置文件 2.3 密钥登录 3 scp传文件 3.1 scp命令简介 3.2 基本语法 4 参考文献",content:"# 1 SSH基本知识\n\n\n# 1.1 SSH是什么\n\nSSH为Secure Shell的缩写，是一种网络协议，用于加密两台计算机之间的通信，保证不被窃听或篡改，并且支持各种身份验证机制。在事务中，它主要用户保证远程登录贺远程通信的安全，任何网络服务都可以用这个协议来加密。\n\n\n# 1.2 SSH架构\n\nSSH的软件架构是C/S模式，即客户端-服务器模式。在这个架构中，SSH软件分成了两个部分：向服务器发出请求的部分，称为客户端，OpenSSH的实现为ssh；接受客户端发出的请求的部分，称为服务器，OpenSSH的实现为sshd。 其中大写的SSH表示协议，小写的ssh表示客户端软件。 OpenSSH的客户端是二进制程序ssh。它在Linux/Unix系统的位置是/usr/local/bin/ssh，windows系统的位置是/Program Files/OpenSSH/bin/ssh.exe。Linux系统一般都自带ssh，如果没有则需要自己安装。安装命令如下：\n\n# Ubuntu 和 Debian\nsudo apt install openssh-client\n# CentOS 和 Fedora\nsudo dnf install openssh-clients\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n# 2 ssh登录\n\n\n# 2.1 基本用法\n\n远程登录服务器有以下几种方式：\n\nssh hostname # 没有指定用户名，将使用客户端的当前用户名\nssh user@hostname # 指定用户名\nssh user@hostname -p 22 # 登录端口为22，使用-p可以登录到某一特定的端口。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n其中user为用户名，hostname为IP地址或域名 第一次登录时会提示：\n\nThe authenticity of host '123.57.47.211 (123.57.47.211)' can't be established.\nECDSA key fingerprint is SHA256:iy237yysfCe013/l+kpDGfEG9xxHxm0dnxnAbJTPpG8.\nAre you sure you want to continue connecting (yes/no/[fingerprint])?\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n上述这段文字告诉用户，这台服务器的指纹是陌生的，让用户选择是否要继续连接（输入yes或no）。 所谓“服务器指纹”，指的是 SSH 服务器公钥的哈希值。每台 SSH 服务器都有唯一一对密钥，用于跟客户端通信，其中公钥的哈希值就可以用来识别服务器。\n\n输入yes，然后回车即可。这样会将服务器的信息记录在~/.ssh//known_hosts文件中，然后输入密码即可登录到远程服务器。 在~/.ssh/known_hosts文件中保存了本机连接过的所有服务器的公钥指纹信息，每次通过ssh连接一台服务器，系统会通过该文件判断当前需要连接的服务器是否为陌生主机。而如果之前ssh登陆过的服务器的密钥发生了更改，那么登录就会收到提示Host key verification failed，由于发生改变了，所以西我们需要删除之前的主机的指纹信息，添加新的。这个可以使用ssh-keygen -R <hostname>来进行删除。\n\n如果我们需要退出登录，输入logout或exit都可以实现，也可以使用快捷键Ctrl+d退出。\n\n\n# 2.2 配置文件\n\n创建文件~/.ssh/config，此为用户的个人配置文件，其保存相关配置信息。我们可以在文件中输入：\n\nHost myServer1\n    HostName IP地址或域名\n    User 用户名\nHost myServer2\n    HostName IP地址或域名\n    User 用户名\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n之后再使用服务器时，就可以直接使用别名myServer1、myServer2进行登录。 SSH客户端的全局配置文件为/etc/ssh/ssh_config，其优先级低于用户个人配置文件。除了配置文件，~/.ssh还有一些用户个人的密钥文件和其他文件\n\n\n# 2.3 密钥登录\n\n * 创建密钥 首先在本台主机上创建密钥，输入ssh-keygen指令，然后一直回车即可。该命令会为本机生成公私钥对，通过密钥来进行远程登录的验证机制使用了密码学中的非对称加密体系。执行命令后，会在~/.ssh/文件夹下生成两个新的文件：\n   \n     1. `id_rsa`：私钥\n     2. `id_rsa.pub`：公钥\n   \n   注意，一定要保护好生成的私钥`id_rsa`，一旦暴露，利用上述指令可以重新生成新的密钥。\n   \n   \n   \n\n * 免密登录 如果想要免密登录某个服务器，我们只需要将刚才生成的公钥保存在需要登录的远程服务器~/.ssh/authorized_keys文件中。例如我想免密登录到myServer1服务器，则将~/.ssh/id_rsa.pub公钥中的内容，复制到myServer1中的~/.ssh/authorized_keys文件中。也可以使用如下命令一键添加公钥： ssh-copy-id myServer1。 第一次应用ssh-copy-id系统会提示输入远程服务器的密码，之后登录时就可以免密登录了。\n\n一般来说，应用密钥登录比使用密码登录更加安全，所以启用密钥登录之后，最好关闭服务器的密码登录。如果需要在远程服务器上关闭密码登录。具体方法是先远程登录到服务器中，然后找到sshd的配置文件/etc/ssh/sshd_config，最后将PasswordAuthentication这一项设置为no。 PasswordAuthentication no sshd是服务器运行的后台进程，当我们修改配置文件以后，需要重新启动sshd，然后修改才能生效。可应用下面语句重启远程服务器上的ssh和sshd服务。\n\nsudo systemctl restart ssh.service\nsudo systemctl restart sshd.service\n\n\n1\n2\n\n1\n2\n\n * 执行远程命令 免密登录后，我们可以在命令行下直接执行远程命令：ssh user@hostname command。这样的命令会使SSH在登录成功后，立刻在远程主机上执行命令comand。但并不是真正的登录，执行完命令后还在原主机。 测试：ssh myServer1 ls\n\n\n# 3 scp传文件\n\n\n# 3.1 scp命令简介\n\nscp是secure copy的缩写，相当于cp命令+SSH。它的底层是SSH协议，默认端口是22，相当于先使用ssh命令登录远程主机，然后再进行拷贝操作。 scp主要用于以下三种复制操作：\n\n * 本地复制到远程。\n * 远程复制到本地。\n * 两个远程系统之间的复制。\n\n使用scp传输数据时，文件和密码都是加密的，不会泄露敏感信息。\n\n\n# 3.2 基本语法\n\nscp的语法类似cp的语法。\n\nscp source destination\n\n\n1\n\n1\n\n\n上面命令中，source是文件当前的位置，destination是文件所要复制到的位置。它们都可以包含用户名和主机名。例如：\n\nscp myServer1:main.cpp main.cpp\n\n\n1\n\n1\n\n\n上面命令即是将远程主机（myServer1）用户主目录下的main.cpp复制为本机当前目录下的main.cpp。注意主机与文件之间要使用:分隔。 scp会先用SSH登录到远程主机，然后在加密连接之中复制文件。客户端发起连接后，会提示用户输入密码。其中用户名和主机名若省略则是代表当前主机下的当前用户名。\n\nscp支持一次复制多个文件。scp source1 source2 destination。如果存在同名文件，scp会在没有警告的情况下覆盖同名文件。\n\n\n# 4 参考文献\n\nLinux基础课 菜鸟教程",normalizedContent:"# 1 ssh基本知识\n\n\n# 1.1 ssh是什么\n\nssh为secure shell的缩写，是一种网络协议，用于加密两台计算机之间的通信，保证不被窃听或篡改，并且支持各种身份验证机制。在事务中，它主要用户保证远程登录贺远程通信的安全，任何网络服务都可以用这个协议来加密。\n\n\n# 1.2 ssh架构\n\nssh的软件架构是c/s模式，即客户端-服务器模式。在这个架构中，ssh软件分成了两个部分：向服务器发出请求的部分，称为客户端，openssh的实现为ssh；接受客户端发出的请求的部分，称为服务器，openssh的实现为sshd。 其中大写的ssh表示协议，小写的ssh表示客户端软件。 openssh的客户端是二进制程序ssh。它在linux/unix系统的位置是/usr/local/bin/ssh，windows系统的位置是/program files/openssh/bin/ssh.exe。linux系统一般都自带ssh，如果没有则需要自己安装。安装命令如下：\n\n# ubuntu 和 debian\nsudo apt install openssh-client\n# centos 和 fedora\nsudo dnf install openssh-clients\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n# 2 ssh登录\n\n\n# 2.1 基本用法\n\n远程登录服务器有以下几种方式：\n\nssh hostname # 没有指定用户名，将使用客户端的当前用户名\nssh user@hostname # 指定用户名\nssh user@hostname -p 22 # 登录端口为22，使用-p可以登录到某一特定的端口。\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n其中user为用户名，hostname为ip地址或域名 第一次登录时会提示：\n\nthe authenticity of host '123.57.47.211 (123.57.47.211)' can't be established.\necdsa key fingerprint is sha256:iy237yysfce013/l+kpdgfeg9xxhxm0dnxnabjtppg8.\nare you sure you want to continue connecting (yes/no/[fingerprint])?\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n上述这段文字告诉用户，这台服务器的指纹是陌生的，让用户选择是否要继续连接（输入yes或no）。 所谓“服务器指纹”，指的是 ssh 服务器公钥的哈希值。每台 ssh 服务器都有唯一一对密钥，用于跟客户端通信，其中公钥的哈希值就可以用来识别服务器。\n\n输入yes，然后回车即可。这样会将服务器的信息记录在~/.ssh//known_hosts文件中，然后输入密码即可登录到远程服务器。 在~/.ssh/known_hosts文件中保存了本机连接过的所有服务器的公钥指纹信息，每次通过ssh连接一台服务器，系统会通过该文件判断当前需要连接的服务器是否为陌生主机。而如果之前ssh登陆过的服务器的密钥发生了更改，那么登录就会收到提示host key verification failed，由于发生改变了，所以西我们需要删除之前的主机的指纹信息，添加新的。这个可以使用ssh-keygen -r <hostname>来进行删除。\n\n如果我们需要退出登录，输入logout或exit都可以实现，也可以使用快捷键ctrl+d退出。\n\n\n# 2.2 配置文件\n\n创建文件~/.ssh/config，此为用户的个人配置文件，其保存相关配置信息。我们可以在文件中输入：\n\nhost myserver1\n    hostname ip地址或域名\n    user 用户名\nhost myserver2\n    hostname ip地址或域名\n    user 用户名\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n之后再使用服务器时，就可以直接使用别名myserver1、myserver2进行登录。 ssh客户端的全局配置文件为/etc/ssh/ssh_config，其优先级低于用户个人配置文件。除了配置文件，~/.ssh还有一些用户个人的密钥文件和其他文件\n\n\n# 2.3 密钥登录\n\n * 创建密钥 首先在本台主机上创建密钥，输入ssh-keygen指令，然后一直回车即可。该命令会为本机生成公私钥对，通过密钥来进行远程登录的验证机制使用了密码学中的非对称加密体系。执行命令后，会在~/.ssh/文件夹下生成两个新的文件：\n   \n     1. `id_rsa`：私钥\n     2. `id_rsa.pub`：公钥\n   \n   注意，一定要保护好生成的私钥`id_rsa`，一旦暴露，利用上述指令可以重新生成新的密钥。\n   \n   \n   \n\n * 免密登录 如果想要免密登录某个服务器，我们只需要将刚才生成的公钥保存在需要登录的远程服务器~/.ssh/authorized_keys文件中。例如我想免密登录到myserver1服务器，则将~/.ssh/id_rsa.pub公钥中的内容，复制到myserver1中的~/.ssh/authorized_keys文件中。也可以使用如下命令一键添加公钥： ssh-copy-id myserver1。 第一次应用ssh-copy-id系统会提示输入远程服务器的密码，之后登录时就可以免密登录了。\n\n一般来说，应用密钥登录比使用密码登录更加安全，所以启用密钥登录之后，最好关闭服务器的密码登录。如果需要在远程服务器上关闭密码登录。具体方法是先远程登录到服务器中，然后找到sshd的配置文件/etc/ssh/sshd_config，最后将passwordauthentication这一项设置为no。 passwordauthentication no sshd是服务器运行的后台进程，当我们修改配置文件以后，需要重新启动sshd，然后修改才能生效。可应用下面语句重启远程服务器上的ssh和sshd服务。\n\nsudo systemctl restart ssh.service\nsudo systemctl restart sshd.service\n\n\n1\n2\n\n1\n2\n\n * 执行远程命令 免密登录后，我们可以在命令行下直接执行远程命令：ssh user@hostname command。这样的命令会使ssh在登录成功后，立刻在远程主机上执行命令comand。但并不是真正的登录，执行完命令后还在原主机。 测试：ssh myserver1 ls\n\n\n# 3 scp传文件\n\n\n# 3.1 scp命令简介\n\nscp是secure copy的缩写，相当于cp命令+ssh。它的底层是ssh协议，默认端口是22，相当于先使用ssh命令登录远程主机，然后再进行拷贝操作。 scp主要用于以下三种复制操作：\n\n * 本地复制到远程。\n * 远程复制到本地。\n * 两个远程系统之间的复制。\n\n使用scp传输数据时，文件和密码都是加密的，不会泄露敏感信息。\n\n\n# 3.2 基本语法\n\nscp的语法类似cp的语法。\n\nscp source destination\n\n\n1\n\n1\n\n\n上面命令中，source是文件当前的位置，destination是文件所要复制到的位置。它们都可以包含用户名和主机名。例如：\n\nscp myserver1:main.cpp main.cpp\n\n\n1\n\n1\n\n\n上面命令即是将远程主机（myserver1）用户主目录下的main.cpp复制为本机当前目录下的main.cpp。注意主机与文件之间要使用:分隔。 scp会先用ssh登录到远程主机，然后在加密连接之中复制文件。客户端发起连接后，会提示用户输入密码。其中用户名和主机名若省略则是代表当前主机下的当前用户名。\n\nscp支持一次复制多个文件。scp source1 source2 destination。如果存在同名文件，scp会在没有警告的情况下覆盖同名文件。\n\n\n# 4 参考文献\n\nlinux基础课 菜鸟教程",charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"Tmux教程",frontmatter:{title:"Tmux教程",date:"2022-01-21T00:00:00.000Z",tags:["Tmux"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},categories:["工具","开发工具"],permalink:"/pages/c81c74/",readingShow:"top"},regularPath:"/02.%E5%B7%A5%E5%85%B7/03.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/02.Tmux%E6%95%99%E7%A8%8B.html",relativePath:"02.工具/03.开发工具/02.Tmux教程.md",key:"v-1e268ac6",path:"/pages/c81c74/",headers:[{level:2,title:"1 tmux使用教程",slug:"_1-tmux使用教程",normalizedTitle:"1 tmux使用教程",charIndex:2},{level:3,title:"1.1 tmux安装",slug:"_1-1-tmux安装",normalizedTitle:"1.1 tmux安装",charIndex:17},{level:3,title:"1.2 tmux简介",slug:"_1-2-tmux简介",normalizedTitle:"1.2 tmux简介",charIndex:185},{level:3,title:"1.3 tmux结构",slug:"_1-3-tmux结构",normalizedTitle:"1.3 tmux结构",charIndex:714},{level:3,title:"1.4 tmux操作",slug:"_1-4-tmux操作",normalizedTitle:"1.4 tmux操作",charIndex:998},{level:4,title:"1.4.1 前缀键",slug:"_1-4-1-前缀键",normalizedTitle:"1.4.1 前缀键",charIndex:1074},{level:4,title:"1.4.2 会话(session)操作",slug:"_1-4-2-会话-session-操作",normalizedTitle:"1.4.2 会话(session)操作",charIndex:1456},{level:4,title:"1.4.3 窗口(window)操作",slug:"_1-4-3-窗口-window-操作",normalizedTitle:"1.4.3 窗口(window)操作",charIndex:2801},{level:4,title:"1.4.4 面板(pane)操作",slug:"_1-4-4-面板-pane-操作",normalizedTitle:"1.4.4 面板(pane)操作",charIndex:3384},{level:2,title:"2 参考文献",slug:"_2-参考文献",normalizedTitle:"2 参考文献",charIndex:5072}],headersStr:"1 tmux使用教程 1.1 tmux安装 1.2 tmux简介 1.3 tmux结构 1.4 tmux操作 1.4.1 前缀键 1.4.2 会话(session)操作 1.4.3 窗口(window)操作 1.4.4 面板(pane)操作 2 参考文献",content:'# 1 tmux使用教程\n\n\n# 1.1 tmux安装\n\n# Ubuntu 或 Debian\n$ sudo apt-get install tmux\n\n# CentOS 或 Fedora\n$ sudo yum install tmux\n\n# Mac\n$ brew install tmux\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 1.2 tmux简介\n\ntmux是一个非常优秀的终端复用器（terminal multiplexer），其可以使用一系列的终端session，它使您可以在一个终端中的多个程序之间轻松切换、分离它们（它们继续在后台运行）并将它们重新附加到不同的终端。\n\nsession：我们知道，在windows命令行中我们打开一个终端窗口，然后输入命令实现与计算机的交流。而这种用户与计算机的这种临时的交互就叫做session。\n\ntmux的主要功能有：\n\n * 分屏，即允许在单个窗口中访问多个会话。这对我们同时运行多个命令行程序非常有用。\n * 允许断开Terminal连接后，继续运行进程。这样，我们可以随时随地放心的进行操作，即使工作进行到一半突然断开，我们打开tmux仍可以重新进入到操作现场。\n * 会话共享（适用于结对编程或者远程教学）。我们可以将tmux的会话地址分享给其他人，这样他们就可以通过SSH接入该会话。更骚的是，如果你要给其他人演示远程服务器的操作，不必一直盯着屏幕，我们可以借助tmux，他就可以完全进入你的会话。\n\n当然，tmux的功能还有很多，相比于其他的终端复用器，tmux更易用也更强大，这也是我们为什么要学习tmux的原因。\n\n\n# 1.3 tmux结构\n\ntmux是采用C/S模型构建的，我们输入tmux即相当于开启了一个服务器，此时默认将新建一个session，然后再session中新建一个window，window中新建一个pane。其联系为：一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。\n\n以下即是实例： tmux: session 0: window 0: pane 0 pane 1 pane 2 ... window 1 window 2 ... session 1 session 2 ...\n\n\n\n\n# 1.4 tmux操作\n\n注：以下操作大多数都会给出命令和对应的快捷键，如果用于学习，建议两种操作都要学会，但在平常操作中，使用快捷键是更方便的。\n\n# 1.4.1 前缀键\n\ntmux提供了很多的快捷键。特别的是所有的快捷键都需要通过前缀键唤起，默认的快捷键为ctrl + b。我们可以通过tmux list-keys命令来查看所有快捷键指令。\n\n当然如果觉得ctrl + b不好用，习惯用其他的键，这里提供修改前缀键的方法如下：\n\n# 首先打开文件~/.tmux.conf\nvim ~/.tmux.conf\n# 设置前缀为Ctrl + a。\nset -g prefix C-a\n# 解除Ctrl + b与前缀的对应关系。\nunbind C-b\n# 绑定ctrl + a 成为新的指令前缀。\nbind C-a send-prefix\n#然后让它生效。我们也可以直接重启让它生效。\nsource ~/.tmux.conf\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 1.4.2 会话(session)操作\n\n * 新建会话：tmux new -s sessionName。\n   \n   这样，我们就可以创建一个名为sessionName的会话了。当然我们也可以直接简写为tmux，这样会新建一个无名称的会话。但为了我们方便管理，所以建议还是指定会话名称。\n\n * 断开当前会话：tmux detach。\n   \n   这样，我们就可以断开当前会话，但是会话 还是会在后台运行。当然，我们还可以使用快捷键：先按ctrl + b，再按 ctrl + d即可退出。\n   \n   注意：这个并没有真正的关闭会话。\n\n * 进入已存在的会话：tmux a -t sessionName或者直接输入tmux a。\n   \n   前者可以指定进入的sessionName会话，而后者是默认进入第一个会话。其中的a命令实际上就是attach，我们可以简写为a。\n\n * 关闭会话：tmux kill -session -t sessionName或者tmux kill -server。\n   \n   我们可以使用tmux的kill命令，其中kill命令有四种：kill -pane, kill -server, kill -session, kill window。根据需求我们使用自己需要的命令，需要注意的是，根据前面的联系，我们关闭了session，那么其中的所有pane和window也都不存在了，同理关闭server,那么所有session也都不存在了。所以这里即是使用kill -session和kill -server，前者关闭sessionName这个会话，后者关闭所有的会话。\n\n * 查看所有的会话：tmux ls。\n   \n   \n\n * 切换会话：switch命令用于切换会话。\n   \n   # 使用会话编号来切换\n   tmux switch -t 0\n   # 使用会话名称来切换\n   tmux switch -t sessionName\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n\n * 重命名会话：tmux rename-session -t sessionName new Name。\n\n * 常用会话操作快捷键。\n   \n   前缀       指令         功能\n   Ctrl+b   d          断开当前会话\n   Ctrl+b   D          选择要断开的会话\n   Ctrl+b   $          重命名当前会话\n   Ctrl+b   s          列出当前会话用于选择并切换\n   Ctrl+b   r          强制重载当前会话\n   Ctrl+b   ctrl + z   挂起当前会话\n\n * tmux中复制/粘贴文本的通用方法。\n   \n   (1).按下Ctrl + b前缀键，然后按[；\n   \n   (2).用鼠标选中文本，然后被选中的文本会被自动复制到tmux的剪贴板；\n   \n   (3).按下Ctrl + b后前缀键，然后按]，会自动将剪贴板的内容粘贴到光标处。\n\n# 1.4.3 窗口(window)操作\n\n * 新建窗口：tmux new-window -n windowName。\n   \n   如此我们可创建一个新的名为windowName的窗口。当然我们也可以直接输入tmux new-window来创建一个没有指定名称的窗口。 创建一个新窗口后，原窗口我们是看不到了的，但依然存在。\n\n * 切换窗口：tmux select-window -t windowName。\n\n * 重命名窗口：tmux rename-window windowName。\n\n * 常用窗口操作快捷键。\n   \n   前缀       指令      功能\n   Ctrl+b   c       新建窗口\n   Ctrl+b   &       关闭当前窗口，需要输入y or n确认\n   Ctrl+b   编号      切换到指定编号的窗口\n   Ctrl+b   p       切换到上一个窗口\n   Ctrl+b   n       切换到下一个窗口\n   Ctrl+b   w       显示窗口列表用于切换。\n   Ctrl+b   ,（逗号）   重命名当前窗口\n   Ctrl+b   .       修改当前窗口编号（适用于窗口排序）\n   Ctrl+b   f       快速定位到窗口（输入关键字匹配窗口）\n\n# 1.4.4 面板(pane)操作\n\n * 划分面板。\n   \n   注意，此划分是针对当前选中的面板，面板可以无限划分。\n   \n   # 划分成上下两个面板\n   tmux split-window\n   #划分成左右两个面板\n   tmux split-window -h\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n   \n   \n\n * 切换面板。\n   \n   tmux select-pane命令用来移动光标位置，这个更严谨的说应该是切换光标，因为我们的光标正好可以选中面板，即可以通过鼠标点击选中。当然，前者过于简单且没有逼格，我们可以通过快捷键或者命令来实现。\n   \n   # 光标切换到上方面板\n   tmux select-pane -U\n   # 光标切换到下方面板\n   tmux select-pane -D\n   # 光标切换到左方面板\n   tmux select-pane -L\n   # 光标切换到右方面板\n   tmux select-pane -R\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * 交换面板位置。\n   \n   tmux swap-pane可用于交换面板位置。同切换面板差不多的形式。\n   \n   # 上移\n   tmux swap-pane -U\n   # 下移\n   tmux swap-pane -D\n   # 左移\n   tmux swap-pane -L\n   # 右移\n   tmux swap-pane -R\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * 常用面板操作快捷键。\n   \n   前缀       指令               描述\n   Ctrl+b   "                当前面板上下一分为二，下侧新建面板\n   Ctrl+b   %                当前面板左右一分为二，右侧新建面板\n   Ctrl+b   x                关闭当前面板（关闭前需输入y or n确认）\n   Ctrl+b   z                最大化当前面板，再重复一次按键后恢复正常（v1.8版本新增）\n   Ctrl+b   !                将当前面板移动到新的窗口打开（原窗口中存在两个及以上面板有效）\n   Ctrl+b   ;                切换到最后一次使用的面板\n   Ctrl+b   q                显示面板编号，在编号消失前输入对应的数字可切换到相应的面板\n   Ctrl+b   方向键              移动光标切换面板\n   Ctrl+b   hjkl(分别代表左下上右)   移动光标切换面板\n   Ctrl+b   {                向前置换当前面板\n   Ctrl+b   }                向后置换当前面板\n   Ctrl+b   Ctrl+o           顺时针旋转当前窗口中的所有面板\n   Ctrl+b   o                选择下一面板\n   Ctrl+b   空格键              在自带的面板布局中循环切换\n   Ctrl+b   Alt+方向键          以5个单元格为单位调整当前面板边缘\n   Ctrl+b   Ctrl+方向键         以1个单元格为单位调整当前面板边缘（Mac下被系统快捷键覆盖）\n   Ctrl+b   t                显示时钟\n\n\n# 2 参考文献\n\nTmux 使用教程-阮一峰\n\nTmux使用手册-路易斯\n\ntmux使用教程-小可七',normalizedContent:'# 1 tmux使用教程\n\n\n# 1.1 tmux安装\n\n# ubuntu 或 debian\n$ sudo apt-get install tmux\n\n# centos 或 fedora\n$ sudo yum install tmux\n\n# mac\n$ brew install tmux\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 1.2 tmux简介\n\ntmux是一个非常优秀的终端复用器（terminal multiplexer），其可以使用一系列的终端session，它使您可以在一个终端中的多个程序之间轻松切换、分离它们（它们继续在后台运行）并将它们重新附加到不同的终端。\n\nsession：我们知道，在windows命令行中我们打开一个终端窗口，然后输入命令实现与计算机的交流。而这种用户与计算机的这种临时的交互就叫做session。\n\ntmux的主要功能有：\n\n * 分屏，即允许在单个窗口中访问多个会话。这对我们同时运行多个命令行程序非常有用。\n * 允许断开terminal连接后，继续运行进程。这样，我们可以随时随地放心的进行操作，即使工作进行到一半突然断开，我们打开tmux仍可以重新进入到操作现场。\n * 会话共享（适用于结对编程或者远程教学）。我们可以将tmux的会话地址分享给其他人，这样他们就可以通过ssh接入该会话。更骚的是，如果你要给其他人演示远程服务器的操作，不必一直盯着屏幕，我们可以借助tmux，他就可以完全进入你的会话。\n\n当然，tmux的功能还有很多，相比于其他的终端复用器，tmux更易用也更强大，这也是我们为什么要学习tmux的原因。\n\n\n# 1.3 tmux结构\n\ntmux是采用c/s模型构建的，我们输入tmux即相当于开启了一个服务器，此时默认将新建一个session，然后再session中新建一个window，window中新建一个pane。其联系为：一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。\n\n以下即是实例： tmux: session 0: window 0: pane 0 pane 1 pane 2 ... window 1 window 2 ... session 1 session 2 ...\n\n\n\n\n# 1.4 tmux操作\n\n注：以下操作大多数都会给出命令和对应的快捷键，如果用于学习，建议两种操作都要学会，但在平常操作中，使用快捷键是更方便的。\n\n# 1.4.1 前缀键\n\ntmux提供了很多的快捷键。特别的是所有的快捷键都需要通过前缀键唤起，默认的快捷键为ctrl + b。我们可以通过tmux list-keys命令来查看所有快捷键指令。\n\n当然如果觉得ctrl + b不好用，习惯用其他的键，这里提供修改前缀键的方法如下：\n\n# 首先打开文件~/.tmux.conf\nvim ~/.tmux.conf\n# 设置前缀为ctrl + a。\nset -g prefix c-a\n# 解除ctrl + b与前缀的对应关系。\nunbind c-b\n# 绑定ctrl + a 成为新的指令前缀。\nbind c-a send-prefix\n#然后让它生效。我们也可以直接重启让它生效。\nsource ~/.tmux.conf\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 1.4.2 会话(session)操作\n\n * 新建会话：tmux new -s sessionname。\n   \n   这样，我们就可以创建一个名为sessionname的会话了。当然我们也可以直接简写为tmux，这样会新建一个无名称的会话。但为了我们方便管理，所以建议还是指定会话名称。\n\n * 断开当前会话：tmux detach。\n   \n   这样，我们就可以断开当前会话，但是会话 还是会在后台运行。当然，我们还可以使用快捷键：先按ctrl + b，再按 ctrl + d即可退出。\n   \n   注意：这个并没有真正的关闭会话。\n\n * 进入已存在的会话：tmux a -t sessionname或者直接输入tmux a。\n   \n   前者可以指定进入的sessionname会话，而后者是默认进入第一个会话。其中的a命令实际上就是attach，我们可以简写为a。\n\n * 关闭会话：tmux kill -session -t sessionname或者tmux kill -server。\n   \n   我们可以使用tmux的kill命令，其中kill命令有四种：kill -pane, kill -server, kill -session, kill window。根据需求我们使用自己需要的命令，需要注意的是，根据前面的联系，我们关闭了session，那么其中的所有pane和window也都不存在了，同理关闭server,那么所有session也都不存在了。所以这里即是使用kill -session和kill -server，前者关闭sessionname这个会话，后者关闭所有的会话。\n\n * 查看所有的会话：tmux ls。\n   \n   \n\n * 切换会话：switch命令用于切换会话。\n   \n   # 使用会话编号来切换\n   tmux switch -t 0\n   # 使用会话名称来切换\n   tmux switch -t sessionname\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n\n * 重命名会话：tmux rename-session -t sessionname new name。\n\n * 常用会话操作快捷键。\n   \n   前缀       指令         功能\n   ctrl+b   d          断开当前会话\n   ctrl+b   d          选择要断开的会话\n   ctrl+b   $          重命名当前会话\n   ctrl+b   s          列出当前会话用于选择并切换\n   ctrl+b   r          强制重载当前会话\n   ctrl+b   ctrl + z   挂起当前会话\n\n * tmux中复制/粘贴文本的通用方法。\n   \n   (1).按下ctrl + b前缀键，然后按[；\n   \n   (2).用鼠标选中文本，然后被选中的文本会被自动复制到tmux的剪贴板；\n   \n   (3).按下ctrl + b后前缀键，然后按]，会自动将剪贴板的内容粘贴到光标处。\n\n# 1.4.3 窗口(window)操作\n\n * 新建窗口：tmux new-window -n windowname。\n   \n   如此我们可创建一个新的名为windowname的窗口。当然我们也可以直接输入tmux new-window来创建一个没有指定名称的窗口。 创建一个新窗口后，原窗口我们是看不到了的，但依然存在。\n\n * 切换窗口：tmux select-window -t windowname。\n\n * 重命名窗口：tmux rename-window windowname。\n\n * 常用窗口操作快捷键。\n   \n   前缀       指令      功能\n   ctrl+b   c       新建窗口\n   ctrl+b   &       关闭当前窗口，需要输入y or n确认\n   ctrl+b   编号      切换到指定编号的窗口\n   ctrl+b   p       切换到上一个窗口\n   ctrl+b   n       切换到下一个窗口\n   ctrl+b   w       显示窗口列表用于切换。\n   ctrl+b   ,（逗号）   重命名当前窗口\n   ctrl+b   .       修改当前窗口编号（适用于窗口排序）\n   ctrl+b   f       快速定位到窗口（输入关键字匹配窗口）\n\n# 1.4.4 面板(pane)操作\n\n * 划分面板。\n   \n   注意，此划分是针对当前选中的面板，面板可以无限划分。\n   \n   # 划分成上下两个面板\n   tmux split-window\n   #划分成左右两个面板\n   tmux split-window -h\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n   \n   \n\n * 切换面板。\n   \n   tmux select-pane命令用来移动光标位置，这个更严谨的说应该是切换光标，因为我们的光标正好可以选中面板，即可以通过鼠标点击选中。当然，前者过于简单且没有逼格，我们可以通过快捷键或者命令来实现。\n   \n   # 光标切换到上方面板\n   tmux select-pane -u\n   # 光标切换到下方面板\n   tmux select-pane -d\n   # 光标切换到左方面板\n   tmux select-pane -l\n   # 光标切换到右方面板\n   tmux select-pane -r\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * 交换面板位置。\n   \n   tmux swap-pane可用于交换面板位置。同切换面板差不多的形式。\n   \n   # 上移\n   tmux swap-pane -u\n   # 下移\n   tmux swap-pane -d\n   # 左移\n   tmux swap-pane -l\n   # 右移\n   tmux swap-pane -r\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * 常用面板操作快捷键。\n   \n   前缀       指令               描述\n   ctrl+b   "                当前面板上下一分为二，下侧新建面板\n   ctrl+b   %                当前面板左右一分为二，右侧新建面板\n   ctrl+b   x                关闭当前面板（关闭前需输入y or n确认）\n   ctrl+b   z                最大化当前面板，再重复一次按键后恢复正常（v1.8版本新增）\n   ctrl+b   !                将当前面板移动到新的窗口打开（原窗口中存在两个及以上面板有效）\n   ctrl+b   ;                切换到最后一次使用的面板\n   ctrl+b   q                显示面板编号，在编号消失前输入对应的数字可切换到相应的面板\n   ctrl+b   方向键              移动光标切换面板\n   ctrl+b   hjkl(分别代表左下上右)   移动光标切换面板\n   ctrl+b   {                向前置换当前面板\n   ctrl+b   }                向后置换当前面板\n   ctrl+b   ctrl+o           顺时针旋转当前窗口中的所有面板\n   ctrl+b   o                选择下一面板\n   ctrl+b   空格键              在自带的面板布局中循环切换\n   ctrl+b   alt+方向键          以5个单元格为单位调整当前面板边缘\n   ctrl+b   ctrl+方向键         以1个单元格为单位调整当前面板边缘（mac下被系统快捷键覆盖）\n   ctrl+b   t                显示时钟\n\n\n# 2 参考文献\n\ntmux 使用教程-阮一峰\n\ntmux使用手册-路易斯\n\ntmux使用教程-小可七',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"Vim教程",frontmatter:{title:"Vim教程",date:"2022-01-21T10:00:00.000Z",tags:["Vim"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},categories:["工具","开发工具"],permalink:"/pages/e7b5a5/",readingShow:"top"},regularPath:"/02.%E5%B7%A5%E5%85%B7/03.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/03.Vim%E6%95%99%E7%A8%8B.html",relativePath:"02.工具/03.开发工具/03.Vim教程.md",key:"v-1a482803",path:"/pages/e7b5a5/",headers:[{level:2,title:"1. Vim",slug:"_1-vim",normalizedTitle:"1. vim",charIndex:2},{level:3,title:"1.1 Vim简介",slug:"_1-1-vim简介",normalizedTitle:"1.1 vim简介",charIndex:13},{level:3,title:"1.2 Vim模式",slug:"_1-2-vim模式",normalizedTitle:"1.2 vim模式",charIndex:342},{level:4,title:"1.2.1 正常模式(Normal-mode)",slug:"_1-2-1-正常模式-normal-mode",normalizedTitle:"1.2.1 正常模式(normal-mode)",charIndex:563},{level:4,title:"1.2.2 插入模式(Insert-mode)",slug:"_1-2-2-插入模式-insert-mode",normalizedTitle:"1.2.2 插入模式(insert-mode)",charIndex:5148},{level:4,title:"1.2.3 命令模式(Command -mode)",slug:"_1-2-3-命令模式-command-mode",normalizedTitle:"1.2.3 命令模式(command -mode)",charIndex:5585},{level:4,title:"1.2.4 可视模式(Visual-mode)",slug:"_1-2-4-可视模式-visual-mode",normalizedTitle:"1.2.4 可视模式(visual-mode)",charIndex:6297},{level:3,title:"1.3 快捷键速览图",slug:"_1-3-快捷键速览图",normalizedTitle:"1.3 快捷键速览图",charIndex:7386},{level:2,title:"2 参考文献",slug:"_2-参考文献",normalizedTitle:"2 参考文献",charIndex:7403}],headersStr:"1. Vim 1.1 Vim简介 1.2 Vim模式 1.2.1 正常模式(Normal-mode) 1.2.2 插入模式(Insert-mode) 1.2.3 命令模式(Command -mode) 1.2.4 可视模式(Visual-mode) 1.3 快捷键速览图 2 参考文献",content:'# 1. Vim\n\n\n# 1.1 Vim简介\n\nvim就是linux系统上的一款文本编辑器，具有语法高亮，代码补全，代码缩进，根据扩展名识别编程语言以及编译等方便编程的功能。是程序开发者一款非常好用的工具，这也是我们为什么要学习vim。\n\n需要注意的是，作为程序员一般认为vim是一个程序开发工具而不是文字处理软件。如果学会了vim，对编程效率有极大的提高。\n\n如果没有安装vim，可以通过:sudo apt-get install vim来安装。\n\n\n\n这个就是vim的界面，界面介绍在之后会介绍，同时vim对应的键盘功能图如下：\n\n\n\n图源：https://www.runoob.com/linux/linux-vim.html\n\n这个键盘图特别重要，也是vim的核心。\n\n\n# 1.2 Vim模式\n\n在使用vim之间，我们有必要了解它的模式，也可以认为是状态，一共有四种模式：\n\n * 正常模式(Normal-mode)；\n * 插入模式(Insert-mode)；\n * 命令模式(Command -mode)；\n * 可视模式(Visual-mode)。\n\n有的时候通常也认为是三个模式，即没有可视模式（可能是因为这个模式存在感低），我们可以参考下图理解模式之间的转换：\n\n\n\n接下来我们分别介绍这几个模式。\n\n# 1.2.1 正常模式(Normal-mode)\n\n此模式一般用于浏览文件，包括一些复制，粘贴，删除等操作。我们从任何模式返回到正常模式，只需要按下ESC键。\n\n当我们通过vim 文件名.后缀启动vim时，就进入到了正常模式，如果已有文件，则打开它，否则就打开一个新的文件，并命名为文件名。\n\n此时我们是无法向文件写内容的，此状态下敲击键盘会被vim识别为命令，而不是输入字符。\n\n当我们输入i，I, a,A 时会进入插入模式。\n\n当我们输入v时会进入可视模式。\n\n当我们输入:时会进入命令模式，即在最底下一行输入命令。所以也叫底线命令模式。\n\n要重点介绍的一个内容就是如何删除、复制，剪切以及粘贴了。vim对于复制，剪切，粘贴有它自己的一套术语。其中复制被叫做yank(y)， 剪切被叫做delete(d)，粘贴被叫做put(p)。\n\n * 删除\n   \n   * c -向下删除一行。如果要删除多行，则输入nc，即可向下删除nnn行。\n   * x - 向后删除一个字符，相当于del按键。如果要连续删除多个字符，则输入nx，即可删除nnn个。\n   * X -向前删除一个字符， 相当于Backspace按键。同理nX。\n\n * 复制(yank)\n   \n   我们如果需要复制文本，那么需要将光标放到你想要复制的地方，然后根据需求按下相应命令即可。\n   \n   * y -复制选中的文本（选中文本在视图模式中会讲到）。\n   \n   * yy -复制当前行，包括换行符。\n   \n   * <number>yy -复制从光标所在的当前行开始的number行文本。\n     \n     例如3yy即可复制从当前行开始的333行文本。\n   \n   * y$ -复制从光标位置到行尾的文本。\n   \n   * y^ -复制从光标位置到行首的文本。\n   \n   * yw -复制到下一个词的开头。\n   \n   * yiw - 复制当前词。\n   \n   * y% -复制匹配符号范围的内容。默认支持的符号对为(),{},[]。这个在复制括号内容时，非常有用。\n   \n   * yG -复制游标所在行到最后一行的行的所有数据。\n   \n   * ynG -n为数组，复制游标所在行到第nnn行的所有数据。\n\n * 剪切(delete)\n   \n   这个命令正常来说也可以作删除用。剪切文本时将光标移动到想要的位置，根据需求按下相应命令即可。\n   \n   * d -剪切选中的文本。\n   \n   * dd -剪切当前行，包括换行符等。\n   \n   * <number>dd -剪切从光标位置所在的行开始的number行文本。\n   \n   * d$ - 剪切从光标位置到行尾的内容。\n   \n   * ...不难发现，这些命令和复制差不多，就是将y换成d。这里就不再做阐述了。\n\n * 粘贴(put)\n   \n   先将光标移动到想要粘贴的位置，然后按p键即可将剪贴板的内容复制到当前光标后面。\n   \n   当然，大写的P则是复制到光标位置前面。\n\n * 其他常用操作\n   \n   快捷键                                     功能\n   J                                       将光标所在行与下一行的数据结合成同一行\n   gg=G                                    将全文代码格式化\n   u                                       撤销。(常用)\n   Ctrl+r                                  取消撤销。(常用)\n   这个 u与 Ctrl+r 是很常用的指令！一个是复原，另一个则是重做一次～   \n   利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！\n   .                                       不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！\n                                           (常用)\n   n                                       重复前一个查找操作（常用）\n   N                                       反向重复前一个查找操作（常用）\n\n其他的不常用操作这里不作列举。\n\n我们可以通过方向键操作光标位置，注意linux中的方向键可以通过hjkl分别代表左下上右。这里给出移动光标的方法表格：\n\n快捷键                                                  功能\nh 或 向左箭头键(←)                                         光标向左移动一个字符\nj 或 向下箭头键(↓)                                         光标向下移动一个字符\nk 或 向上箭头键(↑)                                         光标向上移动一个字符\nl 或 向右箭头键(→)                                         光标向右移动一个字符\n如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。    \n如果想要进行多次移动的话，例如向下移动 30 行，可以使用 "30j" 或 "30↓" 的组合按键，\n亦即加上想要进行的次数(数字)后，按下动作即可！\nCtrl] + f                                            屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)\nCtrl + b                                             屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)\nCtrl + d                                             屏幕『向下』移动半页\nCtrl] + u                                            屏幕『向上』移动半页\n+                                                    光标移动到非空格符的下一行行首\n-                                                    光标移动到非空格符的上一行行首\nn<space>                                             那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20\n                                                     则光标会向后面移动 20 个字符距离。\n0 或功能键``Home`                                        这是数字『 0 』：移动到这一行的最前面字符处 (常用)\n$ 或功能键``End`                                         移动到这一行的最后面字符处(常用)\nH                                                    光标移动到这个屏幕的最上方那一行的第一个字符\nM                                                    光标移动到这个屏幕的中央那一行的第一个字符\nL                                                    光标移动到这个屏幕的最下方那一行的第一个字符\nG                                                    移动到这个档案的最后一行(常用)\n:n或nG                                                n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)\ngg                                                   移动到这个档案的第一行，相当于 1G 啊！ (常用)\nn<Enter>                                             n 为数字。光标向下移动 n 行(常用)\nf{char}                                              光标跳转到光标所在行从光标开始之后的char字符处。即从光标位置到该行尾检索char字符，光标位置前的不处理\nF{char}                                              光标跳转到光标所在行从光标开始之前的char字符处。即从行开头到光标处检索char字符，光标位置前的不处理\nW或者w（大小写均可）                                          跳转到下一个单词的开头。支持数字前缀\nb或者B（大小写均可）                                          跳转到上一个单词的开头。支持数字前缀。\n{                                                    光标跳转到段首\n}                                                    光标跳转到段尾\n^                                                    光标跳转到软行首。即该行的最早非空格位置字符。\nE或e（大小写均可）                                           移动到词尾。\n(                                                    句首\n)                                                    下一句首\n%                                                    括号匹配。\n\n正常模式只有一些基本的命令，因此我们需要靠命令模式来输入更多的命令。\n\n# 1.2.2 插入模式(Insert-mode)\n\n由上相信大家应该知道怎么由正常模式进入输入模式，即按下i(insert)即可进入插入模式。\n\n在插入模式中，操作和正常的文本编辑器差不多，这里不作叙述。给出对应的快捷键操作表。\n\n快捷键                  功能\nCtrl + m或者Ctrl + j   开启新行\nCtrl + e             插入光标下的字符\nCtrl + y             插入光标上的字符\nCtrl + a             插入上次插入的文本\nCtrl + @             插入上次插入的文本并结束插入模式\nCtrl + w             删除光标前的一个单词\nCtrl + u             删除当前行的所有字符\nCtrl + T             在当前行首插入一个移位宽度的缩进\nCtrl + D             从当前行首删除一个位移宽度的缩进\n\n# 1.2.3 命令模式(Command -mode)\n\n我们在一般命令模式下按下:/?这三个字母中的任意一个就可以进入命令行模式了，命令行在最下面，可以进行查找、替换、保存、退出、配置编译器等操作。需要注意的就是我们每执行完一个命令之后就会回到正常模式，所以在需要操作的时候一定要输入:/?这三个字母中的其中一个。\n\n当然输入三个字母进入实现的命令是不一样的，这里给出具体操作。\n\n * /word -向光标之下（向后搜索）寻找第一个值为word的字符串。\n\n * ?word -向光标之上（向前搜索）寻找第一个值为word的字符串。\n\n * :n1,n2s/word1/word2/g -n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将字符串替换为word2。\n   \n   如果在g后面加上c命令，即:n1,n2s/word1/word2/gc那么会在替换前要求用户确认。\n\n * :1,$s/word1/word2/g -将全文的word1替换成word2。\n   \n   同理，如果在g后面加上c命令，也会要求确认。\n\n * :w -保存。\n\n * :w! -强制保存，当文件属性为只读时强制写入。不过这还是跟你对该文档的权限有关。\n\n * :q -退出vim。\n\n * :q! -强制退出vim。\n\n * :wq -保存并退出。\n\n * :set paste -设置成粘贴模式，取消代码自动缩进。\n\n * :set nopaste -取消粘贴模式，开启代码自动缩进。\n\n * :set nu -显示行号。\n\n * set nonu -隐藏行号。\n\n * :noh -关闭查找关键词高亮。\n\n# 1.2.4 可视模式(Visual-mode)\n\n这个模式存在感很低，有的甚至将它归结为正常模式。因为进入可视模式最直接的一个目的就是选中区域，然后再这个区域上进行操作，例如删除，替换等。不过，我认为这个模式异常重要，因为技巧性特别多。用好了这个模式，效率能大大的提高。\n\n * 如何选中一块区域？\n   \n   在vim中有三种激活可视模式并选择一块区域的方法：\n   \n   模式类型   激活方式       选择效果         左下角提示（即提示你当前处于何种模式）\n   字符文本   v(小写)      逐个字符选择文本     VISUAL\n   行文本    V(大写)      逐行选择文本       VISUAL LINE\n   块文本    Ctrl + v   按照块的方式选择文本   VISUAL BLOCK\n   \n   可能看着有点懵。我们来解释一下，\n   \n   * 对于字符文本选择，实际上就是从当前光标位置开始，通过方向键去逐个字符连续选取文本，和我们在平常的文本编辑器中按住shift键移动方向键选取功能相同；\n   * 对于行文本选择，那么也是从当前光标位置开始选择，通过方向键去逐行连续选取文本，和上一个区别在于粒度不一样，这个方式选择的最小单位是行；\n   * 而对于块文本选择为最强大的选择模式，因为前面两种选择具有局限性，这个模式它可以完全无视行的存在，可以在文本中按照需要的区域自由u许纳泽。\n   \n   我们来看一个例子：\n   \n   \n   \n   假设我们要选择Hello,Linux，那么使用字符文本选择我们只需要将光标移动到H处，然后进入字符文本选择模式，再通过方向键选中即可。块文本选择同理操作即可。\n\n * 如何快速选择目标区域？\n   \n   如果通过以上模式而不使用快捷键选取，那么效率很低。而在正常模式中，我们已经介绍了很多快速移动光标的命令，而在可视模式下，这些快速移动光标的命令也是可以使用的。\n\n * 如何重复选择目标区域?\n   \n   可以使用gv命令来重新选中之前选中的目标区域。\n\n * 对选中的区域进行操作\n   \n   命令   命令效果\n   d    删除选中文本\n   c    修改选中文本\n   r    替换选中文本\n   I    在选中文本前插入\n   A    在选中文本后插入\n   gu   选中区域转为小写\n   gU   选中区域转为大写\n   g~   大小写互调\n   >    向右缩进一个单位\n   <    向左缩进一个单位\n\n\n# 1.3 快捷键速览图\n\n\n\n\n# 2 参考文献\n\ny总Linux基础课\n\n精通 VIM ，此文就够了-zempty\n\nLinux vi/vim - runoob.com\n\nvim编辑器 莫迟',normalizedContent:'# 1. vim\n\n\n# 1.1 vim简介\n\nvim就是linux系统上的一款文本编辑器，具有语法高亮，代码补全，代码缩进，根据扩展名识别编程语言以及编译等方便编程的功能。是程序开发者一款非常好用的工具，这也是我们为什么要学习vim。\n\n需要注意的是，作为程序员一般认为vim是一个程序开发工具而不是文字处理软件。如果学会了vim，对编程效率有极大的提高。\n\n如果没有安装vim，可以通过:sudo apt-get install vim来安装。\n\n\n\n这个就是vim的界面，界面介绍在之后会介绍，同时vim对应的键盘功能图如下：\n\n\n\n图源：https://www.runoob.com/linux/linux-vim.html\n\n这个键盘图特别重要，也是vim的核心。\n\n\n# 1.2 vim模式\n\n在使用vim之间，我们有必要了解它的模式，也可以认为是状态，一共有四种模式：\n\n * 正常模式(normal-mode)；\n * 插入模式(insert-mode)；\n * 命令模式(command -mode)；\n * 可视模式(visual-mode)。\n\n有的时候通常也认为是三个模式，即没有可视模式（可能是因为这个模式存在感低），我们可以参考下图理解模式之间的转换：\n\n\n\n接下来我们分别介绍这几个模式。\n\n# 1.2.1 正常模式(normal-mode)\n\n此模式一般用于浏览文件，包括一些复制，粘贴，删除等操作。我们从任何模式返回到正常模式，只需要按下esc键。\n\n当我们通过vim 文件名.后缀启动vim时，就进入到了正常模式，如果已有文件，则打开它，否则就打开一个新的文件，并命名为文件名。\n\n此时我们是无法向文件写内容的，此状态下敲击键盘会被vim识别为命令，而不是输入字符。\n\n当我们输入i，i, a,a 时会进入插入模式。\n\n当我们输入v时会进入可视模式。\n\n当我们输入:时会进入命令模式，即在最底下一行输入命令。所以也叫底线命令模式。\n\n要重点介绍的一个内容就是如何删除、复制，剪切以及粘贴了。vim对于复制，剪切，粘贴有它自己的一套术语。其中复制被叫做yank(y)， 剪切被叫做delete(d)，粘贴被叫做put(p)。\n\n * 删除\n   \n   * c -向下删除一行。如果要删除多行，则输入nc，即可向下删除nnn行。\n   * x - 向后删除一个字符，相当于del按键。如果要连续删除多个字符，则输入nx，即可删除nnn个。\n   * x -向前删除一个字符， 相当于backspace按键。同理nx。\n\n * 复制(yank)\n   \n   我们如果需要复制文本，那么需要将光标放到你想要复制的地方，然后根据需求按下相应命令即可。\n   \n   * y -复制选中的文本（选中文本在视图模式中会讲到）。\n   \n   * yy -复制当前行，包括换行符。\n   \n   * <number>yy -复制从光标所在的当前行开始的number行文本。\n     \n     例如3yy即可复制从当前行开始的333行文本。\n   \n   * y$ -复制从光标位置到行尾的文本。\n   \n   * y^ -复制从光标位置到行首的文本。\n   \n   * yw -复制到下一个词的开头。\n   \n   * yiw - 复制当前词。\n   \n   * y% -复制匹配符号范围的内容。默认支持的符号对为(),{},[]。这个在复制括号内容时，非常有用。\n   \n   * yg -复制游标所在行到最后一行的行的所有数据。\n   \n   * yng -n为数组，复制游标所在行到第nnn行的所有数据。\n\n * 剪切(delete)\n   \n   这个命令正常来说也可以作删除用。剪切文本时将光标移动到想要的位置，根据需求按下相应命令即可。\n   \n   * d -剪切选中的文本。\n   \n   * dd -剪切当前行，包括换行符等。\n   \n   * <number>dd -剪切从光标位置所在的行开始的number行文本。\n   \n   * d$ - 剪切从光标位置到行尾的内容。\n   \n   * ...不难发现，这些命令和复制差不多，就是将y换成d。这里就不再做阐述了。\n\n * 粘贴(put)\n   \n   先将光标移动到想要粘贴的位置，然后按p键即可将剪贴板的内容复制到当前光标后面。\n   \n   当然，大写的p则是复制到光标位置前面。\n\n * 其他常用操作\n   \n   快捷键                                     功能\n   j                                       将光标所在行与下一行的数据结合成同一行\n   gg=g                                    将全文代码格式化\n   u                                       撤销。(常用)\n   ctrl+r                                  取消撤销。(常用)\n   这个 u与 ctrl+r 是很常用的指令！一个是复原，另一个则是重做一次～   \n   利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！\n   .                                       不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！\n                                           (常用)\n   n                                       重复前一个查找操作（常用）\n   n                                       反向重复前一个查找操作（常用）\n\n其他的不常用操作这里不作列举。\n\n我们可以通过方向键操作光标位置，注意linux中的方向键可以通过hjkl分别代表左下上右。这里给出移动光标的方法表格：\n\n快捷键                                                  功能\nh 或 向左箭头键(←)                                         光标向左移动一个字符\nj 或 向下箭头键(↓)                                         光标向下移动一个字符\nk 或 向上箭头键(↑)                                         光标向上移动一个字符\nl 或 向右箭头键(→)                                         光标向右移动一个字符\n如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。    \n如果想要进行多次移动的话，例如向下移动 30 行，可以使用 "30j" 或 "30↓" 的组合按键，\n亦即加上想要进行的次数(数字)后，按下动作即可！\nctrl] + f                                            屏幕『向下』移动一页，相当于 [page down]按键 (常用)\nctrl + b                                             屏幕『向上』移动一页，相当于 [page up] 按键 (常用)\nctrl + d                                             屏幕『向下』移动半页\nctrl] + u                                            屏幕『向上』移动半页\n+                                                    光标移动到非空格符的下一行行首\n-                                                    光标移动到非空格符的上一行行首\nn<space>                                             那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20\n                                                     则光标会向后面移动 20 个字符距离。\n0 或功能键``home`                                        这是数字『 0 』：移动到这一行的最前面字符处 (常用)\n$ 或功能键``end`                                         移动到这一行的最后面字符处(常用)\nh                                                    光标移动到这个屏幕的最上方那一行的第一个字符\nm                                                    光标移动到这个屏幕的中央那一行的第一个字符\nl                                                    光标移动到这个屏幕的最下方那一行的第一个字符\ng                                                    移动到这个档案的最后一行(常用)\n:n或ng                                                n 为数字。移动到这个档案的第 n 行。例如 20g 则会移动到这个档案的第 20 行(可配合 :set nu)\ngg                                                   移动到这个档案的第一行，相当于 1g 啊！ (常用)\nn<enter>                                             n 为数字。光标向下移动 n 行(常用)\nf{char}                                              光标跳转到光标所在行从光标开始之后的char字符处。即从光标位置到该行尾检索char字符，光标位置前的不处理\nf{char}                                              光标跳转到光标所在行从光标开始之前的char字符处。即从行开头到光标处检索char字符，光标位置前的不处理\nw或者w（大小写均可）                                          跳转到下一个单词的开头。支持数字前缀\nb或者b（大小写均可）                                          跳转到上一个单词的开头。支持数字前缀。\n{                                                    光标跳转到段首\n}                                                    光标跳转到段尾\n^                                                    光标跳转到软行首。即该行的最早非空格位置字符。\ne或e（大小写均可）                                           移动到词尾。\n(                                                    句首\n)                                                    下一句首\n%                                                    括号匹配。\n\n正常模式只有一些基本的命令，因此我们需要靠命令模式来输入更多的命令。\n\n# 1.2.2 插入模式(insert-mode)\n\n由上相信大家应该知道怎么由正常模式进入输入模式，即按下i(insert)即可进入插入模式。\n\n在插入模式中，操作和正常的文本编辑器差不多，这里不作叙述。给出对应的快捷键操作表。\n\n快捷键                  功能\nctrl + m或者ctrl + j   开启新行\nctrl + e             插入光标下的字符\nctrl + y             插入光标上的字符\nctrl + a             插入上次插入的文本\nctrl + @             插入上次插入的文本并结束插入模式\nctrl + w             删除光标前的一个单词\nctrl + u             删除当前行的所有字符\nctrl + t             在当前行首插入一个移位宽度的缩进\nctrl + d             从当前行首删除一个位移宽度的缩进\n\n# 1.2.3 命令模式(command -mode)\n\n我们在一般命令模式下按下:/?这三个字母中的任意一个就可以进入命令行模式了，命令行在最下面，可以进行查找、替换、保存、退出、配置编译器等操作。需要注意的就是我们每执行完一个命令之后就会回到正常模式，所以在需要操作的时候一定要输入:/?这三个字母中的其中一个。\n\n当然输入三个字母进入实现的命令是不一样的，这里给出具体操作。\n\n * /word -向光标之下（向后搜索）寻找第一个值为word的字符串。\n\n * ?word -向光标之上（向前搜索）寻找第一个值为word的字符串。\n\n * :n1,n2s/word1/word2/g -n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将字符串替换为word2。\n   \n   如果在g后面加上c命令，即:n1,n2s/word1/word2/gc那么会在替换前要求用户确认。\n\n * :1,$s/word1/word2/g -将全文的word1替换成word2。\n   \n   同理，如果在g后面加上c命令，也会要求确认。\n\n * :w -保存。\n\n * :w! -强制保存，当文件属性为只读时强制写入。不过这还是跟你对该文档的权限有关。\n\n * :q -退出vim。\n\n * :q! -强制退出vim。\n\n * :wq -保存并退出。\n\n * :set paste -设置成粘贴模式，取消代码自动缩进。\n\n * :set nopaste -取消粘贴模式，开启代码自动缩进。\n\n * :set nu -显示行号。\n\n * set nonu -隐藏行号。\n\n * :noh -关闭查找关键词高亮。\n\n# 1.2.4 可视模式(visual-mode)\n\n这个模式存在感很低，有的甚至将它归结为正常模式。因为进入可视模式最直接的一个目的就是选中区域，然后再这个区域上进行操作，例如删除，替换等。不过，我认为这个模式异常重要，因为技巧性特别多。用好了这个模式，效率能大大的提高。\n\n * 如何选中一块区域？\n   \n   在vim中有三种激活可视模式并选择一块区域的方法：\n   \n   模式类型   激活方式       选择效果         左下角提示（即提示你当前处于何种模式）\n   字符文本   v(小写)      逐个字符选择文本     visual\n   行文本    v(大写)      逐行选择文本       visual line\n   块文本    ctrl + v   按照块的方式选择文本   visual block\n   \n   可能看着有点懵。我们来解释一下，\n   \n   * 对于字符文本选择，实际上就是从当前光标位置开始，通过方向键去逐个字符连续选取文本，和我们在平常的文本编辑器中按住shift键移动方向键选取功能相同；\n   * 对于行文本选择，那么也是从当前光标位置开始选择，通过方向键去逐行连续选取文本，和上一个区别在于粒度不一样，这个方式选择的最小单位是行；\n   * 而对于块文本选择为最强大的选择模式，因为前面两种选择具有局限性，这个模式它可以完全无视行的存在，可以在文本中按照需要的区域自由u许纳泽。\n   \n   我们来看一个例子：\n   \n   \n   \n   假设我们要选择hello,linux，那么使用字符文本选择我们只需要将光标移动到h处，然后进入字符文本选择模式，再通过方向键选中即可。块文本选择同理操作即可。\n\n * 如何快速选择目标区域？\n   \n   如果通过以上模式而不使用快捷键选取，那么效率很低。而在正常模式中，我们已经介绍了很多快速移动光标的命令，而在可视模式下，这些快速移动光标的命令也是可以使用的。\n\n * 如何重复选择目标区域?\n   \n   可以使用gv命令来重新选中之前选中的目标区域。\n\n * 对选中的区域进行操作\n   \n   命令   命令效果\n   d    删除选中文本\n   c    修改选中文本\n   r    替换选中文本\n   i    在选中文本前插入\n   a    在选中文本后插入\n   gu   选中区域转为小写\n   gu   选中区域转为大写\n   g~   大小写互调\n   >    向右缩进一个单位\n   <    向左缩进一个单位\n\n\n# 1.3 快捷键速览图\n\n\n\n\n# 2 参考文献\n\ny总linux基础课\n\n精通 vim ，此文就够了-zempty\n\nlinux vi/vim - runoob.com\n\nvim编辑器 莫迟',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"雪韵初见·南京初雪",frontmatter:{title:"雪韵初见·南京初雪",author:{name:"Pursuit",link:"https://github.com/unique-pure"},date:"2023-12-19T09:28:46.000Z",permalink:"/pages/608406/",categories:["生活杂谈","随写编年","2023年"],tags:[null],readingShow:"top"},regularPath:"/04.%E7%94%9F%E6%B4%BB%E6%9D%82%E8%B0%88/01.%E9%9A%8F%E5%86%99%E7%BC%96%E5%B9%B4/02.2023%E5%B9%B4/01.%E9%9B%AA%E9%9F%B5%E5%88%9D%E8%A7%81%C2%B7%E5%8D%97%E4%BA%AC%E5%88%9D%E9%9B%AA.html",relativePath:"04.生活杂谈/01.随写编年/02.2023年/01.雪韵初见·南京初雪.md",key:"v-59070e48",path:"/pages/608406/",headersStr:null,content:"2023年12月18日，南京下了一整天的雪，雪花纷纷，如诗如画。白茫茫的世界，仿佛是一片纯净的画布，被雪的柔美覆盖。而在南航校园里，这场雪更添了一份独特的美丽。南航的雪景如同童话般迷人，树木被白雪裹挟着，建筑物顶部披上了银装，仿佛置身于梦幻世界。学生们穿梭在雪花飞舞的空间，踏出一串串有趣的足迹，留下了一段段温暖的回忆。\n\n\n\n\n\n\n\n\n\n\n\n\n雪积的很厚，虽然相比北方可能还算是微薄的，但对于南京来说，已经是难得的雪景。\n我印象中江西是只下过一场大雪的，那时的记忆如同冰雪一样清晰。那场雪是我小学时的冬天，当时还是童真稚嫩的模样。和同学们一起在学校的草坪上嬉戏，打着雪仗，欢笑声在雪的映衬下更显灿烂。虽然我们玩得不亦乐乎，但那时候的我还没有尝试过堆雪人，有些许遗憾。 而今天，机会来了，和实验室的小伙伴们欢聚一堂，一同投身到雪雕的世界中，我们聚精会神地堆起雪人，大宝（左）和小雪（右）矗立在雪地中，虽然抽象却充满了趣味。\n\n雪人巍然而立，也成为了这场雪夜的参与者。堆完雪人后，我们迫不及待地展开了雪仗大战，雪花在夜空中飞舞，欢笑声在寒冷的空气中回荡。在这激烈而欢快的雪仗中，我们体验到了友情的温暖，仿佛回到了童年时光，充满着无尽的欢笑和快乐。\n\n有机会一定要去北方玩，尤其是在冬季，感受那儿更为宏伟壮丽的雪景，或许可以尝试一下滑雪\n\n南航其他艺术家雪人图片大赏：\n\n\n\n\n\n\n\n",normalizedContent:"2023年12月18日，南京下了一整天的雪，雪花纷纷，如诗如画。白茫茫的世界，仿佛是一片纯净的画布，被雪的柔美覆盖。而在南航校园里，这场雪更添了一份独特的美丽。南航的雪景如同童话般迷人，树木被白雪裹挟着，建筑物顶部披上了银装，仿佛置身于梦幻世界。学生们穿梭在雪花飞舞的空间，踏出一串串有趣的足迹，留下了一段段温暖的回忆。\n\n\n\n\n\n\n\n\n\n\n\n\n雪积的很厚，虽然相比北方可能还算是微薄的，但对于南京来说，已经是难得的雪景。\n我印象中江西是只下过一场大雪的，那时的记忆如同冰雪一样清晰。那场雪是我小学时的冬天，当时还是童真稚嫩的模样。和同学们一起在学校的草坪上嬉戏，打着雪仗，欢笑声在雪的映衬下更显灿烂。虽然我们玩得不亦乐乎，但那时候的我还没有尝试过堆雪人，有些许遗憾。 而今天，机会来了，和实验室的小伙伴们欢聚一堂，一同投身到雪雕的世界中，我们聚精会神地堆起雪人，大宝（左）和小雪（右）矗立在雪地中，虽然抽象却充满了趣味。\n\n雪人巍然而立，也成为了这场雪夜的参与者。堆完雪人后，我们迫不及待地展开了雪仗大战，雪花在夜空中飞舞，欢笑声在寒冷的空气中回荡。在这激烈而欢快的雪仗中，我们体验到了友情的温暖，仿佛回到了童年时光，充满着无尽的欢笑和快乐。\n\n有机会一定要去北方玩，尤其是在冬季，感受那儿更为宏伟壮丽的雪景，或许可以尝试一下滑雪\n\n南航其他艺术家雪人图片大赏：\n\n\n\n\n\n\n\n",charsets:{cjk:!0},lastUpdated:"2023/12/19, 10:12:18",lastUpdatedTimestamp:1702951938e3},{title:"Shell教程",frontmatter:{title:"Shell教程",date:"2022-01-22T09:23:42.000Z",tags:["Shell"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/0fc47a/",categories:["工具","开发工具"],readingShow:"top"},regularPath:"/02.%E5%B7%A5%E5%85%B7/03.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/01.Shell%E6%95%99%E7%A8%8B.html",relativePath:"02.工具/03.开发工具/01.Shell教程.md",key:"v-509f409b",path:"/pages/0fc47a/",headers:[{level:2,title:"1. Shell概论",slug:"_1-shell概论",normalizedTitle:"1. shell概论",charIndex:2},{level:2,title:"2 Shell语法",slug:"_2-shell语法",normalizedTitle:"2 shell语法",charIndex:1006},{level:3,title:"2.1 注释",slug:"_2-1-注释",normalizedTitle:"2.1 注释",charIndex:1020},{level:3,title:"2.2 变量",slug:"_2-2-变量",normalizedTitle:"2.2 变量",charIndex:1447},{level:3,title:"2.3 数组",slug:"_2-3-数组",normalizedTitle:"2.3 数组",charIndex:4945},{level:3,title:"2.4 expr命令与基本运算符",slug:"_2-4-expr命令与基本运算符",normalizedTitle:"2.4 expr命令与基本运算符",charIndex:6294},{level:3,title:"2.5 read命令",slug:"_2-5-read命令",normalizedTitle:"2.5 read命令",charIndex:11340},{level:3,title:"2.6 echo命令",slug:"_2-6-echo命令",normalizedTitle:"2.6 echo命令",charIndex:11593},{level:3,title:"2.7 printf命令",slug:"_2-7-printf命令",normalizedTitle:"2.7 printf命令",charIndex:12489},{level:3,title:"2.8 test命令与判断符号[]",slug:"_2-8-test命令与判断符号",normalizedTitle:"2.8 test命令与判断符号[]",charIndex:13291},{level:3,title:"2.9 判断语句",slug:"_2-9-判断语句",normalizedTitle:"2.9 判断语句",charIndex:14178},{level:3,title:"2.10 循环语句",slug:"_2-10-循环语句",normalizedTitle:"2.10 循环语句",charIndex:14555},{level:3,title:"2.11 函数",slug:"_2-11-函数",normalizedTitle:"2.11 函数",charIndex:15457},{level:3,title:"2.12 exit命令",slug:"_2-12-exit命令",normalizedTitle:"2.12 exit命令",charIndex:16008},{level:3,title:"2.13 文件重定向",slug:"_2-13-文件重定向",normalizedTitle:"2.13 文件重定向",charIndex:16135},{level:3,title:"2.14 引入外部脚本",slug:"_2-14-引入外部脚本",normalizedTitle:"2.14 引入外部脚本",charIndex:17010},{level:2,title:"3 参考文献",slug:"_3-参考文献",normalizedTitle:"3 参考文献",charIndex:17126}],headersStr:"1. Shell概论 2 Shell语法 2.1 注释 2.2 变量 2.3 数组 2.4 expr命令与基本运算符 2.5 read命令 2.6 echo命令 2.7 printf命令 2.8 test命令与判断符号[] 2.9 判断语句 2.10 循环语句 2.11 函数 2.12 exit命令 2.13 文件重定向 2.14 引入外部脚本 3 参考文献",content:'# 1. Shell概论\n\nShell是一个用C语言编写的程序，它诞生于Unix，是我们通过命令行与Unix/Linux交互的工具。笼统地说：Shell既是一种命令语言，又是一种程序设计语言。\n\n而Shell脚本是一种为Shell编写的脚本程序，有的时候也被称为Shell（但二者是两个完全不同的概念！），它可以直接在命令行中执行，也可以将一套逻辑组织成一个文件，方便复用。 Acwing网站提供给的AC Terminal中的命令行就可以看成是一个“Shell脚本在逐行执行”。\n\nUnix/Linux系统中常见的shell脚本有很多：\n\n * Bourne Shell（/usr/bin/sh或/bin/sh）\n * Bourne Again Shell（/bin/bash）\n * C Shell（/usr/bin/csh）\n * K Shell（/usr/bin/ksh）\n * Shell for Root（/sbin/sh）\n\n由于Linux系统中一般默认使用bash，而且其易用免费，所以我们接下来学习bash中的语法。\n\n脚本示例\n\n进入终端，新建一个hello.sh文件，内容如下：\n\n#! /bin/bash\necho "Hello, World!"\n\n\n1\n2\n\n1\n2\n\n\n说明：\n\n * sh后缀则表示该文件是Shell脚本文件。\n\n * #!告诉系统这个脚本用什么解释器来执行，后面所跟的就是你所需要用的解释器。这个一般都需要添加上，具体解释见运行。\n\n * echo指令用于字符串的输出，所以运行该文件会输出Hello,World。\n\n运行方式：\n\n * 作为可执行文件\n   \n   该方法将hello.sh作为可执行程序运行，由于未指定解释器，所以使用该方法第一行一定要指定解释器。\n\n#! /bin/bash\nchmod +x hello.sh #使脚本具有可执行权限；\n./hello.sh #当前路径下执行\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n * 用解释器执行\n   \n   该方法直接运行解释器，此时hello.sh作为Shell解释器的参数。此时Shell脚本就不需要指定解释器信息，则不需要第一行的注释了。\n   \n   bash hello.sh #当然也可以用缩写 sh hello.sh\n   \n   \n   1\n   \n   1\n   \n\n输出：\n\n\n\n\n# 2 Shell语法\n\n\n# 2.1 注释\n\n * 单行注释\n   \n   每一行中#之后的内容均是注释。\n   \n   # 这是一行注释\n   \n   echo "Hello, World" # 这也是一行注释\n   \n   \n   1\n   2\n   3\n   \n   1\n   2\n   3\n   \n\n * 多行注释\n   \n   Shell中的多行注释有点特别，格式为：\n   \n   :<<EOF\n   第一行注释\n   ...\n   第n行注释\n   EOF\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   其中EOF可以替换成其他任意字符串，如：\n   \n   :<<!\n   第一行注释\n   ...\n   第n行注释\n   !\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n# 2.2 变量\n\n * 定义变量\n   \n   定义变量时，变量名不加美元符号$，同时特别需要注意的一点就是变量名与等号之间不能有空格（如果有自动打空格的习惯在这里最好克制）。shell中的变量命名同样须遵循如下规则：\n   \n   * 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。\n   * 中间不能有空格，可以使用下划线 _。\n   * 不能使用标点符号。\n   * 不能使用bash里的关键字（可用help命令查看保留关键字）。\n   \n   如下：\n   \n   # 有效的Shell变量名称\n   _var\n   var123\n   LF_DDFHI_X\n   \n   # 无效的Shell变量名称\n   ?var\n   123abc\n   echo\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   和现在大多数的语言一样，Shell定义变量不需要指定变量类型，如下：\n   \n   name1="a" #单引号定义字符串\n   name2=\'a\' #双引号定义字符串\n   name3=a   #也可以不加引号，同样表示字符串\n   \n   \n   1\n   2\n   3\n   \n   1\n   2\n   3\n   \n   \n   在Bash shell中，每一个变量的值都是字符串，无论你给变量赋值用的时单引号双引号还是没有使用引号，都是使用字符串的i形式存储的，这很特殊。\n\n * 使用变量\n   \n   使用变量我们需要加上$符号或者${}符号。花括号时可选的，主要是为了帮助解释器识别变量边界。\n   \n   一定要注意：只有使用变量的时候才加美元符号$\n   \n   name=hzf\n   echo $name\n   echo ${name}\n   echo ${name}123\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n\n\n\n * 只读变量\n   \n   我们可以使用readOnly或者declare将变量设置为只读。\n   \n   name=hzf\n   readOnly name\n   #declare -r name #两种写法均可。\n   name=ylf #此时会报错，因为已经设置成了只读变量。\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n\n\n\n\n\n * 删除变量\n   \n   unset可以删除变量。\n   \n   name=hzf\n   unset name\n   echo $name\n   \n   \n   1\n   2\n   3\n   \n   1\n   2\n   3\n   \n   \n   此时没有输出hzf，代表已经删除了，这里没有报错是因为Shell将没有定义的变量设置为空字符串。\n\n * 变量类型\n   \n   根据访问权限划分可以分为：\n   \n   * 自定义变量（局部变量）\n     \n     在脚本或命令中定义，仅在当前Shell示例中有效，其他Shell启动的程序不能访问局部变量。即为子进程不能访问的变量。\n   \n   * 环境变量（全局变量）\n     \n     所有程序，包括shell启动程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。即为子进程可以访问的变量。\n   \n   自定义变量转换为环境变量：\n   \n   name=hzf#定义自定义变量\n   export name\n   delcare -x name#两种方法均可\n   \n   \n   1\n   2\n   3\n   \n   1\n   2\n   3\n   \n   \n   环境变量转化为自定义变量\n   \n   export name=hzf#定义环境变量。\n   delcare +x name#改为自定义变量。\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n * Shell字符串\n   \n   字符串可以用单引号，也可以用双引号，也可以不用引号。但其中是有区别的：\n   \n   * 使用单引号字符串，其中的变量名不会输出，但可以输出转义字符。单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。\n   \n   * 不用引号的字符串，其中变量可以输出，但是不能输出转移字符。\n   \n   * 使用双引号的字符串，既可以输出变量也可以输出转义字符。\n   \n   示例：\n   \n   name=hzf\n   echo 123$name\\n\n   echo "123$name\\n"\n   echo \'123$name\\n\'\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n   \n   输出：\n\n\n\n字符串操作\n\n * 拼接字符串\n   \n   name=xyz\n   #双引号字符串拼接\n   s1="Hello, $ {name} !”\n   s2="Hello, "$ {name}"!"\n   echo $s1 $s2\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n\n * 获取字符串长度\n   \n   name=hzf\n   echo ${#name}\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n\n\n * 提取字符串\n   \n   注意，第一个字符的索引为000，给出的两个参数第一个为起始位置，第二个为截取长度。\n   \n   name="Hello, World!"                                                                                                        \n   echo ${name}\n   echo ${name:0:4}\n   echo ${name:0}\n   echo ${name:1}\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n\n * 文件参数变量\n   \n   在执行Shell脚本时，可以向脚本传递参数。$1是第一个参数，$2是第二个参数，以此类推。特殊的，$0是文件名（包含路径）。例如：\n   \n   echo "文件名:$0"                                                                                                                                              \n   echo "第一个参数:$1"\n   echo "第二个参数:$2"\n   echo "$*"\n   echo "$@"\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   然后我们执行的时候在后面添加参数即可。如果没有给出，那么则为空字符。\n\n\n\n * 其他参数相关变量\n   \n   参数           说明\n   $#           代表文件传入的参数个数，如上例中值为2\n   $*           由所有参数构成的用空格隔开的字符串，如上例中值为"$1 $2"\n   $@           每个参数分别用双引号括起来的字符串，如上例中值为"$1" "$2"\n   $$           脚本当前运行的进程ID\n   $?           上一条命令的退出状态（注意不是stdout，而是exit code）。0表示正常退出，其他值表示错误\n   $(command)   返回command这条命令的stdout（可嵌套）\n   command      返回command这条命令的stdout（不可嵌套）\n\n\n# 2.3 数组\n\n数组中可以存放多个值。Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小（与 PHP 类似）。与大部分编程语言类似，数组元素的下标由 0 开始。\n\n * 定义\n   \n   Shell 数组用括号来表示，元素用"空格"符号分割开，语法格式如下：\n   \n   array_name=(value1 value2 ... valuen)\n   \n   \n   1\n   \n   1\n   \n   \n   如：\n   \n   name=(张三 "李四" \'王五\')\n   \n   \n   1\n   \n   1\n   \n   \n   也可以直接通过定义数组中元素的值来创建数组，如：\n   \n   name[0]="张三"\n   \n   \n   1\n   \n   1\n   \n   \n   这样就创建了name数组。\n\n * 访问数组元素\n   \n   * 访问单个元素\n     \n     语法格式为：${array_name[index]}\n     \n     如：\n     \n     name[0]="123"                                                                                                                                                 \n     name[3]="124"\n     echo "${name[0]}"\n     echo "${name[3]}"\n     \n     \n     1\n     2\n     3\n     4\n     \n     1\n     2\n     3\n     4\n     \n   \n   \n   \n   * 访问所有元素\n     \n     格式：\n     \n     ${array[@]}#第一种写法\n     ${array[*]}#第二种写法\n     \n     \n     1\n     2\n     \n     1\n     2\n     \n     \n     示例：\n     \n     array=(1 abc "def" yxc)\n     \n     echo ${array[@]}  # 第一种写法\n     echo ${array[*]}  # 第二种写法\n     \n     \n     1\n     2\n     3\n     4\n     \n     1\n     2\n     3\n     4\n     \n     \n     \n   \n   * 获取数组长度\n     \n     同字符串写法：\n     \n     array=(1 abc "def" yxc)\n     \n     echo ${#array[@]} #第一种写法\n     echo ${#array[*]} #第二种写法\n     \n     \n     1\n     2\n     3\n     4\n     \n     1\n     2\n     3\n     4\n     \n\n\n\n\n# 2.4 expr命令与基本运算符\n\nShell 和其他编程语言一样，支持多种运算符，包括：\n\n * 算数运算符\n * 关系运算符\n * 布尔运算符\n * 字符串运算符\n * 文件测试运算符\n\n但是原生Bash不支持简单的数学运算，我们需要通过其他命令来实现，如awk,expr，expr命令最常用，所以这里介绍expr。\n\nexpr是一款表达式计算工具，使用它能完成表达式的求值操作。格式为：\n\nexpr 表达式\n\n\n1\n\n1\n\n\n * 表达式说明\n   \n   * 用空格隔开每一项\n   * 用反斜杠放在shell特定的字符前面（发现表达式运行错误时，可以试试转义）\n   * 对包含空格和其他特殊字符的字符串要用引号括起来\n   * expr会在stdout中输出结果。如果为逻辑关系表达式，则结果为真，stdout为1，否则为0。\n   * expr的exit code：如果为逻辑关系表达式，则结果为真，exit code为0，否则为1。\n   * 完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号，而是反引号，代表执行该命令。通常在 Esc 键下边。\n\n * 算数表达式\n   \n   下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：\n   \n   运算符   说明                          举例\n   +     加法                          expr $a + $b 结果为 30。\n   -     减法                          expr $a - $b 结果为 -10。\n   *     乘法                          expr $a \\* $b 结果为 200。\n   /     除法                          expr $b / $a 结果为 2。\n   %     取余                          expr $b % $a 结果为 0。\n   =     赋值                          a=$b 将把变量 b 的值赋给 a。\n   ==    相等。用于比较两个数字，相同则返回 true。     [ $a == $b ] 返回 false。\n   !=    不相等。用于比较两个数字，不相同则返回 true。   [ $a != $b ] 返回 true。\n   \n   **注意：**条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。注意乘号等特殊符号需要转义。()可表优先级，但同样需要反斜杠转移。\n   \n   实例：\n   \n   a=10                                                                                                                                                                         \n   b=20\n   \n   echo "a + b = `expr $a + $b`"\n   echo "a - b = `expr $a - $b`"\n   echo "a * b = `expr $a \\* $b`"\n   echo "a / b = `expr $a / $b`"\n   echo "a % b = `expr $a % $b`"\n   echo "a == b = `expr [$a == $b]`"\n   echo "a != b = `expr [$a != $b]`"\n   a=$b\n   echo "$a"\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n\n\n * 关系运算符\n   \n   Shell支持正常的关系比较运算符，即<,<=,>,>=等。其会返回01代表结果。\n   \n   实例：\n   \n   a=10                                                                                                                                                                         \n   b=20\n   echo "a < b : `expr $a \\< $b`" #需要转义\n   echo "a > b : `expr $a \'>\' $b`" #也可以用引号括起来。\n   echo "a >= b : `expr $a \'>=\' $b`"\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   \n   \n   同时，Shell也给出了自己特定的比较命令，如下表：\n\n运算符   说明                              举例\n-eq   检测两个数是否相等，相等返回 true。            [ $a -eq $b ] 返回 false。\n-ne   检测两个数是否不相等，不相等返回 true。          [ $a -ne $b ]返回 true。\n-gt   检测左边的数是否大于右边的，如果是，则返回 true。     [ $a -gt $b ] 返回 false。\n-lt   检测左边的数是否小于右边的，如果是，则返回 true。     [ $a -lt $b ] 返回 true。\n-ge   检测左边的数是否大于等于右边的，如果是，则返回 true。   [ $a -ge $b ] 返回 false。\n-le   检测左边的数是否小于等于右边的，如果是，则返回 true。   [ $a -le $b ] 返回 true。\n\n实例（注：if...then是条件语句，之后会讲解）：\n\n#!/bin/bash\n\na=10\nb=20\n\nif [ $a -eq $b ]\nthen\n echo "$a -eq $b : a 等于 b"\nelse\n echo "$a -eq $b: a 不等于 b"\nfi\nif [ $a -ne $b ]\nthen\n echo "$a -ne $b: a 不等于 b"\nelse\n echo "$a -ne $b : a 等于 b"\nfi\nif [ $a -gt $b ]\nthen\n echo "$a -gt $b: a 大于 b"\nelse\n echo "$a -gt $b: a 不大于 b"\nfi\nif [ $a -lt $b ]\nthen\n echo "$a -lt $b: a 小于 b"\nelse\n echo "$a -lt $b: a 不小于 b"\nfi\nif [ $a -ge $b ]\nthen\n echo "$a -ge $b: a 大于或等于 b"\nelse\n echo "$a -ge $b: a 小于 b"\nfi\nif [ $a -le $b ]\nthen\n echo "$a -le $b: a 小于或等于 b"\nelse\n echo "$a -le $b: a 大于 b"\nfi\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n\n * 字符串表达式\n   \n   即结合expr命令实现对字符串的操作，常见有以下：\n   \n   * length str：返回str的长度。\n   * index str charSet:返回字符集charSet中任意一个字符在str中最前面字符的位置。下标从1开始，如果不存在，则返回0。\n   * substr str st len：截取字符串str，从st位置开始，长度最大为len的子串。如果截取不成功，则返回空字符串。\n   \n   实例：\n   \n   str="Hello,World!"\n   echo `expr length "$str"` #`不是单引号，而是反引号，代表执行该命令。\n   echo `expr index "$str" llo`\n   echo `expr substr "$str" 1 4`\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n   \n   \n\n * 文件测试运算符\n   \n   文件测试运算符用于检测 Unix 文件的各种属性。\n   \n   属性检测描述如下：\n   \n   操作符       说明                                         举例\n   -b file   检测文件是否是块设备文件，如果是，则返回 true。                 [ -b $file ] 返回 false。\n   -c file   检测文件是否是字符设备文件，如果是，则返回 true。                [ -c $file ] 返回 false。\n   -d file   检测文件是否是目录，如果是，则返回 true。                    [ -d $file ] 返回 false。\n   -f file   检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。   [ -f $file ] 返回 true。\n   -g file   检测文件是否设置了 SGID 位，如果是，则返回 true。             [ -g $file ] 返回 false。\n   -k file   检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。     [ -k $file ] 返回 false。\n   -p file   检测文件是否是有名管道，如果是，则返回 true。                  [ -p $file ] 返回 false。\n   -u file   检测文件是否设置了 SUID 位，如果是，则返回 true。             [ -u $file ] 返回 false。\n   -r file   检测文件是否可读，如果是，则返回 true。                     [ -r $file ] 返回 true。\n   -w file   检测文件是否可写，如果是，则返回 true。                     [ -w $file ] 返回 true。\n   -x file   检测文件是否可执行，如果是，则返回 true。                    [ -x $file ] 返回 true。\n   -s file   检测文件是否为空（文件大小是否大于0），不为空返回 true。            [ -s $file ] 返回 true。\n   -e file   检测文件（包括目录）是否存在，如果是，则返回 true。               [ -e $file ] 返回 true。\n\n\n# 2.5 read命令\n\nread命令可用于从标准输入中读取单行数据，当读到文件结束符时，exit code为1，否则为0。\n\n参数说明：\n\n * -p：后面可以接提示信息。\n * -t：后面跟秒数，定义输入字符的等待时间，超过等待时间后会自动忽略此命令\n\n实例：\n\nread name\necho $name\nread -p "please input your name:" -t 30 name #读入name的值，等待30s。\necho $name\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n\n\n# 2.6 echo命令\n\necho命令用于字符串的输出，在前面的过程中我们已经接触到了，其命令格式为：\n\necho string\n\n\n1\n\n1\n\n\n我们可以用echo实现更复杂的输出格式控制。\n\n * 显示普通字符串\n   \n   echo "Hello, World!"\n   \n   \n   1\n   \n   1\n   \n   \n   这种情况下，我们不加双引号也是可以的。\n\n * 显示转义字符\n   \n   echo "\\"Hello,World!\\""\n   \n   \n   1\n   \n   1\n   \n   \n   同样，这里的双引号也可以省略。\n\n * 显示变量\n   \n   name=hzf\n   echo "My name is $name"\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n * 显示换行等特殊字符\n   \n   注意，这些字符都需要通过-e命令开启转义才能起作用的，如：\\\\ \\a \\b \\c \\d \\e \\f \\n \\r \\t \\v 这些是要在有 -e 的时候才能起作用, 其他时候的转义是不用- e也能转义的。\n   \n   echo -e "Hello\\n" #-e开启转义。\n   echo "World!"\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n\n\n * 显示结果定向至文件\n   \n   echo "Hello, World!" > output.txt\n   \n   \n   1\n   \n   1\n   \n   \n   \n\n * 原样输出字符串\n   \n   前面有提及，如果想原样输出，不进行转义或者取变量，用单引号。\n   \n   name=hzf\n   echo \'$name\'\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n   \n   \n\n * 显示命令执行结果\n   \n   使用反引号。\n   \n   echo `date`\n   echo `ls`\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n\n\n\n# 2.7 printf命令\n\nShell的printf命令和C语言中的printf差不多，用于格式化输出。该命令不会像echo命令一样自动添加换行。其语法为：\n\nprintf format-string [args]\n\n\n1\n\n1\n\n\n其中format-string为格式控制字符串，[args]为参数列表。\n\n实例：\n\n#-表示左对齐，没有则表示右对齐，d为宽度。%s表示输出字符串，%d整型输出。\n#%-10s则表示输出宽度为10的左对齐字符串。而%-4.2f则表示输出4位整数，保留2位小数。\nprintf "%-10s %-8s %-4s\\n" 姓名 性别 体重kg  \nprintf "%-10s %-8s %-4.2f\\n" 郭靖 男 66.1234\nprintf "%-10s %-8s %-4.2f\\n" 杨过 男 48.6543\nprintf "%-10s %-8s %-4.2f\\n" 郭芙 女 47.9876\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n * 命令格式指示符\n   \n   符号      说明\n   %c      ASCII字符.显示相对应参数的第一个字符\n   %d,%i   十进制整数\n   %E      浮点格式([-d].precisionE [+-dd])\n   %e      浮点格式([-d].precisione [+-dd])\n   %g      %e或%f转换,看哪一个较短,则删除结尾的零\n   %G      %E或%f转换,看哪一个较短,则删除结尾的零\n   %s      字符串\n   %u      不带正负号的十进制值\n   %x      不带正负号的十六进制.使用a至f表示10至15\n   %%      字面意义的%\n   %X      不带正负号的十六进制.使用A至F表示10至15\n\n\n# 2.8 test命令与判断符号[]\n\n在命令行中输入man test，即可查看test命令的用法。 test命令可以用于判断文件类型，以及对变量做比较。test命令用exit code返回结果，而不是使用stdout。0表示真，非0表示假。这里可以通过echo $?来输出上一条命令的结果。\n\n * 文件判断 命令格式：test 测试参数 filename 其中常用测试参数如下表：\n\n测试参数   代表意义\n-e     文件是否存在\n-f     是否为文件\n-d     是否为目录\n-r     文件是否可读\n-w     文件是否可写\n-x     文件是否可执行\n-s     是否为非空文件\n测试     \n       \n\n * 整数之间的比较 命令格式：test $a 关系运算符 $b 其中关系运算符为上文所提及的，这里不作列举。\n * 字符串比较 相关操作如表所示：\n\n测试参数                代表意义\ntest -z str         判断str是否为空，如果为空，返回true，否则false\ntest -n str         判断str是否为非空，如果非空，返回true，否则false.其中-n可以省略\ntest str1 == str2   判断str1是否等于str2\ntest str1 != str2   判断str1是否不等于str2\n`                   \n\n * 多重条件判定 即判断多个条件是否符合要求，可以嵌套多层。具体操作图表所示：\n\n测试参数   代表意义\n-a     两条件是否同时成立\n-o     两条件是否至少一个成立\n!      取反。对返回结果取反\n       \n\n * 判断符号[] 和test命令用法几乎一模一样，只是将需要判断的内容放入括号中。 更常用于if语句中，且[[]]是[]的加强版，支持的特性也更多。 值得注意的是一些特性：[]内的每一项都必须用空格隔开；中括号内的变量，最好用双引号括起来；中括号内的常数，最好用单或双引号括起来。\n\n\n# 2.9 判断语句\n\n * if语句 和python的语法有点像，命令格式如下：\n\nif [ 条件 ]\nthen\n  内容\nelif [ 条件 ]\nthen \n  内容\nelse\n  内容\n fi\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n注意fi为结束标记，是一定需要加的，作为结尾闭合。 实例：\n\n * case...esac形式 命令格式如下：\n\ncase $变量名 in \n  value1)\n    内容\n    ;; # ;;，类似break\n  value2)\n    内容\n    ;;\n  *) #类似default\n    内容\n    ;;\nesac # 也是结尾闭合语句\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n测试\n\n\n# 2.10 循环语句\n\n * for...in...do...done语句 命令格式：\n\nfor var in val1 val2 val3 ... valN\ndo\n  内容\ndone # 结尾闭合\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n循环规则为：从左到右遍历，当变量值为列表时，则一次遍历完列表。 实例1：输出a 2 cc，每个元素一行：\n\nfor var in a 2 cc\ndo \n  echo $var\ndone            \n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n\n * for((...;...;...)) do...done语句 命令格式：\n\nfor ((expression; condition; expression))\ndo\n  内容\ndone\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n测试：输出1-10。\n\nfor ((i=0; i<=10; ++i))\ndo\n  echo $i\ndone \n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n * while...do...done语句 命令格式：\n\nwhile 条件\ndo \n  内容\ndone\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n实例：文件结束符为ctrl+d，输入文件结束符后read指令返回false。\n\nwhile reabashd name\ndo\n  echo $name\ndone\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n\n * unti...do..done语句 和while语句相同，while能实现的脚本until同样可以实现。但区别是until循环的退出状态为0，与while刚好相反，即while循环在条件为真时继续执行循环而until在条件为假时继续执行循环。\n * break语句\n * 跳出当前的一层循环，break不能跳出case语句。\n * continue语句 跳出当前循环。\n * 死循环的处理方式 如果Terminal可以打开该程序，则输入Ctrl+c即可。否则可以直接关闭进程：使用top命令找到该进程的PID；输入kill -9 PID即可关掉此进程。\n\n\n# 2.11 函数\n\n定义格式：\n\n[ function ] function_name [()]{\n  内容;\n  [return int;]\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n说明：\n\n 1. 可以带function func()定义，也可以直接fun()定义，不带任何参数。\n 2. 参数返回，可以显示加：return返回，如果不加，将以最后一条命令运行结果作为返回值。return后跟数值n(0-255，不能超过该范围)。 其中函数返回值通过$?获取。\n 3. 函数体声明局部变量可以用local关键字声明。\n\n实例：\n\nfunction add(){\n  echo "相加预算函数"\n  echo "请输入第一个数"\n  read a\n  echo "请输入第二个数"\n  read b\n  return $(($a + $b))\n}\nadd\necho "结果为$?"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n * 函数参数 在shell中，调用函数可以向其传递参数。在函数体内部，通过$n的形式来获取参数的值。例如，$1表示第一个参数，$2表示第二个参数。这个规则和上文说的文件参数相同。也是在执行的后面添加参数。\n\n\n# 2.12 exit命令\n\nexit命令用来退出当前的shell进程，并返回一个退出状态（0-255，只有0表示成功，其他都表示失败）；使用$?即可接收这个退出状态。 exit命令可以接收一个整数值作为参数，代表退出状态。如果不指定，默认值为0。\n\n\n# 2.13 文件重定向\n\n每个进程默认打开3个文件描述符：\n\n * stdin：标准输入，从命令行读取数据，文件描述符为0。\n * stdout：标准输出，向命令行输出数据，文件描述符为1。\n * stderr：标准错误输出，向命令行输出数据，文件描述符为2。 可以用文件重定向将这三个文件重定向到其他文件中去。重定向命令列表如下：\n\n命令                说明\ncommand > file    将输出重定向到 file。\ncommand < file    将输入重定向到 file。\ncommand >> file   将输出以追加的方式重定向到 file。\nn > file          将文件描述符为 n 的文件重定向到 file。\nn >> file         将文件描述符为 n 的文件以追加的方式重定向到 file。\nn >& m            将输出文件 m 和 n 合并。\nn <& m            将输入文件 m 和 n 合并。\n<< tag            将开始标记 tag 和结束标记 tag 之间的内容作为输入。\n\n * 输入输出重定向实例\n\necho -e "Hello \\c" > output.txt  # 将stdout重定向到output.txt中\necho "World" >> output.txt  # 将字符串追加到output.txt中\n\nread str < output.txt  # 从output.txt中读取字符串\n\necho $str  # 输出结果：Hello World\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n * 同时重定向stdin和stdout\n\n创建main.sh编写脚本：\n\nread a\nread b\n\necho $(expr "$a" + "$b")\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n创建input.txt，填写内容为：\n\n10\n20\n\n\n1\n2\n\n1\n2\n\n\n执行结果如下：\n\n\n# 2.14 引入外部脚本\n\n类似C/C++中的include操作，bash也可以引入其他文件中的代码。 语法格式为：\n\n. filename # 注意空格\n或者\nsource filename\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 3 参考文献\n\nLinux基础课 菜鸟教程',normalizedContent:'# 1. shell概论\n\nshell是一个用c语言编写的程序，它诞生于unix，是我们通过命令行与unix/linux交互的工具。笼统地说：shell既是一种命令语言，又是一种程序设计语言。\n\n而shell脚本是一种为shell编写的脚本程序，有的时候也被称为shell（但二者是两个完全不同的概念！），它可以直接在命令行中执行，也可以将一套逻辑组织成一个文件，方便复用。 acwing网站提供给的ac terminal中的命令行就可以看成是一个“shell脚本在逐行执行”。\n\nunix/linux系统中常见的shell脚本有很多：\n\n * bourne shell（/usr/bin/sh或/bin/sh）\n * bourne again shell（/bin/bash）\n * c shell（/usr/bin/csh）\n * k shell（/usr/bin/ksh）\n * shell for root（/sbin/sh）\n\n由于linux系统中一般默认使用bash，而且其易用免费，所以我们接下来学习bash中的语法。\n\n脚本示例\n\n进入终端，新建一个hello.sh文件，内容如下：\n\n#! /bin/bash\necho "hello, world!"\n\n\n1\n2\n\n1\n2\n\n\n说明：\n\n * sh后缀则表示该文件是shell脚本文件。\n\n * #!告诉系统这个脚本用什么解释器来执行，后面所跟的就是你所需要用的解释器。这个一般都需要添加上，具体解释见运行。\n\n * echo指令用于字符串的输出，所以运行该文件会输出hello,world。\n\n运行方式：\n\n * 作为可执行文件\n   \n   该方法将hello.sh作为可执行程序运行，由于未指定解释器，所以使用该方法第一行一定要指定解释器。\n\n#! /bin/bash\nchmod +x hello.sh #使脚本具有可执行权限；\n./hello.sh #当前路径下执行\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n * 用解释器执行\n   \n   该方法直接运行解释器，此时hello.sh作为shell解释器的参数。此时shell脚本就不需要指定解释器信息，则不需要第一行的注释了。\n   \n   bash hello.sh #当然也可以用缩写 sh hello.sh\n   \n   \n   1\n   \n   1\n   \n\n输出：\n\n\n\n\n# 2 shell语法\n\n\n# 2.1 注释\n\n * 单行注释\n   \n   每一行中#之后的内容均是注释。\n   \n   # 这是一行注释\n   \n   echo "hello, world" # 这也是一行注释\n   \n   \n   1\n   2\n   3\n   \n   1\n   2\n   3\n   \n\n * 多行注释\n   \n   shell中的多行注释有点特别，格式为：\n   \n   :<<eof\n   第一行注释\n   ...\n   第n行注释\n   eof\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   其中eof可以替换成其他任意字符串，如：\n   \n   :<<!\n   第一行注释\n   ...\n   第n行注释\n   !\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n# 2.2 变量\n\n * 定义变量\n   \n   定义变量时，变量名不加美元符号$，同时特别需要注意的一点就是变量名与等号之间不能有空格（如果有自动打空格的习惯在这里最好克制）。shell中的变量命名同样须遵循如下规则：\n   \n   * 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。\n   * 中间不能有空格，可以使用下划线 _。\n   * 不能使用标点符号。\n   * 不能使用bash里的关键字（可用help命令查看保留关键字）。\n   \n   如下：\n   \n   # 有效的shell变量名称\n   _var\n   var123\n   lf_ddfhi_x\n   \n   # 无效的shell变量名称\n   ?var\n   123abc\n   echo\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   和现在大多数的语言一样，shell定义变量不需要指定变量类型，如下：\n   \n   name1="a" #单引号定义字符串\n   name2=\'a\' #双引号定义字符串\n   name3=a   #也可以不加引号，同样表示字符串\n   \n   \n   1\n   2\n   3\n   \n   1\n   2\n   3\n   \n   \n   在bash shell中，每一个变量的值都是字符串，无论你给变量赋值用的时单引号双引号还是没有使用引号，都是使用字符串的i形式存储的，这很特殊。\n\n * 使用变量\n   \n   使用变量我们需要加上$符号或者${}符号。花括号时可选的，主要是为了帮助解释器识别变量边界。\n   \n   一定要注意：只有使用变量的时候才加美元符号$\n   \n   name=hzf\n   echo $name\n   echo ${name}\n   echo ${name}123\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n\n\n\n * 只读变量\n   \n   我们可以使用readonly或者declare将变量设置为只读。\n   \n   name=hzf\n   readonly name\n   #declare -r name #两种写法均可。\n   name=ylf #此时会报错，因为已经设置成了只读变量。\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n\n\n\n\n\n * 删除变量\n   \n   unset可以删除变量。\n   \n   name=hzf\n   unset name\n   echo $name\n   \n   \n   1\n   2\n   3\n   \n   1\n   2\n   3\n   \n   \n   此时没有输出hzf，代表已经删除了，这里没有报错是因为shell将没有定义的变量设置为空字符串。\n\n * 变量类型\n   \n   根据访问权限划分可以分为：\n   \n   * 自定义变量（局部变量）\n     \n     在脚本或命令中定义，仅在当前shell示例中有效，其他shell启动的程序不能访问局部变量。即为子进程不能访问的变量。\n   \n   * 环境变量（全局变量）\n     \n     所有程序，包括shell启动程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。即为子进程可以访问的变量。\n   \n   自定义变量转换为环境变量：\n   \n   name=hzf#定义自定义变量\n   export name\n   delcare -x name#两种方法均可\n   \n   \n   1\n   2\n   3\n   \n   1\n   2\n   3\n   \n   \n   环境变量转化为自定义变量\n   \n   export name=hzf#定义环境变量。\n   delcare +x name#改为自定义变量。\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n * shell字符串\n   \n   字符串可以用单引号，也可以用双引号，也可以不用引号。但其中是有区别的：\n   \n   * 使用单引号字符串，其中的变量名不会输出，但可以输出转义字符。单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。\n   \n   * 不用引号的字符串，其中变量可以输出，但是不能输出转移字符。\n   \n   * 使用双引号的字符串，既可以输出变量也可以输出转义字符。\n   \n   示例：\n   \n   name=hzf\n   echo 123$name\\n\n   echo "123$name\\n"\n   echo \'123$name\\n\'\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n   \n   输出：\n\n\n\n字符串操作\n\n * 拼接字符串\n   \n   name=xyz\n   #双引号字符串拼接\n   s1="hello, $ {name} !”\n   s2="hello, "$ {name}"!"\n   echo $s1 $s2\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n\n * 获取字符串长度\n   \n   name=hzf\n   echo ${#name}\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n\n\n * 提取字符串\n   \n   注意，第一个字符的索引为000，给出的两个参数第一个为起始位置，第二个为截取长度。\n   \n   name="hello, world!"                                                                                                        \n   echo ${name}\n   echo ${name:0:4}\n   echo ${name:0}\n   echo ${name:1}\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n\n * 文件参数变量\n   \n   在执行shell脚本时，可以向脚本传递参数。$1是第一个参数，$2是第二个参数，以此类推。特殊的，$0是文件名（包含路径）。例如：\n   \n   echo "文件名:$0"                                                                                                                                              \n   echo "第一个参数:$1"\n   echo "第二个参数:$2"\n   echo "$*"\n   echo "$@"\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   然后我们执行的时候在后面添加参数即可。如果没有给出，那么则为空字符。\n\n\n\n * 其他参数相关变量\n   \n   参数           说明\n   $#           代表文件传入的参数个数，如上例中值为2\n   $*           由所有参数构成的用空格隔开的字符串，如上例中值为"$1 $2"\n   $@           每个参数分别用双引号括起来的字符串，如上例中值为"$1" "$2"\n   $$           脚本当前运行的进程id\n   $?           上一条命令的退出状态（注意不是stdout，而是exit code）。0表示正常退出，其他值表示错误\n   $(command)   返回command这条命令的stdout（可嵌套）\n   command      返回command这条命令的stdout（不可嵌套）\n\n\n# 2.3 数组\n\n数组中可以存放多个值。bash shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小（与 php 类似）。与大部分编程语言类似，数组元素的下标由 0 开始。\n\n * 定义\n   \n   shell 数组用括号来表示，元素用"空格"符号分割开，语法格式如下：\n   \n   array_name=(value1 value2 ... valuen)\n   \n   \n   1\n   \n   1\n   \n   \n   如：\n   \n   name=(张三 "李四" \'王五\')\n   \n   \n   1\n   \n   1\n   \n   \n   也可以直接通过定义数组中元素的值来创建数组，如：\n   \n   name[0]="张三"\n   \n   \n   1\n   \n   1\n   \n   \n   这样就创建了name数组。\n\n * 访问数组元素\n   \n   * 访问单个元素\n     \n     语法格式为：${array_name[index]}\n     \n     如：\n     \n     name[0]="123"                                                                                                                                                 \n     name[3]="124"\n     echo "${name[0]}"\n     echo "${name[3]}"\n     \n     \n     1\n     2\n     3\n     4\n     \n     1\n     2\n     3\n     4\n     \n   \n   \n   \n   * 访问所有元素\n     \n     格式：\n     \n     ${array[@]}#第一种写法\n     ${array[*]}#第二种写法\n     \n     \n     1\n     2\n     \n     1\n     2\n     \n     \n     示例：\n     \n     array=(1 abc "def" yxc)\n     \n     echo ${array[@]}  # 第一种写法\n     echo ${array[*]}  # 第二种写法\n     \n     \n     1\n     2\n     3\n     4\n     \n     1\n     2\n     3\n     4\n     \n     \n     \n   \n   * 获取数组长度\n     \n     同字符串写法：\n     \n     array=(1 abc "def" yxc)\n     \n     echo ${#array[@]} #第一种写法\n     echo ${#array[*]} #第二种写法\n     \n     \n     1\n     2\n     3\n     4\n     \n     1\n     2\n     3\n     4\n     \n\n\n\n\n# 2.4 expr命令与基本运算符\n\nshell 和其他编程语言一样，支持多种运算符，包括：\n\n * 算数运算符\n * 关系运算符\n * 布尔运算符\n * 字符串运算符\n * 文件测试运算符\n\n但是原生bash不支持简单的数学运算，我们需要通过其他命令来实现，如awk,expr，expr命令最常用，所以这里介绍expr。\n\nexpr是一款表达式计算工具，使用它能完成表达式的求值操作。格式为：\n\nexpr 表达式\n\n\n1\n\n1\n\n\n * 表达式说明\n   \n   * 用空格隔开每一项\n   * 用反斜杠放在shell特定的字符前面（发现表达式运行错误时，可以试试转义）\n   * 对包含空格和其他特殊字符的字符串要用引号括起来\n   * expr会在stdout中输出结果。如果为逻辑关系表达式，则结果为真，stdout为1，否则为0。\n   * expr的exit code：如果为逻辑关系表达式，则结果为真，exit code为0，否则为1。\n   * 完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号，而是反引号，代表执行该命令。通常在 esc 键下边。\n\n * 算数表达式\n   \n   下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：\n   \n   运算符   说明                          举例\n   +     加法                          expr $a + $b 结果为 30。\n   -     减法                          expr $a - $b 结果为 -10。\n   *     乘法                          expr $a \\* $b 结果为 200。\n   /     除法                          expr $b / $a 结果为 2。\n   %     取余                          expr $b % $a 结果为 0。\n   =     赋值                          a=$b 将把变量 b 的值赋给 a。\n   ==    相等。用于比较两个数字，相同则返回 true。     [ $a == $b ] 返回 false。\n   !=    不相等。用于比较两个数字，不相同则返回 true。   [ $a != $b ] 返回 true。\n   \n   **注意：**条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。注意乘号等特殊符号需要转义。()可表优先级，但同样需要反斜杠转移。\n   \n   实例：\n   \n   a=10                                                                                                                                                                         \n   b=20\n   \n   echo "a + b = `expr $a + $b`"\n   echo "a - b = `expr $a - $b`"\n   echo "a * b = `expr $a \\* $b`"\n   echo "a / b = `expr $a / $b`"\n   echo "a % b = `expr $a % $b`"\n   echo "a == b = `expr [$a == $b]`"\n   echo "a != b = `expr [$a != $b]`"\n   a=$b\n   echo "$a"\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n\n\n * 关系运算符\n   \n   shell支持正常的关系比较运算符，即<,<=,>,>=等。其会返回01代表结果。\n   \n   实例：\n   \n   a=10                                                                                                                                                                         \n   b=20\n   echo "a < b : `expr $a \\< $b`" #需要转义\n   echo "a > b : `expr $a \'>\' $b`" #也可以用引号括起来。\n   echo "a >= b : `expr $a \'>=\' $b`"\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n   1\n   2\n   3\n   4\n   5\n   \n   \n   \n   \n   同时，shell也给出了自己特定的比较命令，如下表：\n\n运算符   说明                              举例\n-eq   检测两个数是否相等，相等返回 true。            [ $a -eq $b ] 返回 false。\n-ne   检测两个数是否不相等，不相等返回 true。          [ $a -ne $b ]返回 true。\n-gt   检测左边的数是否大于右边的，如果是，则返回 true。     [ $a -gt $b ] 返回 false。\n-lt   检测左边的数是否小于右边的，如果是，则返回 true。     [ $a -lt $b ] 返回 true。\n-ge   检测左边的数是否大于等于右边的，如果是，则返回 true。   [ $a -ge $b ] 返回 false。\n-le   检测左边的数是否小于等于右边的，如果是，则返回 true。   [ $a -le $b ] 返回 true。\n\n实例（注：if...then是条件语句，之后会讲解）：\n\n#!/bin/bash\n\na=10\nb=20\n\nif [ $a -eq $b ]\nthen\n echo "$a -eq $b : a 等于 b"\nelse\n echo "$a -eq $b: a 不等于 b"\nfi\nif [ $a -ne $b ]\nthen\n echo "$a -ne $b: a 不等于 b"\nelse\n echo "$a -ne $b : a 等于 b"\nfi\nif [ $a -gt $b ]\nthen\n echo "$a -gt $b: a 大于 b"\nelse\n echo "$a -gt $b: a 不大于 b"\nfi\nif [ $a -lt $b ]\nthen\n echo "$a -lt $b: a 小于 b"\nelse\n echo "$a -lt $b: a 不小于 b"\nfi\nif [ $a -ge $b ]\nthen\n echo "$a -ge $b: a 大于或等于 b"\nelse\n echo "$a -ge $b: a 小于 b"\nfi\nif [ $a -le $b ]\nthen\n echo "$a -le $b: a 小于或等于 b"\nelse\n echo "$a -le $b: a 大于 b"\nfi\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n\n * 字符串表达式\n   \n   即结合expr命令实现对字符串的操作，常见有以下：\n   \n   * length str：返回str的长度。\n   * index str charset:返回字符集charset中任意一个字符在str中最前面字符的位置。下标从1开始，如果不存在，则返回0。\n   * substr str st len：截取字符串str，从st位置开始，长度最大为len的子串。如果截取不成功，则返回空字符串。\n   \n   实例：\n   \n   str="hello,world!"\n   echo `expr length "$str"` #`不是单引号，而是反引号，代表执行该命令。\n   echo `expr index "$str" llo`\n   echo `expr substr "$str" 1 4`\n   \n   \n   1\n   2\n   3\n   4\n   \n   1\n   2\n   3\n   4\n   \n   \n   \n\n * 文件测试运算符\n   \n   文件测试运算符用于检测 unix 文件的各种属性。\n   \n   属性检测描述如下：\n   \n   操作符       说明                                         举例\n   -b file   检测文件是否是块设备文件，如果是，则返回 true。                 [ -b $file ] 返回 false。\n   -c file   检测文件是否是字符设备文件，如果是，则返回 true。                [ -c $file ] 返回 false。\n   -d file   检测文件是否是目录，如果是，则返回 true。                    [ -d $file ] 返回 false。\n   -f file   检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。   [ -f $file ] 返回 true。\n   -g file   检测文件是否设置了 sgid 位，如果是，则返回 true。             [ -g $file ] 返回 false。\n   -k file   检测文件是否设置了粘着位(sticky bit)，如果是，则返回 true。     [ -k $file ] 返回 false。\n   -p file   检测文件是否是有名管道，如果是，则返回 true。                  [ -p $file ] 返回 false。\n   -u file   检测文件是否设置了 suid 位，如果是，则返回 true。             [ -u $file ] 返回 false。\n   -r file   检测文件是否可读，如果是，则返回 true。                     [ -r $file ] 返回 true。\n   -w file   检测文件是否可写，如果是，则返回 true。                     [ -w $file ] 返回 true。\n   -x file   检测文件是否可执行，如果是，则返回 true。                    [ -x $file ] 返回 true。\n   -s file   检测文件是否为空（文件大小是否大于0），不为空返回 true。            [ -s $file ] 返回 true。\n   -e file   检测文件（包括目录）是否存在，如果是，则返回 true。               [ -e $file ] 返回 true。\n\n\n# 2.5 read命令\n\nread命令可用于从标准输入中读取单行数据，当读到文件结束符时，exit code为1，否则为0。\n\n参数说明：\n\n * -p：后面可以接提示信息。\n * -t：后面跟秒数，定义输入字符的等待时间，超过等待时间后会自动忽略此命令\n\n实例：\n\nread name\necho $name\nread -p "please input your name:" -t 30 name #读入name的值，等待30s。\necho $name\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n\n\n# 2.6 echo命令\n\necho命令用于字符串的输出，在前面的过程中我们已经接触到了，其命令格式为：\n\necho string\n\n\n1\n\n1\n\n\n我们可以用echo实现更复杂的输出格式控制。\n\n * 显示普通字符串\n   \n   echo "hello, world!"\n   \n   \n   1\n   \n   1\n   \n   \n   这种情况下，我们不加双引号也是可以的。\n\n * 显示转义字符\n   \n   echo "\\"hello,world!\\""\n   \n   \n   1\n   \n   1\n   \n   \n   同样，这里的双引号也可以省略。\n\n * 显示变量\n   \n   name=hzf\n   echo "my name is $name"\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n * 显示换行等特殊字符\n   \n   注意，这些字符都需要通过-e命令开启转义才能起作用的，如：\\\\ \\a \\b \\c \\d \\e \\f \\n \\r \\t \\v 这些是要在有 -e 的时候才能起作用, 其他时候的转义是不用- e也能转义的。\n   \n   echo -e "hello\\n" #-e开启转义。\n   echo "world!"\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n\n\n * 显示结果定向至文件\n   \n   echo "hello, world!" > output.txt\n   \n   \n   1\n   \n   1\n   \n   \n   \n\n * 原样输出字符串\n   \n   前面有提及，如果想原样输出，不进行转义或者取变量，用单引号。\n   \n   name=hzf\n   echo \'$name\'\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n   \n   \n\n * 显示命令执行结果\n   \n   使用反引号。\n   \n   echo `date`\n   echo `ls`\n   \n   \n   1\n   2\n   \n   1\n   2\n   \n\n\n\n\n# 2.7 printf命令\n\nshell的printf命令和c语言中的printf差不多，用于格式化输出。该命令不会像echo命令一样自动添加换行。其语法为：\n\nprintf format-string [args]\n\n\n1\n\n1\n\n\n其中format-string为格式控制字符串，[args]为参数列表。\n\n实例：\n\n#-表示左对齐，没有则表示右对齐，d为宽度。%s表示输出字符串，%d整型输出。\n#%-10s则表示输出宽度为10的左对齐字符串。而%-4.2f则表示输出4位整数，保留2位小数。\nprintf "%-10s %-8s %-4s\\n" 姓名 性别 体重kg  \nprintf "%-10s %-8s %-4.2f\\n" 郭靖 男 66.1234\nprintf "%-10s %-8s %-4.2f\\n" 杨过 男 48.6543\nprintf "%-10s %-8s %-4.2f\\n" 郭芙 女 47.9876\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n * 命令格式指示符\n   \n   符号      说明\n   %c      ascii字符.显示相对应参数的第一个字符\n   %d,%i   十进制整数\n   %e      浮点格式([-d].precisione [+-dd])\n   %e      浮点格式([-d].precisione [+-dd])\n   %g      %e或%f转换,看哪一个较短,则删除结尾的零\n   %g      %e或%f转换,看哪一个较短,则删除结尾的零\n   %s      字符串\n   %u      不带正负号的十进制值\n   %x      不带正负号的十六进制.使用a至f表示10至15\n   %%      字面意义的%\n   %x      不带正负号的十六进制.使用a至f表示10至15\n\n\n# 2.8 test命令与判断符号[]\n\n在命令行中输入man test，即可查看test命令的用法。 test命令可以用于判断文件类型，以及对变量做比较。test命令用exit code返回结果，而不是使用stdout。0表示真，非0表示假。这里可以通过echo $?来输出上一条命令的结果。\n\n * 文件判断 命令格式：test 测试参数 filename 其中常用测试参数如下表：\n\n测试参数   代表意义\n-e     文件是否存在\n-f     是否为文件\n-d     是否为目录\n-r     文件是否可读\n-w     文件是否可写\n-x     文件是否可执行\n-s     是否为非空文件\n测试     \n       \n\n * 整数之间的比较 命令格式：test $a 关系运算符 $b 其中关系运算符为上文所提及的，这里不作列举。\n * 字符串比较 相关操作如表所示：\n\n测试参数                代表意义\ntest -z str         判断str是否为空，如果为空，返回true，否则false\ntest -n str         判断str是否为非空，如果非空，返回true，否则false.其中-n可以省略\ntest str1 == str2   判断str1是否等于str2\ntest str1 != str2   判断str1是否不等于str2\n`                   \n\n * 多重条件判定 即判断多个条件是否符合要求，可以嵌套多层。具体操作图表所示：\n\n测试参数   代表意义\n-a     两条件是否同时成立\n-o     两条件是否至少一个成立\n!      取反。对返回结果取反\n       \n\n * 判断符号[] 和test命令用法几乎一模一样，只是将需要判断的内容放入括号中。 更常用于if语句中，且[[]]是[]的加强版，支持的特性也更多。 值得注意的是一些特性：[]内的每一项都必须用空格隔开；中括号内的变量，最好用双引号括起来；中括号内的常数，最好用单或双引号括起来。\n\n\n# 2.9 判断语句\n\n * if语句 和python的语法有点像，命令格式如下：\n\nif [ 条件 ]\nthen\n  内容\nelif [ 条件 ]\nthen \n  内容\nelse\n  内容\n fi\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n注意fi为结束标记，是一定需要加的，作为结尾闭合。 实例：\n\n * case...esac形式 命令格式如下：\n\ncase $变量名 in \n  value1)\n    内容\n    ;; # ;;，类似break\n  value2)\n    内容\n    ;;\n  *) #类似default\n    内容\n    ;;\nesac # 也是结尾闭合语句\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n测试\n\n\n# 2.10 循环语句\n\n * for...in...do...done语句 命令格式：\n\nfor var in val1 val2 val3 ... valn\ndo\n  内容\ndone # 结尾闭合\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n循环规则为：从左到右遍历，当变量值为列表时，则一次遍历完列表。 实例1：输出a 2 cc，每个元素一行：\n\nfor var in a 2 cc\ndo \n  echo $var\ndone            \n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n\n * for((...;...;...)) do...done语句 命令格式：\n\nfor ((expression; condition; expression))\ndo\n  内容\ndone\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n测试：输出1-10。\n\nfor ((i=0; i<=10; ++i))\ndo\n  echo $i\ndone \n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n * while...do...done语句 命令格式：\n\nwhile 条件\ndo \n  内容\ndone\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n实例：文件结束符为ctrl+d，输入文件结束符后read指令返回false。\n\nwhile reabashd name\ndo\n  echo $name\ndone\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n\n\n * unti...do..done语句 和while语句相同，while能实现的脚本until同样可以实现。但区别是until循环的退出状态为0，与while刚好相反，即while循环在条件为真时继续执行循环而until在条件为假时继续执行循环。\n * break语句\n * 跳出当前的一层循环，break不能跳出case语句。\n * continue语句 跳出当前循环。\n * 死循环的处理方式 如果terminal可以打开该程序，则输入ctrl+c即可。否则可以直接关闭进程：使用top命令找到该进程的pid；输入kill -9 pid即可关掉此进程。\n\n\n# 2.11 函数\n\n定义格式：\n\n[ function ] function_name [()]{\n  内容;\n  [return int;]\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n说明：\n\n 1. 可以带function func()定义，也可以直接fun()定义，不带任何参数。\n 2. 参数返回，可以显示加：return返回，如果不加，将以最后一条命令运行结果作为返回值。return后跟数值n(0-255，不能超过该范围)。 其中函数返回值通过$?获取。\n 3. 函数体声明局部变量可以用local关键字声明。\n\n实例：\n\nfunction add(){\n  echo "相加预算函数"\n  echo "请输入第一个数"\n  read a\n  echo "请输入第二个数"\n  read b\n  return $(($a + $b))\n}\nadd\necho "结果为$?"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n * 函数参数 在shell中，调用函数可以向其传递参数。在函数体内部，通过$n的形式来获取参数的值。例如，$1表示第一个参数，$2表示第二个参数。这个规则和上文说的文件参数相同。也是在执行的后面添加参数。\n\n\n# 2.12 exit命令\n\nexit命令用来退出当前的shell进程，并返回一个退出状态（0-255，只有0表示成功，其他都表示失败）；使用$?即可接收这个退出状态。 exit命令可以接收一个整数值作为参数，代表退出状态。如果不指定，默认值为0。\n\n\n# 2.13 文件重定向\n\n每个进程默认打开3个文件描述符：\n\n * stdin：标准输入，从命令行读取数据，文件描述符为0。\n * stdout：标准输出，向命令行输出数据，文件描述符为1。\n * stderr：标准错误输出，向命令行输出数据，文件描述符为2。 可以用文件重定向将这三个文件重定向到其他文件中去。重定向命令列表如下：\n\n命令                说明\ncommand > file    将输出重定向到 file。\ncommand < file    将输入重定向到 file。\ncommand >> file   将输出以追加的方式重定向到 file。\nn > file          将文件描述符为 n 的文件重定向到 file。\nn >> file         将文件描述符为 n 的文件以追加的方式重定向到 file。\nn >& m            将输出文件 m 和 n 合并。\nn <& m            将输入文件 m 和 n 合并。\n<< tag            将开始标记 tag 和结束标记 tag 之间的内容作为输入。\n\n * 输入输出重定向实例\n\necho -e "hello \\c" > output.txt  # 将stdout重定向到output.txt中\necho "world" >> output.txt  # 将字符串追加到output.txt中\n\nread str < output.txt  # 从output.txt中读取字符串\n\necho $str  # 输出结果：hello world\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n * 同时重定向stdin和stdout\n\n创建main.sh编写脚本：\n\nread a\nread b\n\necho $(expr "$a" + "$b")\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n创建input.txt，填写内容为：\n\n10\n20\n\n\n1\n2\n\n1\n2\n\n\n执行结果如下：\n\n\n# 2.14 引入外部脚本\n\n类似c/c++中的include操作，bash也可以引入其他文件中的代码。 语法格式为：\n\n. filename # 注意空格\n或者\nsource filename\n\n\n1\n2\n3\n\n1\n2\n3\n\n\n\n# 3 参考文献\n\nlinux基础课 菜鸟教程',charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"遵循最佳实践，各种语言实现数据结构和算法的模版",frontmatter:{title:"遵循最佳实践，各种语言实现数据结构和算法的模版",tags:["算法"],author:{name:"Pursuit"},link:"https://github.com/unique-pure",date:"2023-12-14T16:52:26.000Z",categories:["资源收藏","优秀项目"],permalink:"/pages/0070df/",readingShow:"top"},regularPath:"/05.%E8%B5%84%E6%BA%90%E6%94%B6%E8%97%8F/02.%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE/01.%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%A8%A1%E7%89%88.html",relativePath:"05.资源收藏/02.优秀项目/01.算法实现模版.md",key:"v-6cf98a73",path:"/pages/0070df/",headersStr:null,content:"The Algorithms提供 GitHub 最大的开源算法库。 The Algorithms 官方网站 The Algorithms Github仓库\n\n以下是部分语言实现数据和算法的仓库，以供学习。\n\n 1. Go\n 2. Java\n 3. C++\n 4. C\n 5. Python\n 6. JavaScript",normalizedContent:"the algorithms提供 github 最大的开源算法库。 the algorithms 官方网站 the algorithms github仓库\n\n以下是部分语言实现数据和算法的仓库，以供学习。\n\n 1. go\n 2. java\n 3. c++\n 4. c\n 5. python\n 6. javascript",charsets:{cjk:!0},lastUpdated:"2023/12/15, 11:35:04",lastUpdatedTimestamp:1702611304e3},{title:"遵循最佳实践，各种语言实现设计模式的模版",frontmatter:{title:"遵循最佳实践，各种语言实现设计模式的模版",tags:["设计模式"],author:{name:"Pursuit"},link:"https://github.com/unique-pure",date:"2023-12-14T17:21:13.000Z",permalink:"/pages/7634df/",categories:["资源收藏","优秀项目"],readingShow:"top"},regularPath:"/05.%E8%B5%84%E6%BA%90%E6%94%B6%E8%97%8F/02.%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%A8%A1%E7%89%88.html",relativePath:"05.资源收藏/02.优秀项目/02.设计模式实现模版.md",key:"v-47fabeb6",path:"/pages/7634df/",headersStr:null,content:"23种设计模式分类如下：\n\n模式类型    描述                                             包括的模式\n创建型模式   这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new         工厂模式（Factory Pattern）\n        运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。      抽象工厂模式（Abstract Factory Pattern）\n                                                       单例模式（Singleton Pattern）\n                                                       建造者模式（Builder Pattern）\n                                                       原型模式（Prototype Pattern）\n结构型模式   这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。   适配器模式（Adapter Pattern）\n                                                       桥接模式（Bridge Pattern）\n                                                       过滤器模式（Filter、Criteria Pattern）\n                                                       组合模式（Composite Pattern）\n                                                       装饰器模式（Decorator Pattern）\n                                                       外观模式（Facade Pattern）\n                                                       享元模式（Flyweight Pattern）\n                                                       代理模式（Proxy Pattern）\n行为型模式   这些设计模式特别关注对象之间的通信，即对象之间的行为。                    责任链模式（Chain of Responsibility Pattern）\n                                                       命令模式（Command Pattern）\n                                                       解释器模式（Interpreter Pattern）\n                                                       迭代器模式（Iterator Pattern）\n                                                       中介者模式（Mediator Pattern）\n                                                       备忘录模式（Memento Pattern）\n                                                       观察者模式（Observer Pattern）\n                                                       状态模式（State Pattern）\n                                                       空对象模式（Null Object Pattern）\n                                                       策略模式（Strategy Pattern）\n                                                       模板模式（Template Pattern）\n                                                       访问者模式（Visitor Pattern）\n\n设计模式的六大原则是软件设计中的基石，它们为构建灵活、易于维护和升级的软件系统提供了指导。以下是对这六大原则的简要说明：\n\n 1. 开闭原则（Open Close Principle）：\n    \n    * 意义：对扩展开放，对修改关闭。即在需要进行拓展时，不修改原有代码，实现热插拔的效果。\n    * 实现方式：使用接口和抽象类，通过抽象化来保持程序的扩展性，易于维护和升级。\n\n 2. 里氏代换原则（Liskov Substitution Principle）：\n    \n    * 意义：任何基类可以出现的地方，子类一定可以出现。基类能够被派生类替换，且不影响软件单位的功能，实现真正的复用。\n    * 补充关系：是对开闭原则的补充，通过继承关系实现对抽象化的具体步骤规范。\n\n 3. 依赖倒转原则（Dependence Inversion Principle）：\n    \n    * 基础：是开闭原则的基础。具体内容为针对接口编程，依赖于抽象而不依赖于具体。\n\n 4. 接口隔离原则（Interface Segregation Principle）：\n    \n    * 意义：使用多个隔离的接口比使用单个接口更好，降低类之间的耦合度。\n    * 设计思想：从大型软件架构出发，强调降低依赖，降低耦合。\n\n 5. 迪米特法则，又称最少知道原则（Demeter Principle）：\n    \n    * 定义：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。\n\n 6. 合成复用原则（Composite Reuse Principle）：\n    \n    * 意义：尽量使用合成/聚合的方式，而不是使用继承。通过组合而非继承实现代码复用，增强系统的灵活性。\n\n这些原则提供了一种指导思想，帮助开发人员设计出具有弹性、可维护性和可扩展性的软件系统。通过遵循这些原则，可以有效应对软件变化，提高代码质量和可维护性。\n\n以下是部分语言实现设计模式的仓库，以供学习。\n\n 1. Go\n 2. Java\n 3. C++\n 4. Python\n 5. JavaScript",normalizedContent:"23种设计模式分类如下：\n\n模式类型    描述                                             包括的模式\n创建型模式   这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new         工厂模式（factory pattern）\n        运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。      抽象工厂模式（abstract factory pattern）\n                                                       单例模式（singleton pattern）\n                                                       建造者模式（builder pattern）\n                                                       原型模式（prototype pattern）\n结构型模式   这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。   适配器模式（adapter pattern）\n                                                       桥接模式（bridge pattern）\n                                                       过滤器模式（filter、criteria pattern）\n                                                       组合模式（composite pattern）\n                                                       装饰器模式（decorator pattern）\n                                                       外观模式（facade pattern）\n                                                       享元模式（flyweight pattern）\n                                                       代理模式（proxy pattern）\n行为型模式   这些设计模式特别关注对象之间的通信，即对象之间的行为。                    责任链模式（chain of responsibility pattern）\n                                                       命令模式（command pattern）\n                                                       解释器模式（interpreter pattern）\n                                                       迭代器模式（iterator pattern）\n                                                       中介者模式（mediator pattern）\n                                                       备忘录模式（memento pattern）\n                                                       观察者模式（observer pattern）\n                                                       状态模式（state pattern）\n                                                       空对象模式（null object pattern）\n                                                       策略模式（strategy pattern）\n                                                       模板模式（template pattern）\n                                                       访问者模式（visitor pattern）\n\n设计模式的六大原则是软件设计中的基石，它们为构建灵活、易于维护和升级的软件系统提供了指导。以下是对这六大原则的简要说明：\n\n 1. 开闭原则（open close principle）：\n    \n    * 意义：对扩展开放，对修改关闭。即在需要进行拓展时，不修改原有代码，实现热插拔的效果。\n    * 实现方式：使用接口和抽象类，通过抽象化来保持程序的扩展性，易于维护和升级。\n\n 2. 里氏代换原则（liskov substitution principle）：\n    \n    * 意义：任何基类可以出现的地方，子类一定可以出现。基类能够被派生类替换，且不影响软件单位的功能，实现真正的复用。\n    * 补充关系：是对开闭原则的补充，通过继承关系实现对抽象化的具体步骤规范。\n\n 3. 依赖倒转原则（dependence inversion principle）：\n    \n    * 基础：是开闭原则的基础。具体内容为针对接口编程，依赖于抽象而不依赖于具体。\n\n 4. 接口隔离原则（interface segregation principle）：\n    \n    * 意义：使用多个隔离的接口比使用单个接口更好，降低类之间的耦合度。\n    * 设计思想：从大型软件架构出发，强调降低依赖，降低耦合。\n\n 5. 迪米特法则，又称最少知道原则（demeter principle）：\n    \n    * 定义：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。\n\n 6. 合成复用原则（composite reuse principle）：\n    \n    * 意义：尽量使用合成/聚合的方式，而不是使用继承。通过组合而非继承实现代码复用，增强系统的灵活性。\n\n这些原则提供了一种指导思想，帮助开发人员设计出具有弹性、可维护性和可扩展性的软件系统。通过遵循这些原则，可以有效应对软件变化，提高代码质量和可维护性。\n\n以下是部分语言实现设计模式的仓库，以供学习。\n\n 1. go\n 2. java\n 3. c++\n 4. python\n 5. javascript",charsets:{cjk:!0},lastUpdated:"2023/12/14, 19:43:19",lastUpdatedTimestamp:1702554199e3},{title:"个人简介",frontmatter:{title:"个人简介",permalink:"/about/",categories:["关于"],description:null,date:"2023-11-24T16:30:27.000Z",tags:[null],author:{name:"Pursuit",link:"https://github.com/unique-pure"},readingShow:"top"},regularPath:"/07.%E5%85%B3%E4%BA%8E/01.about.html",relativePath:"07.关于/01.about.md",key:"v-4a02579b",path:"/about/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:45:17",lastUpdatedTimestamp:1700822717e3},{title:"友链",frontmatter:{title:"友链",permalink:"/friend/",categories:["友链"],description:null,date:"2023-11-24T16:30:27.000Z",tags:[null],author:{name:"Pursuit",link:"https://github.com/unique-pure"},readingShow:"top"},regularPath:"/08.%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5/01.%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5.html",relativePath:"08.友情链接/01.友情链接.md",key:"v-30e085c9",path:"/friend/",headers:[{level:2,title:"我的友链",slug:"我的友链",normalizedTitle:"我的友链",charIndex:2},{level:2,title:"友链申请",slug:"友链申请",normalizedTitle:"友链申请",charIndex:195}],headersStr:"我的友链 友链申请",content:'# 我的友链\n\npursuit\n\n💻学习📝记录🔗分享\n\n- name: pursuit\n  desc: "💻学习📝记录🔗分享"\n  avatar: /img/avatar.jpeg # 头像\n  link: https://unique-pure.github.io/ # 链接\n  bgColor: "#f8f9fa"\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 友链申请\n\n * 申请要求：\n   * ✅ 网站能够正常访问\n   * ✅ 网站类型为个人博客\n   * ✅ 网站需要包含本站友链\n   * ✅ 网站需要开通一年以上，且原创文章不少于 50 篇\n   * ❌ 不接受商业性或包含侵入性广告的站点\n   * ❌ 不接受违反中华人民共和国法律法规的站点\n\n如果符合如上条件，可在本页面评论区留言您的友链信息，格式：(点击代码块右上角一键复制)\n\n- name: pursuit # 昵称\n  desc: 💻学习📝记录🔗分享 # 介绍\n  avatar: https://github.com/unique-pure/NewPicGoLibrary/blob/main/img/67893254.jpeg # 头像\n  link: https://unique-pure.github.io/ # 链接\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n申请前记得先添加本站哦~',normalizedContent:'# 我的友链\n\npursuit\n\n💻学习📝记录🔗分享\n\n- name: pursuit\n  desc: "💻学习📝记录🔗分享"\n  avatar: /img/avatar.jpeg # 头像\n  link: https://unique-pure.github.io/ # 链接\n  bgcolor: "#f8f9fa"\n\n\n1\n2\n3\n4\n5\n\n1\n2\n3\n4\n5\n\n\n\n# 友链申请\n\n * 申请要求：\n   * ✅ 网站能够正常访问\n   * ✅ 网站类型为个人博客\n   * ✅ 网站需要包含本站友链\n   * ✅ 网站需要开通一年以上，且原创文章不少于 50 篇\n   * ❌ 不接受商业性或包含侵入性广告的站点\n   * ❌ 不接受违反中华人民共和国法律法规的站点\n\n如果符合如上条件，可在本页面评论区留言您的友链信息，格式：(点击代码块右上角一键复制)\n\n- name: pursuit # 昵称\n  desc: 💻学习📝记录🔗分享 # 介绍\n  avatar: https://github.com/unique-pure/newpicgolibrary/blob/main/img/67893254.jpeg # 头像\n  link: https://unique-pure.github.io/ # 链接\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n申请前记得先添加本站哦~',charsets:{cjk:!0},lastUpdated:"2023/11/24, 18:39:24",lastUpdatedTimestamp:1700822364e3},{title:"Go 语言优秀资源整理，为项目落地加速🏃",frontmatter:{title:"Go 语言优秀资源整理，为项目落地加速🏃",author:{name:"Pursuit"},link:"https://github.com/unique-pure",date:"2023-12-15T11:26:53.000Z",permalink:"/pages/9fd05a/",categories:["资源收藏","优秀项目"],tags:[null],readingShow:"top"},regularPath:"/05.%E8%B5%84%E6%BA%90%E6%94%B6%E8%97%8F/02.%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE/03.Go%E4%BC%98%E7%A7%80%E8%B5%84%E6%BA%90.html",relativePath:"05.资源收藏/02.优秀项目/03.Go优秀资源.md",key:"v-3a888ae4",path:"/pages/9fd05a/",headers:[{level:2,title:"指导原则",slug:"指导原则",normalizedTitle:"指导原则",charIndex:411},{level:2,title:"Awesome",slug:"awesome",normalizedTitle:"awesome",charIndex:637},{level:2,title:"大牛/组织",slug:"大牛-组织",normalizedTitle:"大牛/组织",charIndex:1038},{level:3,title:"大牛",slug:"大牛",normalizedTitle:"大牛",charIndex:1038},{level:3,title:"组织",slug:"组织",normalizedTitle:"组织",charIndex:1041},{level:2,title:"文档",slug:"文档",normalizedTitle:"文档",charIndex:1497},{level:2,title:"指南",slug:"指南",normalizedTitle:"指南",charIndex:1591},{level:2,title:"文章",slug:"文章",normalizedTitle:"文章",charIndex:3115},{level:2,title:"付费教程",slug:"付费教程",normalizedTitle:"付费教程",charIndex:3476},{level:2,title:"成品项目",slug:"成品项目",normalizedTitle:"成品项目",charIndex:3546},{level:3,title:"静态网站生成器",slug:"静态网站生成器",normalizedTitle:"静态网站生成器",charIndex:4184},{level:2,title:"学习项目",slug:"学习项目",normalizedTitle:"学习项目",charIndex:4265},{level:2,title:"开源类库",slug:"开源类库",normalizedTitle:"开源类库",charIndex:4446},{level:3,title:"Web 框架",slug:"web-框架",normalizedTitle:"web 框架",charIndex:4455},{level:3,title:"业务框架",slug:"业务框架",normalizedTitle:"业务框架",charIndex:5037},{level:3,title:"项目骨架",slug:"项目骨架",normalizedTitle:"项目骨架",charIndex:5438},{level:3,title:"DDD 框架",slug:"ddd-框架",normalizedTitle:"ddd 框架",charIndex:5701},{level:3,title:"TCP 框架",slug:"tcp-框架",normalizedTitle:"tcp 框架",charIndex:5868},{level:3,title:"中间件",slug:"中间件",normalizedTitle:"中间件",charIndex:5901},{level:3,title:"并发",slug:"并发",normalizedTitle:"并发",charIndex:2597},{level:3,title:"命令行",slug:"命令行",normalizedTitle:"命令行",charIndex:1485},{level:4,title:"参数解析",slug:"参数解析",normalizedTitle:"参数解析",charIndex:6100},{level:4,title:"输出展示",slug:"输出展示",normalizedTitle:"输出展示",charIndex:6285},{level:4,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:6943},{level:3,title:"终端工具",slug:"终端工具",normalizedTitle:"终端工具",charIndex:7229},{level:3,title:"路由",slug:"路由",normalizedTitle:"路由",charIndex:7637},{level:3,title:"网络",slug:"网络",normalizedTitle:"网络",charIndex:7880},{level:4,title:"LDAP",slug:"ldap",normalizedTitle:"ldap",charIndex:9469},{level:4,title:"网络代理",slug:"网络代理",normalizedTitle:"网络代理",charIndex:9537},{level:3,title:"HTTP压测",slug:"http压测",normalizedTitle:"http压测",charIndex:10006},{level:3,title:"HTTP",slug:"http",normalizedTitle:"http",charIndex:3612},{level:3,title:"WebSocket",slug:"websocket",normalizedTitle:"websocket",charIndex:10424},{level:3,title:"即时通信",slug:"即时通信",normalizedTitle:"即时通信",charIndex:10629},{level:3,title:"网关",slug:"网关",normalizedTitle:"网关",charIndex:10948},{level:3,title:"序列化",slug:"序列化",normalizedTitle:"序列化",charIndex:11061},{level:3,title:"解压缩",slug:"解压缩",normalizedTitle:"解压缩",charIndex:11405},{level:3,title:"RPC",slug:"rpc",normalizedTitle:"rpc",charIndex:8417},{level:3,title:"邮件",slug:"邮件",normalizedTitle:"邮件",charIndex:3854},{level:3,title:"消息队列",slug:"消息队列",normalizedTitle:"消息队列",charIndex:12202},{level:3,title:"文件/存储",slug:"文件-存储",normalizedTitle:"文件/存储",charIndex:12297},{level:3,title:"模板引擎",slug:"模板引擎",normalizedTitle:"模板引擎",charIndex:13030},{level:3,title:"代码生成",slug:"代码生成",normalizedTitle:"代码生成",charIndex:11287},{level:3,title:"文本处理",slug:"文本处理",normalizedTitle:"文本处理",charIndex:13298},{level:4,title:"Markdown",slug:"markdown",normalizedTitle:"markdown",charIndex:3893},{level:4,title:"HTML/CSS",slug:"html-css",normalizedTitle:"html/css",charIndex:13566},{level:4,title:"其他",slug:"其他-2",normalizedTitle:"其他",charIndex:6943},{level:3,title:"文档",slug:"文档-2",normalizedTitle:"文档",charIndex:1497},{level:3,title:"数学计算",slug:"数学计算",normalizedTitle:"数学计算",charIndex:15251},{level:3,title:"日期时间",slug:"日期时间",normalizedTitle:"日期时间",charIndex:15387},{level:3,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:8601},{level:3,title:"爬虫",slug:"爬虫",normalizedTitle:"爬虫",charIndex:9662},{level:3,title:"数据库",slug:"数据库",normalizedTitle:"数据库",charIndex:1921},{level:4,title:"SQL解析",slug:"sql解析",normalizedTitle:"sql解析",charIndex:16169},{level:4,title:"分布式事务",slug:"分布式事务",normalizedTitle:"分布式事务",charIndex:16312},{level:4,title:"数据库相关",slug:"数据库相关",normalizedTitle:"数据库相关",charIndex:16386},{level:4,title:"数据库客户端",slug:"数据库客户端",normalizedTitle:"数据库客户端",charIndex:17733},{level:4,title:"数据库引擎",slug:"数据库引擎",normalizedTitle:"数据库引擎",charIndex:18165},{level:3,title:"缓存",slug:"缓存",normalizedTitle:"缓存",charIndex:19169},{level:3,title:"搜索推荐",slug:"搜索推荐",normalizedTitle:"搜索推荐",charIndex:19478},{level:3,title:"表单",slug:"表单",normalizedTitle:"表单",charIndex:19883},{level:3,title:"Auth",slug:"auth",normalizedTitle:"auth",charIndex:9491},{level:3,title:"加密/解密",slug:"加密-解密",normalizedTitle:"加密/解密",charIndex:20183},{level:3,title:"视频",slug:"视频",normalizedTitle:"视频",charIndex:3149},{level:3,title:"图形处理",slug:"图形处理",normalizedTitle:"图形处理",charIndex:20705},{level:4,title:"图片识别",slug:"图片识别",normalizedTitle:"图片识别",charIndex:21400},{level:3,title:"图表",slug:"图表",normalizedTitle:"图表",charIndex:6505},{level:3,title:"构建编译",slug:"构建编译",normalizedTitle:"构建编译",charIndex:21634},{level:4,title:"静态资源内嵌",slug:"静态资源内嵌",normalizedTitle:"静态资源内嵌",charIndex:22078},{level:3,title:"优雅升级",slug:"优雅升级",normalizedTitle:"优雅升级",charIndex:22260},{level:3,title:"代码分析",slug:"代码分析",normalizedTitle:"代码分析",charIndex:22373},{level:3,title:"调试",slug:"调试",normalizedTitle:"调试",charIndex:23187},{level:3,title:"测试",slug:"测试",normalizedTitle:"测试",charIndex:2349},{level:3,title:"错误处理",slug:"错误处理",normalizedTitle:"错误处理",charIndex:7850},{level:3,title:"安全",slug:"安全",normalizedTitle:"安全",charIndex:3039},{level:3,title:"系统信息",slug:"系统信息",normalizedTitle:"系统信息",charIndex:25630},{level:3,title:"UUID",slug:"uuid",normalizedTitle:"uuid",charIndex:25827},{level:3,title:"日志",slug:"日志",normalizedTitle:"日志",charIndex:25477},{level:3,title:"监控告警",slug:"监控告警",normalizedTitle:"监控告警",charIndex:26370},{level:3,title:"统计分析",slug:"统计分析",normalizedTitle:"统计分析",charIndex:22618},{level:3,title:"容器技术",slug:"容器技术",normalizedTitle:"容器技术",charIndex:3700},{level:3,title:"集群管理",slug:"集群管理",normalizedTitle:"集群管理",charIndex:27259},{level:4,title:"Kubernetes",slug:"kubernetes",normalizedTitle:"kubernetes",charIndex:3689},{level:3,title:"机器学习",slug:"机器学习",normalizedTitle:"机器学习",charIndex:27522},{level:3,title:"人工智能",slug:"人工智能",normalizedTitle:"人工智能",charIndex:27790},{level:3,title:"算法",slug:"算法",normalizedTitle:"算法",charIndex:918},{level:3,title:"数据结构",slug:"数据结构",normalizedTitle:"数据结构",charIndex:948},{level:3,title:"依赖注入",slug:"依赖注入",normalizedTitle:"依赖注入",charIndex:28944},{level:3,title:"JSON",slug:"json",normalizedTitle:"json",charIndex:4951},{level:3,title:"依赖管理",slug:"依赖管理",normalizedTitle:"依赖管理",charIndex:29529},{level:3,title:"微服务",slug:"微服务",normalizedTitle:"微服务",charIndex:5826},{level:3,title:"Serverless",slug:"serverless",normalizedTitle:"serverless",charIndex:30168},{level:3,title:"devops",slug:"devops",normalizedTitle:"devops",charIndex:30570},{level:3,title:"持续集成/部署",slug:"持续集成-部署",normalizedTitle:"持续集成/部署",charIndex:30611},{level:3,title:"Git",slug:"git",normalizedTitle:"git",charIndex:99},{level:3,title:"限流器",slug:"限流器",normalizedTitle:"限流器",charIndex:31439},{level:3,title:"编译器",slug:"编译器",normalizedTitle:"编译器",charIndex:31681},{level:3,title:"解释器",slug:"解释器",normalizedTitle:"解释器",charIndex:19967},{level:4,title:"语言解释器",slug:"语言解释器",normalizedTitle:"语言解释器",charIndex:31868},{level:4,title:"PHP",slug:"php",normalizedTitle:"php",charIndex:7936},{level:4,title:"自定义解释器",slug:"自定义解释器",normalizedTitle:"自定义解释器",charIndex:32822},{level:3,title:"代码生成",slug:"代码生成-2",normalizedTitle:"代码生成",charIndex:11287},{level:3,title:"编辑器",slug:"编辑器",normalizedTitle:"编辑器",charIndex:33622},{level:3,title:"运行器",slug:"运行器",normalizedTitle:"运行器",charIndex:33676},{level:3,title:"查询语言",slug:"查询语言",normalizedTitle:"查询语言",charIndex:33775},{level:3,title:"游戏相关",slug:"游戏相关",normalizedTitle:"游戏相关",charIndex:33988},{level:3,title:"桌面开发",slug:"桌面开发",normalizedTitle:"桌面开发",charIndex:34101},{level:4,title:"GUI",slug:"gui",normalizedTitle:"gui",charIndex:34109},{level:4,title:"桌面辅助包",slug:"桌面辅助包",normalizedTitle:"桌面辅助包",charIndex:34953},{level:4,title:"桌面应用",slug:"桌面应用",normalizedTitle:"桌面应用",charIndex:34575},{level:3,title:"移动端",slug:"移动端",normalizedTitle:"移动端",charIndex:35121},{level:3,title:"协程/线程",slug:"协程-线程",normalizedTitle:"协程/线程",charIndex:35179},{level:3,title:"任务/定时器",slug:"任务-定时器",normalizedTitle:"任务/定时器",charIndex:35400},{level:3,title:"流处理",slug:"流处理",normalizedTitle:"流处理",charIndex:30560},{level:3,title:"微信",slug:"微信",normalizedTitle:"微信",charIndex:4040},{level:3,title:"SDK",slug:"sdk",normalizedTitle:"sdk",charIndex:5403},{level:3,title:"区块链",slug:"区块链",normalizedTitle:"区块链",charIndex:36087},{level:3,title:"开发辅助包",slug:"开发辅助包",normalizedTitle:"开发辅助包",charIndex:36208},{level:3,title:"代码生成",slug:"代码生成-3",normalizedTitle:"代码生成",charIndex:11287},{level:3,title:"系统开发",slug:"系统开发",normalizedTitle:"系统开发",charIndex:37306},{level:3,title:"未归类",slug:"未归类",normalizedTitle:"未归类",charIndex:37527},{level:2,title:"logo",slug:"logo",normalizedTitle:"logo",charIndex:30355},{level:2,title:"工具",slug:"工具",normalizedTitle:"工具",charIndex:537},{level:2,title:"资源站点",slug:"资源站点",normalizedTitle:"资源站点",charIndex:38787}],headersStr:"指导原则 Awesome 大牛/组织 大牛 组织 文档 指南 文章 付费教程 成品项目 静态网站生成器 学习项目 开源类库 Web 框架 业务框架 项目骨架 DDD 框架 TCP 框架 中间件 并发 命令行 参数解析 输出展示 其他 终端工具 路由 网络 LDAP 网络代理 HTTP压测 HTTP WebSocket 即时通信 网关 序列化 解压缩 RPC 邮件 消息队列 文件/存储 模板引擎 代码生成 文本处理 Markdown HTML/CSS 其他 文档 数学计算 日期时间 配置 爬虫 数据库 SQL解析 分布式事务 数据库相关 数据库客户端 数据库引擎 缓存 搜索推荐 表单 Auth 加密/解密 视频 图形处理 图片识别 图表 构建编译 静态资源内嵌 优雅升级 代码分析 调试 测试 错误处理 安全 系统信息 UUID 日志 监控告警 统计分析 容器技术 集群管理 Kubernetes 机器学习 人工智能 算法 数据结构 依赖注入 JSON 依赖管理 微服务 Serverless devops 持续集成/部署 Git 限流器 编译器 解释器 语言解释器 PHP 自定义解释器 代码生成 编辑器 运行器 查询语言 游戏相关 桌面开发 GUI 桌面辅助包 桌面应用 移动端 协程/线程 任务/定时器 流处理 微信 SDK 区块链 开发辅助包 代码生成 系统开发 未归类 logo 工具 资源站点",content:'> Go 语言优秀资源整理，为项目落地加速🏃\n> \n> 转载分享，出处如下，谢谢 😆\n> \n> 原文地址: https://shockerli.net/post/go-awesome\n> \n> GitHub: https://github.com/shockerli/go-awesome\n\n----------------------------------------\n\n> 官网: https://golang.org\n> \n> 国内官网镜像(访问快): https://golang.google.cn\n> \n> GitHub: https://github.com/golang/go\n> \n> 开发者平台: https://go.dev\n> \n> Wiki: https://github.com/golang/go/wiki\n> \n> 官方博客: https://blog.golang.org\n\n\n# 指导原则\n\n * 简单性\n   \n   > 复杂性把可读的程序变得不可读，复杂性终结了很多软件项目。\n\n * 可读性\n   \n   > 代码是给人看的，代码阅读时长远超编写。程序必须可维护，那可读是第一步。\n\n * 生产率\n   \n   > 拥有众多的工具集和基础库，可以很简单方便的完成绝大多数工作。 编译速度足够快，拥有动态语言的高效，但却不会面临动态语言不可靠的问题。 自带编程规范，使得团队代码一致，也帮助开发者发现和避免潜在的错误。\n\n\n# Awesome\n\n * GitHub Topic for Go\n * Awesome Go\n * golang-open-source-projects - 含描述的中文版 Awesome Go\n * Awesome Go Storage - Go 存储相关开源项目\n * awesome-go-China - 专门收集华人写的开源项目\n * Go Patterns - Go 版本的设计模式\n * sevenelevenlee/go-patterns - 设计模式\n * GoF 设计模式\n * greyireland/algorithm-pattern - 算法模板\n * go-algorithms - Go 版本的数据结构和算法\n * Go 学习之路 - Go 学习资料汇集\n * Go 开发者路线图\n * ReposHub-Go\n * VisuAlgo - 数据结构和算法动态可视化\n\n\n# 大牛/组织\n\n> Go 语言方面的大牛，或者优秀 Go 项目的组织\n\n\n# 大牛\n\n * mattn - 写了数百个 Go 项目，盛产优质项目\n * Unknwon - gogs/macaron 等项目作者，《The Way to Go》译者\n * Jinzhu - gorm/QOR 等作者\n * valyala - fasthttp/fastjson 等作者\n * vmihailenco - go-redis/go-pg 等作者\n * kataras - iris 作者\n * bep\n * spf13\n * tidwall\n\n\n# 组织\n\n * Gorilla web toolkit\n * loov\n * HashiCorp\n * lestrrat-go\n * Uber - Open Source Software at Uber\n * Stretchr - Tame your unstructured data\n * Containous\n * Charm - 提供一系列优秀的命令行工具和库\n\n\n# 文档\n\n * Proposing Changes to Go - Go 语言设计文档\n * Go 语言设计与实现\n * Go 语言原本\n * Go 101 （中文版）\n * Go 官方入门指南\n * Go 语言高级编程\n * Go 专家编程\n * Go 编程语言\n * Golang 标准库文档(官方/中文)\n * Go 语言标准库 在线阅读\n * 《The Way to Go》中文版\n * Go 语言圣经（中文版）\n * Go语言入门教程\n * Go 实战开发\n * Go Web 应用开发\n * Go 学习技能树\n * 实效 Go 编程\n * Go 语言语法详解笔记\n * Go 语言学习资料与社区索引\n * Go database/sql tutorial\n * GO 命令教程\n * 深入解析 Go\n * Go 语言博客实践\n * 学习 Go 语言\n * Go2编程指南\n * Go database/sql tutorial - Go 数据库(database/sql)开发使用教程\n * Go Web Examples - Go Web 开发示例\n * Go Assembly - 通过示例介绍 Go 汇编功能\n * Ultimate Go - 终极 Go 学习指南，包含大量文档化的代码和程序分析\n * Go 教程 - 腾讯云开发者手册\n * Golang 开发笔记\n * golang-notes - Go 源码阅读笔记\n * The Little Go Book （中文版）\n * Learning Go — from zero to hero\n * go-internals - 深入理解 Go\n * Learn Go with Tests\n * Go基础教程\n * 7天用Go从零实现系列\n * Go 语言高性能编程\n * Golang - 100天从新手到大师 - 某培训机构的部分教程内容\n * hoanhan101/algo - 107+ 编码面试问题，包括详细的解决方案，测试用例和程序分析\n * over-golang - Go 学习笔记\n * over-algorithm - Go 算法笔记\n * learngo - 1000+ Go 示例、练习和测试\n * go-leetcode - LeetCode 实现\n * 玩转 GO - 《Mastering GO》中文译本\n * leetcode-cookbook - LeetCode in Go\n * Golang修养之路\n * Go语法树入门\n * Go Concurrency Patterns - Go 并发模式场景集合\n * yezihack/algo - 数据结构与算法\n * golang-cheat-sheet-cn - GitHub上最流行的Golang代码速查表中文翻译版本\n\n\n# 指南\n\n * Uber Go Style Guide\n * The Go Programming Language Specification （中文老版）\n * 实效 Go 编程\n * Go Code Review Comments\n * Go Code Convention\n * Go FAQ 101\n * Go Details 101\n * Go Tips 101\n * Go Quizzes 101\n * go-advices\n * go-perfbook - 编写和优化Go代码\n * Practical Go: Real world advice for writing maintainable Go programs （Go 语言实践：编写可维护的程序的建议）\n * Go 安全指南 - 腾讯发布的《代码安全指南》Go 语言篇\n * Go Concurrency Guide\n * Go Recipes - 一些技巧\n\n\n# 文章\n\n * Go Training - 大量优质 Go 相关文章、视频等资料\n * Go语言爱好者周刊\n * Go 夜读 - Go 标准包、开源项目源代码阅读讲解\n * Go-Questions - Go 语言学习入门和进阶知识\n * Go的50度灰：Golang新开发者要注意的陷阱和常见错误\n * Go 程序的性能优化及 pprof 的使用\n * gops - Go语言程序查看和诊断工具\n * Go源码分析——http.ListenAndServe()是如何工作的\n * GoConvey 框架使用指南\n * GoStub 框架使用指南\n * GoMock 框架使用指南\n * Monkey 框架使用指南\n * The Evolution of a Go Programmer - Go 程序员的进化之路\n\n\n# 付费教程\n\n * 基于 Go 语言构建企业级的 RESTful API 服务 - 掘金小册\n * Go语言核心36讲 - 极客时间\n\n\n# 成品项目\n\n * Shiori - 书签管理\n * studygolang - Go 语言中文网\n * mkcert - 生成本地 HTTPS 加密证书的工具\n * cfssl - Cloudflare 开源的 PKI 和 TLS 工具集\n * Rainbond - 基于Docker、Kubernetes等容器技术的开源PaaS\n * NYADB2 - Go 实现的关系型数据库, 值得用于学习\n * EiBlog - 博客\n * pan-light - 不限速的百度网盘客户端, 基于 Go + Qt5 开发\n * BaiduPCS-Go - 百度网盘客户端（命令行）\n * daily-warm - 每天定时发邮件给你关心的人\n * pipe - 博客平台\n * mdr - 命令行下的 Markdown 阅读工具\n * miniflux - Feed 阅读器\n * golinks - 创建自定义书签、命令、搜索等\n * 链滴笔记 - 桌面端笔记应用\n * wayback - 网页快照备份\n * bbs-go - 开源社区\n * OpenSCRM - 基于Go和React的企业微信私域流量管理系统\n * Answer - 问答社区\n * listmonk - 资讯、邮件列表管理工具（Web）\n * 1Panel - Linux 服务器运维管理面板\n * Artalk - 自托管评论系统\n * memos - 笔记服务，具有移动客户端、浏览器扩展等生态\n\n\n# 静态网站生成器\n\n * Hugo\n * jrnl\n * plenti\n * verless\n * ink\n * moul - 生成照片站点\n * zas\n\n\n# 学习项目\n\n * 1m-go-websockets - 该项目演示了如何用 Go 编写一个可以提供超过一百万个 websockets 连接、运行内存小于 1GB 的服务器\n * Go by Example - 通过实例学习 Go\n * IAM - 身份识别与访问管理系统（教学项目）\n * 100-go-mistakes - 100 个 Go 常见错误\n\n\n# 开源类库\n\n\n# Web 框架\n\n * Macaron - 一款具有高生产力和模块化设计的 Go Web 框架 国产\n * Beego - 一个使用 Go 的思维来帮助您构建并开发 Go 应用程序的开源框架 国产\n * Gin - 轻量 Web 框架\n * Iris - Web 开发框架\n * Revel\n * echo\n * Faygo - 国产\n * Teleport - Socket 框架\n * GoFrame - 国产\n * QOR - 系列应用开发组件包\n * DotWeb - 国产\n * REST Layer - REST API framework\n * Honeytrap\n * Ponzu\n * utron\n * muxie\n * Buffalo - 快速生成 Web 项目的开发工具\n * go-web-framework-benchmark\n * fiber - 一种 Express 风格的、基于 fasthttp 的 HTTP Web 框架\n * aah\n * go-zero - 好未来开源的 Web 框架\n * pingcap/fn - 支持绑定任何方法，构建成 POST+JSON 接口\n * flamego - unknwon 开发的又一款 Web 框架\n * REST Layer - REST API 框架\n * rk-boot\n\n\n# 业务框架\n\n * YAO - 使用 JSON 即可创建数据库模型、编写 API 接口、描述管理后台界面的应用引擎\n * GoAdminGroup/go-admin - 后台管理快速开发框架，与 laravel-admin 类似\n * wenjianzhang/go-admin - 基于 Gin + Vue 实现的后台框架\n * gin-vue-admin - 基于 Gin + Vue 实现的后台框架\n * goxygen - 基于 Go, React, MongoDB 技术实现的全栈应用生成器\n * nging - Go语言通用后台管理框架\n * snake - 业务API框架\n * PocketBase - 带有后台管理面板、文件和权限管理、集成 SQLite 数据库的单一文件后端服务开发框架，支持 Dart 和 JS SDK 快速开发 APP\n * DoTenX - 低代码框架\n\n\n# 项目骨架\n\n * Standard Go Project Layout - Go 项目目录结构示例\n * go-starter - Adobe 的 Go 工程模板\n * go-clean-arch\n * go-rest-api - Go RESTful API Starter Kit\n * Create Go App CLI - 通过命令行创建前后端项目的开发骨架\n * clean-gin - 基于 Gin 构建的整洁架构项目骨架\n * golang-repo-template - 一个包含了很多实践的项目模板\n\n\n# DDD 框架\n\n * Wild Workouts - DDD、整洁架构、CQRS的示例项目\n * Clean Architecture in Go - 整洁架构示例\n * freedom - 基于六边形架构的框架\n * esim - 基于六边形架构的微服务框架\n * go-cleanarch - Go 整洁架构规则校验工具\n\n\n# TCP 框架\n\n * zinx - TCP并发服务器框架\n\n\n# 中间件\n\n * Negroni - Web 中间件\n * csrf - CSRF 中间件\n * handlers - A collection of useful handlers for Go\'s net/http package\n\n\n# 并发\n\n * SizedWaitGroup - 并发控制\n * concurrent - concurrency utilities\n\n\n# 命令行\n\n# 参数解析\n\n * urfave/cli - 命令行程序构建工具\n * Cobra - 命令行构建包\n * flaggy - 命令参数解析\n * pflag - 命令行参数处理\n * kong - 命令行解析\n * clop - 命令行解析包\n * go-flags - 命令行参数解析\n * mow.cli\n * go-arg - 基于结构体Tag解析命令行参数\n\n# 输出展示\n\n * progressbar - 在终端上输出进度条\n * cheggaaa/pb - 终端进度条\n * mpb - 支持多个进度条\n * Color - 命令行文字颜色\n * gookit/color - 命令行色彩使用库\n * termui - 终端仪表盘\n * tui - 终端 UI\n * termenv - 终端应用程序的高级 ANSI 样式和颜色支持\n * asciigraph - 在终端中绘制 ASCII 字符的图表\n * spinner - 涵盖70多种符号或进度条的控制器\n * tablewriter - 终端中输出表格内容\n * PIXterm - 在命令行终端中绘图\n * WTF - 一个命令行的信息仪表盘，可以定制显示内容\n * termdash - 基于 Go Terminal 的仪表板系统\n * bubbles - TUI 组件\n * bubbletea - TUI 框架\n * PTerm - 支持图表、表格、进度条、树等终端输出展示\n * Lip Gloss - 终端布局、样式\n * gum\n * glow - 终端渲染展示 Markdown\n * Slides - 终端渲染展示 Markdown\n * tview - Terminal UI\n * ASCIIPlayer - 在终端中通过 ASCII 输出图片或视频，支持 png、jpeg、gif、mp4、avi 等格式\n * go-pretty - 终端渲染表格、列表、进度条等\n * tcell\n\n# 其他\n\n * gosu - 以指定的用户权限来运行脚本\n * gotop - 类 top 系统监控显示\n * go-colorable - Colorable writer for Windows\n * go-isatty - TTY 环境判断\n * fzf - 终端模糊查询神器，支持多平台\n * go-daemon - daemon 进程包\n * go-prompt - 命令行交互式输入\n * peco - 交互式过滤工具\n * pty - PTY for Go\n * vtclean - 从终端输出字符串中解析出纯文本\n * Survey - 交互式输入\n\n\n# 终端工具\n\n * vgrep - 支持滚动分页的 grep\n * GoTTY - 基于Web的命令行实时共享\n * Jump - 根据习惯快速跳转目录\n * GoFish - 一个受 Homebrew 启发的跨平台软件管理工具，支持 Linux 和 Windows\n * viddy - 增强版 watch 命令\n * miller - 一个类似 sed、awk、cut、join 和 sort 的工具，用来处理基于命名索引的数据\n * assh - SSH 增强工具\n * duf - 比 df 更好用的磁盘使用率工具\n * ov - 终端文本阅读器，可替代 less、more、tail -f 等\n * trdsql - 可对 CSV/LTSV/JSON/TBLN 等文件执行 SQL 查询和导出\n * vhs - 终端录像工具，提供了在终端中录制和回放终端会话的功能，类似于将终端会话记录为视频的方式\n\n\n# 路由\n\n * HttpRouter\n * mux - URL 路由和调度器\n * chi\n * gocraft/web\n * go-querystring - 转换结构体为URL请求参数\n * gorilla/schema - converts structs to and from form values\n * CleverGo\n * rewrite - rewrite 中间件\n * BunRouter - 支持中间件、错误处理、路由优先级、兼容 net/http 接口\n\n\n# 网络\n\n * DNS - DNS 库\n * CoreDNS - DNS 服务器\n * RoadRunner - PHP 应用服务器、进程管理器、负载均衡，用于替代 Nginx + FPM\n * FrankenPHP - PHP 应用服务器\n * GoReplay - 流量收集&回放\n * Sharingan - 滴滴开源的流量录制回放工具\n * Glorp - HTTP 拦截&重放的 CLI 工具\n * p2pspider - 种子嗅探器\n * torrent - BitTorrent 相关工具库\n * rain - BitTorrent 客户端和库\n * httpteleport - Teleports 10Gbps http traffic over 1Gbps networks\n * FIND3 - WiFi 设备发现\n * SubFinder - 子域名发现工具\n * ggz - 短网址服务\n * httpstat\n * grab - 文件下载\n * go-getter - 可使用 URL 作为输入的主要形式从各种来源下载文件或目录\n * go-netty - 网络框架\n * gnet - 事件驱动 Go 网络框架\n * netpoll - 专注于 RPC 场景的 Non-blocking I/O 网络库\n * httplab - The interactive web server\n * yamux - Multiplexer\n * sftp - SFTP support for the go.crypto/ssh package\n * goftp - FTP 客户端\n * SFTPGo - 功能齐全且可高度配置的SFTP服务器，可选择支持HTTP/S、FTP/S和WebDAV。支持的存储后端包括：本地文件系统、加密的本地文件系统、S3（兼容）对象存储、Google Cloud Storage、Azure Blob Storage以及其他SFTP服务器。\n * evio - 事件驱动网络框架（reactor 模式）\n * gaio - 事件驱动网络框架（proactor 模式）\n * httpretty - 在终端上漂亮地打印出 HTTP 请求\n * blocky - 作为局域网 DNS 代理拦截广告\n * lossy - 模拟 net.PacketConn 和 net.Conn 接口的带宽，延迟和数据包丢失\n * go-libp2p - P2P\n * go-ipfs-api - IPFS\n * gomobile-ipfs - 为移动终端提供IPFS网络访问支持\n * go-multiaddr - multiaddr\n * kcp-go - 可靠的 UDP 通讯包\n * gliderlabs/ssh - 像 net/http 一样轻松搭建 SSH 服务器\n * netaddr - 网络地址处理\n * sx - 网络扫描命令工具\n * echoip - IP 地址查找服务\n * EasyTCP - TCP Server 框架\n * GoPacket - 网络捕获抓包\n * croc - 两台电脑之间传输文件\n * cmux - 监听同一个端口，启动多种协议服务\n * GeoIP2 Reader for Go - 解析&读取 MaxMind GeoLite2 和 GeoIP2 数据库\n * dns.toys - DNS 服务器\n * Apache Traffic Control - CDN 流量控制\n * NextTrace - 可视化路由追踪工具\n * pget - 文件下载工具，可多连接下载\n * CloudflareSpeedTest - 测试 Cloudflare CDN 延迟和速度，获取最快 IP\n\n# LDAP\n\n * go-ldap\n * GLAuth - LDAP Server\n * gldap - LDAP Service\n\n# 网络代理\n\n * Caddy - 类似 Nginx 的 Web 服务器\n * Traefik - 反向代理&负载均衡\n * snail007/goproxy - golang 实现的高性能代理服务器\n * ProxyPool - 采集免费的代理资源为爬虫提供有效的IP代理\n * frp - 可用于内网穿透的高性能的反向代理应用\n * nps - 一款轻量级、高性能、功能强大的内网穿透代理服务器\n * Pomerium - 基于身份的反向代理\n * V2Ray\n * V2Fly - V2Ray 的社区版本\n * Tailscale - WireGuard 解决方案\n * Clash - 支持多种协议的多平台代理客户端\n * elazarl/goproxy - HTTP 代理\n * oxy - Go middlewares for HTTP servers & proxies\n * ouqiang/goproxy - Go HTTP(S)代理库, 支持中间人代理解密HTTPS\n * pgrok - 提供给穷人的内网穿透\n\n\n# HTTP压测\n\n * Vegeta - HTTP 负载压测工具\n * hey - Web 压测工具\n * bombardier - Web 压测工具\n * go-wrk\n * plow\n * Ddosify\n\n\n# HTTP\n\n * fasthttp - 比 net/http 快 10 倍的 HTTP 工具包\n * Resty - HTTP & REST 客户端包\n * gout - HTTP 客户端\n * gentleman - HTTP 客户端\n * goz\n * UserAgent - 解析 HTTP User Agent\n * purell - URL 规范工具包\n * go-autorest - HTTP 管道请求方式的客户端\n * Req - HTTP 客户端\n * cors - CORS Handler\n * CertMagic - 为任意 Go 程序自动加上 HTTPS，TLS 证书签发、更新全自动\n\n\n# WebSocket\n\n * gorilla/websocket\n * nhooyr/websocket - 官方推荐的包\n * websocketd - Go 开发的一键搭建 WebSocket 服务器命令行工具\n * ws - WebSocket 开发包\n * melody - WebSocket 服务框架\n * neffos - 一个快速且可扩展的 WebSocket 框架\n * fastws\n\n\n# 即时通信\n\n * Centrifugo - 实时消息服务器，可以与任何语言编写的应用程序后端结合使用\n * goim - 支持集群的 im 及实时推送服务\n * Tinode - 即时消息服务器，通过 websocket/JSON 或 gRPC/TCP 等协议传输\n * WebRTC - WebRTC 实现\n * Berty - 安全的点对点通讯软件\n * Keybase - 即时通讯工具 Keybase 全平台客户端\n * gotify - 基于 WebSocket 的 PUSH 通知服务\n * nakama - 用于社交/实时游戏/实时应用的分布式服务端程序，自带面板、用户、聊天、存储、社交等功能\n * OpenIM\n\n\n# 网关\n\n * GoKu API Gateway CE - eoLinker 开源的 API 网关\n * Easegress\n * Manba\n * Tpk\n * BFE - 基于百度统一接入前端开源的七层流量接入系统\n\n\n# 序列化\n\n * vmihailenco/msgpack - 支持 msgpack\n * go/codec - 支持 msgpack/binc/cbor/json\n * golang/protobuf - Go 版本的 Protocol Buffers\n * gogo/protobuf - golang/protobuf 的扩展替代品\n * Objx - 操作 map, slice, JSON 等数据的包\n * msgp - MessagePack 代码生成器\n * Buf - protoc 替代品\n * protoc-gen-doc - Google Protocol Buffers 文档生成插件，支持 HTML、JSON、DocBook、Markdown 和自定义模板\n\n\n# 解压缩\n\n * snappy - Go 语言版本的 Snappy\n * cae - 实现 ZIP/TAR.GZ 解压缩\n * archiver - 多格式支持的解压缩包\n * compress - Optimized compression packages\n * Brotli\n * xz - xz 压缩格式读写包\n\n\n# RPC\n\n * gRPC-Go - gRPC 官方包\n * Go gRPC Middleware - gRPC 常用中间件\n * gorpc\n * gorilla/rpc - 构建基于 HTTP 的 RPC 服务，比如 JSON-RPC\n * Lile - gRPC 服务构建包\n * rpcx\n * Twirp - 基于 Protobuf 的 RPC 框架，与 gRPC 类似\n * dubbo-go - Dubbo Go 版本\n * Kitex\n * gRPCurl - 像 cURL 一样通过命令行访问 gRPC 服务\n * protoc-gen-doc - 文档生成插件\n * gRPC-Gateway - 读取 gRPC 服务定义并生成一个反向代理服务器，同时提供 gRPC 和 RESTful 风格的 API\n\n\n# 邮件\n\n * gomail - 邮件发送包\n * scorredoira/email\n * Hermes - Go 版本的 mailgen 引擎，根据配置生成 HTML 格式的邮件\n * Go-Guerrilla - SMTP 邮件服务器\n * MailHog - 基于Web和API的SMTP测试工具\n * Maddy - 邮件服务器\n * jordan-wright/email\n * Mox - 邮件服务器\n * Pop - 邮件发送工具，支持交互式和参数式\n * email-verifier - 邮箱校验，无需发送邮件\n\n\n# 消息队列\n\n * NSQ - 实时分布式消息平台\n * NATS - 云原生消息中间件\n * amqp - AMQP 0.9.1 客户端\n * sarama - Kafka 客户端\n\n\n# 文件/存储\n\n * MinIO - 对象存储服务器\n * rclone - 不同云存储之间同步文件\n * Syncthing - 文件同步\n * fsnotify - 文件系统监控工具\n * reflex - 监听文件变更并执行命令\n * gohttpserver - HTTP 静态文件服务器\n * XLSX - Excel 读写包\n * Excelize - 360 开源的 Excel 工具包\n * gopdf - PDF 生成\n * rsc/pdf - PDF reader\n * SeaweedFS - 分布式文件系统\n * go-fastdfs - 分布式文件存储服务\n * Dragonfly - 基于 P2P 的分布式文件系统\n * filetype - 检测文件类型\n * Afero - 文件操作包\n * fsync - 文件/目录同步\n * filebrowser - Web File Browser\n * Bigfile - 文件传输管理系统\n * filetype - 文件类型与 MIME 检测\n * go-app-paths - 跨平台检索目录文件\n * copy - 拷贝文件夹\n * lakeFS - 类 Git 文件对象存储\n * Duplicacy - 无锁云备份工具，支持几乎所有存储方式\n * CasaOS - 家庭云系统\n * AList - 支持多存储的文件列表程序\n * UniPDF - PDF 读写处理\n * mimetype - MIME 类型与文件扩展检测\n * gocryptfs - 加密 overlay 文件系统\n * restic - 备份工具，使用现代的加密方法对数据进行安全的备份，支持\n\n\n# 模板引擎\n\n * goTemplateBenchmark - 给各 Go 模板引擎做性能测试，当然也就包含了最全的模板引擎包\n * Jet - 速度很快\n * amber - HTML 模板引擎\n * fasttemplate - Simple and fast template engine for Go\n * quicktemplate\n * mustache\n * Ace\n * Sprig - 常用模板方法\n * pongo2 - Django 语法风格的模板引擎\n * plush\n\n\n# 代码生成\n\n * esc\n\n\n# 文本处理\n\n# Markdown\n\n * Blackfriday - Markdown 解析器\n * Lute - 结构化的 Markdown 引擎\n * goldmark - Markdown 解析器\n * docx2md - 转换 Word 为 Markdown\n * glamour - 命令行下渲染 Markdown\n * go-md2man - 转换 Markdown 为 man 手册内容\n * gomarkdown/markdown\n * html-to-markdown - 转换 HTML 为 Markdown\n\n# HTML/CSS\n\n * DOM - HTML DOM 节点操作\n * obelisk - 保存 Web 网页为 HTML 单页面\n * html2text - HTML 转 text\n * go-readability - 让 HTML 可读性更高\n * gomponents - 声明式视图组件，可以渲染成 HTML5\n * daz - HTML 组件组合，渲染 HTML\n * html-strip-tags-go - 去除 HTML 标签\n * bluemonday - XSS 探测\n * cascadia - CSS 选择器\n * htmlquery - XPath 语法查询 HTML\n * xmlquery - XPath 语法查询 XML\n * xpath - XPath 语法\n * goquery - jQuery 语法查询 HTML\n * css - CSS 选择器\n\n# 其他\n\n * go-runewidth - 字符长度计算\n * gpy - Go 语言汉字转拼音工具\n * go-hashids - hashids 的 Go 版本\n * go-pinyin - 汉语拼音转换工具 Go 版\n * mahonia - 字符集编码转换\n * pangu.go - Go 版本的 pangu，给中英文之间加空格\n * goorgeous - A Go ORG syntax parser to HTML\n * sergi/go-diff - Go 版本的 diff 工具包\n * sourcegraph/go-diff - Go 版本的 diff 工具包\n * Chroma - 代码语法高亮\n * syntaxhighlight - 代码高亮\n * kyokomi/emoji\n * enescakir/emoji\n * golang/freetype - Freetype font rasterizer\n * prose - natural language processing library\n * minify - Web 静态资源压缩(HTML/JS/CSS/JSON/XML/SVG)\n * Inflection - Pluralizes and singularizes English nouns\n * autocorrect - 自动给中英文之间加入合理的空格并纠正专用名词大小写\n * bleve - modern text indexing\n * etree - XML 解析&生成\n * go-xml\n * feeds - RSS 内容生成\n * gofeed - RSS & Atom feeds 内容解析\n * sitemap - sitemap.xml 生成\n * yarr - RSS 阅读软件\n * gogrep - 通过语法树搜索 Go 源码\n * PipeIt - 文本转换，清理和提取工具\n * regexp2 - 全功能正则表达式引擎。如果标准库的 regexp 满足不了你，可以尝试使用 regexp2\n * html2article - 基于文本密度的 html2article 实现\n * hostctl - hosts 命令行管理工具\n * go-shellwords - 解析命令行中字段\n * woke - 检查文本文件中是否存在歧视词汇\n * go-password-validator - 密码强度校验器\n * xurls - 从文本中提取 URL\n * whatlanggo - 自然语言探测\n * go-enry - 检测编程语言\n * fuzzy - 字符串模糊匹配\n * godlp - 数据脱敏\n * Zoekt - 文本搜索引擎\n\n\n# 文档\n\n * swag - Swagger for Go\n * gin-swagger - Swagger for Gin\n * go-swagger - Swagger 2.0 implementation for go\n\n\n# 数学计算\n\n * decimal - 解决浮点数计算精度问题\n * fixed\n * apd - decimal 包\n * mathfmt - 将 LaTeX 语法的注释转换为数学公式格式\n * q - 量子计算模拟器\n * accounting - 货币格式化\n\n\n# 日期时间\n\n * now\n * when - 自然日期时间解析\n * Carbon - Carbon 时间处理库的 Go 语言实现\n * strftime - 时间格式化\n * dateparse - 解析任意未知格式的时间字符串\n\n\n# 配置\n\n * GoDotEnv - .env 配置文件解析\n * go-yaml/yaml\n * ghodss/yaml\n * toml - TOML 解析&编码包\n * INI - INI 配置文件解析\n * Viper - 支持 JSON, TOML, YAML, HCL, Java 等配置文件\n * fig\n * Multiconfig\n * configor\n * envconfig\n * confd - 配置管理工具\n * HCL - configuration language\n * env - 解析 ENV 环境变量到结构体中\n * configor\n * koanf\n * go-toml - TOML\n * butler - Adobe 开源的配置管理系统\n * envsubst - 环境变量替换\n\n\n# 爬虫\n\n * Crawlab - 基于Golang的分布式爬虫管理平台，支持Python、NodeJS、Go、Java、PHP等多种编程语言以及多种爬虫框架\n * Colly - 网络爬虫框架\n * Pholcus - 支持分布式的高并发、重量级爬虫软件\n * go_spider\n * Muffet - 网站链接检查器\n * Creeper\n * Geziyor - 支持 JS 渲染的快速爬虫框架\n * Apollo - 一个爬虫工具\n * ferret - 声明式 Web 数据抓取\n * gocrawl\n * Antch\n * katana - 爬虫&蜘蛛框架\n\n\n# 数据库\n\n# SQL解析\n\n * pingcap/parser - 兼容 MySQL 的 SQL 解析\n * xsqlparser - SQL 解析\n * sqlparser - SQL 解析\n * vitess-sqlparser - SQL 解析\n * dbml-go - DBML 解析\n\n# 分布式事务\n\n * go-saga - Saga 分布式事务实现\n * DTM - 跨语言的分布式事务管理服务，支持TCC、Saga、XA等\n\n# 数据库相关\n\n * usql - 几乎支持全部 SQL 与 NoSQL 数据库的命令行工具\n * GORM - GORM V2\n   * GORM V1\n   * gorm2sql - 根据 Model Struct 生成建表语句\n   * gorm-sharding - 基于 Conn 层做 SQL 拦截、AST 解析、分表路由、自增主键填充，对使用者透明\n * Xorm\n * XormPlus - Xorm 的定制增强版本\n * GoRose\n * sqlx - database/sql 扩展包\n * dbq - 数据库操作\n * gendry - 滴滴开源的SQL Builder\n * ozzo-dbx\n * Squirrel - Fluent SQL Builder\n * qb - the database toolkit for go\n * mgo\n   * globalsign/mgo - The MongoDB driver for Go\n   * mgo使用指南\n * kingshard - MySQL Proxy\n * SOAR - 对SQL进行优化和改写的自动化工具\n * SQLE - SQL 审核工具\n * Vitess - 用于部署、扩展和管理大型MySQL实例集群的数据库解决方案\n * gh-ost - GitHub 开源的在线更改 MySQL 表结构的工具\n * SQLer - write APIs using direct SQL queries with no hassle, let\'s rethink about SQL\n * gocraft/dbr\n * Gaea - 小米开源的基于 MySQL 协议的数据库中间件\n * OctoSQL - 支持多数据库的 SQL 查询工具\n * goose - 数据库迁移工具\n * migrate - 数据库迁移工具\n * dbmate - 数据库迁移工具\n * ent - An Entity Framework For Go\n * godb - a Go query builder and struct mapper\n * go-nulltype\n * go-mysql - MySQL 工具集\n * SQLittle - 纯读取 SQLite 文件\n * Bifrost - MySQL 同步到 Redis、ClickHouse 等服务的异构中间件\n * elasticsql - 转换 SQL 成 Elasticsearch DSL\n * POP - 基于 sqlx 封装的数据库 ORM 工具\n * REL - Modern Database Access Layer for Go\n * RDB - Redis RDB 文件解析和生成工具，支持转 JSON、转 AOF、寻找 Big Key、生成 RDB 文件及绘制内存火焰图等功能\n * Bytebase - 基于网络、零配置、无依赖的数据库 Schema 变更和版本控制管理工具\n * Bun - SQL 优先的 ORM，写 SQL 的方式写 Go 代码，支持 PostgreSQL、MySQL、MSSQL、SQLite\n\n# 数据库客户端\n\n * Go-MySQL-Driver - MySQL 驱动\n * go-mssqldb - MSSQL 驱动\n * pq - PostgreSQL 驱动\n * mongo-go-driver - MongoDB 官方出品的 Go 语言驱动\n * qmgo - MongoDB 客户端\n * clickhouse-go - ClickHouse 官方 Go 语言客户端\n * go-clickhouse - ClickHouse 客户端\n * go-sqlite3 - SQLite3 驱动\n * gohbase - HBase 客户端\n * redigo - Redis 客户端\n * go-redis - Redis 客户端\n * rueidis - Redis 客户端\n * redsync - 基于 Redis 的分布式锁\n * redislock - 基于 Redis 的分布式锁\n * Tiny RDM - Redis 桌面客户端\n\n# 数据库引擎\n\n * etcd - KV 分布式存储\n * InfluxDB - 时间序列数据库\n * Prometheus - 服务监控系统 & 时间序列数据库\n * tstorage - 时间序列数据库\n * Thanos - 支持 Prometheus 简化部署、高可用、分布式存储\n * CockroachDB - 分布式 SQL 数据库\n * Cayley - 图数据库\n * RadonDB - 基于 MySQL 研发的新一代分布式关系型数据库\n * TiDB - 分布式关系型数据库，兼容 MySQL 协议\n * AresDB - Uber 开源的 GPU 驱动的实时分析存储&查询引擎\n * leveldb - LevelDB 的 Go 实现\n * Dgraph - 分布式图数据库\n * rqlite - 基于 SQLite 的轻量级分布式关系数据库\n * gaeadb\n * BadgerDB - KV 数据库，支持 ACID 事务\n * LBADD - 用 Go 实现的分布式 SQL 数据库\n * go-memdb - 建立在不可变 Radix 树上的内存数据库\n * VectorSQL - 应用于 IoT 和大数据的 DBMS 数据库，类似于 ClickHouse\n * BuntDB - 基于内存的KV数据库，支持磁盘持久化、ACID事务\n * TinySQL - 迷你分布式关系型数据库\n * Tile38 - GEO 数据库\n * Redcon - 兼容 Redis 协议的自定义 Redis 服务，采用 BuntDB 和 Tile38 实现存储\n * genji - 文档内嵌型数据库\n * Dolt - 像 Git 一样操作数据库\n * rosedb - 简洁、高效的 KV 数据库，支持多种数据结构\n * LinDB - 分布式时序数据库\n * mandodb - 一个示例项目，作者介绍如何从零开始实现一个小型的时序数据库\n * go-mysql-server - 解析 MySQL 协议并优化 SQL 的数据库引擎\n * Milvus - 向量数据库\n * FerretDB - MangoDB 替代品\n * LotusDB - 快速 KV 存储引擎，兼容 LSM 和 B+ 树\n * NutsDB - 可持久化、事务的内嵌 KV 数据库\n * Olric\n\n\n# 缓存\n\n * GCache\n * bbolt - key/value store\n * BigCache\n * go-cache - KV 内存缓存\n * gomemcache - Memcache 客户端\n * cache2go\n * ristretto\n * fastcache\n * FreeCache\n * godis - Go 语言实现的 Redis 服务器和分布式集群\n * groupcache - 分布式缓存\n * cachego - 支持 Redis、Bolt 等缓存接口\n * diskv - 基于硬盘的 KV 存储\n * Pebble - 被 CockroachDB 使用的 KV 存储\n\n\n# 搜索推荐\n\n * wukong - 全文搜索引擎\n * go-elasticsearch - 官方 ES 客户端\n * elastic - Elasticsearch 客户端\n * go-mysql-elasticsearch - Sync MySQL data into elasticsearch\n * gse - Go 语言分词\n * sego - Go 中文分词\n * gojieba - "结巴"中文分词的 Go 语言版本\n * Riot - 全文搜索引擎\n * simplefts - 超简单的全文搜索引擎实现\n * Blast - 全文搜索(Archived)\n * Fuzzy Search - 文本模糊搜索\n * gorse - 单节点训练和分布式预测推荐系统引擎\n * gofound - 全文搜索引擎\n * ZincSearch - 全文搜索引擎\n * Bluge - 文本分词\n\n\n# 表单\n\n * validator\n * ozzo-validation - 使用代码指定规则，而非Tag\n * go-tagexpr - 字节跳动开源的结构体标签表达式解释器\n * govalidator\n\n\n# Auth\n\n * Casbin - 权限控制管理\n * pam-ussh - Uber\'s SSH certificate pam module\n * jwt-go - JWT for Go\n * kataras/jwt - JWT 轻量级实现\n * cristalhq/jwt\n * sessions - 后端 SESSION 服务\n * securecookie - cookie 加密/解密\n * Goth - Multi-Provider Authentication for Go\n * branca - 号称比 JWT 更安全的 token 解决方案\n * gin-jwt - Gin 框架的 JWT 中间件\n * Authboss - Web Auth 系统\n * ZITADEL - 身份认证系统，支持各种认证模式\n\n\n# 加密/解密\n\n * 2fa - Two-factor authentication on the command line\n * age - 文件加密工具（库）\n * CIRCL - Cloudflare Interoperable, Reusable Cryptographic Library\n\n\n# 视频\n\n * goav - FFmpeg 视频处理\n * lal - 直播流媒体网络传输服务器\n * bililive-go - 直播录制工具\n * screego - 通过浏览器共享开发者屏幕\n * livego - 直播服务器\n * Monibuca - 流媒体服务器开发框架\n * olive - 支持虎牙等平台的直播录制\n * lux - 各大视频网站的视频下载工具\n\n\n# 图形处理\n\n * barcode - 条形码/二维码生成器\n * picfit - 图片操作、裁剪、管理服务器\n * gmfs - 图片操作、裁剪、管理服务器\n * besticon - favicon 服务\n * Caire - 图片操作库\n * Imaging - 图片操作库\n * gocaptcha - 验证码生成\n * base64Captcha - 验证码\n * go-is-svg - 校验是否为 SVG 图片\n * identicon - 根据用户的 IP 、邮箱名等任意数据为用户产生漂亮的随机头像\n * prominentcolor - 识别图片的主要颜色\n * dchest/captcha - 生成和验证图片或音频验证码\n * bimg - 图片处理\n * imaginary - 图片处理服务\n * primitive - 用原始几何图形绘制图形\n * orly - 生成你自己的O\'RLY动物书封面\n * smartcrop - 智能裁剪图片\n * gift - 图片滤镜\n * Germanium - 给代码生成图片\n * Go Graphics - 2D 图片渲染\n * canvas - 矢量图绘制\n * formulae - 数学公式解析、计算、图表绘制\n * imagor - 图像处理服务器\n * Triangula - 给图片增加三角形纹样风格的滤镜\n * D2 - 一种将文本转换成图形的图表脚本语言\n * ImGo - 简洁、链式调用的图像处理库\n * Invoice - 发票生成工具，可通过参数和配置文件进行创建和管理各种类型的发票\n\n# 图片识别\n\n * go-face - 面部识别\n\n\n# 图表\n\n * go-echarts - Echarts 图表库\n * gonum/plot - 图形绘制\n * pinhole - 3D 线框图绘制\n * globe - 地球线框图绘制\n * ink - Go 中的 2D 图形框架\n * go-plantuml - 基于 Go 源码生成 plantuml 图\n * go-diagrams - 通过代码生成图表\n * GoCity - 3D 展示城市\n\n\n# 构建编译\n\n * Mage - 类似于 Makefile 的命令行工具，用于构建和运行 Go 项目\n * GoReleaser - Go 多平台二进制文件打包、并支持发布到 Homebrew 的工具\n * goxc - 跨平台编译工具（因 1.5 版本开始已自带交叉编译，故已不再维护）\n * Task - 类似于 Make 的构建工具\n * codegangsta/gin - 热编译工具\n * Air - 热编译工具\n * gowatch - 热编译工具\n * Fresh - 热编译工具\n * dh-make-golang - 自动构建 Debian 包\n * gobinaries - 不用安装Go就能编译安装Go编写的程序\n * nFPM - deb、rpm、apk 等打包工具\n * Gox - Go 跨端编译工具\n * garble - 混淆代码\n * gobfuscate - 混淆代码\n * go-appimage - Go 语言实现 AppImage 打包工具\n\n# 静态资源内嵌\n\n * pkger - 将静态文件打包成 Go 二进制文件\n * mewn - 静态文件嵌入打包到二进制文件\n * statik - 静态文件嵌入\n * go.rice\n * go-bindata - 将静态文件转换成 Go 代码文件\n * vfsgen - 将静态文件打包成 http.FileSystem 类型进行访问\n * packr\n\n\n# 优雅升级\n\n * tableflip - Web 服务升级\n * selfupdate - 二进制文件自动升级\n * overseer\n * go-github-selfupdate - 依托 GitHub 自动升级\n\n\n# 代码分析\n\n * reviewdog - Code Review 机器人\n * revive - 代码检查分析\n * GolangCI-Lint - 代码质量检查分析工具\n * errcheck - 检测未处理的错误(errors)\n * Staticcheck - 一系列的 Go 代码静态分析工具\n * Golint - Google 官方出品的代码质量检测工具\n * GoReporter\n * go-critic\n * gocloc - 分语言代码行数统计\n * coca - 代码统计分析\n * Go Report Card - Go 项目质量分析报告工具\n * ddsv-go - 死锁检测工具\n * golang/perf - 官方性能量化分析工具\n * GoPlantUML - 为 Go 项目生成 PlantUML 类图\n * gosize - 分析Go二进制文件大小\n * shotizam - 分析 Go 二进制文件的大小并输出到 SQLite3\n * goconst - 查找可以被常量替换的重复字符串\n * sploit - 帮助二进制分析和开发的库\n * perf - Perf Utilities for Go\n * fgprof - Go 性能分析工具\n * conprof - 协程分析\n * statsview - 实时 Go 运行时统计数据可视化分析器\n * codesearch - 代码搜索工具\n * Pyroscope - 可视化程序性能监控工具，支持多种语言\n * gosec - 代码安全性检查工具\n * gokart - 代码静态分析工具\n * gofumpt - gofmt 增强版代码格式化工具\n * NoVerify - PHP 代码分析工具\n * fieldalignment - 结构体字段内存对齐分析和自动修复工具\n * Bearer - 代码安全扫描工具\n\n\n# 调试\n\n * go-spew - 变量打印工具\n * Delve - Debug 工具\n * gdlv - Delve 界面版本\n * Weaver - 跟踪 Go 程序执行链路\n * repr - 变量打印工具\n * pp - 彩色变量打印工具\n * ffmt - 变量打印工具\n * gops - 谷歌官方出品的 Go 程序监控调试工具\n * pprof\n * go-callvis - 可视化Go程序的调用图\n * q - 自动打印变量类型并且格式化输出\n * Litter\n * RDebug - 滴滴开源的一款用于 RD 研发、自测、调试的实用工具\n * debugcharts - Go 内存占用可视化调试工具\n * gcvis - 实时可视化 gctrace\n * pkg/profile\n * statsviz - 在浏览器中实时查看 Go 应用程序运行时统计信息（GC，MemStats 等）\n * autopprof - 自动分析 pprof\n * stack - 捕获、操作、格式化调用栈信息\n * pretty - 打印变量\n * go-deadlock - 对 (RW)Mutex 进行注入，并提供死锁检测\n * mmcloughlin/profile\n * gcnotifier - 当发生 GC 时通知\n * grmon - 命令行监控显示 goroutines\n * valast - 打印输出变量的 go/ast 结构，类似于 PHP 的 var_export 函数\n * lensm - Go 汇编与源码对照查看工具\n * holmes - 基于规则的自动 Go Profile Dumper\n\n\n# 测试\n\n * GoConvey - 含Web界面的单元测试框架\n * GoMock - 谷歌出品的Mock测试框架\n * GoStub\n * Monkey - (Archived) Monkey patching in Go\n * gomonkey - 猴子补丁，对函数、变量等进行打桩，方便单元测试，Fork 自 Monkey\n * SuperMonkey - 让私有方法可测\n * mockery - 自动为接口生成 mock 代码\n * Ginkgo - BBD 测试框架\n * fperf - 压测工具\n * gocheck\n * Testify\n * gotests - 根据源码自动生成测试文件\n * TestSQL - 根据 SQL 创建语句生成测试数据\n * httpmock - HTTP Mock\n * Goblin - BDD 测试框架\n * go-faker/faker - Struct Data Fake Generator\n * gofakeit - 随机数据生成器\n * dmgk/faker\n * go-tprof - 包测试报告生成工具\n * go-fuzz - randomized testing for Go\n * gofight - Testing API Handler\n * sqlmock - SQL 测试\n * sqlbench - SQL\n * silk - 基于 Markdown 的接口测试\n * gock - HTTP mock 测试\n * godog - BDD 测试框架 Cucumber 的 Go 版本\n * endly - E2E（端到端）测试\n * is - 迷你测试框架\n * Terratest - 基础设施测试，比如 Docker\n * agouti - Web 驱动的验收测试框架\n * httpexpect - 端到端 HTTP & REST 测试框架\n * gocov - 测试覆盖率\n * miniredis - Redis 数据测试\n * htmltest - HTML 测试\n * gnomock - 无需 mock 的 Go 代码测试框架\n * gunit - xUnit 风格测试框架\n * quicktest\n * k6 - 负载测试工具\n * go-cover-treemap - 将覆盖率测试结果转换成 TreeMap 图\n * ZTF - 禅道开源的自动化测试框架\n * Moq - 为接口生成 Mock 代码\n\n\n# 错误处理\n\n * errors\n * errorx\n * errwrap - Go tool to wrap and fix errors with the new %w verb directive\n * erris - Linter for errors.Is and errors.As\n * eris - 旨在通过错误包装，堆栈跟踪和输出格式为你提供对错误处理的更多控制\n * errlog - 使用静态和堆栈跟踪分析来快速确定哪个函数调用导致的错误\n * juju/errors\n * go-fault - GitHub 官方出品，基于标准库 http 中间件的故障注入库\n * merry - 支持堆栈、状态码的错误处理\n * cockroachdb/errors - 功能强大、可替代 errors 和 github.com/pkg/errors 的错误处理包\n * go-multierror - 支持错误列表\n\n\n# 安全\n\n * Kunpeng - 开源POC检测框架\n * nmap - 安全审计工具 nmap 开发包\n * Hetty - 用于安全研究的 HTTP 工具包，具有 Web 接口和代理日志查看器的拦截 HTTP 代理\n * Fibratus - Windows 内核漏洞利用和跟踪工具\n * Secure - HTTP 安全中间件\n * nuclei - 基于YAML语法模板的定制化快速漏洞扫描器\n * Gitleaks - 用于在 Git 存储库中查找敏感信息和密钥的开源工具\n\n\n# 系统信息\n\n * go-hardware - 收集了一堆关于硬件信息的包\n * cpuid - CPU 信息\n * gopsutil - ps 功能包\n * go-sysinfo - 系统信息\n * go-locale - 跨平台语言检测库\n * go-ps - 系统进程信息\n * psgo - ps 命令实现\n * ghw - 硬件信息\n * machineid - 获取机器ID\n\n\n# UUID\n\n * go.uuid - UUID 库\n * SEQSVR - Go + MySQL 实现的分布式 ID 生成服务\n * google/uuid - Google 开源的 uuid 包\n * gofrs/uuid\n * snowflake - Twitter snowflake IDs\n * sonyflake - Sony 版本的 Twitter\'s Snowflake\n * ulid - ULID Go 语言实现\n * ksuid - K-Sortable Globally Unique IDs\n * go-nanoid - NanoID 实现\n * xid - 全局唯一 ID 生成器\n\n\n# 日志\n\n * logr - 日志包标准接口\n * Logrus - 日志记录包\n * zerolog\n * zap - Uber 开发的日志记录包\n * Seelog\n * logkit - 七牛开源的日志收集工具\n * gogstash - 类似于 Logstash 的日志收集器\n * lumberjack - 日志文件切割\n * file-rotatelogs - 日志文件切割\n * go-syslog - 极速 Syslog 解析器\n * glog\n\n\n# 监控告警\n\n * OpenFalcon - 小米开源的监控系统\n * Prometheus - 服务监控系统 & 时间序列数据库\n * Grafana - 分析监视平台, 支持 Graphite, Elasticsearch, OpenTSDB, Prometheus, InfluxDB 等数据源\n   * grabana - 用 Go 代码快速创建 grafana dashboards\n * Jaeger - 分布式追踪系统\n * go-osstat - 系统指标统计\n * grafterm - Metrics dashboards on terminal\n * mymon - MySQL 运行监控\n * PingMe - 支持多消息平台的服务可用性报警命令工具\n * supervisord - Go 语言实现 Supervisor\n * Grafana Tempo - 分布式追踪系统\n * EaseProbe - 服务探活工具并通知\n * Uptrace - APM 工具，支持 OpenTelemetry 追踪、指标和日志\n * Nightingale - 滴滴基于 OpenFalcon 开源的监控系统\n\n\n# 统计分析\n\n * Fathom - Web 站点统计\n * Veneur - 分布式实时数据处理管道\n * gonum - 科学计算相关\n\n\n# 容器技术\n\n * moby - Docker\n * docker-ce\n * Rancher - 全栈化企业级容器管理平台\n * Gorsair\n * docui - TUI Client for Docker\n * Podman - 管理和运行任何符合 OCI 规范的容器和容器镜像\n * Skopeo - 镜像管理工具\n * Buildah - 构建 OCI 容器镜像的工具\n * go-docker - 用 Go 实现 Docker 核心功能\n * Packer - 轻量级的镜像定义工具\n * cosign - 容器签名和验证\n * SlimToolkit - 检查、缩小和调试容器\n\n\n# 集群管理\n\n * Nomad - 集群管理器和调度器\n * OpenShift Origin - Red Hat 开发的容器化软件解决方案\n\n# Kubernetes\n\n * kubernetes - 容器调度管理平台\n * k0s - 最小体积的 k8s 发行版\n * sealos - 一条命令部署 Kubernetes 高可用集群\n * KubeEye - 通过配置规则发现 Kubernetes 上的各种问题\n * endpoints-operator - K8S内部服务访问外部服务的具备探活功能的4层LB\n\n\n# 机器学习\n\n * goml - 机器学习库\n * GoLearn - 一个 "开箱即用" 的机器学习库\n * glow - 易用的分布式计算系统\n * Gobot - 机器人和物理计算语言库\n * Olivia - 神经网络\n * Pico - 基于像素强度比较的物体检测纸张的纯 Go 脸部检测库\n * tfgo - Tensorflow in Go\n * Prophecis - 微众银行自研的一站式云原生机器学习平台\n * AID - 机器学习ops平台，发现、部署、优化\n * SQLFlow - SQL引擎+AI引擎\n\n\n# 人工智能\n\n * go-openai - OpenAI API Go 客户端 SDK\n * LocalAI - 低成本的硬件上运行模型计算的本地计算框架，支持多种模型，提供兼容 OpenAI 接口协议的 REST API\n\n\n# 算法\n\n * GoDS - Go 实现了多种数据结构\n * Dragonboat - 多组 Raft 共识算法库\n * eliben/raft - Raft 算法\n * hashicorp/raft - Raft 算法\n * Graft - Raft 算法\n * golang-lru - LRU 算法实现\n * tinylru\n * finn - Fast Raft framework using the Redis protocol for Go\n * xorfilter\n * priyankchheda/algorithms - 各种算法的 Go 语言实现\n * meow - Meow hash\n * basalt - 高性能的分布式的专门空间优化的 Bitmap 服务, 杜绝 Bloomfilter 和 CuckooFilter 的误判\n * go-blurhash - BlurHash，是模糊图片的一种哈希算法\n * xxhash - xxHash 哈希算法实现\n * go-multihash - 各种 Hash 算法实现\n * memberlist - 基于 gossip 协议实现的管理集群成员和成员失败检测的开发包\n * backoff - 指数退避算法(Exponential Backoff)\n * FSM - 有限状态机\n\n\n# 数据结构\n\n * go-datastructures\n * Play-with-Data-Structures - 「玩转数据结构」课程的 Go 语言实现版本\n * HashMap\n * SipHash - SipHash-2-4\n * Bigslice\n * golang-set - The missing set collection\n * rbang - R!tree 实现\n * rtreego - R-tree\n * google/btree - B-Tree\n * tinybtree - B-tree\n * dataframe-go - 用于数据统计和操作的包\n * go-set - 集合工具包\n * orderedmap - 有序字典\n * trie\n * Slim - 空间高利用率的数据结构\n * bitset - 位集合及其操作\n * bloom - Bloom filters\n * roaring - 压缩位图\n * go-immutable-radix - Radix 树\n\n\n# 依赖注入\n\n * go-autowire - 使用注解自动生成 wire - 依赖注入\n * dig\n * Fx\n\n\n# JSON\n\n * GJSON - JSON 解释器\n * SJSON - JSON 修改工具\n * fastjson - fast JSON parser and validator for Go\n * jsonparser\n * ffjson\n * json-iterator - 滴滴开源的 JSON 解析器\n * gojsonq - JSON/YAML/XML/CSV 等数据查询\n * easyjson\n * go-jsonc - 将带注释的 JSON 转为无注释的\n * jin - JSON 操作工具包，同时具有标准库和类似 tidwall/gjson 和 tidwall/sjson 的功能\n * hujson - 支持注释的 JSON 解码\n * pkg/json - JSON Decoder\n * ColorJSON - 终端中打印彩色 JSON\n * jid - JSON 数据解析读取工具\n * jsonc - 支持注释与逗号\n * sonic - 字节跳动开源的 JSON 解析器&修改器\n * go-json\n * jsonquery - XPath 语法查询 JSON\n * fx - 命令行 JSON 显示\n\n\n# 依赖管理\n\n * goproxy.io - GOPROXY 代理服务\n * goproxy.cn - 更适合国内用户的代理服务\n * Gopm - Go 包管理工具\n * govendor - Vendor 包管理工具\n * gom - 包版本管理工具\n * rvflash/goup - 检查包版本是否有更新\n * owenthereal/goup - Go 多版本管理\n * Athens - GOPROXY 代理服务\n\n\n# 微服务\n\n * Istio [中文文档] - 大型微服务系统管理工具\n * goa\n * Micro - 微服务工具\n * Go Micro - 微服务框架\n * Go kit - Go 微服务工具集\n * GoKit CLI - Go kit 脚手架\n * gogo\n * go-chassis\n * Kite\n * Kratos - B站开源的微服务框架\n * Temporal - 微服务编排平台\n * Serf - 服务编排管理平台\n * Open Policy Agent - 通用策略引擎，CNCF 孵化项目\n * gizmo - 微服务工具集\n * MOSN - 用于边缘和服务网格的云原生网络数据平面\n * Erda - 为企业提供 DevOps、微服务治理、多云管理的 PaaS\n * Service Weaver\n * Consul - 服务发现、配置管理中心服务\n * Traefik Mesh - 简单的服务网格\n\n\n# Serverless\n\n * OpenFaaS - Serverless Functions Made Simple(功能服务化的 FaaS 框架)\n * faasd - 轻量级 FaaS 引擎\n * fn - 事件驱动的 FaaS\n * riff - 基于 Kubernetes 的 FaaS\n * Nuclio - 实时事件与数据的 Serverless 框架\n * Flogo - 事件驱动的 Serverless 框架\n * Dapr - 微软开源的云和边缘计算的微服务构件\n * kubeless\n * Fission - 基于 Kubernetes 的 Serverless\n * pulumi\n * Knative\n * fx\n * IronFunctions\n * schollz/faas - 让任何包的函数变成一个 HTTP 接口\n * Vanus - 无服务事件流处理系统\n\n\n# devops\n\n * act - 本地运行 GitHub Actions\n\n\n# 持续集成/部署\n\n * CDS - 持续集成服务\n * gopub\n * CodePub\n * syncd - 代码部署工具\n * Drone - 基于 Docker 的持续发布平台\n * Cyclone - 持续集成&发布平台\n * tbls - 用于记录数据库文档的 CI 友好工具\n * Woodpecker - Fork 自 Drone\n * Dagger - 基于容器的 CI/CD 工具\n\n\n# Git\n\n * gogs - 类似于 GitLab 的 Git 服务器\n * Gitea - 由 gogs 分叉出的 Git 服务器\n * go-git - Go 实现的 Git 操作\n * gitin - commit/branch/status explorer for git\n * hub - GitHub 命令行工具\n * git-o-matic - 一个监控 Git 仓库变化和自动 pull/push 的工具\n * gitbase - SQL 的方式查询 Git 日志\n * git-chglog - CHANGELOG 管理工具\n * chglog - CHANGELOG 管理工具\n * lazyhub - GitHub 的终端 UI 客户端\n * goaction - 在 Go 中编写 GitHub Action\n * bit - Git 命令增强版，支持文件和分支名称自动完成、命令和标志建议\n * go-github - GitHub API 操作库\n * askgit - 通过 SQL 访问 Git 仓库信息\n * git2graph - 根据 Git 仓库提交记录生成结构图\n * lazygit - Git 终端 UI\n * gh-dash - GitHub CLI（gh）漂亮终端面板\n * Soft Serve - 命令行式自托管 Git 服务器\n * Git LFS - 处理大文件的 Git 扩展\n\n\n# 限流器\n\n * Tollbooth - Simple middleware to rate-limit HTTP requests\n * ratelimit\n * RateLimit\n * go-rate\n * Circuit - 熔断器\n * uber-go/ratelimit\n * Sentinel - 阿里巴巴开源的面向分布式服务架构的流量控制组件 Go 语言版本\n * gohalt - 限流\n * gobreaker - 熔断器\n * ulule/limiter\n\n\n# 编译器\n\n * TinyGo - 一个适用于微控制器、WebAssembly 和命令行工具的 Go 编译器\n * minigo - A Go compiler from scratch\n * llir/llvm - LLVM 编译器\n * jit-compiler - JIT 编译器\n * Go+ - 七牛云开源面向数据科学的语言，完全兼容Go语言\n\n\n# 解释器\n\n# 语言解释器\n\n * participle - 通用的自定义语法解析包\n * GopherLua - VM and compiler for Lua in Go\n * go-lua - A Lua VM in pure Go\n * DCLua - Go Lua Compiler and VM\n * otto - JavaScript 解释器\n * goja - ECMAScript 5.1(+) 实现\n * v8go - Execute JavaScript from Go\n * gpython - Python Interpreter on Go\n * Grumpy - 转换 Python 为 Go 代码，谷歌开源\n * starlark-go - Starlark in Go\n * avo - x86 汇编程序构建器\n * wagon - WebAssembly 解释器\n * GopherJS - 把 Go 代码编译成 JavaScript 代码\n * Yaegi - Go 语言解释器\n * properties - Java properties scanner for Go\n * jvm.go - JVM\n * gobasic - A BASIC interpreter written in golang\n * golisp - Lisp 解释器\n * dst - Go Decorated Syntax Tree\n * mvdan/sh - Shell 解析、格式化、接口\n * tdewolff/parse - 通用词法分析器 Lexer，并内置支持解析 HTML/CSS/JSON/XML/JS/SVG 语法\n * Joker - Clojure\n\n# PHP\n\n * z7zmey/php-parser - PHP AST 语法解析\n * deuill/go-php - PHP bindings for Go\n * goridge - High-performance PHP-to-Golang IPC bridge\n * RoadRunner - 高性能PHP应用服务器，支持负载均衡及进程管理\n * VKCOM/php-parse - PHP AST 语法解析\n\n# 自定义解释器\n\n * CUE - Configure Unify Execute(Validate and define text-based and dynamic configuration)\n * cel-go - Common Expression Language(CEL 的 Go 实现)\n * Math-Engine - 使用 Go 实现的数学表达式解析计算引擎库，学习语法解析很适用\n * Gval - 表达式计算\n * expression-parsing\n * goexp - Recursive descent expression parser in Go\n * goastch - Go AST 语法解析\n * tdop\n * swallow\n * Anko\n * Expr - 编译&执行字符串中的表达式\n * Tengo - 用 Go 编写的脚本语言\n * V - Go 编写的语言\n * kumarUjjawal/bison\n * Monkey\n * govaluate\n * Compiler - 将自定义语法代码编译成 X86-64 Assembly\n * elvish - 交互式 Shell 语言\n * QLBridge - Go SQL Runtime Engine\n * YQL - SQL WHERE 风格的规则引擎\n * Flux - InfluxDB 数据语言\n * Spiker - Go 编写的简单规则表达式执行器，支持自定义函数和流程控制，适用于业务规则复杂的场景\n * gocc - 解析器生成器，可以将指定的文法转换为 Go 语言的解析器程序代码，用于编译和解析特定类型的源代码\n\n\n# 代码生成\n\n * jennifer - Go 代码生成\n * ifacemaker - 根据结构体方法生成接口\n * gg - Go 代码生成\n\n\n# 编辑器\n\n * micro - 基于终端的编辑器\n * sourcegraph - 代码搜索&导航\n\n\n# 运行器\n\n * gore - 在线运行 Go 代码\n * nodebook - 在线运行多种语言\n * go-pry - 像 Python、R、PHP 等在终端交互式输入与运行 Go 代码\n\n\n# 查询语言\n\n * graphql - Go 实现的 GraphQL\n * graphql-go\n * GQLEngine - 基于 graphql-go 实现\n * RQL - REST 资源查询语言\n * Thunder - GraphQL 服务构建框架\n * gqlgen - 构建 GraphQL 服务器的包\n * super-graph - 无需编写代码即可在 Go 项目中构建复杂的 GraphQL API\n\n\n# 游戏相关\n\n * Nano - 游戏开发框架\n * Leaf\n * einx\n * CloudRetro - 游戏云服务框架\n * G3N - Go 3D Game Engine\n * Ebiten - 2D 游戏库\n\n\n# 桌面开发\n\n# GUI\n\n * Lorca - 用 Go 编写 HTML5 桌面程序，依赖 Chrome 进行 UI 渲染，但却不把 Chrome 打包到应用中\n * webview - 用 Go/C/C++ 构建跨平台的桌面软件\n * walk - Windows GUI toolkit\n * go-gtk - Go bindings for GTK\n * andlabs/ui - Platform-native GUI library for Go\n * fyne - Material Design 风格的 GUI\n * go-gl - Go bindings for OpenGL (generated via glow)\n * therecipe/qt - 基于 Qt 的跨全平台 UI 包\n * giu - 基于 Dear ImGui 的跨平台 GUI 框架\n * go-app - 一个 WebAssembly 框架，用于使用 Go，HTML 和 CSS 构建 GUI 应用\n * wails - 使用 Go 和 Web 技术创建桌面应用程序\n * chromedp - 纯 Go 语言实现的驱动浏览器的 Chrome DevTools Protocol，可用于爬虫、反爬虫、测试等场景\n * Rod - 一个为简化自动化和爬虫设计的 devtools driver，利用浏览器的 devtools 可编程接口来操控浏览器\n * go-astilectron - 基于 Electron 的跨平台开发\n * Gio - 跨平台 UI 框架，支持移动应用\n * nucular - 基于 Gio 的实现\n * GoVCL - 跨平台的 GUI 包\n * vugu - WebAssembly UI 框架\n * GoGi - 2D/3D GUI 框架\n * systray - 跨平台支持菜单栏管理\n * go-flutter - 绑定 Flutter 到桌面应用\n * NuxUI\n\n# 桌面辅助包\n\n * pkg/browser - 在浏览器中打开文件、URL\n * MacDriver - macOS 原生 API\n * gon - 为 macOS 签名和公证\n\n# 桌面应用\n\n * xbar - 基于 Wails.app 开发的 macOS 菜单栏管理\n * 阿里云盘小白羊版 - UI由Flutter构建\n\n\n# 移动端\n\n * golang/mobile - Go support for Mobile devices\n\n\n# 协程/线程\n\n * ants - 协程池\n * tunny\n * go-workers - 安全地并发运行一组 worker，通过 channel 进行输入输出\n * Machine - 受 errgroup.Group 启发的协程管理\n * thread\n * conc - 更好用的结构化并发控制\n * zeropool - 零回收、类型安全的协程池\n * workerpool - 无阻塞队列任务池\n * pond - 协程池\n\n\n# 任务/定时器\n\n * RxGo - Go 版 ReactiveX，简单方便的处理异步数据流\n * Grift - Go based task runner\n * cron - a cron library for go\n * gocron - 任务定时调度器\n * jobrunner\n * CurlyQ - 后台任务处理库\n * overtalk/task - 任务的管理&执行，支持自定义次数的重发\n * PPGo_Job - 定时任务管理系统\n * gocelery - Celery 的 Go 语言实现\n * Machinery - 通过分布式消息实现异步任务调度\n * dkron - 分布式任务调度系统\n * Grit - 基于 MultiTree 实现的任务管理\n * Asynq - 异步分布式任务队列\n * cronsun - 分布式任务系统\n\n\n# 流处理\n\n * benthos\n * gostream\n * watermill\n * go-streams\n * goflow\n * Cadence (Cadence Web UI) - Uber开源的分布式工作流引擎，主要用于微服务编排和分布式事务等场景\n\n\n# 微信\n\n * weapp - 微信小程序 SDK\n * wechat - WeChat SDK for Go\n * wechat-go - 微信 Web 版 API 的 Go 实现\n\n\n# SDK\n\n * gopay - QQ、微信（WeChat）、支付宝（AliPay）的Go版本SDK\n * alipay - 支付宝SDK\n\n\n# 区块链\n\n * Hyperledger Fabric - 基于区块链的超级账本\n * go-ethereum - 以太坊协议的官方 Go 语言实现\n * bbgo - 用 Go 编写的加密货币交易框架\n * btcd - 比特币实现\n\n\n# 开发辅助包\n\n * cvt - 任意数据类型转换，支持自定义类型、提取结构体字段和值\n * copier - struct 之间拷贝值\n * cast - 数据类型转换\n * diff - 结构体&值比较\n * go-extend\n * com - 工具包\n * php2go - Go 实现的 140+ 个 PHP 函数功能包\n * gommon - Common packages for Go\n * reflect2 - reflect api without runtime reflect.Value cost\n * mapstructure - 将 map 值转换到结构体中\n * naza - Go语言基础库\n * automaxprocs - 自动设置 GOMAXPROCS\n * c2go - 将 C 代码转换为 Go 代码的工具\n * rnm - 代码重构辅助工具\n * memviz - 图形化数据结构\n * underscore.go\n * go-testdeep - 非常灵活的深度比较包，扩展了 Go 测试包\n * go-model - struct 操作包\n * concurrent-map - 并发安全 map\n * goleak - 检测 goroutine 泄漏\n * guregu/null - SQL/JSON的null处理包，提供替代类型\n * stats - 标准数字统计\n * Chronos - 静态竞争检测器\n * collection - 替代原生的 Slice\n * rf - 代码重构工具\n * bytebufferpool - byte buffers pool\n * bpool - byte buffers pool，支持 bytes.Buffers\n * mergo - 合并结构体和字典数据\n * go-funk - 基于反射实现的常用函数\n * lo - 基于 1.18+ 泛型的常用函数\n * juniper - 基于泛型实现常用的容器、迭代器、数据流等功能\n * mergo - 合并结构体和字典\n * xstrings - 字符串相关函数\n * pie - slice/map 链式处理\n\n\n# 代码生成\n\n * ChimeraCoder/gojson - 根据 JSON 生成结构体\n * db2struct - 根据表结构生成结构体\n * smallnest/gen - 根据表结构生成结构体\n * sqlc - 根据 SQL 语句生成 Go 代码\n * xo - 根据表结构或查询语句自动生成 Go 代码\n\n\n# 系统开发\n\n * LinuxKit - 为容器构建安全、便携、可移植操作系统的工具包\n * go-systemd - 绑定 systemd\n * Lima - Linux-on-Mac ("macOS subsystem for Linux", "containerd for Mac")\n * gopher-os - 一个兼容 Linux 的 64 位 POSIX 风格系统\n * gouring - 不依赖 CGO 实现系统调用\n\n\n# 未归类\n\n * go-playground - 比官方更好用的 Go Playground\n * Robotgo - Golang 跨平台自动化系统，控制键盘鼠标位图和读取屏幕，窗口句柄以及全局事件监听\n * go-homedir\n * i18n - i18n 多语言工具包\n * go-i18n - 多语言工具包\n * Paginater - 分页工具\n * gls - Goroutine local storage\n * mcuadros/go-version - 版本号比较\n * go-semver - 语义版本\n * semver - 另一个语义版本\n * hashicorp/go-version\n * Metabolize - Decodes HTML meta tags into a Golang struct\n * otp - 一次性密码工具包(One Time Password utilities)\n * misspell - 常拼写错误的英语单词\n * CRDT - CRDT(Convergent and Commutative Replicated Data Types)最终一致性算法的实现\n * script - Making it easy to write shell-like scripts in Go\n * sysadmin-utils\n * licenseclassifier - 识别文件中的 LICENSE 类型\n * go-license-detector\n * rose - 在 HTML 中嵌入和运行 Go 代码\n * esbuild - JavaScript 构建打包工具\n * clipboard - 剪切板\n * clipboard - 剪切板\n * clipboard - 剪切板\n * Timeliner - 搜集整理个人在社交网站上的数据并索引成时间线\n * hc - HomeKit 平台开发框架\n * address - 地址处理库，支持多国语言\n * webhook - 可执行 Shell 命令的 Web Hook 服务\n * webhookd - 为 Shell 脚本提供 Web Hook 服务\n * go-cid - CID spec Go 语言实现\n * gorush - APP 消息通知服务\n * EventBus - 事件总线\n * go-winio - 为 Win32 IO 操作提供接口支持\n * fq - 以 jq 语法读取二进制数据/文件\n * lego - Let\'s Encrypt client and ACME library\n\n\n# logo\n\n * Gophers\n\n\n# 工具\n\n * syndbg/goenv - Go 版本管理\n * wfarr/goenv - Go 版本管理\n * gvm - Go 版本管理\n * GoLand - IDE 软件\n * Visual Studio Code\n\n\n# 资源站点\n\n * Go 101\n * Go 语言中文网\n * Golang 中国\n * go-zh\n * Golang sizeof tips - 输入结构体定义，会显示内存布局\n * Golang Programs\n * Golang bot',normalizedContent:'> go 语言优秀资源整理，为项目落地加速🏃\n> \n> 转载分享，出处如下，谢谢 😆\n> \n> 原文地址: https://shockerli.net/post/go-awesome\n> \n> github: https://github.com/shockerli/go-awesome\n\n----------------------------------------\n\n> 官网: https://golang.org\n> \n> 国内官网镜像(访问快): https://golang.google.cn\n> \n> github: https://github.com/golang/go\n> \n> 开发者平台: https://go.dev\n> \n> wiki: https://github.com/golang/go/wiki\n> \n> 官方博客: https://blog.golang.org\n\n\n# 指导原则\n\n * 简单性\n   \n   > 复杂性把可读的程序变得不可读，复杂性终结了很多软件项目。\n\n * 可读性\n   \n   > 代码是给人看的，代码阅读时长远超编写。程序必须可维护，那可读是第一步。\n\n * 生产率\n   \n   > 拥有众多的工具集和基础库，可以很简单方便的完成绝大多数工作。 编译速度足够快，拥有动态语言的高效，但却不会面临动态语言不可靠的问题。 自带编程规范，使得团队代码一致，也帮助开发者发现和避免潜在的错误。\n\n\n# awesome\n\n * github topic for go\n * awesome go\n * golang-open-source-projects - 含描述的中文版 awesome go\n * awesome go storage - go 存储相关开源项目\n * awesome-go-china - 专门收集华人写的开源项目\n * go patterns - go 版本的设计模式\n * sevenelevenlee/go-patterns - 设计模式\n * gof 设计模式\n * greyireland/algorithm-pattern - 算法模板\n * go-algorithms - go 版本的数据结构和算法\n * go 学习之路 - go 学习资料汇集\n * go 开发者路线图\n * reposhub-go\n * visualgo - 数据结构和算法动态可视化\n\n\n# 大牛/组织\n\n> go 语言方面的大牛，或者优秀 go 项目的组织\n\n\n# 大牛\n\n * mattn - 写了数百个 go 项目，盛产优质项目\n * unknwon - gogs/macaron 等项目作者，《the way to go》译者\n * jinzhu - gorm/qor 等作者\n * valyala - fasthttp/fastjson 等作者\n * vmihailenco - go-redis/go-pg 等作者\n * kataras - iris 作者\n * bep\n * spf13\n * tidwall\n\n\n# 组织\n\n * gorilla web toolkit\n * loov\n * hashicorp\n * lestrrat-go\n * uber - open source software at uber\n * stretchr - tame your unstructured data\n * containous\n * charm - 提供一系列优秀的命令行工具和库\n\n\n# 文档\n\n * proposing changes to go - go 语言设计文档\n * go 语言设计与实现\n * go 语言原本\n * go 101 （中文版）\n * go 官方入门指南\n * go 语言高级编程\n * go 专家编程\n * go 编程语言\n * golang 标准库文档(官方/中文)\n * go 语言标准库 在线阅读\n * 《the way to go》中文版\n * go 语言圣经（中文版）\n * go语言入门教程\n * go 实战开发\n * go web 应用开发\n * go 学习技能树\n * 实效 go 编程\n * go 语言语法详解笔记\n * go 语言学习资料与社区索引\n * go database/sql tutorial\n * go 命令教程\n * 深入解析 go\n * go 语言博客实践\n * 学习 go 语言\n * go2编程指南\n * go database/sql tutorial - go 数据库(database/sql)开发使用教程\n * go web examples - go web 开发示例\n * go assembly - 通过示例介绍 go 汇编功能\n * ultimate go - 终极 go 学习指南，包含大量文档化的代码和程序分析\n * go 教程 - 腾讯云开发者手册\n * golang 开发笔记\n * golang-notes - go 源码阅读笔记\n * the little go book （中文版）\n * learning go — from zero to hero\n * go-internals - 深入理解 go\n * learn go with tests\n * go基础教程\n * 7天用go从零实现系列\n * go 语言高性能编程\n * golang - 100天从新手到大师 - 某培训机构的部分教程内容\n * hoanhan101/algo - 107+ 编码面试问题，包括详细的解决方案，测试用例和程序分析\n * over-golang - go 学习笔记\n * over-algorithm - go 算法笔记\n * learngo - 1000+ go 示例、练习和测试\n * go-leetcode - leetcode 实现\n * 玩转 go - 《mastering go》中文译本\n * leetcode-cookbook - leetcode in go\n * golang修养之路\n * go语法树入门\n * go concurrency patterns - go 并发模式场景集合\n * yezihack/algo - 数据结构与算法\n * golang-cheat-sheet-cn - github上最流行的golang代码速查表中文翻译版本\n\n\n# 指南\n\n * uber go style guide\n * the go programming language specification （中文老版）\n * 实效 go 编程\n * go code review comments\n * go code convention\n * go faq 101\n * go details 101\n * go tips 101\n * go quizzes 101\n * go-advices\n * go-perfbook - 编写和优化go代码\n * practical go: real world advice for writing maintainable go programs （go 语言实践：编写可维护的程序的建议）\n * go 安全指南 - 腾讯发布的《代码安全指南》go 语言篇\n * go concurrency guide\n * go recipes - 一些技巧\n\n\n# 文章\n\n * go training - 大量优质 go 相关文章、视频等资料\n * go语言爱好者周刊\n * go 夜读 - go 标准包、开源项目源代码阅读讲解\n * go-questions - go 语言学习入门和进阶知识\n * go的50度灰：golang新开发者要注意的陷阱和常见错误\n * go 程序的性能优化及 pprof 的使用\n * gops - go语言程序查看和诊断工具\n * go源码分析——http.listenandserve()是如何工作的\n * goconvey 框架使用指南\n * gostub 框架使用指南\n * gomock 框架使用指南\n * monkey 框架使用指南\n * the evolution of a go programmer - go 程序员的进化之路\n\n\n# 付费教程\n\n * 基于 go 语言构建企业级的 restful api 服务 - 掘金小册\n * go语言核心36讲 - 极客时间\n\n\n# 成品项目\n\n * shiori - 书签管理\n * studygolang - go 语言中文网\n * mkcert - 生成本地 https 加密证书的工具\n * cfssl - cloudflare 开源的 pki 和 tls 工具集\n * rainbond - 基于docker、kubernetes等容器技术的开源paas\n * nyadb2 - go 实现的关系型数据库, 值得用于学习\n * eiblog - 博客\n * pan-light - 不限速的百度网盘客户端, 基于 go + qt5 开发\n * baidupcs-go - 百度网盘客户端（命令行）\n * daily-warm - 每天定时发邮件给你关心的人\n * pipe - 博客平台\n * mdr - 命令行下的 markdown 阅读工具\n * miniflux - feed 阅读器\n * golinks - 创建自定义书签、命令、搜索等\n * 链滴笔记 - 桌面端笔记应用\n * wayback - 网页快照备份\n * bbs-go - 开源社区\n * openscrm - 基于go和react的企业微信私域流量管理系统\n * answer - 问答社区\n * listmonk - 资讯、邮件列表管理工具（web）\n * 1panel - linux 服务器运维管理面板\n * artalk - 自托管评论系统\n * memos - 笔记服务，具有移动客户端、浏览器扩展等生态\n\n\n# 静态网站生成器\n\n * hugo\n * jrnl\n * plenti\n * verless\n * ink\n * moul - 生成照片站点\n * zas\n\n\n# 学习项目\n\n * 1m-go-websockets - 该项目演示了如何用 go 编写一个可以提供超过一百万个 websockets 连接、运行内存小于 1gb 的服务器\n * go by example - 通过实例学习 go\n * iam - 身份识别与访问管理系统（教学项目）\n * 100-go-mistakes - 100 个 go 常见错误\n\n\n# 开源类库\n\n\n# web 框架\n\n * macaron - 一款具有高生产力和模块化设计的 go web 框架 国产\n * beego - 一个使用 go 的思维来帮助您构建并开发 go 应用程序的开源框架 国产\n * gin - 轻量 web 框架\n * iris - web 开发框架\n * revel\n * echo\n * faygo - 国产\n * teleport - socket 框架\n * goframe - 国产\n * qor - 系列应用开发组件包\n * dotweb - 国产\n * rest layer - rest api framework\n * honeytrap\n * ponzu\n * utron\n * muxie\n * buffalo - 快速生成 web 项目的开发工具\n * go-web-framework-benchmark\n * fiber - 一种 express 风格的、基于 fasthttp 的 http web 框架\n * aah\n * go-zero - 好未来开源的 web 框架\n * pingcap/fn - 支持绑定任何方法，构建成 post+json 接口\n * flamego - unknwon 开发的又一款 web 框架\n * rest layer - rest api 框架\n * rk-boot\n\n\n# 业务框架\n\n * yao - 使用 json 即可创建数据库模型、编写 api 接口、描述管理后台界面的应用引擎\n * goadmingroup/go-admin - 后台管理快速开发框架，与 laravel-admin 类似\n * wenjianzhang/go-admin - 基于 gin + vue 实现的后台框架\n * gin-vue-admin - 基于 gin + vue 实现的后台框架\n * goxygen - 基于 go, react, mongodb 技术实现的全栈应用生成器\n * nging - go语言通用后台管理框架\n * snake - 业务api框架\n * pocketbase - 带有后台管理面板、文件和权限管理、集成 sqlite 数据库的单一文件后端服务开发框架，支持 dart 和 js sdk 快速开发 app\n * dotenx - 低代码框架\n\n\n# 项目骨架\n\n * standard go project layout - go 项目目录结构示例\n * go-starter - adobe 的 go 工程模板\n * go-clean-arch\n * go-rest-api - go restful api starter kit\n * create go app cli - 通过命令行创建前后端项目的开发骨架\n * clean-gin - 基于 gin 构建的整洁架构项目骨架\n * golang-repo-template - 一个包含了很多实践的项目模板\n\n\n# ddd 框架\n\n * wild workouts - ddd、整洁架构、cqrs的示例项目\n * clean architecture in go - 整洁架构示例\n * freedom - 基于六边形架构的框架\n * esim - 基于六边形架构的微服务框架\n * go-cleanarch - go 整洁架构规则校验工具\n\n\n# tcp 框架\n\n * zinx - tcp并发服务器框架\n\n\n# 中间件\n\n * negroni - web 中间件\n * csrf - csrf 中间件\n * handlers - a collection of useful handlers for go\'s net/http package\n\n\n# 并发\n\n * sizedwaitgroup - 并发控制\n * concurrent - concurrency utilities\n\n\n# 命令行\n\n# 参数解析\n\n * urfave/cli - 命令行程序构建工具\n * cobra - 命令行构建包\n * flaggy - 命令参数解析\n * pflag - 命令行参数处理\n * kong - 命令行解析\n * clop - 命令行解析包\n * go-flags - 命令行参数解析\n * mow.cli\n * go-arg - 基于结构体tag解析命令行参数\n\n# 输出展示\n\n * progressbar - 在终端上输出进度条\n * cheggaaa/pb - 终端进度条\n * mpb - 支持多个进度条\n * color - 命令行文字颜色\n * gookit/color - 命令行色彩使用库\n * termui - 终端仪表盘\n * tui - 终端 ui\n * termenv - 终端应用程序的高级 ansi 样式和颜色支持\n * asciigraph - 在终端中绘制 ascii 字符的图表\n * spinner - 涵盖70多种符号或进度条的控制器\n * tablewriter - 终端中输出表格内容\n * pixterm - 在命令行终端中绘图\n * wtf - 一个命令行的信息仪表盘，可以定制显示内容\n * termdash - 基于 go terminal 的仪表板系统\n * bubbles - tui 组件\n * bubbletea - tui 框架\n * pterm - 支持图表、表格、进度条、树等终端输出展示\n * lip gloss - 终端布局、样式\n * gum\n * glow - 终端渲染展示 markdown\n * slides - 终端渲染展示 markdown\n * tview - terminal ui\n * asciiplayer - 在终端中通过 ascii 输出图片或视频，支持 png、jpeg、gif、mp4、avi 等格式\n * go-pretty - 终端渲染表格、列表、进度条等\n * tcell\n\n# 其他\n\n * gosu - 以指定的用户权限来运行脚本\n * gotop - 类 top 系统监控显示\n * go-colorable - colorable writer for windows\n * go-isatty - tty 环境判断\n * fzf - 终端模糊查询神器，支持多平台\n * go-daemon - daemon 进程包\n * go-prompt - 命令行交互式输入\n * peco - 交互式过滤工具\n * pty - pty for go\n * vtclean - 从终端输出字符串中解析出纯文本\n * survey - 交互式输入\n\n\n# 终端工具\n\n * vgrep - 支持滚动分页的 grep\n * gotty - 基于web的命令行实时共享\n * jump - 根据习惯快速跳转目录\n * gofish - 一个受 homebrew 启发的跨平台软件管理工具，支持 linux 和 windows\n * viddy - 增强版 watch 命令\n * miller - 一个类似 sed、awk、cut、join 和 sort 的工具，用来处理基于命名索引的数据\n * assh - ssh 增强工具\n * duf - 比 df 更好用的磁盘使用率工具\n * ov - 终端文本阅读器，可替代 less、more、tail -f 等\n * trdsql - 可对 csv/ltsv/json/tbln 等文件执行 sql 查询和导出\n * vhs - 终端录像工具，提供了在终端中录制和回放终端会话的功能，类似于将终端会话记录为视频的方式\n\n\n# 路由\n\n * httprouter\n * mux - url 路由和调度器\n * chi\n * gocraft/web\n * go-querystring - 转换结构体为url请求参数\n * gorilla/schema - converts structs to and from form values\n * clevergo\n * rewrite - rewrite 中间件\n * bunrouter - 支持中间件、错误处理、路由优先级、兼容 net/http 接口\n\n\n# 网络\n\n * dns - dns 库\n * coredns - dns 服务器\n * roadrunner - php 应用服务器、进程管理器、负载均衡，用于替代 nginx + fpm\n * frankenphp - php 应用服务器\n * goreplay - 流量收集&回放\n * sharingan - 滴滴开源的流量录制回放工具\n * glorp - http 拦截&重放的 cli 工具\n * p2pspider - 种子嗅探器\n * torrent - bittorrent 相关工具库\n * rain - bittorrent 客户端和库\n * httpteleport - teleports 10gbps http traffic over 1gbps networks\n * find3 - wifi 设备发现\n * subfinder - 子域名发现工具\n * ggz - 短网址服务\n * httpstat\n * grab - 文件下载\n * go-getter - 可使用 url 作为输入的主要形式从各种来源下载文件或目录\n * go-netty - 网络框架\n * gnet - 事件驱动 go 网络框架\n * netpoll - 专注于 rpc 场景的 non-blocking i/o 网络库\n * httplab - the interactive web server\n * yamux - multiplexer\n * sftp - sftp support for the go.crypto/ssh package\n * goftp - ftp 客户端\n * sftpgo - 功能齐全且可高度配置的sftp服务器，可选择支持http/s、ftp/s和webdav。支持的存储后端包括：本地文件系统、加密的本地文件系统、s3（兼容）对象存储、google cloud storage、azure blob storage以及其他sftp服务器。\n * evio - 事件驱动网络框架（reactor 模式）\n * gaio - 事件驱动网络框架（proactor 模式）\n * httpretty - 在终端上漂亮地打印出 http 请求\n * blocky - 作为局域网 dns 代理拦截广告\n * lossy - 模拟 net.packetconn 和 net.conn 接口的带宽，延迟和数据包丢失\n * go-libp2p - p2p\n * go-ipfs-api - ipfs\n * gomobile-ipfs - 为移动终端提供ipfs网络访问支持\n * go-multiaddr - multiaddr\n * kcp-go - 可靠的 udp 通讯包\n * gliderlabs/ssh - 像 net/http 一样轻松搭建 ssh 服务器\n * netaddr - 网络地址处理\n * sx - 网络扫描命令工具\n * echoip - ip 地址查找服务\n * easytcp - tcp server 框架\n * gopacket - 网络捕获抓包\n * croc - 两台电脑之间传输文件\n * cmux - 监听同一个端口，启动多种协议服务\n * geoip2 reader for go - 解析&读取 maxmind geolite2 和 geoip2 数据库\n * dns.toys - dns 服务器\n * apache traffic control - cdn 流量控制\n * nexttrace - 可视化路由追踪工具\n * pget - 文件下载工具，可多连接下载\n * cloudflarespeedtest - 测试 cloudflare cdn 延迟和速度，获取最快 ip\n\n# ldap\n\n * go-ldap\n * glauth - ldap server\n * gldap - ldap service\n\n# 网络代理\n\n * caddy - 类似 nginx 的 web 服务器\n * traefik - 反向代理&负载均衡\n * snail007/goproxy - golang 实现的高性能代理服务器\n * proxypool - 采集免费的代理资源为爬虫提供有效的ip代理\n * frp - 可用于内网穿透的高性能的反向代理应用\n * nps - 一款轻量级、高性能、功能强大的内网穿透代理服务器\n * pomerium - 基于身份的反向代理\n * v2ray\n * v2fly - v2ray 的社区版本\n * tailscale - wireguard 解决方案\n * clash - 支持多种协议的多平台代理客户端\n * elazarl/goproxy - http 代理\n * oxy - go middlewares for http servers & proxies\n * ouqiang/goproxy - go http(s)代理库, 支持中间人代理解密https\n * pgrok - 提供给穷人的内网穿透\n\n\n# http压测\n\n * vegeta - http 负载压测工具\n * hey - web 压测工具\n * bombardier - web 压测工具\n * go-wrk\n * plow\n * ddosify\n\n\n# http\n\n * fasthttp - 比 net/http 快 10 倍的 http 工具包\n * resty - http & rest 客户端包\n * gout - http 客户端\n * gentleman - http 客户端\n * goz\n * useragent - 解析 http user agent\n * purell - url 规范工具包\n * go-autorest - http 管道请求方式的客户端\n * req - http 客户端\n * cors - cors handler\n * certmagic - 为任意 go 程序自动加上 https，tls 证书签发、更新全自动\n\n\n# websocket\n\n * gorilla/websocket\n * nhooyr/websocket - 官方推荐的包\n * websocketd - go 开发的一键搭建 websocket 服务器命令行工具\n * ws - websocket 开发包\n * melody - websocket 服务框架\n * neffos - 一个快速且可扩展的 websocket 框架\n * fastws\n\n\n# 即时通信\n\n * centrifugo - 实时消息服务器，可以与任何语言编写的应用程序后端结合使用\n * goim - 支持集群的 im 及实时推送服务\n * tinode - 即时消息服务器，通过 websocket/json 或 grpc/tcp 等协议传输\n * webrtc - webrtc 实现\n * berty - 安全的点对点通讯软件\n * keybase - 即时通讯工具 keybase 全平台客户端\n * gotify - 基于 websocket 的 push 通知服务\n * nakama - 用于社交/实时游戏/实时应用的分布式服务端程序，自带面板、用户、聊天、存储、社交等功能\n * openim\n\n\n# 网关\n\n * goku api gateway ce - eolinker 开源的 api 网关\n * easegress\n * manba\n * tpk\n * bfe - 基于百度统一接入前端开源的七层流量接入系统\n\n\n# 序列化\n\n * vmihailenco/msgpack - 支持 msgpack\n * go/codec - 支持 msgpack/binc/cbor/json\n * golang/protobuf - go 版本的 protocol buffers\n * gogo/protobuf - golang/protobuf 的扩展替代品\n * objx - 操作 map, slice, json 等数据的包\n * msgp - messagepack 代码生成器\n * buf - protoc 替代品\n * protoc-gen-doc - google protocol buffers 文档生成插件，支持 html、json、docbook、markdown 和自定义模板\n\n\n# 解压缩\n\n * snappy - go 语言版本的 snappy\n * cae - 实现 zip/tar.gz 解压缩\n * archiver - 多格式支持的解压缩包\n * compress - optimized compression packages\n * brotli\n * xz - xz 压缩格式读写包\n\n\n# rpc\n\n * grpc-go - grpc 官方包\n * go grpc middleware - grpc 常用中间件\n * gorpc\n * gorilla/rpc - 构建基于 http 的 rpc 服务，比如 json-rpc\n * lile - grpc 服务构建包\n * rpcx\n * twirp - 基于 protobuf 的 rpc 框架，与 grpc 类似\n * dubbo-go - dubbo go 版本\n * kitex\n * grpcurl - 像 curl 一样通过命令行访问 grpc 服务\n * protoc-gen-doc - 文档生成插件\n * grpc-gateway - 读取 grpc 服务定义并生成一个反向代理服务器，同时提供 grpc 和 restful 风格的 api\n\n\n# 邮件\n\n * gomail - 邮件发送包\n * scorredoira/email\n * hermes - go 版本的 mailgen 引擎，根据配置生成 html 格式的邮件\n * go-guerrilla - smtp 邮件服务器\n * mailhog - 基于web和api的smtp测试工具\n * maddy - 邮件服务器\n * jordan-wright/email\n * mox - 邮件服务器\n * pop - 邮件发送工具，支持交互式和参数式\n * email-verifier - 邮箱校验，无需发送邮件\n\n\n# 消息队列\n\n * nsq - 实时分布式消息平台\n * nats - 云原生消息中间件\n * amqp - amqp 0.9.1 客户端\n * sarama - kafka 客户端\n\n\n# 文件/存储\n\n * minio - 对象存储服务器\n * rclone - 不同云存储之间同步文件\n * syncthing - 文件同步\n * fsnotify - 文件系统监控工具\n * reflex - 监听文件变更并执行命令\n * gohttpserver - http 静态文件服务器\n * xlsx - excel 读写包\n * excelize - 360 开源的 excel 工具包\n * gopdf - pdf 生成\n * rsc/pdf - pdf reader\n * seaweedfs - 分布式文件系统\n * go-fastdfs - 分布式文件存储服务\n * dragonfly - 基于 p2p 的分布式文件系统\n * filetype - 检测文件类型\n * afero - 文件操作包\n * fsync - 文件/目录同步\n * filebrowser - web file browser\n * bigfile - 文件传输管理系统\n * filetype - 文件类型与 mime 检测\n * go-app-paths - 跨平台检索目录文件\n * copy - 拷贝文件夹\n * lakefs - 类 git 文件对象存储\n * duplicacy - 无锁云备份工具，支持几乎所有存储方式\n * casaos - 家庭云系统\n * alist - 支持多存储的文件列表程序\n * unipdf - pdf 读写处理\n * mimetype - mime 类型与文件扩展检测\n * gocryptfs - 加密 overlay 文件系统\n * restic - 备份工具，使用现代的加密方法对数据进行安全的备份，支持\n\n\n# 模板引擎\n\n * gotemplatebenchmark - 给各 go 模板引擎做性能测试，当然也就包含了最全的模板引擎包\n * jet - 速度很快\n * amber - html 模板引擎\n * fasttemplate - simple and fast template engine for go\n * quicktemplate\n * mustache\n * ace\n * sprig - 常用模板方法\n * pongo2 - django 语法风格的模板引擎\n * plush\n\n\n# 代码生成\n\n * esc\n\n\n# 文本处理\n\n# markdown\n\n * blackfriday - markdown 解析器\n * lute - 结构化的 markdown 引擎\n * goldmark - markdown 解析器\n * docx2md - 转换 word 为 markdown\n * glamour - 命令行下渲染 markdown\n * go-md2man - 转换 markdown 为 man 手册内容\n * gomarkdown/markdown\n * html-to-markdown - 转换 html 为 markdown\n\n# html/css\n\n * dom - html dom 节点操作\n * obelisk - 保存 web 网页为 html 单页面\n * html2text - html 转 text\n * go-readability - 让 html 可读性更高\n * gomponents - 声明式视图组件，可以渲染成 html5\n * daz - html 组件组合，渲染 html\n * html-strip-tags-go - 去除 html 标签\n * bluemonday - xss 探测\n * cascadia - css 选择器\n * htmlquery - xpath 语法查询 html\n * xmlquery - xpath 语法查询 xml\n * xpath - xpath 语法\n * goquery - jquery 语法查询 html\n * css - css 选择器\n\n# 其他\n\n * go-runewidth - 字符长度计算\n * gpy - go 语言汉字转拼音工具\n * go-hashids - hashids 的 go 版本\n * go-pinyin - 汉语拼音转换工具 go 版\n * mahonia - 字符集编码转换\n * pangu.go - go 版本的 pangu，给中英文之间加空格\n * goorgeous - a go org syntax parser to html\n * sergi/go-diff - go 版本的 diff 工具包\n * sourcegraph/go-diff - go 版本的 diff 工具包\n * chroma - 代码语法高亮\n * syntaxhighlight - 代码高亮\n * kyokomi/emoji\n * enescakir/emoji\n * golang/freetype - freetype font rasterizer\n * prose - natural language processing library\n * minify - web 静态资源压缩(html/js/css/json/xml/svg)\n * inflection - pluralizes and singularizes english nouns\n * autocorrect - 自动给中英文之间加入合理的空格并纠正专用名词大小写\n * bleve - modern text indexing\n * etree - xml 解析&生成\n * go-xml\n * feeds - rss 内容生成\n * gofeed - rss & atom feeds 内容解析\n * sitemap - sitemap.xml 生成\n * yarr - rss 阅读软件\n * gogrep - 通过语法树搜索 go 源码\n * pipeit - 文本转换，清理和提取工具\n * regexp2 - 全功能正则表达式引擎。如果标准库的 regexp 满足不了你，可以尝试使用 regexp2\n * html2article - 基于文本密度的 html2article 实现\n * hostctl - hosts 命令行管理工具\n * go-shellwords - 解析命令行中字段\n * woke - 检查文本文件中是否存在歧视词汇\n * go-password-validator - 密码强度校验器\n * xurls - 从文本中提取 url\n * whatlanggo - 自然语言探测\n * go-enry - 检测编程语言\n * fuzzy - 字符串模糊匹配\n * godlp - 数据脱敏\n * zoekt - 文本搜索引擎\n\n\n# 文档\n\n * swag - swagger for go\n * gin-swagger - swagger for gin\n * go-swagger - swagger 2.0 implementation for go\n\n\n# 数学计算\n\n * decimal - 解决浮点数计算精度问题\n * fixed\n * apd - decimal 包\n * mathfmt - 将 latex 语法的注释转换为数学公式格式\n * q - 量子计算模拟器\n * accounting - 货币格式化\n\n\n# 日期时间\n\n * now\n * when - 自然日期时间解析\n * carbon - carbon 时间处理库的 go 语言实现\n * strftime - 时间格式化\n * dateparse - 解析任意未知格式的时间字符串\n\n\n# 配置\n\n * godotenv - .env 配置文件解析\n * go-yaml/yaml\n * ghodss/yaml\n * toml - toml 解析&编码包\n * ini - ini 配置文件解析\n * viper - 支持 json, toml, yaml, hcl, java 等配置文件\n * fig\n * multiconfig\n * configor\n * envconfig\n * confd - 配置管理工具\n * hcl - configuration language\n * env - 解析 env 环境变量到结构体中\n * configor\n * koanf\n * go-toml - toml\n * butler - adobe 开源的配置管理系统\n * envsubst - 环境变量替换\n\n\n# 爬虫\n\n * crawlab - 基于golang的分布式爬虫管理平台，支持python、nodejs、go、java、php等多种编程语言以及多种爬虫框架\n * colly - 网络爬虫框架\n * pholcus - 支持分布式的高并发、重量级爬虫软件\n * go_spider\n * muffet - 网站链接检查器\n * creeper\n * geziyor - 支持 js 渲染的快速爬虫框架\n * apollo - 一个爬虫工具\n * ferret - 声明式 web 数据抓取\n * gocrawl\n * antch\n * katana - 爬虫&蜘蛛框架\n\n\n# 数据库\n\n# sql解析\n\n * pingcap/parser - 兼容 mysql 的 sql 解析\n * xsqlparser - sql 解析\n * sqlparser - sql 解析\n * vitess-sqlparser - sql 解析\n * dbml-go - dbml 解析\n\n# 分布式事务\n\n * go-saga - saga 分布式事务实现\n * dtm - 跨语言的分布式事务管理服务，支持tcc、saga、xa等\n\n# 数据库相关\n\n * usql - 几乎支持全部 sql 与 nosql 数据库的命令行工具\n * gorm - gorm v2\n   * gorm v1\n   * gorm2sql - 根据 model struct 生成建表语句\n   * gorm-sharding - 基于 conn 层做 sql 拦截、ast 解析、分表路由、自增主键填充，对使用者透明\n * xorm\n * xormplus - xorm 的定制增强版本\n * gorose\n * sqlx - database/sql 扩展包\n * dbq - 数据库操作\n * gendry - 滴滴开源的sql builder\n * ozzo-dbx\n * squirrel - fluent sql builder\n * qb - the database toolkit for go\n * mgo\n   * globalsign/mgo - the mongodb driver for go\n   * mgo使用指南\n * kingshard - mysql proxy\n * soar - 对sql进行优化和改写的自动化工具\n * sqle - sql 审核工具\n * vitess - 用于部署、扩展和管理大型mysql实例集群的数据库解决方案\n * gh-ost - github 开源的在线更改 mysql 表结构的工具\n * sqler - write apis using direct sql queries with no hassle, let\'s rethink about sql\n * gocraft/dbr\n * gaea - 小米开源的基于 mysql 协议的数据库中间件\n * octosql - 支持多数据库的 sql 查询工具\n * goose - 数据库迁移工具\n * migrate - 数据库迁移工具\n * dbmate - 数据库迁移工具\n * ent - an entity framework for go\n * godb - a go query builder and struct mapper\n * go-nulltype\n * go-mysql - mysql 工具集\n * sqlittle - 纯读取 sqlite 文件\n * bifrost - mysql 同步到 redis、clickhouse 等服务的异构中间件\n * elasticsql - 转换 sql 成 elasticsearch dsl\n * pop - 基于 sqlx 封装的数据库 orm 工具\n * rel - modern database access layer for go\n * rdb - redis rdb 文件解析和生成工具，支持转 json、转 aof、寻找 big key、生成 rdb 文件及绘制内存火焰图等功能\n * bytebase - 基于网络、零配置、无依赖的数据库 schema 变更和版本控制管理工具\n * bun - sql 优先的 orm，写 sql 的方式写 go 代码，支持 postgresql、mysql、mssql、sqlite\n\n# 数据库客户端\n\n * go-mysql-driver - mysql 驱动\n * go-mssqldb - mssql 驱动\n * pq - postgresql 驱动\n * mongo-go-driver - mongodb 官方出品的 go 语言驱动\n * qmgo - mongodb 客户端\n * clickhouse-go - clickhouse 官方 go 语言客户端\n * go-clickhouse - clickhouse 客户端\n * go-sqlite3 - sqlite3 驱动\n * gohbase - hbase 客户端\n * redigo - redis 客户端\n * go-redis - redis 客户端\n * rueidis - redis 客户端\n * redsync - 基于 redis 的分布式锁\n * redislock - 基于 redis 的分布式锁\n * tiny rdm - redis 桌面客户端\n\n# 数据库引擎\n\n * etcd - kv 分布式存储\n * influxdb - 时间序列数据库\n * prometheus - 服务监控系统 & 时间序列数据库\n * tstorage - 时间序列数据库\n * thanos - 支持 prometheus 简化部署、高可用、分布式存储\n * cockroachdb - 分布式 sql 数据库\n * cayley - 图数据库\n * radondb - 基于 mysql 研发的新一代分布式关系型数据库\n * tidb - 分布式关系型数据库，兼容 mysql 协议\n * aresdb - uber 开源的 gpu 驱动的实时分析存储&查询引擎\n * leveldb - leveldb 的 go 实现\n * dgraph - 分布式图数据库\n * rqlite - 基于 sqlite 的轻量级分布式关系数据库\n * gaeadb\n * badgerdb - kv 数据库，支持 acid 事务\n * lbadd - 用 go 实现的分布式 sql 数据库\n * go-memdb - 建立在不可变 radix 树上的内存数据库\n * vectorsql - 应用于 iot 和大数据的 dbms 数据库，类似于 clickhouse\n * buntdb - 基于内存的kv数据库，支持磁盘持久化、acid事务\n * tinysql - 迷你分布式关系型数据库\n * tile38 - geo 数据库\n * redcon - 兼容 redis 协议的自定义 redis 服务，采用 buntdb 和 tile38 实现存储\n * genji - 文档内嵌型数据库\n * dolt - 像 git 一样操作数据库\n * rosedb - 简洁、高效的 kv 数据库，支持多种数据结构\n * lindb - 分布式时序数据库\n * mandodb - 一个示例项目，作者介绍如何从零开始实现一个小型的时序数据库\n * go-mysql-server - 解析 mysql 协议并优化 sql 的数据库引擎\n * milvus - 向量数据库\n * ferretdb - mangodb 替代品\n * lotusdb - 快速 kv 存储引擎，兼容 lsm 和 b+ 树\n * nutsdb - 可持久化、事务的内嵌 kv 数据库\n * olric\n\n\n# 缓存\n\n * gcache\n * bbolt - key/value store\n * bigcache\n * go-cache - kv 内存缓存\n * gomemcache - memcache 客户端\n * cache2go\n * ristretto\n * fastcache\n * freecache\n * godis - go 语言实现的 redis 服务器和分布式集群\n * groupcache - 分布式缓存\n * cachego - 支持 redis、bolt 等缓存接口\n * diskv - 基于硬盘的 kv 存储\n * pebble - 被 cockroachdb 使用的 kv 存储\n\n\n# 搜索推荐\n\n * wukong - 全文搜索引擎\n * go-elasticsearch - 官方 es 客户端\n * elastic - elasticsearch 客户端\n * go-mysql-elasticsearch - sync mysql data into elasticsearch\n * gse - go 语言分词\n * sego - go 中文分词\n * gojieba - "结巴"中文分词的 go 语言版本\n * riot - 全文搜索引擎\n * simplefts - 超简单的全文搜索引擎实现\n * blast - 全文搜索(archived)\n * fuzzy search - 文本模糊搜索\n * gorse - 单节点训练和分布式预测推荐系统引擎\n * gofound - 全文搜索引擎\n * zincsearch - 全文搜索引擎\n * bluge - 文本分词\n\n\n# 表单\n\n * validator\n * ozzo-validation - 使用代码指定规则，而非tag\n * go-tagexpr - 字节跳动开源的结构体标签表达式解释器\n * govalidator\n\n\n# auth\n\n * casbin - 权限控制管理\n * pam-ussh - uber\'s ssh certificate pam module\n * jwt-go - jwt for go\n * kataras/jwt - jwt 轻量级实现\n * cristalhq/jwt\n * sessions - 后端 session 服务\n * securecookie - cookie 加密/解密\n * goth - multi-provider authentication for go\n * branca - 号称比 jwt 更安全的 token 解决方案\n * gin-jwt - gin 框架的 jwt 中间件\n * authboss - web auth 系统\n * zitadel - 身份认证系统，支持各种认证模式\n\n\n# 加密/解密\n\n * 2fa - two-factor authentication on the command line\n * age - 文件加密工具（库）\n * circl - cloudflare interoperable, reusable cryptographic library\n\n\n# 视频\n\n * goav - ffmpeg 视频处理\n * lal - 直播流媒体网络传输服务器\n * bililive-go - 直播录制工具\n * screego - 通过浏览器共享开发者屏幕\n * livego - 直播服务器\n * monibuca - 流媒体服务器开发框架\n * olive - 支持虎牙等平台的直播录制\n * lux - 各大视频网站的视频下载工具\n\n\n# 图形处理\n\n * barcode - 条形码/二维码生成器\n * picfit - 图片操作、裁剪、管理服务器\n * gmfs - 图片操作、裁剪、管理服务器\n * besticon - favicon 服务\n * caire - 图片操作库\n * imaging - 图片操作库\n * gocaptcha - 验证码生成\n * base64captcha - 验证码\n * go-is-svg - 校验是否为 svg 图片\n * identicon - 根据用户的 ip 、邮箱名等任意数据为用户产生漂亮的随机头像\n * prominentcolor - 识别图片的主要颜色\n * dchest/captcha - 生成和验证图片或音频验证码\n * bimg - 图片处理\n * imaginary - 图片处理服务\n * primitive - 用原始几何图形绘制图形\n * orly - 生成你自己的o\'rly动物书封面\n * smartcrop - 智能裁剪图片\n * gift - 图片滤镜\n * germanium - 给代码生成图片\n * go graphics - 2d 图片渲染\n * canvas - 矢量图绘制\n * formulae - 数学公式解析、计算、图表绘制\n * imagor - 图像处理服务器\n * triangula - 给图片增加三角形纹样风格的滤镜\n * d2 - 一种将文本转换成图形的图表脚本语言\n * imgo - 简洁、链式调用的图像处理库\n * invoice - 发票生成工具，可通过参数和配置文件进行创建和管理各种类型的发票\n\n# 图片识别\n\n * go-face - 面部识别\n\n\n# 图表\n\n * go-echarts - echarts 图表库\n * gonum/plot - 图形绘制\n * pinhole - 3d 线框图绘制\n * globe - 地球线框图绘制\n * ink - go 中的 2d 图形框架\n * go-plantuml - 基于 go 源码生成 plantuml 图\n * go-diagrams - 通过代码生成图表\n * gocity - 3d 展示城市\n\n\n# 构建编译\n\n * mage - 类似于 makefile 的命令行工具，用于构建和运行 go 项目\n * goreleaser - go 多平台二进制文件打包、并支持发布到 homebrew 的工具\n * goxc - 跨平台编译工具（因 1.5 版本开始已自带交叉编译，故已不再维护）\n * task - 类似于 make 的构建工具\n * codegangsta/gin - 热编译工具\n * air - 热编译工具\n * gowatch - 热编译工具\n * fresh - 热编译工具\n * dh-make-golang - 自动构建 debian 包\n * gobinaries - 不用安装go就能编译安装go编写的程序\n * nfpm - deb、rpm、apk 等打包工具\n * gox - go 跨端编译工具\n * garble - 混淆代码\n * gobfuscate - 混淆代码\n * go-appimage - go 语言实现 appimage 打包工具\n\n# 静态资源内嵌\n\n * pkger - 将静态文件打包成 go 二进制文件\n * mewn - 静态文件嵌入打包到二进制文件\n * statik - 静态文件嵌入\n * go.rice\n * go-bindata - 将静态文件转换成 go 代码文件\n * vfsgen - 将静态文件打包成 http.filesystem 类型进行访问\n * packr\n\n\n# 优雅升级\n\n * tableflip - web 服务升级\n * selfupdate - 二进制文件自动升级\n * overseer\n * go-github-selfupdate - 依托 github 自动升级\n\n\n# 代码分析\n\n * reviewdog - code review 机器人\n * revive - 代码检查分析\n * golangci-lint - 代码质量检查分析工具\n * errcheck - 检测未处理的错误(errors)\n * staticcheck - 一系列的 go 代码静态分析工具\n * golint - google 官方出品的代码质量检测工具\n * goreporter\n * go-critic\n * gocloc - 分语言代码行数统计\n * coca - 代码统计分析\n * go report card - go 项目质量分析报告工具\n * ddsv-go - 死锁检测工具\n * golang/perf - 官方性能量化分析工具\n * goplantuml - 为 go 项目生成 plantuml 类图\n * gosize - 分析go二进制文件大小\n * shotizam - 分析 go 二进制文件的大小并输出到 sqlite3\n * goconst - 查找可以被常量替换的重复字符串\n * sploit - 帮助二进制分析和开发的库\n * perf - perf utilities for go\n * fgprof - go 性能分析工具\n * conprof - 协程分析\n * statsview - 实时 go 运行时统计数据可视化分析器\n * codesearch - 代码搜索工具\n * pyroscope - 可视化程序性能监控工具，支持多种语言\n * gosec - 代码安全性检查工具\n * gokart - 代码静态分析工具\n * gofumpt - gofmt 增强版代码格式化工具\n * noverify - php 代码分析工具\n * fieldalignment - 结构体字段内存对齐分析和自动修复工具\n * bearer - 代码安全扫描工具\n\n\n# 调试\n\n * go-spew - 变量打印工具\n * delve - debug 工具\n * gdlv - delve 界面版本\n * weaver - 跟踪 go 程序执行链路\n * repr - 变量打印工具\n * pp - 彩色变量打印工具\n * ffmt - 变量打印工具\n * gops - 谷歌官方出品的 go 程序监控调试工具\n * pprof\n * go-callvis - 可视化go程序的调用图\n * q - 自动打印变量类型并且格式化输出\n * litter\n * rdebug - 滴滴开源的一款用于 rd 研发、自测、调试的实用工具\n * debugcharts - go 内存占用可视化调试工具\n * gcvis - 实时可视化 gctrace\n * pkg/profile\n * statsviz - 在浏览器中实时查看 go 应用程序运行时统计信息（gc，memstats 等）\n * autopprof - 自动分析 pprof\n * stack - 捕获、操作、格式化调用栈信息\n * pretty - 打印变量\n * go-deadlock - 对 (rw)mutex 进行注入，并提供死锁检测\n * mmcloughlin/profile\n * gcnotifier - 当发生 gc 时通知\n * grmon - 命令行监控显示 goroutines\n * valast - 打印输出变量的 go/ast 结构，类似于 php 的 var_export 函数\n * lensm - go 汇编与源码对照查看工具\n * holmes - 基于规则的自动 go profile dumper\n\n\n# 测试\n\n * goconvey - 含web界面的单元测试框架\n * gomock - 谷歌出品的mock测试框架\n * gostub\n * monkey - (archived) monkey patching in go\n * gomonkey - 猴子补丁，对函数、变量等进行打桩，方便单元测试，fork 自 monkey\n * supermonkey - 让私有方法可测\n * mockery - 自动为接口生成 mock 代码\n * ginkgo - bbd 测试框架\n * fperf - 压测工具\n * gocheck\n * testify\n * gotests - 根据源码自动生成测试文件\n * testsql - 根据 sql 创建语句生成测试数据\n * httpmock - http mock\n * goblin - bdd 测试框架\n * go-faker/faker - struct data fake generator\n * gofakeit - 随机数据生成器\n * dmgk/faker\n * go-tprof - 包测试报告生成工具\n * go-fuzz - randomized testing for go\n * gofight - testing api handler\n * sqlmock - sql 测试\n * sqlbench - sql\n * silk - 基于 markdown 的接口测试\n * gock - http mock 测试\n * godog - bdd 测试框架 cucumber 的 go 版本\n * endly - e2e（端到端）测试\n * is - 迷你测试框架\n * terratest - 基础设施测试，比如 docker\n * agouti - web 驱动的验收测试框架\n * httpexpect - 端到端 http & rest 测试框架\n * gocov - 测试覆盖率\n * miniredis - redis 数据测试\n * htmltest - html 测试\n * gnomock - 无需 mock 的 go 代码测试框架\n * gunit - xunit 风格测试框架\n * quicktest\n * k6 - 负载测试工具\n * go-cover-treemap - 将覆盖率测试结果转换成 treemap 图\n * ztf - 禅道开源的自动化测试框架\n * moq - 为接口生成 mock 代码\n\n\n# 错误处理\n\n * errors\n * errorx\n * errwrap - go tool to wrap and fix errors with the new %w verb directive\n * erris - linter for errors.is and errors.as\n * eris - 旨在通过错误包装，堆栈跟踪和输出格式为你提供对错误处理的更多控制\n * errlog - 使用静态和堆栈跟踪分析来快速确定哪个函数调用导致的错误\n * juju/errors\n * go-fault - github 官方出品，基于标准库 http 中间件的故障注入库\n * merry - 支持堆栈、状态码的错误处理\n * cockroachdb/errors - 功能强大、可替代 errors 和 github.com/pkg/errors 的错误处理包\n * go-multierror - 支持错误列表\n\n\n# 安全\n\n * kunpeng - 开源poc检测框架\n * nmap - 安全审计工具 nmap 开发包\n * hetty - 用于安全研究的 http 工具包，具有 web 接口和代理日志查看器的拦截 http 代理\n * fibratus - windows 内核漏洞利用和跟踪工具\n * secure - http 安全中间件\n * nuclei - 基于yaml语法模板的定制化快速漏洞扫描器\n * gitleaks - 用于在 git 存储库中查找敏感信息和密钥的开源工具\n\n\n# 系统信息\n\n * go-hardware - 收集了一堆关于硬件信息的包\n * cpuid - cpu 信息\n * gopsutil - ps 功能包\n * go-sysinfo - 系统信息\n * go-locale - 跨平台语言检测库\n * go-ps - 系统进程信息\n * psgo - ps 命令实现\n * ghw - 硬件信息\n * machineid - 获取机器id\n\n\n# uuid\n\n * go.uuid - uuid 库\n * seqsvr - go + mysql 实现的分布式 id 生成服务\n * google/uuid - google 开源的 uuid 包\n * gofrs/uuid\n * snowflake - twitter snowflake ids\n * sonyflake - sony 版本的 twitter\'s snowflake\n * ulid - ulid go 语言实现\n * ksuid - k-sortable globally unique ids\n * go-nanoid - nanoid 实现\n * xid - 全局唯一 id 生成器\n\n\n# 日志\n\n * logr - 日志包标准接口\n * logrus - 日志记录包\n * zerolog\n * zap - uber 开发的日志记录包\n * seelog\n * logkit - 七牛开源的日志收集工具\n * gogstash - 类似于 logstash 的日志收集器\n * lumberjack - 日志文件切割\n * file-rotatelogs - 日志文件切割\n * go-syslog - 极速 syslog 解析器\n * glog\n\n\n# 监控告警\n\n * openfalcon - 小米开源的监控系统\n * prometheus - 服务监控系统 & 时间序列数据库\n * grafana - 分析监视平台, 支持 graphite, elasticsearch, opentsdb, prometheus, influxdb 等数据源\n   * grabana - 用 go 代码快速创建 grafana dashboards\n * jaeger - 分布式追踪系统\n * go-osstat - 系统指标统计\n * grafterm - metrics dashboards on terminal\n * mymon - mysql 运行监控\n * pingme - 支持多消息平台的服务可用性报警命令工具\n * supervisord - go 语言实现 supervisor\n * grafana tempo - 分布式追踪系统\n * easeprobe - 服务探活工具并通知\n * uptrace - apm 工具，支持 opentelemetry 追踪、指标和日志\n * nightingale - 滴滴基于 openfalcon 开源的监控系统\n\n\n# 统计分析\n\n * fathom - web 站点统计\n * veneur - 分布式实时数据处理管道\n * gonum - 科学计算相关\n\n\n# 容器技术\n\n * moby - docker\n * docker-ce\n * rancher - 全栈化企业级容器管理平台\n * gorsair\n * docui - tui client for docker\n * podman - 管理和运行任何符合 oci 规范的容器和容器镜像\n * skopeo - 镜像管理工具\n * buildah - 构建 oci 容器镜像的工具\n * go-docker - 用 go 实现 docker 核心功能\n * packer - 轻量级的镜像定义工具\n * cosign - 容器签名和验证\n * slimtoolkit - 检查、缩小和调试容器\n\n\n# 集群管理\n\n * nomad - 集群管理器和调度器\n * openshift origin - red hat 开发的容器化软件解决方案\n\n# kubernetes\n\n * kubernetes - 容器调度管理平台\n * k0s - 最小体积的 k8s 发行版\n * sealos - 一条命令部署 kubernetes 高可用集群\n * kubeeye - 通过配置规则发现 kubernetes 上的各种问题\n * endpoints-operator - k8s内部服务访问外部服务的具备探活功能的4层lb\n\n\n# 机器学习\n\n * goml - 机器学习库\n * golearn - 一个 "开箱即用" 的机器学习库\n * glow - 易用的分布式计算系统\n * gobot - 机器人和物理计算语言库\n * olivia - 神经网络\n * pico - 基于像素强度比较的物体检测纸张的纯 go 脸部检测库\n * tfgo - tensorflow in go\n * prophecis - 微众银行自研的一站式云原生机器学习平台\n * aid - 机器学习ops平台，发现、部署、优化\n * sqlflow - sql引擎+ai引擎\n\n\n# 人工智能\n\n * go-openai - openai api go 客户端 sdk\n * localai - 低成本的硬件上运行模型计算的本地计算框架，支持多种模型，提供兼容 openai 接口协议的 rest api\n\n\n# 算法\n\n * gods - go 实现了多种数据结构\n * dragonboat - 多组 raft 共识算法库\n * eliben/raft - raft 算法\n * hashicorp/raft - raft 算法\n * graft - raft 算法\n * golang-lru - lru 算法实现\n * tinylru\n * finn - fast raft framework using the redis protocol for go\n * xorfilter\n * priyankchheda/algorithms - 各种算法的 go 语言实现\n * meow - meow hash\n * basalt - 高性能的分布式的专门空间优化的 bitmap 服务, 杜绝 bloomfilter 和 cuckoofilter 的误判\n * go-blurhash - blurhash，是模糊图片的一种哈希算法\n * xxhash - xxhash 哈希算法实现\n * go-multihash - 各种 hash 算法实现\n * memberlist - 基于 gossip 协议实现的管理集群成员和成员失败检测的开发包\n * backoff - 指数退避算法(exponential backoff)\n * fsm - 有限状态机\n\n\n# 数据结构\n\n * go-datastructures\n * play-with-data-structures - 「玩转数据结构」课程的 go 语言实现版本\n * hashmap\n * siphash - siphash-2-4\n * bigslice\n * golang-set - the missing set collection\n * rbang - r!tree 实现\n * rtreego - r-tree\n * google/btree - b-tree\n * tinybtree - b-tree\n * dataframe-go - 用于数据统计和操作的包\n * go-set - 集合工具包\n * orderedmap - 有序字典\n * trie\n * slim - 空间高利用率的数据结构\n * bitset - 位集合及其操作\n * bloom - bloom filters\n * roaring - 压缩位图\n * go-immutable-radix - radix 树\n\n\n# 依赖注入\n\n * go-autowire - 使用注解自动生成 wire - 依赖注入\n * dig\n * fx\n\n\n# json\n\n * gjson - json 解释器\n * sjson - json 修改工具\n * fastjson - fast json parser and validator for go\n * jsonparser\n * ffjson\n * json-iterator - 滴滴开源的 json 解析器\n * gojsonq - json/yaml/xml/csv 等数据查询\n * easyjson\n * go-jsonc - 将带注释的 json 转为无注释的\n * jin - json 操作工具包，同时具有标准库和类似 tidwall/gjson 和 tidwall/sjson 的功能\n * hujson - 支持注释的 json 解码\n * pkg/json - json decoder\n * colorjson - 终端中打印彩色 json\n * jid - json 数据解析读取工具\n * jsonc - 支持注释与逗号\n * sonic - 字节跳动开源的 json 解析器&修改器\n * go-json\n * jsonquery - xpath 语法查询 json\n * fx - 命令行 json 显示\n\n\n# 依赖管理\n\n * goproxy.io - goproxy 代理服务\n * goproxy.cn - 更适合国内用户的代理服务\n * gopm - go 包管理工具\n * govendor - vendor 包管理工具\n * gom - 包版本管理工具\n * rvflash/goup - 检查包版本是否有更新\n * owenthereal/goup - go 多版本管理\n * athens - goproxy 代理服务\n\n\n# 微服务\n\n * istio [中文文档] - 大型微服务系统管理工具\n * goa\n * micro - 微服务工具\n * go micro - 微服务框架\n * go kit - go 微服务工具集\n * gokit cli - go kit 脚手架\n * gogo\n * go-chassis\n * kite\n * kratos - b站开源的微服务框架\n * temporal - 微服务编排平台\n * serf - 服务编排管理平台\n * open policy agent - 通用策略引擎，cncf 孵化项目\n * gizmo - 微服务工具集\n * mosn - 用于边缘和服务网格的云原生网络数据平面\n * erda - 为企业提供 devops、微服务治理、多云管理的 paas\n * service weaver\n * consul - 服务发现、配置管理中心服务\n * traefik mesh - 简单的服务网格\n\n\n# serverless\n\n * openfaas - serverless functions made simple(功能服务化的 faas 框架)\n * faasd - 轻量级 faas 引擎\n * fn - 事件驱动的 faas\n * riff - 基于 kubernetes 的 faas\n * nuclio - 实时事件与数据的 serverless 框架\n * flogo - 事件驱动的 serverless 框架\n * dapr - 微软开源的云和边缘计算的微服务构件\n * kubeless\n * fission - 基于 kubernetes 的 serverless\n * pulumi\n * knative\n * fx\n * ironfunctions\n * schollz/faas - 让任何包的函数变成一个 http 接口\n * vanus - 无服务事件流处理系统\n\n\n# devops\n\n * act - 本地运行 github actions\n\n\n# 持续集成/部署\n\n * cds - 持续集成服务\n * gopub\n * codepub\n * syncd - 代码部署工具\n * drone - 基于 docker 的持续发布平台\n * cyclone - 持续集成&发布平台\n * tbls - 用于记录数据库文档的 ci 友好工具\n * woodpecker - fork 自 drone\n * dagger - 基于容器的 ci/cd 工具\n\n\n# git\n\n * gogs - 类似于 gitlab 的 git 服务器\n * gitea - 由 gogs 分叉出的 git 服务器\n * go-git - go 实现的 git 操作\n * gitin - commit/branch/status explorer for git\n * hub - github 命令行工具\n * git-o-matic - 一个监控 git 仓库变化和自动 pull/push 的工具\n * gitbase - sql 的方式查询 git 日志\n * git-chglog - changelog 管理工具\n * chglog - changelog 管理工具\n * lazyhub - github 的终端 ui 客户端\n * goaction - 在 go 中编写 github action\n * bit - git 命令增强版，支持文件和分支名称自动完成、命令和标志建议\n * go-github - github api 操作库\n * askgit - 通过 sql 访问 git 仓库信息\n * git2graph - 根据 git 仓库提交记录生成结构图\n * lazygit - git 终端 ui\n * gh-dash - github cli（gh）漂亮终端面板\n * soft serve - 命令行式自托管 git 服务器\n * git lfs - 处理大文件的 git 扩展\n\n\n# 限流器\n\n * tollbooth - simple middleware to rate-limit http requests\n * ratelimit\n * ratelimit\n * go-rate\n * circuit - 熔断器\n * uber-go/ratelimit\n * sentinel - 阿里巴巴开源的面向分布式服务架构的流量控制组件 go 语言版本\n * gohalt - 限流\n * gobreaker - 熔断器\n * ulule/limiter\n\n\n# 编译器\n\n * tinygo - 一个适用于微控制器、webassembly 和命令行工具的 go 编译器\n * minigo - a go compiler from scratch\n * llir/llvm - llvm 编译器\n * jit-compiler - jit 编译器\n * go+ - 七牛云开源面向数据科学的语言，完全兼容go语言\n\n\n# 解释器\n\n# 语言解释器\n\n * participle - 通用的自定义语法解析包\n * gopherlua - vm and compiler for lua in go\n * go-lua - a lua vm in pure go\n * dclua - go lua compiler and vm\n * otto - javascript 解释器\n * goja - ecmascript 5.1(+) 实现\n * v8go - execute javascript from go\n * gpython - python interpreter on go\n * grumpy - 转换 python 为 go 代码，谷歌开源\n * starlark-go - starlark in go\n * avo - x86 汇编程序构建器\n * wagon - webassembly 解释器\n * gopherjs - 把 go 代码编译成 javascript 代码\n * yaegi - go 语言解释器\n * properties - java properties scanner for go\n * jvm.go - jvm\n * gobasic - a basic interpreter written in golang\n * golisp - lisp 解释器\n * dst - go decorated syntax tree\n * mvdan/sh - shell 解析、格式化、接口\n * tdewolff/parse - 通用词法分析器 lexer，并内置支持解析 html/css/json/xml/js/svg 语法\n * joker - clojure\n\n# php\n\n * z7zmey/php-parser - php ast 语法解析\n * deuill/go-php - php bindings for go\n * goridge - high-performance php-to-golang ipc bridge\n * roadrunner - 高性能php应用服务器，支持负载均衡及进程管理\n * vkcom/php-parse - php ast 语法解析\n\n# 自定义解释器\n\n * cue - configure unify execute(validate and define text-based and dynamic configuration)\n * cel-go - common expression language(cel 的 go 实现)\n * math-engine - 使用 go 实现的数学表达式解析计算引擎库，学习语法解析很适用\n * gval - 表达式计算\n * expression-parsing\n * goexp - recursive descent expression parser in go\n * goastch - go ast 语法解析\n * tdop\n * swallow\n * anko\n * expr - 编译&执行字符串中的表达式\n * tengo - 用 go 编写的脚本语言\n * v - go 编写的语言\n * kumarujjawal/bison\n * monkey\n * govaluate\n * compiler - 将自定义语法代码编译成 x86-64 assembly\n * elvish - 交互式 shell 语言\n * qlbridge - go sql runtime engine\n * yql - sql where 风格的规则引擎\n * flux - influxdb 数据语言\n * spiker - go 编写的简单规则表达式执行器，支持自定义函数和流程控制，适用于业务规则复杂的场景\n * gocc - 解析器生成器，可以将指定的文法转换为 go 语言的解析器程序代码，用于编译和解析特定类型的源代码\n\n\n# 代码生成\n\n * jennifer - go 代码生成\n * ifacemaker - 根据结构体方法生成接口\n * gg - go 代码生成\n\n\n# 编辑器\n\n * micro - 基于终端的编辑器\n * sourcegraph - 代码搜索&导航\n\n\n# 运行器\n\n * gore - 在线运行 go 代码\n * nodebook - 在线运行多种语言\n * go-pry - 像 python、r、php 等在终端交互式输入与运行 go 代码\n\n\n# 查询语言\n\n * graphql - go 实现的 graphql\n * graphql-go\n * gqlengine - 基于 graphql-go 实现\n * rql - rest 资源查询语言\n * thunder - graphql 服务构建框架\n * gqlgen - 构建 graphql 服务器的包\n * super-graph - 无需编写代码即可在 go 项目中构建复杂的 graphql api\n\n\n# 游戏相关\n\n * nano - 游戏开发框架\n * leaf\n * einx\n * cloudretro - 游戏云服务框架\n * g3n - go 3d game engine\n * ebiten - 2d 游戏库\n\n\n# 桌面开发\n\n# gui\n\n * lorca - 用 go 编写 html5 桌面程序，依赖 chrome 进行 ui 渲染，但却不把 chrome 打包到应用中\n * webview - 用 go/c/c++ 构建跨平台的桌面软件\n * walk - windows gui toolkit\n * go-gtk - go bindings for gtk\n * andlabs/ui - platform-native gui library for go\n * fyne - material design 风格的 gui\n * go-gl - go bindings for opengl (generated via glow)\n * therecipe/qt - 基于 qt 的跨全平台 ui 包\n * giu - 基于 dear imgui 的跨平台 gui 框架\n * go-app - 一个 webassembly 框架，用于使用 go，html 和 css 构建 gui 应用\n * wails - 使用 go 和 web 技术创建桌面应用程序\n * chromedp - 纯 go 语言实现的驱动浏览器的 chrome devtools protocol，可用于爬虫、反爬虫、测试等场景\n * rod - 一个为简化自动化和爬虫设计的 devtools driver，利用浏览器的 devtools 可编程接口来操控浏览器\n * go-astilectron - 基于 electron 的跨平台开发\n * gio - 跨平台 ui 框架，支持移动应用\n * nucular - 基于 gio 的实现\n * govcl - 跨平台的 gui 包\n * vugu - webassembly ui 框架\n * gogi - 2d/3d gui 框架\n * systray - 跨平台支持菜单栏管理\n * go-flutter - 绑定 flutter 到桌面应用\n * nuxui\n\n# 桌面辅助包\n\n * pkg/browser - 在浏览器中打开文件、url\n * macdriver - macos 原生 api\n * gon - 为 macos 签名和公证\n\n# 桌面应用\n\n * xbar - 基于 wails.app 开发的 macos 菜单栏管理\n * 阿里云盘小白羊版 - ui由flutter构建\n\n\n# 移动端\n\n * golang/mobile - go support for mobile devices\n\n\n# 协程/线程\n\n * ants - 协程池\n * tunny\n * go-workers - 安全地并发运行一组 worker，通过 channel 进行输入输出\n * machine - 受 errgroup.group 启发的协程管理\n * thread\n * conc - 更好用的结构化并发控制\n * zeropool - 零回收、类型安全的协程池\n * workerpool - 无阻塞队列任务池\n * pond - 协程池\n\n\n# 任务/定时器\n\n * rxgo - go 版 reactivex，简单方便的处理异步数据流\n * grift - go based task runner\n * cron - a cron library for go\n * gocron - 任务定时调度器\n * jobrunner\n * curlyq - 后台任务处理库\n * overtalk/task - 任务的管理&执行，支持自定义次数的重发\n * ppgo_job - 定时任务管理系统\n * gocelery - celery 的 go 语言实现\n * machinery - 通过分布式消息实现异步任务调度\n * dkron - 分布式任务调度系统\n * grit - 基于 multitree 实现的任务管理\n * asynq - 异步分布式任务队列\n * cronsun - 分布式任务系统\n\n\n# 流处理\n\n * benthos\n * gostream\n * watermill\n * go-streams\n * goflow\n * cadence (cadence web ui) - uber开源的分布式工作流引擎，主要用于微服务编排和分布式事务等场景\n\n\n# 微信\n\n * weapp - 微信小程序 sdk\n * wechat - wechat sdk for go\n * wechat-go - 微信 web 版 api 的 go 实现\n\n\n# sdk\n\n * gopay - qq、微信（wechat）、支付宝（alipay）的go版本sdk\n * alipay - 支付宝sdk\n\n\n# 区块链\n\n * hyperledger fabric - 基于区块链的超级账本\n * go-ethereum - 以太坊协议的官方 go 语言实现\n * bbgo - 用 go 编写的加密货币交易框架\n * btcd - 比特币实现\n\n\n# 开发辅助包\n\n * cvt - 任意数据类型转换，支持自定义类型、提取结构体字段和值\n * copier - struct 之间拷贝值\n * cast - 数据类型转换\n * diff - 结构体&值比较\n * go-extend\n * com - 工具包\n * php2go - go 实现的 140+ 个 php 函数功能包\n * gommon - common packages for go\n * reflect2 - reflect api without runtime reflect.value cost\n * mapstructure - 将 map 值转换到结构体中\n * naza - go语言基础库\n * automaxprocs - 自动设置 gomaxprocs\n * c2go - 将 c 代码转换为 go 代码的工具\n * rnm - 代码重构辅助工具\n * memviz - 图形化数据结构\n * underscore.go\n * go-testdeep - 非常灵活的深度比较包，扩展了 go 测试包\n * go-model - struct 操作包\n * concurrent-map - 并发安全 map\n * goleak - 检测 goroutine 泄漏\n * guregu/null - sql/json的null处理包，提供替代类型\n * stats - 标准数字统计\n * chronos - 静态竞争检测器\n * collection - 替代原生的 slice\n * rf - 代码重构工具\n * bytebufferpool - byte buffers pool\n * bpool - byte buffers pool，支持 bytes.buffers\n * mergo - 合并结构体和字典数据\n * go-funk - 基于反射实现的常用函数\n * lo - 基于 1.18+ 泛型的常用函数\n * juniper - 基于泛型实现常用的容器、迭代器、数据流等功能\n * mergo - 合并结构体和字典\n * xstrings - 字符串相关函数\n * pie - slice/map 链式处理\n\n\n# 代码生成\n\n * chimeracoder/gojson - 根据 json 生成结构体\n * db2struct - 根据表结构生成结构体\n * smallnest/gen - 根据表结构生成结构体\n * sqlc - 根据 sql 语句生成 go 代码\n * xo - 根据表结构或查询语句自动生成 go 代码\n\n\n# 系统开发\n\n * linuxkit - 为容器构建安全、便携、可移植操作系统的工具包\n * go-systemd - 绑定 systemd\n * lima - linux-on-mac ("macos subsystem for linux", "containerd for mac")\n * gopher-os - 一个兼容 linux 的 64 位 posix 风格系统\n * gouring - 不依赖 cgo 实现系统调用\n\n\n# 未归类\n\n * go-playground - 比官方更好用的 go playground\n * robotgo - golang 跨平台自动化系统，控制键盘鼠标位图和读取屏幕，窗口句柄以及全局事件监听\n * go-homedir\n * i18n - i18n 多语言工具包\n * go-i18n - 多语言工具包\n * paginater - 分页工具\n * gls - goroutine local storage\n * mcuadros/go-version - 版本号比较\n * go-semver - 语义版本\n * semver - 另一个语义版本\n * hashicorp/go-version\n * metabolize - decodes html meta tags into a golang struct\n * otp - 一次性密码工具包(one time password utilities)\n * misspell - 常拼写错误的英语单词\n * crdt - crdt(convergent and commutative replicated data types)最终一致性算法的实现\n * script - making it easy to write shell-like scripts in go\n * sysadmin-utils\n * licenseclassifier - 识别文件中的 license 类型\n * go-license-detector\n * rose - 在 html 中嵌入和运行 go 代码\n * esbuild - javascript 构建打包工具\n * clipboard - 剪切板\n * clipboard - 剪切板\n * clipboard - 剪切板\n * timeliner - 搜集整理个人在社交网站上的数据并索引成时间线\n * hc - homekit 平台开发框架\n * address - 地址处理库，支持多国语言\n * webhook - 可执行 shell 命令的 web hook 服务\n * webhookd - 为 shell 脚本提供 web hook 服务\n * go-cid - cid spec go 语言实现\n * gorush - app 消息通知服务\n * eventbus - 事件总线\n * go-winio - 为 win32 io 操作提供接口支持\n * fq - 以 jq 语法读取二进制数据/文件\n * lego - let\'s encrypt client and acme library\n\n\n# logo\n\n * gophers\n\n\n# 工具\n\n * syndbg/goenv - go 版本管理\n * wfarr/goenv - go 版本管理\n * gvm - go 版本管理\n * goland - ide 软件\n * visual studio code\n\n\n# 资源站点\n\n * go 101\n * go 语言中文网\n * golang 中国\n * go-zh\n * golang sizeof tips - 输入结构体定义，会显示内存布局\n * golang programs\n * golang bot',charsets:{cjk:!0},lastUpdated:"2023/12/19, 10:12:18",lastUpdatedTimestamp:1702951938e3},{title:"设计模式之观察者模式详解（Java实现）",frontmatter:{title:"设计模式之观察者模式详解（Java实现）",date:"2022-05-01T09:43:00.000Z",tags:["观察者模式"],author:{name:"Pursuit",link:"https://github.com/unique-pure"},permalink:"/pages/e1f6d9/",categories:["开发","开发框架","设计模式"],readingShow:"top"},regularPath:"/01.%E5%BC%80%E5%8F%91/02.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%88Java%E5%AE%9E%E7%8E%B0%EF%BC%89.html",relativePath:"01.开发/02.开发框架/03.设计模式/12.设计模式之观察者模式详解（Java实现）.md",key:"v-7587d3fc",path:"/pages/e1f6d9/",headers:[{level:2,title:"1 观察者模式介绍",slug:"_1-观察者模式介绍",normalizedTitle:"1 观察者模式介绍",charIndex:2},{level:2,title:"2 观察者模式详解",slug:"_2-观察者模式详解",normalizedTitle:"2 观察者模式详解",charIndex:1190},{level:3,title:"2.1 观察者模式结构",slug:"_2-1-观察者模式结构",normalizedTitle:"2.1 观察者模式结构",charIndex:1204},{level:3,title:"2.2 观察者模式实现",slug:"_2-2-观察者模式实现",normalizedTitle:"2.2 观察者模式实现",charIndex:1801},{level:3,title:"2.3 观察者模式应用举例",slug:"_2-3-观察者模式应用举例",normalizedTitle:"2.3 观察者模式应用举例",charIndex:3090},{level:2,title:"3 观察者模式与MVC",slug:"_3-观察者模式与mvc",normalizedTitle:"3 观察者模式与mvc",charIndex:3413}],headersStr:"1 观察者模式介绍 2 观察者模式详解 2.1 观察者模式结构 2.2 观察者模式实现 2.3 观察者模式应用举例 3 观察者模式与MVC",content:"# 1 观察者模式介绍\n\n“红灯停，绿灯行”。在这个过程中，交通信号灯是汽车的观察目标，而汽车则是观察者。随着交通信号灯的变化，汽车的行为也随之变化，一盏交通信号灯可以指挥多辆汽车。\n\n\n\n在软件系统中有些对象之间也存在类似交通信号灯和汽车之间的关系，一个对象的状态或行为的变化将导致其他对象的状态或行为也发生改变。观察者模式（Observer Pattern）则是用于建立一种对象与对象之间的依赖关系，使得每当一个对象状态发生改变时其相关依赖对象皆得到通知并被自动更新。发生改变的对象称为观察目标，被通知的对象称为观察者，一个观察目标可以对应多个观察者。它有如下别名：\n\n * 发布-订阅(Publish/Subscribe)模式\n * 模型-视图(Model/View)模式\n * 源-监听器(Source/Listener)模式\n * 从属者(Dependents)模式\n\n> 主要解决： 一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。\n> \n> 何时使用： 一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。\n> \n> 如何解决： 使用面向对象技术，可以将这种依赖关系弱化。\n> \n> 关键代码： 在抽象类里有一个 ArrayList 存放观察者们。\n> \n> 应用实例： 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。\n> \n> 优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。\n> \n> 缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。\n> \n> 使用场景：\n> \n>  * 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。\n>  * 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。\n>  * 一个对象必须通知其他对象，而并不知道这些对象是谁。\n>  * 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。\n> \n> 注意事项： 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。\n\n\n# 2 观察者模式详解\n\n\n# 2.1 观察者模式结构\n\n观察者模式结构中通常包括观察目标和观察者两个继承层次结构，其结构图如下：\n\n\n\n由图可知，观察者模式包含以下4个角色。\n\n 1. Subject（目标）：目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供了一系列方法来增加和删除观察者对象，同时它定义了通知方法notify()。目标类可以是接口，也可以是抽象类或具体类。\n 2. ConcreteSubject（具体目标）：具体目标是目标类的子类，它通常包含有经常发生改变的数据，当它的状态发生改变时它向各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法。如果无须扩展目标类，具体目标类可以省略。\n 3. Observer（观察者）：观察者将对观察目标的改变做出反映，观察者一般定义为接口，该接口声明了更新数据的方法update()，因此又称为抽象观察者。\n 4. ConcreteObserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者Observer中定义的update()方法。通常在实现时可以调用具体目标类的attach()方法将自己添加到目标类的集合中或者通过detach()方法将自己从目标类的集合中删除。\n\n\n# 2.2 观察者模式实现\n\n抽象目标类典型代码如下：\n\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic abstract class Subject {\n    //定义一个观察者集合用于存储所有观察者对象\n    protected List<Observer> observers = new ArrayList();\n\n    //注册方法，用于向观察者集合中增加一个观察者\n    public void attach(Observer observer) {\n        observers.add(observer);\n    }\n\n    //注销方法，用于在观察者集合中删除一个观察者\n    public void detach(Observer observer) {\n        observers.remove(observer);\n    }\n\n    //声明抽象通知方法\n    public abstract void notify();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n具体目标类典型代码如下：\n\npublic class ConcreteSubject extends Subject {\n    //实现通知方法\n    public void notify() {\n        //遍历观察者集合，调用每一个观察者的响应方法\n        for(Observer obs:observers) {\n            obs.update();\n        }\n    } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n抽象观察者典型代码如下：\n\npublic interface Observer {\n    //声明响应方法\n    public void update();\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n具体观察者典型代码如下：\n\npublic class ConcreteObserver implements Observer {\n    //实现响应方法\n    public void update() {\n        //具体响应代码\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n * 有时候在具体观察者类ConcreteObserver中需要使用到具体目标类ConcreteSubject中的状态（属性），会存在关联或依赖关系。\n * 如果在具体层之间具有关联关系，系统的扩展性将受到一定的影响，增加新的具体目标类有时候需要修改原有观察者的代码，在一定程度上违背了开闭原则，但是如果原有观察者类无须关联新增的具体目标，则系统扩展性不受影响。\n\n\n# 2.3 观察者模式应用举例\n\n * 题目描述\n   \n   > 在某多人联机对战游戏中，多个玩家可以加入同一战队组成联盟，当战队中的某一成员受到敌人攻击时将给所有其他盟友发送通知，盟友收到通知后将做出响应。现使用观察者模式设计并实现该过程，以实现战队成员之间的联动。\n\n * 题目分析\n   \n   战队成员之间的联动过程：联盟成员受到攻击——>发送通知给盟友——>盟友做出响应。\n\n * UML类图\n   \n   其中，AllyControlCenter充当抽象目标类，ConcreteAllyControlCenter充当具体目标类，Observer充当抽象观察者，Player充当具体观察者。\n\n * 代码\n   \n   代码地址\n\n\n# 3 观察者模式与MVC\n\n在当前流行的MVC（Model-View-Controller）架构中也应用了观察者模式，MVC是一种架构模式，它包含了3个角色，即模型(Model)，视图(View)和控制器(Controller)。其中，模型可对应于观察者模式中的观察目标，而视图对应于观察者，控制器可充当两者之间的中介者。当模型层的数据发生改变时，视图层将自动改变其显示内容。MVC的结构图如下：\n\n",normalizedContent:"# 1 观察者模式介绍\n\n“红灯停，绿灯行”。在这个过程中，交通信号灯是汽车的观察目标，而汽车则是观察者。随着交通信号灯的变化，汽车的行为也随之变化，一盏交通信号灯可以指挥多辆汽车。\n\n\n\n在软件系统中有些对象之间也存在类似交通信号灯和汽车之间的关系，一个对象的状态或行为的变化将导致其他对象的状态或行为也发生改变。观察者模式（observer pattern）则是用于建立一种对象与对象之间的依赖关系，使得每当一个对象状态发生改变时其相关依赖对象皆得到通知并被自动更新。发生改变的对象称为观察目标，被通知的对象称为观察者，一个观察目标可以对应多个观察者。它有如下别名：\n\n * 发布-订阅(publish/subscribe)模式\n * 模型-视图(model/view)模式\n * 源-监听器(source/listener)模式\n * 从属者(dependents)模式\n\n> 主要解决： 一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。\n> \n> 何时使用： 一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。\n> \n> 如何解决： 使用面向对象技术，可以将这种依赖关系弱化。\n> \n> 关键代码： 在抽象类里有一个 arraylist 存放观察者们。\n> \n> 应用实例： 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。\n> \n> 优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。\n> \n> 缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。\n> \n> 使用场景：\n> \n>  * 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。\n>  * 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。\n>  * 一个对象必须通知其他对象，而并不知道这些对象是谁。\n>  * 需要在系统中创建一个触发链，a对象的行为将影响b对象，b对象的行为将影响c对象……，可以使用观察者模式创建一种链式触发机制。\n> \n> 注意事项： 1、java 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。\n\n\n# 2 观察者模式详解\n\n\n# 2.1 观察者模式结构\n\n观察者模式结构中通常包括观察目标和观察者两个继承层次结构，其结构图如下：\n\n\n\n由图可知，观察者模式包含以下4个角色。\n\n 1. subject（目标）：目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供了一系列方法来增加和删除观察者对象，同时它定义了通知方法notify()。目标类可以是接口，也可以是抽象类或具体类。\n 2. concretesubject（具体目标）：具体目标是目标类的子类，它通常包含有经常发生改变的数据，当它的状态发生改变时它向各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法。如果无须扩展目标类，具体目标类可以省略。\n 3. observer（观察者）：观察者将对观察目标的改变做出反映，观察者一般定义为接口，该接口声明了更新数据的方法update()，因此又称为抽象观察者。\n 4. concreteobserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者observer中定义的update()方法。通常在实现时可以调用具体目标类的attach()方法将自己添加到目标类的集合中或者通过detach()方法将自己从目标类的集合中删除。\n\n\n# 2.2 观察者模式实现\n\n抽象目标类典型代码如下：\n\nimport java.util.list;\nimport java.util.arraylist;\n\npublic abstract class subject {\n    //定义一个观察者集合用于存储所有观察者对象\n    protected list<observer> observers = new arraylist();\n\n    //注册方法，用于向观察者集合中增加一个观察者\n    public void attach(observer observer) {\n        observers.add(observer);\n    }\n\n    //注销方法，用于在观察者集合中删除一个观察者\n    public void detach(observer observer) {\n        observers.remove(observer);\n    }\n\n    //声明抽象通知方法\n    public abstract void notify();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n具体目标类典型代码如下：\n\npublic class concretesubject extends subject {\n    //实现通知方法\n    public void notify() {\n        //遍历观察者集合，调用每一个观察者的响应方法\n        for(observer obs:observers) {\n            obs.update();\n        }\n    } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n抽象观察者典型代码如下：\n\npublic interface observer {\n    //声明响应方法\n    public void update();\n}\n\n\n1\n2\n3\n4\n\n1\n2\n3\n4\n\n\n具体观察者典型代码如下：\n\npublic class concreteobserver implements observer {\n    //实现响应方法\n    public void update() {\n        //具体响应代码\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n1\n2\n3\n4\n5\n6\n\n * 有时候在具体观察者类concreteobserver中需要使用到具体目标类concretesubject中的状态（属性），会存在关联或依赖关系。\n * 如果在具体层之间具有关联关系，系统的扩展性将受到一定的影响，增加新的具体目标类有时候需要修改原有观察者的代码，在一定程度上违背了开闭原则，但是如果原有观察者类无须关联新增的具体目标，则系统扩展性不受影响。\n\n\n# 2.3 观察者模式应用举例\n\n * 题目描述\n   \n   > 在某多人联机对战游戏中，多个玩家可以加入同一战队组成联盟，当战队中的某一成员受到敌人攻击时将给所有其他盟友发送通知，盟友收到通知后将做出响应。现使用观察者模式设计并实现该过程，以实现战队成员之间的联动。\n\n * 题目分析\n   \n   战队成员之间的联动过程：联盟成员受到攻击——>发送通知给盟友——>盟友做出响应。\n\n * uml类图\n   \n   其中，allycontrolcenter充当抽象目标类，concreteallycontrolcenter充当具体目标类，observer充当抽象观察者，player充当具体观察者。\n\n * 代码\n   \n   代码地址\n\n\n# 3 观察者模式与mvc\n\n在当前流行的mvc（model-view-controller）架构中也应用了观察者模式，mvc是一种架构模式，它包含了3个角色，即模型(model)，视图(view)和控制器(controller)。其中，模型可对应于观察者模式中的观察目标，而视图对应于观察者，控制器可充当两者之间的中介者。当模型层的数据发生改变时，视图层将自动改变其显示内容。mvc的结构图如下：\n\n",charsets:{cjk:!0},lastUpdated:"2023/11/25, 22:00:34",lastUpdatedTimestamp:1700920834e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1,readingShow:"top"},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-1e09ee2b",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/21, 20:55:58",lastUpdatedTimestamp:1700571358e3},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1,readingShow:"top"},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-6097fb0b",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/21, 20:55:58",lastUpdatedTimestamp:1700571358e3},{title:"随写编年",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"04.生活杂谈/01.随写编年",description:"记录每年的日常"}},title:"随写编年",permalink:"/life/year/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"pursuit",link:"https://github.com/unique-pure"},date:"2023-11-24T16:04:42.000Z",readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.sub01.%E9%9A%8F%E5%86%99%E7%BC%96%E5%B9%B4.html",relativePath:"00.目录页/04.sub01.随写编年.md",key:"v-10f2e34e",path:"/life/year/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 18:39:24",lastUpdatedTimestamp:1700822364e3},{title:"Home",frontmatter:{home:!0,heroText:"Pursuit's blog",tagline:"日拱一卒无有尽，功不唐捐终入海",features:[{title:"开发",details:"C++、Go、Python、Linux、数据结构与算法等相关技术",link:"/develop/",imgUrl:"/img/web.png"},{title:"工具",details:"Git、Github等工具使用",link:"/tool/",imgUrl:"/img/ui.png"},{title:"学习笔记",details:"记录自己的学习笔记，包括但不限于讲座笔记、论文笔记等",link:"/note/",imgUrl:"/img/other.png"}],readingShow:"top"},regularPath:"/",relativePath:"index.md",key:"v-3fce6544",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/24, 22:16:11",lastUpdatedTimestamp:1700835371e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1,readingShow:"top"},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-0e8002ab",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/21, 20:55:58",lastUpdatedTimestamp:1700571358e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"开发",link:"/develop/",items:[{text:"编程语言",link:"/develop/language/"},{text:"开发框架",link:"/develop/framework/"},{text:"数据结构与算法",link:"/develop/algorithm/"},{text:"数据存储",link:"/develop/storage/"},{text:"系统架构",link:"/develop/system/"},{text:"计算机网络",link:"/develop/network/"},{text:"云原生",link:"/develop/cloud/"}]},{text:"工具",link:"/tool/",items:[{text:"版本控制",link:"/tool/vcs/"},{text:"网络工具",link:"/tool/network/"},{text:"开发工具",link:"/tool/develop/"}]},{text:"学习笔记",link:"/note/",items:[{text:"学术搬砖",link:"/note/paper/"},{text:"实践项目",link:"/note/project/"},{text:"讲座研讨",link:"/note/lecture/"}]},{text:"生活杂谈",link:"/life/",items:[{text:"随写编年",link:"/life/year/"},{text:"追忆青春",link:"/life/youth/"},{text:"旅行日记",link:"/life/travel/"},{text:"文艺时光",link:"/life/art/"},{text:"烹调分享",link:"/life/cook/"}]},{text:"资源收藏",link:"/resource/",items:[{text:"实用网站",link:"/resource/website/"},{text:"优秀项目",link:"/resource/project/"}]},{text:"更多",link:"/more/",items:[{text:"面试",link:"/more/interview/"},{text:"实用技巧",link:"/more/tip/"},{text:"博客相关",link:"/more/blog/"}]},{text:"关于",link:"/about/"},{text:"友链",link:"/friend/"},{text:"索引",link:"/archives/",items:[{text:"分类",link:"/categories/"},{text:"标签",link:"/tags/"},{text:"归档",link:"/archives/"}]}],sidebarDepth:2,logo:"/img/logo.jpeg",repo:"unique-pure/my-vdoing-blog-template",searchMaxSuggestions:10,searchPlaceholder:"按下 𝑺 搜索",lastUpdated:"上次更新",editLinks:!1,sidebar:{"/00.目录页/":[["01.开发.md","开发","/develop/"],["02.工具.md","工具","/tool/"],["03.学习笔记.md","学习笔记","/note/"],["04.生活杂谈.md","生活杂谈","/life/"],["05.资源收藏.md","资源收藏","/resource/"],["06.更多.md","更多","/more/"]],catalogue:{"sub01.编程语言":"/develop/language/","sub02.开发框架":"/develop/framework/","sub03.数据结构与算法":"/develop/algorithm/","sub04.数据存储":"/develop/storage/","sub05.系统架构":"/develop/system/","sub06.计算机网络":"/develop/network/","sub07.云原生":"/develop/cloud/","开发":"/develop/","sub01版本控制":"/tool/vcs/","sub02网络工具":"/tool/network/","sub03.开发工具":"/tool/develop/","工具":"/tool/","sub01.学术搬砖":"/note/paper/","sub02.实践项目":"/note/project/","sub03.讲座研讨":"/note/lecture/","学习笔记":"/note/","sub01.随写编年":"/life/year/","sub02.追忆青春":"/life/youth/","sub03.旅行日记":"/life/travel/","sub04.文艺时光":"/life/art/","sub05.烹调分享":"/life/cook/","生活杂谈":"/life/","sub01实用网站":"/resource/website/","sub02优秀项目":"/resource/project/","资源收藏":"/resource/","sub01.面试":"/more/interview/","sub02.实用技巧":"/more/tip/","sub03.博客相关":"/more/blog/","更多":"/more/"},"/01.开发/":[{title:"编程语言",collapsable:!0,children:[{title:"Go",collapsable:!0,children:[]}]},{title:"开发框架",collapsable:!0,children:[{title:"前端",collapsable:!0,children:[["02.开发框架/01.前端/01.Vite构建工具介绍.md","vite构建工具介绍","/pages/03e0a8/"]]},{title:"后端",collapsable:!0,children:[]},{title:"设计模式",collapsable:!0,children:[["02.开发框架/03.设计模式/01.设计模式之工厂模式详解（Java实现）.md","设计模式之工厂模式详解（Java实现）","/pages/f4cb7a/"],["02.开发框架/03.设计模式/02.设计模式之建造者模式详解（Java实现）.md","设计模式之建造者模式详解（Java实现）","/pages/04c857/"],["02.开发框架/03.设计模式/03.设计模式之原型模式详解（Java实现）.md","设计模式之原型模式详解（Java实现）","/pages/2d97a5/"],["02.开发框架/03.设计模式/04.设计模式之单例模式详解（Java实现）.md","设计模式之单例模式详解（Java实现）","/pages/a1ff4f/"],["02.开发框架/03.设计模式/05.设计模式之适配器模式详解（Java实现）.md","设计模式之适配器模式详解（Java实现）","/pages/2bc5dd/"],["02.开发框架/03.设计模式/06.设计模式之桥接模式详解（Java实现）.md","设计模式之桥接模式详解（Java实现）","/pages/aab372/"],["02.开发框架/03.设计模式/07.设计模式之组合模式详解（Java实现）.md","设计模式之组合模式详解（Java实现）","/pages/eac75e/"],["02.开发框架/03.设计模式/08.设计模式之装饰模式详解（Java实现）.md","设计模式之装饰模式详解（Java实现）","/pages/c49acf/"],["02.开发框架/03.设计模式/09.设计模式之外观模式详解（Java实现）.md","设计模式之外观模式详解（Java实现）","/pages/e40609/"],["02.开发框架/03.设计模式/10.设计模式之代理模式详解（Java实现）.md","设计模式之代理模式详解（Java实现）","/pages/933a7d/"],["02.开发框架/03.设计模式/11.设计模式之命令模式详解（Java实现）.md","设计模式之命令模式详解（Java实现）","/pages/31f81b/"],["02.开发框架/03.设计模式/12.设计模式之观察者模式详解（Java实现）.md","设计模式之观察者模式详解（Java实现）","/pages/e1f6d9/"],["02.开发框架/03.设计模式/13.设计模式之策略模式详解（Java）实现.md","设计模式之策略模式详解（Java实现）","/pages/b22ffc/"],["02.开发框架/03.设计模式/14.设计模式之模板方法模式详解（Java实现）.md","设计模式之模板方法模式详解（Java实现）","/pages/2aa461/"]]}]},{title:"数据结构与算法",collapsable:!0,children:[{title:"基础知识",collapsable:!0,children:[]},{title:"排序算法",collapsable:!0,children:[]},{title:"查找算法",collapsable:!0,children:[["03.数据结构与算法/03.查找算法/01.二分查找.md","二分查找的奇技淫巧","/pages/71fd4b/"]]},{title:"字符串算法",collapsable:!0,children:[]},{title:"位运算",collapsable:!0,children:[["03.数据结构与算法/05.位运算/01.位运算全面总结.md","位运算全面总结","/pages/41f1cd/"]]},{title:"数据结构",collapsable:!0,children:[["03.数据结构与算法/06.数据结构/01.线段树入门.md","线段树入门","/pages/088910/"]]},{title:"动态规划",collapsable:!0,children:[["03.数据结构与算法/07.动态规划/01.数位DP.md","数位DP学习整理","/pages/243023/"],["03.数据结构与算法/07.动态规划/02.状压DP.md","状压DP学习总结+经典例题精解","/pages/671a5d/"],["03.数据结构与算法/07.动态规划/03.HDU 4507 恨7不成妻 （数位DP套路题，详细解析）.md","03.HDU 4507 恨7不成妻 （数位DP套路题）","/pages/243024/"]]},{title:"图算法",collapsable:!0,children:[["03.数据结构与算法/08.图算法/01.Floyd算法教程.md","Floyd算法教程","/pages/3610c3/"],["03.数据结构与算法/08.图算法/02.Dijkstra算法教程.md","Dijkstra算法教程","/pages/180ec0/"],["03.数据结构与算法/08.图算法/03.Kruskal算法教程.md","Kruskal算法详解","/pages/a97764/"],["03.数据结构与算法/08.图算法/04.Prim算法教程.md","Prim算法详解","/pages/affd0f/"]]}]},{title:"数据存储",collapsable:!0,children:[]},{title:"系统架构",collapsable:!0,children:[{title:"Linux",collapsable:!0,children:[["05.系统架构/01.Linux/01.Linux常用命令、管道、环境变量.md","Linux常用命令、管道、环境变量","/pages/d66bf9/"],["05.系统架构/01.Linux/02.Linux常用文件管理命令.md","Linux常用文件管理命令","/pages/b04f81/"],["05.系统架构/01.Linux/03.Linux用户和用户组教程.md","Linux用户和用户组教程","/pages/419777/"]]}]},{title:"计算机网络",collapsable:!0,children:[]},{title:"云原生",collapsable:!0,children:[{title:"容器化技术",collapsable:!0,children:[["07.云原生/01.容器化技术/01.Docker入门教程.md","Docker入门教程","/pages/12de46/"]]},{title:"微服务",collapsable:!0,children:[]}]}],"/02.工具/":[{title:"版本控制",collapsable:!0,children:[["01.版本控制/01.Git Commit 之道：规范化 Commit Message 写作指南.md","Git Commit 之道：规范化 Commit Message 写作指南","/pages/4f7ea8/"],["01.版本控制/02.Git教程.md","Git教程","/pages/992deb/"],["01.版本控制/03.Github搜索技巧.md","Github搜索技巧","/pages/031ffb/"]]},{title:"网络工具",collapsable:!0,children:[["02.网络工具/01.WireGuard组网教程.md","WireGuard组网教程","/pages/50ca39/"],["02.网络工具/02.SSH教程.md","SSH教程","/pages/975871/"]]},{title:"开发工具",collapsable:!0,children:[["03.开发工具/01.Shell教程.md","Shell教程","/pages/0fc47a/"],["03.开发工具/02.Tmux教程.md","Tmux教程","/pages/c81c74/"],["03.开发工具/03.Vim教程.md","Vim教程","/pages/e7b5a5/"]]}],"/03.学习笔记/":[{title:"学术搬砖",collapsable:!0,children:[]},{title:"实践项目",collapsable:!0,children:[]},{title:"讲座研讨",collapsable:!0,children:[]}],"/04.生活杂谈/":[{title:"随写编年",collapsable:!0,children:[{title:"年终总结",collapsable:!0,children:[]},{title:"2023年",collapsable:!0,children:[["01.随写编年/02.2023年/01.雪韵初见·南京初雪.md","雪韵初见·南京初雪","/pages/608406/"]]}]},{title:"追忆青春",collapsable:!0,children:[]},{title:"旅行日记",collapsable:!0,children:[]},{title:"文艺时光",collapsable:!0,children:[]},{title:"烹调分享",collapsable:!0,children:[]}],"/05.资源收藏/":[{title:"实用网站",collapsable:!0,children:[]},{title:"优秀项目",collapsable:!0,children:[["02.优秀项目/01.算法实现模版.md","遵循最佳实践，各种语言实现数据结构和算法的模版","/pages/0070df/"],["02.优秀项目/02.设计模式实现模版.md","遵循最佳实践，各种语言实现设计模式的模版","/pages/7634df/"],["02.优秀项目/03.Go优秀资源.md","Go 语言优秀资源整理，为项目落地加速🏃","/pages/9fd05a/"]]}],"/06.更多/":[{title:"面试",collapsable:!0,children:[]},{title:"实用技巧",collapsable:!0,children:[]},{title:"博客相关",collapsable:!0,children:[]}],"/07.关于/":[["01.about.md","个人简介","/about/"]],"/08.友情链接/":[["01.友情链接.md","友链","/friend/"]]},author:{name:"Pursuit",link:"https://github.com/unique-pure"},blogger:{avatar:"/img/avatar.jpeg",name:"Pursuit",slogan:"但行好事，莫问前程"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:unique.hzf@gmail.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/unique-pure"},{iconClass:"icon-csdn",title:"My CSDN",link:"https://pursuit.blog.csdn.net/"}]},footer:{createYear:2020,copyrightInfo:'Pursuit | <a href="https://github.com/unique-pure/my-vdoing-blog-template/blob/main/LICENSE" target="_blank">MIT License</a>'},extendFrontmatter:{author:{name:"Pursuit",link:"https://github.com/unique-pure"}},htmlModules:{pageB:'<div class="donation">\n      <button>打赏</button>\n      <div class="main">\n        <div class="pic">\n          <img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/wechatpay.jpeg" alt="微信">\n          <img src="https://raw.githubusercontent.com/unique-pure/NewPicGoLibrary/main/img/zhifubaopay.jpeg" alt="支付宝">\n        </div>\n      </div>  \n    </div>'}},locales:{"/":{lang:"zh-CN",title:"Pursuit's blog",description:"随便写写",path:"/"}}};var kl=t(99),wl=t(100),_l=t(11);var El={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:i}}=n;return!(e||!1===t||!0===i)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,i=e.frontmatter.sticky;return t&&i?t==i?Object(_l.a)(n,e):t-i:t&&!i?-1:!t&&i?1:Object(_l.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(_l.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let i=0,r=n.length;i<r;i++){const{frontmatter:{categories:r,tags:o}}=n[i];"array"===Object(_l.n)(r)&&r.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[i]))}),"array"===Object(_l.n)(o)&&o.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[i]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Vt.component(kl.default),Vt.component(wl.default);function jl(n){return n.toString().padStart(2,"0")}t(248);Vt.component("GlobalTip",()=>Promise.all([t.e(0),t.e(20)]).then(t.bind(null,393))),Vt.component("Badge",()=>Promise.all([t.e(0),t.e(6)]).then(t.bind(null,394))),Vt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,99))),Vt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,100)));t(249);var Tl={render:()=>null},Sl=Vt.extend({name:"CodeGroup",data:()=>({codeTabs:[],activeTabIndex:-1}),watch:{activeTabIndex(n){this.activateCodeTab(n)}},mounted(){this.loadTabs()},methods:{loadTabs(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>{const t=n.componentOptions.propsData;return"active"in t&&(this.activeTabIndex=e),{title:t.title,element:n.elm}}),-1===this.activeTabIndex&&this.codeTabs.length>0&&(this.activeTabIndex=0),this.activateCodeTab(0)},changeCodeTab(n){this.activeTabIndex=n},keyDownHandler(n,e){" "===n.key||"Enter"===n.key?(n.preventDefault(),this.activeTabIndex=e):"ArrowRight"===n.key?(n.preventDefault(),e+1<this.codeTabs.length&&(this.activeTabIndex=e+1,this.$refs.tab[e+1].focus())):"ArrowLeft"===n.key&&(n.preventDefault(),e-1>=0&&(this.activeTabIndex=e-1,this.$refs.tab[e-1].focus()))},activateCodeTab(n){this.codeTabs.forEach((e,t)=>{const{element:i}=e;i&&(n===t?i.classList.add("active"):i.classList.remove("active"))})}}}),Al=(t(250),Object(vl.a)(Sl,(function(){var n=this,e=n._self._c;n._self._setupProxy;return e("ClientOnly",[e("div",{staticClass:"code-group"},[e("div",{staticClass:"code-group-nav",attrs:{"v:if":"codeTabs.length"}},n._l(n.codeTabs,(function(t,i){return e("button",{key:t.title,ref:"tab",refInFor:!0,staticClass:"code-group-nav-tab",class:{active:i===n.activeTabIndex},attrs:{"aria-pressed":i===n.activeTabIndex,"aria-expanded":i===n.activeTabIndex},domProps:{textContent:n._s(t.title)},on:{click:function(e){return n.changeCodeTab(i)},keydown:function(e){return n.keyDownHandler(e,i)}}})})),0),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length?n._e():e("pre",{staticClass:"hints",domProps:{textContent:n._s("// Make sure to add code blocks to your code group")}})],2)])}),[],!1,null,null,null).exports),Cl=Vt.extend({name:"CodeGroupItem",props:{title:{type:String,required:!0},active:{type:Boolean,required:!1,default:!1}},mounted(){this.$parent&&this.$parent.loadTabs&&this.$parent.loadTabs()}}),Pl=(t(251),Object(vl.a)(Cl,(function(){var n=this._self._c;this._self._setupProxy;return n("div",{staticClass:"code-group-item",class:{active:this.active},attrs:{"aria-selected":this.active}},[this._t("default")],2)}),[],!1,null,null,null).exports);var Il=({Vue:n})=>{Promise.all([t.e(0),t.e(116)]).then(t.t.bind(null,380,7)),Promise.all([t.e(0),t.e(117)]).then(t.t.bind(null,381,7)),Tl.name&&n.component("ChartJS",Tl),Tl.name&&n.component("CodeDemo",Tl),Al.name&&n.component("CodeGroup",Al),Pl.name&&n.component("CodeGroupItem",Pl),Tl.name&&n.component("FlowChart",Tl),Tl.name&&n.component("Mermaid",Tl),Tl.name&&n.component("Presentation",Tl),Promise.all([t.e(0),t.e(118)]).then(t.t.bind(null,382,7)),Promise.all([t.e(0),t.e(119)]).then(t.t.bind(null,383,7)),Promise.all([t.e(0),t.e(121)]).then(t.t.bind(null,384,7))},zl={name:"ReadingProgress",data:()=>({readingTop:0,readingHeight:1,progressStyle:null,transform:void 0,running:!1}),watch:{$readingShow(){this.progressStyle=this.getProgressStyle(),this.$readingShow&&window.addEventListener("scroll",this.base)}},mounted(){this.transform=this.getTransform(),this.progressStyle=this.getProgressStyle(),this.$readingShow&&window.addEventListener("scroll",this.base)},beforeDestroy(){this.$readingShow&&window.removeEventListener("scroll",this.base)},methods:{base(){this.running||(this.running=!0,requestAnimationFrame(this.getReadingBase))},getReadingBase(){this.readingHeight=this.getReadingHeight()-this.getScreenHeight(),this.readingTop=this.getReadingTop(),this.progressStyle=this.getProgressStyle(),this.running=!1},getReadingHeight:()=>Math.max(document.body.scrollHeight,document.body.offsetHeight,0),getScreenHeight:()=>Math.max(window.innerHeight,document.documentElement.clientHeight,0),getReadingTop:()=>Math.max(window.pageYOffset,document.documentElement.scrollTop,0),getTransform(){const n=document.createElement("div");return["transform","-webkit-transform","-moz-transform","-o-transform","-ms-transform"].find(e=>e in n.style)||void 0},getProgressStyle(){const n=this.readingTop/this.readingHeight;switch(this.$readingShow){case"top":case"bottom":return this.transform?`${this.transform}: scaleX(${n})`:`width: ${100*n}%`;case"left":case"right":return this.transform?`${this.transform}: scaleY(${n})`:`height: ${100*n}%`;default:return null}}}},Bl=(t(252),Object(vl.a)(zl,(function(){var n=this._self._c;return n("ClientOnly",[this.$readingShow?n("div",{staticClass:"reading-progress",class:this.$readingShow},[n("div",{staticClass:"progress",style:this.progressStyle})]):this._e()])}),[],!1,null,"3640397f",null).exports),Dl=(t(253),t(98)),Ll=t.n(Dl),$l=t(27);let Ol,Gl;var ql;"valine"===(ql="gitalk")?t.e(122).then(t.t.bind(null,385,7)).then(n=>Gl=n.default):"gitalk"===ql&&Promise.all([t.e(0),t.e(120)]).then(t.t.bind(null,386,7)).then(()=>t.e(115).then(t.t.bind(null,387,7))).then(n=>Ol=n.default);function Nl(n,e){const t={};return Reflect.ownKeys(n).forEach(i=>{if("string"==typeof n[i])try{t[i]=Ll.a.render(n[i],e)}catch(e){console.warn(`Comment config option error at key named "${i}"`),console.warn("More info: "+e.message),t[i]=n[i]}else t[i]=n[i]}),t}console.log(`How to use "gitalk" in ${$l.name}@v${$l.version}:`,$l.homepage);const Ml={gitalk:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t);new Ol(Nl({clientID:"9df5ccb0d1f027d3397a",clientSecret:"0a6854600c8094a650b26c310c78c061cb320480",repo:"commentRes",owner:"unique-pure",admin:["unique-pure"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n})).render(e)},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}},valine:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t),new Gl({...Nl({clientID:"9df5ccb0d1f027d3397a",clientSecret:"0a6854600c8094a650b26c310c78c061cb320480",repo:"commentRes",owner:"unique-pure",admin:["unique-pure"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n}),el:"#"+e})},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}}},Fl="vuepress-plugin-comment";let Ul=null;function Rl(n){return Ml.gitalk.clear(Fl)}function Hl(n){return!1!==n.comment&&!1!==n.comments}function Vl(n){clearTimeout(Ul);if(document.querySelector("main.page"))return Ml.gitalk.render(n,Fl);Ul=setTimeout(()=>Vl(n),200)}var Jl={mounted(){Ul=setTimeout(()=>{const n={to:{},from:{},...this.$frontmatter};Rl()&&Hl(n)&&Vl(n)},1e3),this.$router.afterEach((n,e)=>{if(n&&e&&n.path===e.path)return;const t={to:n,from:e,...this.$frontmatter};Rl()&&Hl(t)&&Vl(t)})}},Wl=Object(vl.a)(Jl,(function(){return(0,this._self._c)("div")}),[],!1,null,null,null).exports,Kl=[({Vue:n,options:e,router:t,siteData:i})=>{},({Vue:n,options:e,router:t,siteData:i})=>{i.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${jl(n.getUTCMonth()+1)}-${jl(n.getUTCDate())} ${jl(n.getUTCHours())}:${jl(n.getUTCMinutes())}:${jl(n.getUTCSeconds())}`}(e)),t?n.author=t:i.themeConfig.author&&(n.author=i.themeConfig.author)}),n.mixin(El)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:n})=>{"undefined"!=typeof window&&function(){var n=document.createElement("script"),e=window.location.protocol.split(":")[0];n.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(n,t)}()},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?503f098e7e5b3a5b5d8c5fc2938af002";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))},Il,({Vue:n})=>{n.component(Bl.name,Bl),n.mixin({computed:{$readingShow(){return this.$page.frontmatter.readingShow}}})},({Vue:n})=>{n.component("Comment",Wl)}],Ql=["ReadingProgress","GlobalTip","WebInfo","PageInfo","Comment"];class Zl extends class{constructor(){this.store=new Vt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Vt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Zl.prototype,{getPageAsyncComponent:as,getLayoutAsyncComponent:ss,getAsyncComponent:ls,getVueComponent:cs});var Xl={install(n){const e=new Zl;n.$vuepress=e,n.prototype.$vuepress=e}};function Yl(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var nc={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return ds("pageKey",e),Vt.component(e)||Vt.component(e,as(e)),Vt.component(e)?n(e):n("")}},ec={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},tc={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},ic=(t(259),t(260),Object(vl.a)(tc,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),rc={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Vt.config.productionTip=!1,Vt.use(Ra),Vt.use(Xl),Vt.mixin(function(n,e,t=Vt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const i=new(n(t.$vuepress.$get("siteData"))),r=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(i)),o={};return Object.keys(r).reduce((n,e)=>(e.startsWith("$")&&(n[e]=r[e].get),n),o),{computed:o}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const i in n)"/"===i?t=n[i]:0===this.$page.path.indexOf(i)&&(e=n[i]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,i=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?i?i+" | "+t:t:i||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const i=n[t];if(i.path.toLowerCase()===e.toLowerCase())return i}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},yl)),Vt.component("Content",nc),Vt.component("ContentSlotsDistributor",ec),Vt.component("OutboundLink",ic),Vt.component("ClientOnly",rc),Vt.component("Layout",ss("Layout")),Vt.component("NotFound",ss("NotFound")),Vt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.10",hash:"9ff6a64"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:yl.routerBase||yl.base,t=new Ra({base:e,mode:"history",fallback:!1,routes:xl,scrollBehavior:(n,e,t)=>t||(n.hash?!Vt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,i)=>{if(Yl(n,e.path))i();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Yl(n,t)?i(t):i()}else i();else{const t=e.path+"/",r=e.path+".html";Yl(n,r)?i(r):Yl(n,t)?i(t):i()}})}(t);const i={};try{await Promise.all(Kl.filter(n=>"function"==typeof n).map(e=>e({Vue:Vt,options:i,router:t,siteData:yl,isServer:n})))}catch(n){console.error(n)}return{app:new Vt(Object.assign(i,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Ql.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);